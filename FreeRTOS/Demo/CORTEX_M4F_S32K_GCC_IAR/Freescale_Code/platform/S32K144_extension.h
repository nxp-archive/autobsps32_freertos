/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          GNU C Compiler
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KE1xP100M150SF0RM Rev. 0, Mar. 2015
**     Version:             rev. 1.2, 2015-06-02
**     Build:               b150602
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2015 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2015-04-09)
**         Initial version.
**     - rev. 1.1 (2015-05-19)
**         Updated interrupts table
**         Removed SIM_CHIPCTL_DAC2CMP
**         Compacted PORT_PCR registers
**         Compacted PCC registers
**     - rev. 1.2 (2015-06-02)
**         Added 'U' suffix to all integer constants
**         Use "" insted of <> for Platform type inclusion
**         CNT register from WDOG module is RW
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __S32K144_EXTENSION_H__
#define __S32K144_EXTENSION_H__

#include "S32K144.h"
#include "fsl_bitaccess.h"

/*
 * S32K144 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC Status and Control Registers 1
 * - ADC_CFG1 - ADC Configuration Register 1
 * - ADC_CFG2 - ADC Configuration Register 2
 * - ADC_R - ADC Data Result Register
 * - ADC_CV - Compare Value Registers
 * - ADC_SC2 - Status and Control Register 2
 * - ADC_SC3 - Status and Control Register 3
 * - ADC_BASE_OFS - ADC Offset Correction Register
 * - ADC_OFS - ADC Offset Correction Register
 * - ADC_USR_OFS - ADC USER Offset Correction Register
 * - ADC_XOFS - ADC X Offset Correction Register
 * - ADC_YOFS - ADC Y Offset Correction Register
 * - ADC_G - ADC Gain Register
 * - ADC_UG - ADC User Gain Register
 * - ADC_CLPS - ADC General Calibration Value Register
 * - ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPX - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP9 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPS_OFS - ADC General Calibration Value Register
 * - ADC_CLP3_OFS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2_OFS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1_OFS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0_OFS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPX_OFS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP9_OFS - ADC Plus-Side General Calibration Value Register
 */

#define ADC_INSTANCE_COUNT (2U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */
#define ADC1_IDX (1U) /*!< Instance number for ADC1. */

/*******************************************************************************
 * ADC_SC1 - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000000FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. At
 * any one point in time, only one of the SC1n registers is actively controlling
 * ADC conversions. Updating SC1A while SC1n is actively controlling a conversion
 * is allowed, and vice-versa for any of the SC1n registers specific to this MCU.
 * Writing SC1A while SC1A is actively controlling a conversion aborts the
 * current conversion. In Software Trigger mode, when SC2[ADTRG]=0, writes to SC1A
 * subsequently initiate a new conversion, if SC1A[ADCH] contains a value other than
 * all 1s. Writing any of the SC1n registers while that specific SC1n register is
 * actively controlling a conversion aborts the current conversion. None of the
 * SC1B-SC1n registers are used for software trigger operation and therefore
 * writes to the SC1B-SC1n registers do not initiate a new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) |  (value)))
#define ADC_CLR_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) & ~(value)))
#define ADC_TOG_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[3:0] (RW)
 *
 * Selects one of the input channels. Some of the input channel options in the
 * bitfield-setting descriptions might not be available for your device. For the
 * actual ADC channel assignments for your device, see the Chip Configuration
 * details. The successive approximation converter subsystem is turned off when the
 * channel bits are all set, that is, ADCH = 1111. This feature allows explicit
 * disabling of the ADC and isolation of the input channel from all sources.
 * Terminating continuous conversions this way prevents an additional single conversion
 * from being performed. It is not necessary to set ADCH to all 1s to place the
 * ADC in a low-power state when continuous conversions are not enabled because
 * the module automatically enters a low-power state when a conversion completes.
 *
 * Values:
 * - 0b0000 - AD0 is selected as input.
 * - 0b0001 - AD1 is selected as input.
 * - 0b0010 - AD2 is selected as input.
 * - 0b0011 - AD3 is selected as input.
 * - 0b0100 - AD4 is selected as input.
 * - 0b0101 - AD5 is selected as input.
 * - 0b0110 - AD6 is selected as input.
 * - 0b0111 - AD7 is selected as input.
 * - 0b1000 - AD8 is selected as input.
 * - 0b1001 - AD9 is selected as input.
 * - 0b1010 - AD10 is selected as input.
 * - 0b1011 - AD11 is selected as input.
 * - 0b1100 - AD12 is selected as input.
 * - 0b1101 - AD13 is selected as input.
 * - 0b1110 - AD14 is selected as input.
 * - 0b1111 - AD15 is selected as input.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (ADC_RD_SC1_ADCH(base, index))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (ADC_WR_SC1_ADCH(base, index, value))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0b0 - Conversion complete interrupt is disabled.
 * - 0b1 - Conversion complete interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0b0 - Conversion is not completed.
 * - 0b1 - Conversion is completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) |  (value)))
#define ADC_CLR_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) & ~(value)))
#define ADC_TOG_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK.
 *
 * Values:
 * - 0b00 - Alternate clock 1 (ADC_ALTCLK1)
 * - 0b01 - Alternate clock 2 (ADC_ALTCLK2)
 * - 0b10 - Alternate clock 3 (ADC_ALTCLK3)
 * - 0b11 - Alternate clock 4 (ADC_ALTCLK4)
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (ADC_RD_CFG1_ADICLK(base))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (ADC_WR_CFG1_ADICLK(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 0b00 - 8-bit conversion.
 * - 0b01 - 10-bit conversion.
 * - 0b10 - 12-bit conversion.
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (ADC_RD_CFG1_MODE(base))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (ADC_WR_CFG1_MODE(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 0b00 - The divide ratio is 1 and the clock rate is input clock.
 * - 0b01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 0b10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 0b11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (ADC_RD_CFG1_ADIV(base))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (ADC_WR_CFG1_ADIV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x0000000CU
 *
 * Configuration Register 2 (CFG2) selects the long sample time duration during
 * long sample mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) |  (value)))
#define ADC_CLR_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) & ~(value)))
#define ADC_TOG_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field SMPLTS[7:0] (RW)
 *
 * Selects a sample time of 2 to 256 ADCK clock cycles. The value written to
 * this register is the desired sample time minus 1. A sample time of 1 is not
 * supported. Allows higher impedance inputs to be accurately sampled or to maximize
 * conversion speed for lower impedance inputs. Longer sample times can also be
 * used to lower overall power consumption when continuous conversions are enabled
 * if high conversion rates are not required.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_SMPLTS field. */
#define ADC_RD_CFG2_SMPLTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_SMPLTS_MASK) >> ADC_CFG2_SMPLTS_SHIFT)
#define ADC_BRD_CFG2_SMPLTS(base) (ADC_RD_CFG2_SMPLTS(base))

/*! @brief Set the SMPLTS field to a new value. */
#define ADC_WR_CFG2_SMPLTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_SMPLTS_MASK, ADC_CFG2_SMPLTS(value)))
#define ADC_BWR_CFG2_SMPLTS(base, value) (ADC_WR_CFG2_SMPLTS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared. The following table
 * describes the behavior of the data result registers in the different modes of
 * operation. Data result register description Conversion mode D12 D11 D10 D9 D8
 * D7 D6 D5 D4 D3 D2 D1 D0 Format 12-bit single-ended D D D D D D D D D D D D
 * Unsigned right-justified 10-bit single-ended 0 0 D D D D D D D D D D Unsigned
 * right-justified 8-bit single-ended 0 0 0 0 D D D D D D D D Unsigned
 * right-justified D: Data
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[11:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (ADC_RD_R_D(base, index))
/*@}*/

/*******************************************************************************
 * ADC_CV - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers.
 * Therefore, the compare function uses only the CVn fields that are related to the
 * ADC mode of operation. The compare value 2 register (CV2) is used only when the
 * compare range function is enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV register
 */
/*@{*/
#define ADC_RD_CV(base, index)   (ADC_CV_REG(base, index))
#define ADC_WR_CV(base, index, value) (ADC_CV_REG(base, index) = (value))
#define ADC_RMW_CV(base, index, mask, value) (ADC_WR_CV(base, index, (ADC_RD_CV(base, index) & ~(mask)) | (value)))
#define ADC_SET_CV(base, index, value) (ADC_WR_CV(base, index, ADC_RD_CV(base, index) |  (value)))
#define ADC_CLR_CV(base, index, value) (ADC_WR_CV(base, index, ADC_RD_CV(base, index) & ~(value)))
#define ADC_TOG_CV(base, index, value) (ADC_WR_CV(base, index, ADC_RD_CV(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV bitfields
 */

/*!
 * @name Register ADC_CV, field CV[11:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV_CV field. */
#define ADC_RD_CV_CV(base, index) ((ADC_CV_REG(base, index) & ADC_CV_CV_MASK) >> ADC_CV_CV_SHIFT)
#define ADC_BRD_CV_CV(base, index) (ADC_RD_CV_CV(base, index))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV_CV(base, index, value) (ADC_RMW_CV(base, index, ADC_CV_CV_MASK, ADC_CV_CV(value)))
#define ADC_BWR_CV_CV(base, index, value) (ADC_WR_CV_CV(base, index, value))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) |  (value)))
#define ADC_CLR_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) & ~(value)))
#define ADC_TOG_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 0b00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 0b01 - Alternate reference pair, that is, VALTH and VALTL . This pair may
 *     be additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to
 *     this MCU
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (ADC_RD_SC2_REFSEL(base))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (ADC_WR_SC2_REFSEL(base, value))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0b0 - Range function disabled. Only CV1 is compared.
 * - 0b1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0b0 - Configures less than threshold, outside range not inclusive and
 *     inside range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 0b1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0b0 - Compare function disabled.
 * - 0b1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0b0 - Software trigger selected.
 * - 0b1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0b0 - Conversion not in progress.
 * - 0b1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) |  (value)))
#define ADC_CLR_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) & ~(value)))
#define ADC_TOG_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 0b00 - 4 samples averaged.
 * - 0b01 - 8 samples averaged.
 * - 0b10 - 16 samples averaged.
 * - 0b11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (ADC_RD_SC3_AVGS(base))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, ADC_SC3_AVGS_MASK, ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (ADC_WR_SC3_AVGS(base, value))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0b0 - Hardware average function disabled.
 * - 0b1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, ADC_SC3_AVGE_MASK, ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0b0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 0b1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, ADC_SC3_ADCO_MASK, ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (RO)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0b0 - Calibration completed normally.
 * - 0b1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, ADC_SC3_CAL_MASK, ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_BASE_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_BASE_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000043U
 *
 * The BASE Offset Register (BASE_OFS) contains the offset value used by the
 * calibration algorithm to determine Offset Calibration Value (OFS).
 */
/*!
 * @name Constants and macros for entire ADC_BASE_OFS register
 */
/*@{*/
#define ADC_RD_BASE_OFS(base)    (ADC_BASE_OFS_REG(base))
#define ADC_WR_BASE_OFS(base, value) (ADC_BASE_OFS_REG(base) = (value))
#define ADC_RMW_BASE_OFS(base, mask, value) (ADC_WR_BASE_OFS(base, (ADC_RD_BASE_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_BASE_OFS(base, value) (ADC_WR_BASE_OFS(base, ADC_RD_BASE_OFS(base) |  (value)))
#define ADC_CLR_BASE_OFS(base, value) (ADC_WR_BASE_OFS(base, ADC_RD_BASE_OFS(base) & ~(value)))
#define ADC_TOG_BASE_OFS(base, value) (ADC_WR_BASE_OFS(base, ADC_RD_BASE_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_BASE_OFS bitfields
 */

/*!
 * @name Register ADC_BASE_OFS, field BA_OFS[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_BASE_OFS_BA_OFS field. */
#define ADC_RD_BASE_OFS_BA_OFS(base) ((ADC_BASE_OFS_REG(base) & ADC_BASE_OFS_BA_OFS_MASK) >> ADC_BASE_OFS_BA_OFS_SHIFT)
#define ADC_BRD_BASE_OFS_BA_OFS(base) (ADC_RD_BASE_OFS_BA_OFS(base))

/*! @brief Set the BA_OFS field to a new value. */
#define ADC_WR_BASE_OFS_BA_OFS(base, value) (ADC_RMW_BASE_OFS(base, ADC_BASE_OFS_BA_OFS_MASK, ADC_BASE_OFS_BA_OFS(value)))
#define ADC_BWR_BASE_OFS_BA_OFS(base, value) (ADC_WR_BASE_OFS_BA_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ADC Offset Correction Register (OFS) contains the calibration-generated
 * offset error correction value (OFS). The value in (BA_OFF) is used in the
 * calibration algorithm to calculate the offset correction value that gets stored in
 * the (OFS) register. The value in OFS is subtracted from the conversion and the
 * result is transferred into the result registers, Rn. If the result is greater
 * than the maximum or less than the minimum result value, it is forced to the
 * appropriate limit for the current mode of operation.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) |  (value)))
#define ADC_CLR_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) & ~(value)))
#define ADC_TOG_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[11:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (ADC_RD_OFS_OFS(base))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (ADC_WR_OFS_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_USR_OFS - ADC USER Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_USR_OFS - ADC USER Offset Correction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The USER ADC Offset Correction Register (USR_OFS) contains the user defined
 * offset error correction value used in the conversion result error correction
 * algorithm.
 */
/*!
 * @name Constants and macros for entire ADC_USR_OFS register
 */
/*@{*/
#define ADC_RD_USR_OFS(base)     (ADC_USR_OFS_REG(base))
#define ADC_WR_USR_OFS(base, value) (ADC_USR_OFS_REG(base) = (value))
#define ADC_RMW_USR_OFS(base, mask, value) (ADC_WR_USR_OFS(base, (ADC_RD_USR_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_USR_OFS(base, value) (ADC_WR_USR_OFS(base, ADC_RD_USR_OFS(base) |  (value)))
#define ADC_CLR_USR_OFS(base, value) (ADC_WR_USR_OFS(base, ADC_RD_USR_OFS(base) & ~(value)))
#define ADC_TOG_USR_OFS(base, value) (ADC_WR_USR_OFS(base, ADC_RD_USR_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_USR_OFS bitfields
 */

/*!
 * @name Register ADC_USR_OFS, field USR_OFS[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_USR_OFS_USR_OFS field. */
#define ADC_RD_USR_OFS_USR_OFS(base) ((ADC_USR_OFS_REG(base) & ADC_USR_OFS_USR_OFS_MASK) >> ADC_USR_OFS_USR_OFS_SHIFT)
#define ADC_BRD_USR_OFS_USR_OFS(base) (ADC_RD_USR_OFS_USR_OFS(base))

/*! @brief Set the USR_OFS field to a new value. */
#define ADC_WR_USR_OFS_USR_OFS(base, value) (ADC_RMW_USR_OFS(base, ADC_USR_OFS_USR_OFS_MASK, ADC_USR_OFS_USR_OFS(value)))
#define ADC_BWR_USR_OFS_USR_OFS(base, value) (ADC_WR_USR_OFS_USR_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_XOFS - ADC X Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_XOFS - ADC X Offset Correction Register (RW)
 *
 * Reset value: 0x00000006U
 *
 * The ADC X Offset Correction Register (XOFS) contains the X offset for offset
 * error correction used in the conversion result error correction algorithm.
 */
/*!
 * @name Constants and macros for entire ADC_XOFS register
 */
/*@{*/
#define ADC_RD_XOFS(base)        (ADC_XOFS_REG(base))
#define ADC_WR_XOFS(base, value) (ADC_XOFS_REG(base) = (value))
#define ADC_RMW_XOFS(base, mask, value) (ADC_WR_XOFS(base, (ADC_RD_XOFS(base) & ~(mask)) | (value)))
#define ADC_SET_XOFS(base, value) (ADC_WR_XOFS(base, ADC_RD_XOFS(base) |  (value)))
#define ADC_CLR_XOFS(base, value) (ADC_WR_XOFS(base, ADC_RD_XOFS(base) & ~(value)))
#define ADC_TOG_XOFS(base, value) (ADC_WR_XOFS(base, ADC_RD_XOFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_XOFS bitfields
 */

/*!
 * @name Register ADC_XOFS, field OFS[5:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_XOFS_OFS field. */
#define ADC_RD_XOFS_OFS(base) ((ADC_XOFS_REG(base) & ADC_XOFS_OFS_MASK) >> ADC_XOFS_OFS_SHIFT)
#define ADC_BRD_XOFS_OFS(base) (ADC_RD_XOFS_OFS(base))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_XOFS_OFS(base, value) (ADC_RMW_XOFS(base, ADC_XOFS_OFS_MASK, ADC_XOFS_OFS(value)))
#define ADC_BWR_XOFS_OFS(base, value) (ADC_WR_XOFS_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_YOFS - ADC Y Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_YOFS - ADC Y Offset Correction Register (RW)
 *
 * Reset value: 0x00000037U
 *
 * The ADC Y Offset Correction Register (YOFS) contains the offset for error
 * correction used in the conversion result error correction algorithm.
 */
/*!
 * @name Constants and macros for entire ADC_YOFS register
 */
/*@{*/
#define ADC_RD_YOFS(base)        (ADC_YOFS_REG(base))
#define ADC_WR_YOFS(base, value) (ADC_YOFS_REG(base) = (value))
#define ADC_RMW_YOFS(base, mask, value) (ADC_WR_YOFS(base, (ADC_RD_YOFS(base) & ~(mask)) | (value)))
#define ADC_SET_YOFS(base, value) (ADC_WR_YOFS(base, ADC_RD_YOFS(base) |  (value)))
#define ADC_CLR_YOFS(base, value) (ADC_WR_YOFS(base, ADC_RD_YOFS(base) & ~(value)))
#define ADC_TOG_YOFS(base, value) (ADC_WR_YOFS(base, ADC_RD_YOFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_YOFS bitfields
 */

/*!
 * @name Register ADC_YOFS, field YOFS[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_YOFS_YOFS field. */
#define ADC_RD_YOFS_YOFS(base) ((ADC_YOFS_REG(base) & ADC_YOFS_YOFS_MASK) >> ADC_YOFS_YOFS_SHIFT)
#define ADC_BRD_YOFS_YOFS(base) (ADC_RD_YOFS_YOFS(base))

/*! @brief Set the YOFS field to a new value. */
#define ADC_WR_YOFS_YOFS(base, value) (ADC_RMW_YOFS(base, ADC_YOFS_YOFS_MASK, ADC_YOFS_YOFS(value)))
#define ADC_BWR_YOFS_YOFS(base, value) (ADC_WR_YOFS_YOFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_G - ADC Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_G - ADC Gain Register (RW)
 *
 * Reset value: 0x000002F0U
 *
 * The Gain Register (G) contains the gain error correction for the overall
 * conversion. G, a 12-bit real number in binary format, is the gain adjustment
 * factor. This register value is determined and uploaded by the calibration algorithm.
 */
/*!
 * @name Constants and macros for entire ADC_G register
 */
/*@{*/
#define ADC_RD_G(base)           (ADC_G_REG(base))
#define ADC_WR_G(base, value)    (ADC_G_REG(base) = (value))
#define ADC_RMW_G(base, mask, value) (ADC_WR_G(base, (ADC_RD_G(base) & ~(mask)) | (value)))
#define ADC_SET_G(base, value)   (ADC_WR_G(base, ADC_RD_G(base) |  (value)))
#define ADC_CLR_G(base, value)   (ADC_WR_G(base, ADC_RD_G(base) & ~(value)))
#define ADC_TOG_G(base, value)   (ADC_WR_G(base, ADC_RD_G(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_G bitfields
 */

/*!
 * @name Register ADC_G, field G[11:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_G_G field. */
#define ADC_RD_G_G(base)     ((ADC_G_REG(base) & ADC_G_G_MASK) >> ADC_G_G_SHIFT)
#define ADC_BRD_G_G(base)    (ADC_RD_G_G(base))

/*! @brief Set the G field to a new value. */
#define ADC_WR_G_G(base, value) (ADC_RMW_G(base, ADC_G_G_MASK, ADC_G_G(value)))
#define ADC_BWR_G_G(base, value) (ADC_WR_G_G(base, value))
/*@}*/

/*******************************************************************************
 * ADC_UG - ADC User Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_UG - ADC User Gain Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The User Gain Register (UG) contains the user gain error correction. Allow
 * user to adjust the final calibration gain value.
 */
/*!
 * @name Constants and macros for entire ADC_UG register
 */
/*@{*/
#define ADC_RD_UG(base)          (ADC_UG_REG(base))
#define ADC_WR_UG(base, value)   (ADC_UG_REG(base) = (value))
#define ADC_RMW_UG(base, mask, value) (ADC_WR_UG(base, (ADC_RD_UG(base) & ~(mask)) | (value)))
#define ADC_SET_UG(base, value)  (ADC_WR_UG(base, ADC_RD_UG(base) |  (value)))
#define ADC_CLR_UG(base, value)  (ADC_WR_UG(base, ADC_RD_UG(base) & ~(value)))
#define ADC_TOG_UG(base, value)  (ADC_WR_UG(base, ADC_RD_UG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_UG bitfields
 */

/*!
 * @name Register ADC_UG, field UG[9:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_UG_UG field. */
#define ADC_RD_UG_UG(base)   ((ADC_UG_REG(base) & ADC_UG_UG_MASK) >> ADC_UG_UG_SHIFT)
#define ADC_BRD_UG_UG(base)  (ADC_RD_UG_UG(base))

/*! @brief Set the UG field to a new value. */
#define ADC_WR_UG_UG(base, value) (ADC_RMW_UG(base, ADC_UG_UG_MASK, ADC_UG_UG(value)))
#define ADC_BWR_UG_UG(base, value) (ADC_WR_UG_UG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC General Calibration Value Register (RW)
 *
 * Reset value: 0x0000002EU
 *
 * The General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers contain seven
 * calibration values of varying widths: CLP0[5:0], CLP1[6:0], CLP2[7:0],
 * CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set when the
 * self-calibration sequence is done, that is, CAL is cleared. If these registers
 * are written by the user after calibration, the linearity error specifications
 * may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) |  (value)))
#define ADC_CLR_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) & ~(value)))
#define ADC_TOG_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (ADC_RD_CLPS_CLPS(base))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (ADC_WR_CLPS_CLPS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000180U
 *
 * For more information, see CLP3 register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) |  (value)))
#define ADC_CLR_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) & ~(value)))
#define ADC_TOG_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (ADC_RD_CLP3_CLP3(base))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (ADC_WR_CLP3_CLP3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x000000B8U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) |  (value)))
#define ADC_CLR_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) & ~(value)))
#define ADC_TOG_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (ADC_RD_CLP2_CLP2(base))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (ADC_WR_CLP2_CLP2(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000005CU
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) |  (value)))
#define ADC_CLR_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) & ~(value)))
#define ADC_TOG_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (ADC_RD_CLP1_CLP1(base))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (ADC_WR_CLP1_CLP1(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000002EU
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) |  (value)))
#define ADC_CLR_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) & ~(value)))
#define ADC_TOG_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (ADC_RD_CLP0_CLP0(base))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (ADC_WR_CLP0_CLP0(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPX - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPX - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPX register
 */
/*@{*/
#define ADC_RD_CLPX(base)        (ADC_CLPX_REG(base))
#define ADC_WR_CLPX(base, value) (ADC_CLPX_REG(base) = (value))
#define ADC_RMW_CLPX(base, mask, value) (ADC_WR_CLPX(base, (ADC_RD_CLPX(base) & ~(mask)) | (value)))
#define ADC_SET_CLPX(base, value) (ADC_WR_CLPX(base, ADC_RD_CLPX(base) |  (value)))
#define ADC_CLR_CLPX(base, value) (ADC_WR_CLPX(base, ADC_RD_CLPX(base) & ~(value)))
#define ADC_TOG_CLPX(base, value) (ADC_WR_CLPX(base, ADC_RD_CLPX(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPX bitfields
 */

/*!
 * @name Register ADC_CLPX, field CLPX[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPX_CLPX field. */
#define ADC_RD_CLPX_CLPX(base) ((ADC_CLPX_REG(base) & ADC_CLPX_CLPX_MASK) >> ADC_CLPX_CLPX_SHIFT)
#define ADC_BRD_CLPX_CLPX(base) (ADC_RD_CLPX_CLPX(base))

/*! @brief Set the CLPX field to a new value. */
#define ADC_WR_CLPX_CLPX(base, value) (ADC_RMW_CLPX(base, ADC_CLPX_CLPX_MASK, ADC_CLPX_CLPX(value)))
#define ADC_BWR_CLPX_CLPX(base, value) (ADC_WR_CLPX_CLPX(base, value))
/*@}*/

/*!
 * @name Register ADC_CLPX, field CLPXEN[7] (RW)
 *
 * Controls how comparison of CLPX is evaluated to be a pass or fail.
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPX_CLPXEN field. */
#define ADC_RD_CLPX_CLPXEN(base) ((ADC_CLPX_REG(base) & ADC_CLPX_CLPXEN_MASK) >> ADC_CLPX_CLPXEN_SHIFT)
#define ADC_BRD_CLPX_CLPXEN(base) (BITBAND_ACCESS32(&ADC_CLPX_REG(base), ADC_CLPX_CLPXEN_SHIFT))

/*! @brief Set the CLPXEN field to a new value. */
#define ADC_WR_CLPX_CLPXEN(base, value) (ADC_RMW_CLPX(base, ADC_CLPX_CLPXEN_MASK, ADC_CLPX_CLPXEN(value)))
#define ADC_BWR_CLPX_CLPXEN(base, value) (BITBAND_ACCESS32(&ADC_CLPX_REG(base), ADC_CLPX_CLPXEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_CLP9 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP9 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP9 register
 */
/*@{*/
#define ADC_RD_CLP9(base)        (ADC_CLP9_REG(base))
#define ADC_WR_CLP9(base, value) (ADC_CLP9_REG(base) = (value))
#define ADC_RMW_CLP9(base, mask, value) (ADC_WR_CLP9(base, (ADC_RD_CLP9(base) & ~(mask)) | (value)))
#define ADC_SET_CLP9(base, value) (ADC_WR_CLP9(base, ADC_RD_CLP9(base) |  (value)))
#define ADC_CLR_CLP9(base, value) (ADC_WR_CLP9(base, ADC_RD_CLP9(base) & ~(value)))
#define ADC_TOG_CLP9(base, value) (ADC_WR_CLP9(base, ADC_RD_CLP9(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP9 bitfields
 */

/*!
 * @name Register ADC_CLP9, field CLP9[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP9_CLP9 field. */
#define ADC_RD_CLP9_CLP9(base) ((ADC_CLP9_REG(base) & ADC_CLP9_CLP9_MASK) >> ADC_CLP9_CLP9_SHIFT)
#define ADC_BRD_CLP9_CLP9(base) (ADC_RD_CLP9_CLP9(base))

/*! @brief Set the CLP9 field to a new value. */
#define ADC_WR_CLP9_CLP9(base, value) (ADC_RMW_CLP9(base, ADC_CLP9_CLP9_MASK, ADC_CLP9_CLP9(value)))
#define ADC_BWR_CLP9_CLP9(base, value) (ADC_WR_CLP9_CLP9(base, value))
/*@}*/

/*!
 * @name Register ADC_CLP9, field CLP9EN[7] (RW)
 *
 * Controls how comparison of CLP9 is evaluated to be a pass or fail.
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP9_CLP9EN field. */
#define ADC_RD_CLP9_CLP9EN(base) ((ADC_CLP9_REG(base) & ADC_CLP9_CLP9EN_MASK) >> ADC_CLP9_CLP9EN_SHIFT)
#define ADC_BRD_CLP9_CLP9EN(base) (BITBAND_ACCESS32(&ADC_CLP9_REG(base), ADC_CLP9_CLP9EN_SHIFT))

/*! @brief Set the CLP9EN field to a new value. */
#define ADC_WR_CLP9_CLP9EN(base, value) (ADC_RMW_CLP9(base, ADC_CLP9_CLP9EN_MASK, ADC_CLP9_CLP9EN(value)))
#define ADC_BWR_CLP9_CLP9EN(base, value) (BITBAND_ACCESS32(&ADC_CLP9_REG(base), ADC_CLP9_CLP9EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_CLPS_OFS - ADC General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS_OFS - ADC General Calibration Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers contain seven
 * calibration values of varying widths: CLP0[5:0], CLP1[6:0], CLP2[7:0],
 * CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set when the
 * self-calibration sequence is done, that is, CAL is cleared. If these registers
 * are written by the user after calibration, the linearity error specifications
 * may not be met.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS_OFS register
 */
/*@{*/
#define ADC_RD_CLPS_OFS(base)    (ADC_CLPS_OFS_REG(base))
#define ADC_WR_CLPS_OFS(base, value) (ADC_CLPS_OFS_REG(base) = (value))
#define ADC_RMW_CLPS_OFS(base, mask, value) (ADC_WR_CLPS_OFS(base, (ADC_RD_CLPS_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS_OFS(base, value) (ADC_WR_CLPS_OFS(base, ADC_RD_CLPS_OFS(base) |  (value)))
#define ADC_CLR_CLPS_OFS(base, value) (ADC_WR_CLPS_OFS(base, ADC_RD_CLPS_OFS(base) & ~(value)))
#define ADC_TOG_CLPS_OFS(base, value) (ADC_WR_CLPS_OFS(base, ADC_RD_CLPS_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS_OFS bitfields
 */

/*!
 * @name Register ADC_CLPS_OFS, field CLPS_OFS[3:0] (RW)
 *
 * Capacitor offset correction value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_OFS_CLPS_OFS field. */
#define ADC_RD_CLPS_OFS_CLPS_OFS(base) ((ADC_CLPS_OFS_REG(base) & ADC_CLPS_OFS_CLPS_OFS_MASK) >> ADC_CLPS_OFS_CLPS_OFS_SHIFT)
#define ADC_BRD_CLPS_OFS_CLPS_OFS(base) (ADC_RD_CLPS_OFS_CLPS_OFS(base))

/*! @brief Set the CLPS_OFS field to a new value. */
#define ADC_WR_CLPS_OFS_CLPS_OFS(base, value) (ADC_RMW_CLPS_OFS(base, ADC_CLPS_OFS_CLPS_OFS_MASK, ADC_CLPS_OFS_CLPS_OFS(value)))
#define ADC_BWR_CLPS_OFS_CLPS_OFS(base, value) (ADC_WR_CLPS_OFS_CLPS_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP3_OFS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3_OFS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For more information, see CLP3 register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3_OFS register
 */
/*@{*/
#define ADC_RD_CLP3_OFS(base)    (ADC_CLP3_OFS_REG(base))
#define ADC_WR_CLP3_OFS(base, value) (ADC_CLP3_OFS_REG(base) = (value))
#define ADC_RMW_CLP3_OFS(base, mask, value) (ADC_WR_CLP3_OFS(base, (ADC_RD_CLP3_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3_OFS(base, value) (ADC_WR_CLP3_OFS(base, ADC_RD_CLP3_OFS(base) |  (value)))
#define ADC_CLR_CLP3_OFS(base, value) (ADC_WR_CLP3_OFS(base, ADC_RD_CLP3_OFS(base) & ~(value)))
#define ADC_TOG_CLP3_OFS(base, value) (ADC_WR_CLP3_OFS(base, ADC_RD_CLP3_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3_OFS bitfields
 */

/*!
 * @name Register ADC_CLP3_OFS, field CLP3_OFS[3:0] (RW)
 *
 * Capacitor offset correction value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_OFS_CLP3_OFS field. */
#define ADC_RD_CLP3_OFS_CLP3_OFS(base) ((ADC_CLP3_OFS_REG(base) & ADC_CLP3_OFS_CLP3_OFS_MASK) >> ADC_CLP3_OFS_CLP3_OFS_SHIFT)
#define ADC_BRD_CLP3_OFS_CLP3_OFS(base) (ADC_RD_CLP3_OFS_CLP3_OFS(base))

/*! @brief Set the CLP3_OFS field to a new value. */
#define ADC_WR_CLP3_OFS_CLP3_OFS(base, value) (ADC_RMW_CLP3_OFS(base, ADC_CLP3_OFS_CLP3_OFS_MASK, ADC_CLP3_OFS_CLP3_OFS(value)))
#define ADC_BWR_CLP3_OFS_CLP3_OFS(base, value) (ADC_WR_CLP3_OFS_CLP3_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP2_OFS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2_OFS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For more information, see CLP2 register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2_OFS register
 */
/*@{*/
#define ADC_RD_CLP2_OFS(base)    (ADC_CLP2_OFS_REG(base))
#define ADC_WR_CLP2_OFS(base, value) (ADC_CLP2_OFS_REG(base) = (value))
#define ADC_RMW_CLP2_OFS(base, mask, value) (ADC_WR_CLP2_OFS(base, (ADC_RD_CLP2_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2_OFS(base, value) (ADC_WR_CLP2_OFS(base, ADC_RD_CLP2_OFS(base) |  (value)))
#define ADC_CLR_CLP2_OFS(base, value) (ADC_WR_CLP2_OFS(base, ADC_RD_CLP2_OFS(base) & ~(value)))
#define ADC_TOG_CLP2_OFS(base, value) (ADC_WR_CLP2_OFS(base, ADC_RD_CLP2_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2_OFS bitfields
 */

/*!
 * @name Register ADC_CLP2_OFS, field CLP2_OFS[3:0] (RW)
 *
 * Capacitor offset correction value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_OFS_CLP2_OFS field. */
#define ADC_RD_CLP2_OFS_CLP2_OFS(base) ((ADC_CLP2_OFS_REG(base) & ADC_CLP2_OFS_CLP2_OFS_MASK) >> ADC_CLP2_OFS_CLP2_OFS_SHIFT)
#define ADC_BRD_CLP2_OFS_CLP2_OFS(base) (ADC_RD_CLP2_OFS_CLP2_OFS(base))

/*! @brief Set the CLP2_OFS field to a new value. */
#define ADC_WR_CLP2_OFS_CLP2_OFS(base, value) (ADC_RMW_CLP2_OFS(base, ADC_CLP2_OFS_CLP2_OFS_MASK, ADC_CLP2_OFS_CLP2_OFS(value)))
#define ADC_BWR_CLP2_OFS_CLP2_OFS(base, value) (ADC_WR_CLP2_OFS_CLP2_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP1_OFS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1_OFS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For more information, see CLP1 register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1_OFS register
 */
/*@{*/
#define ADC_RD_CLP1_OFS(base)    (ADC_CLP1_OFS_REG(base))
#define ADC_WR_CLP1_OFS(base, value) (ADC_CLP1_OFS_REG(base) = (value))
#define ADC_RMW_CLP1_OFS(base, mask, value) (ADC_WR_CLP1_OFS(base, (ADC_RD_CLP1_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1_OFS(base, value) (ADC_WR_CLP1_OFS(base, ADC_RD_CLP1_OFS(base) |  (value)))
#define ADC_CLR_CLP1_OFS(base, value) (ADC_WR_CLP1_OFS(base, ADC_RD_CLP1_OFS(base) & ~(value)))
#define ADC_TOG_CLP1_OFS(base, value) (ADC_WR_CLP1_OFS(base, ADC_RD_CLP1_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1_OFS bitfields
 */

/*!
 * @name Register ADC_CLP1_OFS, field CLP1_OFS[3:0] (RW)
 *
 * Capacitor offset correction value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_OFS_CLP1_OFS field. */
#define ADC_RD_CLP1_OFS_CLP1_OFS(base) ((ADC_CLP1_OFS_REG(base) & ADC_CLP1_OFS_CLP1_OFS_MASK) >> ADC_CLP1_OFS_CLP1_OFS_SHIFT)
#define ADC_BRD_CLP1_OFS_CLP1_OFS(base) (ADC_RD_CLP1_OFS_CLP1_OFS(base))

/*! @brief Set the CLP1_OFS field to a new value. */
#define ADC_WR_CLP1_OFS_CLP1_OFS(base, value) (ADC_RMW_CLP1_OFS(base, ADC_CLP1_OFS_CLP1_OFS_MASK, ADC_CLP1_OFS_CLP1_OFS(value)))
#define ADC_BWR_CLP1_OFS_CLP1_OFS(base, value) (ADC_WR_CLP1_OFS_CLP1_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP0_OFS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0_OFS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0_OFS register
 */
/*@{*/
#define ADC_RD_CLP0_OFS(base)    (ADC_CLP0_OFS_REG(base))
#define ADC_WR_CLP0_OFS(base, value) (ADC_CLP0_OFS_REG(base) = (value))
#define ADC_RMW_CLP0_OFS(base, mask, value) (ADC_WR_CLP0_OFS(base, (ADC_RD_CLP0_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0_OFS(base, value) (ADC_WR_CLP0_OFS(base, ADC_RD_CLP0_OFS(base) |  (value)))
#define ADC_CLR_CLP0_OFS(base, value) (ADC_WR_CLP0_OFS(base, ADC_RD_CLP0_OFS(base) & ~(value)))
#define ADC_TOG_CLP0_OFS(base, value) (ADC_WR_CLP0_OFS(base, ADC_RD_CLP0_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0_OFS bitfields
 */

/*!
 * @name Register ADC_CLP0_OFS, field CLP0_OFS[3:0] (RW)
 *
 * Capacitor offset correction value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_OFS_CLP0_OFS field. */
#define ADC_RD_CLP0_OFS_CLP0_OFS(base) ((ADC_CLP0_OFS_REG(base) & ADC_CLP0_OFS_CLP0_OFS_MASK) >> ADC_CLP0_OFS_CLP0_OFS_SHIFT)
#define ADC_BRD_CLP0_OFS_CLP0_OFS(base) (ADC_RD_CLP0_OFS_CLP0_OFS(base))

/*! @brief Set the CLP0_OFS field to a new value. */
#define ADC_WR_CLP0_OFS_CLP0_OFS(base, value) (ADC_RMW_CLP0_OFS(base, ADC_CLP0_OFS_CLP0_OFS_MASK, ADC_CLP0_OFS_CLP0_OFS(value)))
#define ADC_BWR_CLP0_OFS_CLP0_OFS(base, value) (ADC_WR_CLP0_OFS_CLP0_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPX_OFS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPX_OFS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000442U
 *
 * For more information, see CLPX_OFS register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPX_OFS register
 */
/*@{*/
#define ADC_RD_CLPX_OFS(base)    (ADC_CLPX_OFS_REG(base))
#define ADC_WR_CLPX_OFS(base, value) (ADC_CLPX_OFS_REG(base) = (value))
#define ADC_RMW_CLPX_OFS(base, mask, value) (ADC_WR_CLPX_OFS(base, (ADC_RD_CLPX_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPX_OFS(base, value) (ADC_WR_CLPX_OFS(base, ADC_RD_CLPX_OFS(base) |  (value)))
#define ADC_CLR_CLPX_OFS(base, value) (ADC_WR_CLPX_OFS(base, ADC_RD_CLPX_OFS(base) & ~(value)))
#define ADC_TOG_CLPX_OFS(base, value) (ADC_WR_CLPX_OFS(base, ADC_RD_CLPX_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPX_OFS bitfields
 */

/*!
 * @name Register ADC_CLPX_OFS, field CLPX_OFS[11:0] (RW)
 *
 * Capacitor offset correction value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPX_OFS_CLPX_OFS field. */
#define ADC_RD_CLPX_OFS_CLPX_OFS(base) ((ADC_CLPX_OFS_REG(base) & ADC_CLPX_OFS_CLPX_OFS_MASK) >> ADC_CLPX_OFS_CLPX_OFS_SHIFT)
#define ADC_BRD_CLPX_OFS_CLPX_OFS(base) (ADC_RD_CLPX_OFS_CLPX_OFS(base))

/*! @brief Set the CLPX_OFS field to a new value. */
#define ADC_WR_CLPX_OFS_CLPX_OFS(base, value) (ADC_RMW_CLPX_OFS(base, ADC_CLPX_OFS_CLPX_OFS_MASK, ADC_CLPX_OFS_CLPX_OFS(value)))
#define ADC_BWR_CLPX_OFS_CLPX_OFS(base, value) (ADC_WR_CLPX_OFS_CLPX_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP9_OFS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP9_OFS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000243U
 *
 * For more information, see CLP9_OFS register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP9_OFS register
 */
/*@{*/
#define ADC_RD_CLP9_OFS(base)    (ADC_CLP9_OFS_REG(base))
#define ADC_WR_CLP9_OFS(base, value) (ADC_CLP9_OFS_REG(base) = (value))
#define ADC_RMW_CLP9_OFS(base, mask, value) (ADC_WR_CLP9_OFS(base, (ADC_RD_CLP9_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_CLP9_OFS(base, value) (ADC_WR_CLP9_OFS(base, ADC_RD_CLP9_OFS(base) |  (value)))
#define ADC_CLR_CLP9_OFS(base, value) (ADC_WR_CLP9_OFS(base, ADC_RD_CLP9_OFS(base) & ~(value)))
#define ADC_TOG_CLP9_OFS(base, value) (ADC_WR_CLP9_OFS(base, ADC_RD_CLP9_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP9_OFS bitfields
 */

/*!
 * @name Register ADC_CLP9_OFS, field CLP9_OFS[11:0] (RW)
 *
 * Capacitor offset correction value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP9_OFS_CLP9_OFS field. */
#define ADC_RD_CLP9_OFS_CLP9_OFS(base) ((ADC_CLP9_OFS_REG(base) & ADC_CLP9_OFS_CLP9_OFS_MASK) >> ADC_CLP9_OFS_CLP9_OFS_SHIFT)
#define ADC_BRD_CLP9_OFS_CLP9_OFS(base) (ADC_RD_CLP9_OFS_CLP9_OFS(base))

/*! @brief Set the CLP9_OFS field to a new value. */
#define ADC_WR_CLP9_OFS_CLP9_OFS(base, value) (ADC_RMW_CLP9_OFS(base, ADC_CLP9_OFS_CLP9_OFS_MASK, ADC_CLP9_OFS_CLP9_OFS(value)))
#define ADC_BWR_CLP9_OFS_CLP9_OFS(base, value) (ADC_WR_CLP9_OFS_CLP9_OFS(base, value))
/*@}*/

/*
 * S32K144 AIPS
 *
 * AIPS-Lite Bridge
 *
 * Registers defined in this header file:
 * - AIPS_MPRA - Master Privilege Register A
 * - AIPS_PACR - Peripheral Access Control Register
 * - AIPS_OPACR - Off-Platform Peripheral Access Control Register
 * - AIPS_PACRU - Peripheral Access Control Register
 */

#define AIPS_INSTANCE_COUNT (1U) /*!< Number of instances of the AIPS module. */
#define AIPS_IDX (0U) /*!< Instance number for AIPS. */

/*******************************************************************************
 * AIPS_MPRA - Master Privilege Register A
 ******************************************************************************/

/*!
 * @brief AIPS_MPRA - Master Privilege Register A (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MPRA specifies identical 4-bit fields defining the access-privilege level
 * associated with a bus master to various peripherals on the chip. The register
 * provides one field per bus master. At reset, the default value loaded into
 * the MPRA fields is chip-specific. See the chip configuration details for the
 * value of a particular device. A register field that maps to an unimplemented
 * master or peripheral behaves as read-only-zero. Each master is assigned a logical
 * ID from 0 to 15. See the master logical ID assignment table in the
 * chip-specific AIPS information.
 */
/*!
 * @name Constants and macros for entire AIPS_MPRA register
 */
/*@{*/
#define AIPS_RD_MPRA(base)       (AIPS_MPRA_REG(base))
#define AIPS_WR_MPRA(base, value) (AIPS_MPRA_REG(base) = (value))
#define AIPS_RMW_MPRA(base, mask, value) (AIPS_WR_MPRA(base, (AIPS_RD_MPRA(base) & ~(mask)) | (value)))
#define AIPS_SET_MPRA(base, value) (AIPS_WR_MPRA(base, AIPS_RD_MPRA(base) |  (value)))
#define AIPS_CLR_MPRA(base, value) (AIPS_WR_MPRA(base, AIPS_RD_MPRA(base) & ~(value)))
#define AIPS_TOG_MPRA(base, value) (AIPS_WR_MPRA(base, AIPS_RD_MPRA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * AIPS_PACR - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACR - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular on-platform peripheral. The peripheral
 * assignment to each PACR field is defined by the memory map slot of the
 * peripheral. See the chip-specific AIPS information for the field assignment of a
 * particular peripheral. Every PACR field to which no peripheral is assigned is
 * reserved. Reads to reserved locations return zeros, and writes are ignored. The
 * following table shows the location of each peripheral slot's PACR field in the
 * PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12] [11:8]
 * [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7 0x24
 * PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC PACR16
 * PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24 PACR25 PACR26
 * PACR27 PACR28 PACR29 PACR30 PACR31
 */
/*!
 * @name Constants and macros for entire AIPS_PACR register
 */
/*@{*/
#define AIPS_RD_PACR(base, index) (AIPS_PACR_REG(base, index))
#define AIPS_WR_PACR(base, index, value) (AIPS_PACR_REG(base, index) = (value))
#define AIPS_RMW_PACR(base, index, mask, value) (AIPS_WR_PACR(base, index, (AIPS_RD_PACR(base, index) & ~(mask)) | (value)))
#define AIPS_SET_PACR(base, index, value) (AIPS_WR_PACR(base, index, AIPS_RD_PACR(base, index) |  (value)))
#define AIPS_CLR_PACR(base, index, value) (AIPS_WR_PACR(base, index, AIPS_RD_PACR(base, index) & ~(value)))
#define AIPS_TOG_PACR(base, index, value) (AIPS_WR_PACR(base, index, AIPS_RD_PACR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACR bitfields
 */

/*!
 * @name Register AIPS_PACR, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP7 field. */
#define AIPS_RD_PACR_TP7(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP7_MASK) >> AIPS_PACR_TP7_SHIFT)
#define AIPS_BRD_PACR_TP7(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP7_SHIFT))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACR_TP7(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP7_MASK, AIPS_PACR_TP7(value)))
#define AIPS_BWR_PACR_TP7(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP7 field. */
#define AIPS_RD_PACR_WP7(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP7_MASK) >> AIPS_PACR_WP7_SHIFT)
#define AIPS_BRD_PACR_WP7(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP7_SHIFT))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACR_WP7(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP7_MASK, AIPS_PACR_WP7(value)))
#define AIPS_BWR_PACR_WP7(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP7 field. */
#define AIPS_RD_PACR_SP7(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP7_MASK) >> AIPS_PACR_SP7_SHIFT)
#define AIPS_BRD_PACR_SP7(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP7_SHIFT))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACR_SP7(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP7_MASK, AIPS_PACR_SP7(value)))
#define AIPS_BWR_PACR_SP7(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP6 field. */
#define AIPS_RD_PACR_TP6(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP6_MASK) >> AIPS_PACR_TP6_SHIFT)
#define AIPS_BRD_PACR_TP6(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP6_SHIFT))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACR_TP6(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP6_MASK, AIPS_PACR_TP6(value)))
#define AIPS_BWR_PACR_TP6(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP6 field. */
#define AIPS_RD_PACR_WP6(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP6_MASK) >> AIPS_PACR_WP6_SHIFT)
#define AIPS_BRD_PACR_WP6(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP6_SHIFT))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACR_WP6(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP6_MASK, AIPS_PACR_WP6(value)))
#define AIPS_BWR_PACR_WP6(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP6 field. */
#define AIPS_RD_PACR_SP6(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP6_MASK) >> AIPS_PACR_SP6_SHIFT)
#define AIPS_BRD_PACR_SP6(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP6_SHIFT))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACR_SP6(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP6_MASK, AIPS_PACR_SP6(value)))
#define AIPS_BWR_PACR_SP6(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP5 field. */
#define AIPS_RD_PACR_TP5(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP5_MASK) >> AIPS_PACR_TP5_SHIFT)
#define AIPS_BRD_PACR_TP5(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP5_SHIFT))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACR_TP5(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP5_MASK, AIPS_PACR_TP5(value)))
#define AIPS_BWR_PACR_TP5(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP5 field. */
#define AIPS_RD_PACR_WP5(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP5_MASK) >> AIPS_PACR_WP5_SHIFT)
#define AIPS_BRD_PACR_WP5(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP5_SHIFT))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACR_WP5(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP5_MASK, AIPS_PACR_WP5(value)))
#define AIPS_BWR_PACR_WP5(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP5 field. */
#define AIPS_RD_PACR_SP5(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP5_MASK) >> AIPS_PACR_SP5_SHIFT)
#define AIPS_BRD_PACR_SP5(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP5_SHIFT))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACR_SP5(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP5_MASK, AIPS_PACR_SP5(value)))
#define AIPS_BWR_PACR_SP5(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP4 field. */
#define AIPS_RD_PACR_TP4(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP4_MASK) >> AIPS_PACR_TP4_SHIFT)
#define AIPS_BRD_PACR_TP4(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP4_SHIFT))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACR_TP4(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP4_MASK, AIPS_PACR_TP4(value)))
#define AIPS_BWR_PACR_TP4(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP4 field. */
#define AIPS_RD_PACR_WP4(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP4_MASK) >> AIPS_PACR_WP4_SHIFT)
#define AIPS_BRD_PACR_WP4(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP4_SHIFT))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACR_WP4(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP4_MASK, AIPS_PACR_WP4(value)))
#define AIPS_BWR_PACR_WP4(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP4 field. */
#define AIPS_RD_PACR_SP4(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP4_MASK) >> AIPS_PACR_SP4_SHIFT)
#define AIPS_BRD_PACR_SP4(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP4_SHIFT))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACR_SP4(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP4_MASK, AIPS_PACR_SP4(value)))
#define AIPS_BWR_PACR_SP4(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP3 field. */
#define AIPS_RD_PACR_TP3(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP3_MASK) >> AIPS_PACR_TP3_SHIFT)
#define AIPS_BRD_PACR_TP3(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP3_SHIFT))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACR_TP3(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP3_MASK, AIPS_PACR_TP3(value)))
#define AIPS_BWR_PACR_TP3(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP3 field. */
#define AIPS_RD_PACR_WP3(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP3_MASK) >> AIPS_PACR_WP3_SHIFT)
#define AIPS_BRD_PACR_WP3(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP3_SHIFT))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACR_WP3(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP3_MASK, AIPS_PACR_WP3(value)))
#define AIPS_BWR_PACR_WP3(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP3 field. */
#define AIPS_RD_PACR_SP3(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP3_MASK) >> AIPS_PACR_SP3_SHIFT)
#define AIPS_BRD_PACR_SP3(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP3_SHIFT))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACR_SP3(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP3_MASK, AIPS_PACR_SP3(value)))
#define AIPS_BWR_PACR_SP3(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP2 field. */
#define AIPS_RD_PACR_TP2(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP2_MASK) >> AIPS_PACR_TP2_SHIFT)
#define AIPS_BRD_PACR_TP2(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP2_SHIFT))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACR_TP2(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP2_MASK, AIPS_PACR_TP2(value)))
#define AIPS_BWR_PACR_TP2(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP2 field. */
#define AIPS_RD_PACR_WP2(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP2_MASK) >> AIPS_PACR_WP2_SHIFT)
#define AIPS_BRD_PACR_WP2(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP2_SHIFT))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACR_WP2(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP2_MASK, AIPS_PACR_WP2(value)))
#define AIPS_BWR_PACR_WP2(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP2 field. */
#define AIPS_RD_PACR_SP2(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP2_MASK) >> AIPS_PACR_SP2_SHIFT)
#define AIPS_BRD_PACR_SP2(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP2_SHIFT))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACR_SP2(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP2_MASK, AIPS_PACR_SP2(value)))
#define AIPS_BWR_PACR_SP2(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP1 field. */
#define AIPS_RD_PACR_TP1(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP1_MASK) >> AIPS_PACR_TP1_SHIFT)
#define AIPS_BRD_PACR_TP1(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP1_SHIFT))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACR_TP1(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP1_MASK, AIPS_PACR_TP1(value)))
#define AIPS_BWR_PACR_TP1(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP1 field. */
#define AIPS_RD_PACR_WP1(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP1_MASK) >> AIPS_PACR_WP1_SHIFT)
#define AIPS_BRD_PACR_WP1(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP1_SHIFT))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACR_WP1(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP1_MASK, AIPS_PACR_WP1(value)))
#define AIPS_BWR_PACR_WP1(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP1 field. */
#define AIPS_RD_PACR_SP1(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP1_MASK) >> AIPS_PACR_SP1_SHIFT)
#define AIPS_BRD_PACR_SP1(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP1_SHIFT))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACR_SP1(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP1_MASK, AIPS_PACR_SP1(value)))
#define AIPS_BWR_PACR_SP1(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_TP0 field. */
#define AIPS_RD_PACR_TP0(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_TP0_MASK) >> AIPS_PACR_TP0_SHIFT)
#define AIPS_BRD_PACR_TP0(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP0_SHIFT))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACR_TP0(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_TP0_MASK, AIPS_PACR_TP0(value)))
#define AIPS_BWR_PACR_TP0(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_TP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_WP0 field. */
#define AIPS_RD_PACR_WP0(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_WP0_MASK) >> AIPS_PACR_WP0_SHIFT)
#define AIPS_BRD_PACR_WP0(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP0_SHIFT))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACR_WP0(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_WP0_MASK, AIPS_PACR_WP0(value)))
#define AIPS_BWR_PACR_WP0(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_WP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACR, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACR_SP0 field. */
#define AIPS_RD_PACR_SP0(base, index) ((AIPS_PACR_REG(base, index) & AIPS_PACR_SP0_MASK) >> AIPS_PACR_SP0_SHIFT)
#define AIPS_BRD_PACR_SP0(base, index) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP0_SHIFT))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACR_SP0(base, index, value) (AIPS_RMW_PACR(base, index, AIPS_PACR_SP0_MASK, AIPS_PACR_SP0(value)))
#define AIPS_BWR_PACR_SP0(base, index, value) (BITBAND_ACCESS32(&AIPS_PACR_REG(base, index), AIPS_PACR_SP0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * AIPS_OPACR - Off-Platform Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_OPACR - Off-Platform Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each OPACR register consists of eight 4-bit OPACR fields. Each OPACR field
 * defines the access levels for a particular off-platform peripheral. The
 * peripheral assignment to each OPACR field is defined by the memory map slot of the
 * peripheral. See the chip-specific AIPS information for the field assignment of a
 * particular peripheral. Every OPACR field to which no peripheral is assigned is
 * reserved. Reads to reserved locations return zeros, and writes are ignored.
 * The following table shows the location of each peripheral slot's OPACR field in
 * the OPACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x40 OPACRA OPACR0 OPACR1 OPACR2 OPACR3 OPACR4 OPACR5
 * OPACR6 OPACR7 0x44 OPACRB OPACR8 OPACR9 OPACR10 OPACR11 OPACR12 OPACR13 OPACR14
 * OPACR15 0x48 OPACRC OPACR16 OPACR17 OPACR18 OPACR19 OPACR20 OPACR21 OPACR22
 * OPACR23 0x4C OPACRD OPACR24 OPACR25 OPACR26 OPACR27 OPACR28 OPACR29 OPACR30 OPACR31
 * 0x50 OPACRE OPACR32 OPACR33 OPACR34 OPACR35 OPACR36 OPACR37 OPACR38 OPACR39
 * 0x54 OPACRF OPACR40 OPACR41 OPACR42 OPACR43 OPACR44 OPACR45 OPACR46 OPACR47
 * 0x58 OPACRG OPACR48 OPACR49 OPACR50 OPACR51 OPACR52 OPACR53 OPACR54 OPACR55 0x5C
 * OPACRH OPACR56 OPACR57 OPACR58 OPACR59 OPACR60 OPACR61 OPACR62 OPACR63 0x60
 * OPACRI OPACR64 OPACR65 OPACR66 OPACR67 OPACR68 OPACR69 OPACR70 OPACR71 0x64
 * OPACRJ OPACR72 OPACR73 OPACR74 OPACR75 OPACR76 OPACR77 OPACR78 OPACR79 0x68 OPACRK
 * OPACR80 OPACR81 OPACR82 OPACR83 OPACR84 OPACR85 OPACR86 OPACR87 0x6C OPACRL
 * OPACR88 OPACR89 OPACR90 OPACR91 OPACR92 OPACR93 OPACR94 OPACR95 0x70 OPACRM
 * OPACR96 OPACR97 OPACR98 OPACR99 OPACR100 OPACR101 OPACR102 OPACR103 0x74 OPACRN
 * OPACR104 OPACR105 OPACR106 OPACR107 OPACR108 OPACR109 OPACR110 OPACR111 0x78
 * OPACRO OPACR112 OPACR113 OPACR114 OPACR115 OPACR116 OPACR117 OPACR118 OPACR119
 * 0x7C OPACRP OPACR120 OPACR121 OPACR122 OPACR123 OPACR124 OPACR125 OPACR126
 * OPACR127
 */
/*!
 * @name Constants and macros for entire AIPS_OPACR register
 */
/*@{*/
#define AIPS_RD_OPACR(base, index) (AIPS_OPACR_REG(base, index))
#define AIPS_WR_OPACR(base, index, value) (AIPS_OPACR_REG(base, index) = (value))
#define AIPS_RMW_OPACR(base, index, mask, value) (AIPS_WR_OPACR(base, index, (AIPS_RD_OPACR(base, index) & ~(mask)) | (value)))
#define AIPS_SET_OPACR(base, index, value) (AIPS_WR_OPACR(base, index, AIPS_RD_OPACR(base, index) |  (value)))
#define AIPS_CLR_OPACR(base, index, value) (AIPS_WR_OPACR(base, index, AIPS_RD_OPACR(base, index) & ~(value)))
#define AIPS_TOG_OPACR(base, index, value) (AIPS_WR_OPACR(base, index, AIPS_RD_OPACR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_OPACR bitfields
 */

/*!
 * @name Register AIPS_OPACR, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP7 field. */
#define AIPS_RD_OPACR_TP7(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP7_MASK) >> AIPS_OPACR_TP7_SHIFT)
#define AIPS_BRD_OPACR_TP7(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP7_SHIFT))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_OPACR_TP7(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP7_MASK, AIPS_OPACR_TP7(value)))
#define AIPS_BWR_OPACR_TP7(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP7 field. */
#define AIPS_RD_OPACR_WP7(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP7_MASK) >> AIPS_OPACR_WP7_SHIFT)
#define AIPS_BRD_OPACR_WP7(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP7_SHIFT))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_OPACR_WP7(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP7_MASK, AIPS_OPACR_WP7(value)))
#define AIPS_BWR_OPACR_WP7(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP7 field. */
#define AIPS_RD_OPACR_SP7(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP7_MASK) >> AIPS_OPACR_SP7_SHIFT)
#define AIPS_BRD_OPACR_SP7(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP7_SHIFT))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_OPACR_SP7(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP7_MASK, AIPS_OPACR_SP7(value)))
#define AIPS_BWR_OPACR_SP7(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP6 field. */
#define AIPS_RD_OPACR_TP6(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP6_MASK) >> AIPS_OPACR_TP6_SHIFT)
#define AIPS_BRD_OPACR_TP6(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP6_SHIFT))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_OPACR_TP6(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP6_MASK, AIPS_OPACR_TP6(value)))
#define AIPS_BWR_OPACR_TP6(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP6 field. */
#define AIPS_RD_OPACR_WP6(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP6_MASK) >> AIPS_OPACR_WP6_SHIFT)
#define AIPS_BRD_OPACR_WP6(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP6_SHIFT))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_OPACR_WP6(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP6_MASK, AIPS_OPACR_WP6(value)))
#define AIPS_BWR_OPACR_WP6(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP6 field. */
#define AIPS_RD_OPACR_SP6(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP6_MASK) >> AIPS_OPACR_SP6_SHIFT)
#define AIPS_BRD_OPACR_SP6(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP6_SHIFT))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_OPACR_SP6(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP6_MASK, AIPS_OPACR_SP6(value)))
#define AIPS_BWR_OPACR_SP6(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP5 field. */
#define AIPS_RD_OPACR_TP5(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP5_MASK) >> AIPS_OPACR_TP5_SHIFT)
#define AIPS_BRD_OPACR_TP5(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP5_SHIFT))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_OPACR_TP5(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP5_MASK, AIPS_OPACR_TP5(value)))
#define AIPS_BWR_OPACR_TP5(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP5 field. */
#define AIPS_RD_OPACR_WP5(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP5_MASK) >> AIPS_OPACR_WP5_SHIFT)
#define AIPS_BRD_OPACR_WP5(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP5_SHIFT))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_OPACR_WP5(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP5_MASK, AIPS_OPACR_WP5(value)))
#define AIPS_BWR_OPACR_WP5(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP5 field. */
#define AIPS_RD_OPACR_SP5(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP5_MASK) >> AIPS_OPACR_SP5_SHIFT)
#define AIPS_BRD_OPACR_SP5(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP5_SHIFT))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_OPACR_SP5(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP5_MASK, AIPS_OPACR_SP5(value)))
#define AIPS_BWR_OPACR_SP5(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP4 field. */
#define AIPS_RD_OPACR_TP4(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP4_MASK) >> AIPS_OPACR_TP4_SHIFT)
#define AIPS_BRD_OPACR_TP4(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP4_SHIFT))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_OPACR_TP4(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP4_MASK, AIPS_OPACR_TP4(value)))
#define AIPS_BWR_OPACR_TP4(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP4 field. */
#define AIPS_RD_OPACR_WP4(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP4_MASK) >> AIPS_OPACR_WP4_SHIFT)
#define AIPS_BRD_OPACR_WP4(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP4_SHIFT))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_OPACR_WP4(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP4_MASK, AIPS_OPACR_WP4(value)))
#define AIPS_BWR_OPACR_WP4(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP4 field. */
#define AIPS_RD_OPACR_SP4(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP4_MASK) >> AIPS_OPACR_SP4_SHIFT)
#define AIPS_BRD_OPACR_SP4(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP4_SHIFT))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_OPACR_SP4(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP4_MASK, AIPS_OPACR_SP4(value)))
#define AIPS_BWR_OPACR_SP4(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP3 field. */
#define AIPS_RD_OPACR_TP3(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP3_MASK) >> AIPS_OPACR_TP3_SHIFT)
#define AIPS_BRD_OPACR_TP3(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP3_SHIFT))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_OPACR_TP3(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP3_MASK, AIPS_OPACR_TP3(value)))
#define AIPS_BWR_OPACR_TP3(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP3 field. */
#define AIPS_RD_OPACR_WP3(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP3_MASK) >> AIPS_OPACR_WP3_SHIFT)
#define AIPS_BRD_OPACR_WP3(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP3_SHIFT))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_OPACR_WP3(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP3_MASK, AIPS_OPACR_WP3(value)))
#define AIPS_BWR_OPACR_WP3(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP3 field. */
#define AIPS_RD_OPACR_SP3(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP3_MASK) >> AIPS_OPACR_SP3_SHIFT)
#define AIPS_BRD_OPACR_SP3(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP3_SHIFT))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_OPACR_SP3(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP3_MASK, AIPS_OPACR_SP3(value)))
#define AIPS_BWR_OPACR_SP3(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP2 field. */
#define AIPS_RD_OPACR_TP2(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP2_MASK) >> AIPS_OPACR_TP2_SHIFT)
#define AIPS_BRD_OPACR_TP2(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP2_SHIFT))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_OPACR_TP2(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP2_MASK, AIPS_OPACR_TP2(value)))
#define AIPS_BWR_OPACR_TP2(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP2 field. */
#define AIPS_RD_OPACR_WP2(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP2_MASK) >> AIPS_OPACR_WP2_SHIFT)
#define AIPS_BRD_OPACR_WP2(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP2_SHIFT))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_OPACR_WP2(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP2_MASK, AIPS_OPACR_WP2(value)))
#define AIPS_BWR_OPACR_WP2(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP2 field. */
#define AIPS_RD_OPACR_SP2(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP2_MASK) >> AIPS_OPACR_SP2_SHIFT)
#define AIPS_BRD_OPACR_SP2(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP2_SHIFT))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_OPACR_SP2(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP2_MASK, AIPS_OPACR_SP2(value)))
#define AIPS_BWR_OPACR_SP2(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP1 field. */
#define AIPS_RD_OPACR_TP1(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP1_MASK) >> AIPS_OPACR_TP1_SHIFT)
#define AIPS_BRD_OPACR_TP1(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP1_SHIFT))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_OPACR_TP1(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP1_MASK, AIPS_OPACR_TP1(value)))
#define AIPS_BWR_OPACR_TP1(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP1 field. */
#define AIPS_RD_OPACR_WP1(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP1_MASK) >> AIPS_OPACR_WP1_SHIFT)
#define AIPS_BRD_OPACR_WP1(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP1_SHIFT))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_OPACR_WP1(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP1_MASK, AIPS_OPACR_WP1(value)))
#define AIPS_BWR_OPACR_WP1(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP1 field. */
#define AIPS_RD_OPACR_SP1(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP1_MASK) >> AIPS_OPACR_SP1_SHIFT)
#define AIPS_BRD_OPACR_SP1(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP1_SHIFT))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_OPACR_SP1(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP1_MASK, AIPS_OPACR_SP1(value)))
#define AIPS_BWR_OPACR_SP1(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_TP0 field. */
#define AIPS_RD_OPACR_TP0(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_TP0_MASK) >> AIPS_OPACR_TP0_SHIFT)
#define AIPS_BRD_OPACR_TP0(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP0_SHIFT))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_OPACR_TP0(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_TP0_MASK, AIPS_OPACR_TP0(value)))
#define AIPS_BWR_OPACR_TP0(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_TP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_WP0 field. */
#define AIPS_RD_OPACR_WP0(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_WP0_MASK) >> AIPS_OPACR_WP0_SHIFT)
#define AIPS_BRD_OPACR_WP0(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP0_SHIFT))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_OPACR_WP0(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_WP0_MASK, AIPS_OPACR_WP0(value)))
#define AIPS_BWR_OPACR_WP0(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_WP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_OPACR, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_OPACR_SP0 field. */
#define AIPS_RD_OPACR_SP0(base, index) ((AIPS_OPACR_REG(base, index) & AIPS_OPACR_SP0_MASK) >> AIPS_OPACR_SP0_SHIFT)
#define AIPS_BRD_OPACR_SP0(base, index) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP0_SHIFT))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_OPACR_SP0(base, index, value) (AIPS_RMW_OPACR(base, index, AIPS_OPACR_SP0_MASK, AIPS_OPACR_SP0(value)))
#define AIPS_BWR_OPACR_SP0(base, index, value) (BITBAND_ACCESS32(&AIPS_OPACR_REG(base, index), AIPS_OPACR_SP0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * AIPS_PACRU - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRU - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * PACRU defines the access levels for the two global spaces.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRU register
 */
/*@{*/
#define AIPS_RD_PACRU(base)      (AIPS_PACRU_REG(base))
#define AIPS_WR_PACRU(base, value) (AIPS_PACRU_REG(base) = (value))
#define AIPS_RMW_PACRU(base, mask, value) (AIPS_WR_PACRU(base, (AIPS_RD_PACRU(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRU(base, value) (AIPS_WR_PACRU(base, AIPS_RD_PACRU(base) |  (value)))
#define AIPS_CLR_PACRU(base, value) (AIPS_WR_PACRU(base, AIPS_RD_PACRU(base) & ~(value)))
#define AIPS_TOG_PACRU(base, value) (AIPS_WR_PACRU(base, AIPS_RD_PACRU(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRU bitfields
 */

/*!
 * @name Register AIPS_PACRU, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRU_TP1 field. */
#define AIPS_RD_PACRU_TP1(base) ((AIPS_PACRU_REG(base) & AIPS_PACRU_TP1_MASK) >> AIPS_PACRU_TP1_SHIFT)
#define AIPS_BRD_PACRU_TP1(base) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_TP1_SHIFT))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRU_TP1(base, value) (AIPS_RMW_PACRU(base, AIPS_PACRU_TP1_MASK, AIPS_PACRU_TP1(value)))
#define AIPS_BWR_PACRU_TP1(base, value) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_TP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesss. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRU_WP1 field. */
#define AIPS_RD_PACRU_WP1(base) ((AIPS_PACRU_REG(base) & AIPS_PACRU_WP1_MASK) >> AIPS_PACRU_WP1_SHIFT)
#define AIPS_BRD_PACRU_WP1(base) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_WP1_SHIFT))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRU_WP1(base, value) (AIPS_RMW_PACRU(base, AIPS_PACRU_WP1_MASK, AIPS_PACRU_WP1(value)))
#define AIPS_BWR_PACRU_WP1(base, value) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_WP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRU_SP1 field. */
#define AIPS_RD_PACRU_SP1(base) ((AIPS_PACRU_REG(base) & AIPS_PACRU_SP1_MASK) >> AIPS_PACRU_SP1_SHIFT)
#define AIPS_BRD_PACRU_SP1(base) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_SP1_SHIFT))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRU_SP1(base, value) (AIPS_RMW_PACRU(base, AIPS_PACRU_SP1_MASK, AIPS_PACRU_SP1(value)))
#define AIPS_BWR_PACRU_SP1(base, value) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_SP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRU_TP0 field. */
#define AIPS_RD_PACRU_TP0(base) ((AIPS_PACRU_REG(base) & AIPS_PACRU_TP0_MASK) >> AIPS_PACRU_TP0_SHIFT)
#define AIPS_BRD_PACRU_TP0(base) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_TP0_SHIFT))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRU_TP0(base, value) (AIPS_RMW_PACRU(base, AIPS_PACRU_TP0_MASK, AIPS_PACRU_TP0(value)))
#define AIPS_BWR_PACRU_TP0(base, value) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_TP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRU_WP0 field. */
#define AIPS_RD_PACRU_WP0(base) ((AIPS_PACRU_REG(base) & AIPS_PACRU_WP0_MASK) >> AIPS_PACRU_WP0_SHIFT)
#define AIPS_BRD_PACRU_WP0(base) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_WP0_SHIFT))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRU_WP0(base, value) (AIPS_RMW_PACRU(base, AIPS_PACRU_WP0_MASK, AIPS_PACRU_WP0(value)))
#define AIPS_BWR_PACRU_WP0(base, value) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_WP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register AIPS_PACRU, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRU_SP0 field. */
#define AIPS_RD_PACRU_SP0(base) ((AIPS_PACRU_REG(base) & AIPS_PACRU_SP0_MASK) >> AIPS_PACRU_SP0_SHIFT)
#define AIPS_BRD_PACRU_SP0(base) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_SP0_SHIFT))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRU_SP0(base, value) (AIPS_RMW_PACRU(base, AIPS_PACRU_SP0_MASK, AIPS_PACRU_SP0(value)))
#define AIPS_BWR_PACRU_SP0(base, value) (BITBAND_ACCESS32(&AIPS_PACRU_REG(base), AIPS_PACRU_SP0_SHIFT) = (value))
/*@}*/

/*
 * S32K144 CAN
 *
 * Flex Controller Area Network module
 *
 * Registers defined in this header file:
 * - CAN_MCR - Module Configuration Register
 * - CAN_CTRL1 - Control 1 register
 * - CAN_TIMER - Free Running Timer
 * - CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 * - CAN_RX14MASK - Rx 14 Mask register
 * - CAN_RX15MASK - Rx 15 Mask register
 * - CAN_ECR - Error Counter
 * - CAN_ESR1 - Error and Status 1 register
 * - CAN_IMASK1 - Interrupt Masks 1 register
 * - CAN_IFLAG1 - Interrupt Flags 1 register
 * - CAN_CTRL2 - Control 2 register
 * - CAN_ESR2 - Error and Status 2 register
 * - CAN_CRCR - CRC Register
 * - CAN_RXFGMASK - Rx FIFO Global Mask register
 * - CAN_RXFIR - Rx FIFO Information Register
 * - CAN_CBT - CAN Bit Timing Register
 * - CAN_RXIMR - Rx Individual Mask Registers
 * - CAN_CTRL1_PN - Pretended Networking Control 1 Register
 * - CAN_CTRL2_PN - Pretended Networking Control 2 Register
 * - CAN_WU_MTC - Pretended Networking Wake Up Match Register
 * - CAN_FLT_ID1 - Pretended Networking ID Filter 1 Register
 * - CAN_FLT_DLC - Pretended Networking DLC Filter Register
 * - CAN_PL1_LO - Pretended Networking Payload Low Filter 1 Register
 * - CAN_PL1_HI - Pretended Networking Payload High Filter 1 Register
 * - CAN_FLT_ID2_IDMASK - Pretended Networking ID Filter 2 Register / ID Mask Register
 * - CAN_PL2_PLMASK_LO - Pretended Networking Payload Low Filter 2 Register / Payload Low Mask Register
 * - CAN_PL2_PLMASK_HI - Pretended Networking Payload High Filter 2 low order bits / Payload High Mask Register
 * - CAN_WMB0_CS - Wake Up Message Buffer Register for C/S
 * - CAN_WMB0_ID - Wake Up Message Buffer Register for ID
 * - CAN_WMB0_D03 - Wake Up Message Buffer Register for Data 0-3
 * - CAN_WMB0_D47 - Wake Up Message Buffer Register Data 4-7
 * - CAN_WMB1_CS - Wake Up Message Buffer Register for C/S
 * - CAN_WMB1_ID - Wake Up Message Buffer Register for ID
 * - CAN_WMB1_D03 - Wake Up Message Buffer Register for Data 0-3
 * - CAN_WMB1_D47 - Wake Up Message Buffer Register Data 4-7
 * - CAN_WMB2_CS - Wake Up Message Buffer Register for C/S
 * - CAN_WMB2_ID - Wake Up Message Buffer Register for ID
 * - CAN_WMB2_D03 - Wake Up Message Buffer Register for Data 0-3
 * - CAN_WMB2_D47 - Wake Up Message Buffer Register Data 4-7
 * - CAN_WMB3_CS - Wake Up Message Buffer Register for C/S
 * - CAN_WMB3_ID - Wake Up Message Buffer Register for ID
 * - CAN_WMB3_D03 - Wake Up Message Buffer Register for Data 0-3
 * - CAN_WMB3_D47 - Wake Up Message Buffer Register Data 4-7
 * - CAN_FDCTRL - CAN FD Control Register
 * - CAN_FDCBT - CAN FD Bit Timing Register
 * - CAN_FDCRC - CAN FD CRC Register
 */

#define CAN_INSTANCE_COUNT (3U) /*!< Number of instances of the CAN module. */
#define CAN0_IDX (0U) /*!< Instance number for CAN0. */
#define CAN1_IDX (1U) /*!< Instance number for CAN1. */
#define CAN2_IDX (2U) /*!< Instance number for CAN2. */

/*******************************************************************************
 * CAN_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief CAN_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0xD890000FU
 *
 * This register defines global system configurations, such as the module
 * operation modes and the maximum message buffer configuration.
 */
/*!
 * @name Constants and macros for entire CAN_MCR register
 */
/*@{*/
#define CAN_RD_MCR(base)         (CAN_MCR_REG(base))
#define CAN_WR_MCR(base, value)  (CAN_MCR_REG(base) = (value))
#define CAN_RMW_MCR(base, mask, value) (CAN_WR_MCR(base, (CAN_RD_MCR(base) & ~(mask)) | (value)))
#define CAN_SET_MCR(base, value) (CAN_WR_MCR(base, CAN_RD_MCR(base) |  (value)))
#define CAN_CLR_MCR(base, value) (CAN_WR_MCR(base, CAN_RD_MCR(base) & ~(value)))
#define CAN_TOG_MCR(base, value) (CAN_WR_MCR(base, CAN_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_MCR bitfields
 */

/*!
 * @name Register CAN_MCR, field MAXMB[6:0] (RW)
 *
 * This 7-bit field defines the number of the last Message Buffers that will
 * take part in the matching and arbitration processes. The reset value (0x0F) is
 * equivalent to a 16 MB configuration. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Number of the last MB =
 * MAXMB MAXMB must be programmed with a value smaller than or equal to the number
 * of available Message Buffers, as described in FlexCAN Memory Partition for
 * CAN FD . Additionally, the definition of MAXMB value must take into account the
 * region of MBs occupied by Rx FIFO and its ID filters table space defined by
 * RFFN bit in CAN_CTRL2 register. MAXMB also impacts the definition of the minimum
 * number of peripheral clocks per CAN bit as described in Table "Minimum Ratio
 * Between Peripheral Clock Frequency and CAN Bit Rate" (see Arbitration and
 * matching timing).
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_MAXMB field. */
#define CAN_RD_MCR_MAXMB(base) ((CAN_MCR_REG(base) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT)
#define CAN_BRD_MCR_MAXMB(base) (CAN_RD_MCR_MAXMB(base))

/*! @brief Set the MAXMB field to a new value. */
#define CAN_WR_MCR_MAXMB(base, value) (CAN_RMW_MCR(base, CAN_MCR_MAXMB_MASK, CAN_MCR_MAXMB(value)))
#define CAN_BWR_MCR_MAXMB(base, value) (CAN_WR_MCR_MAXMB(base, value))
/*@}*/

/*!
 * @name Register CAN_MCR, field IDAM[9:8] (RW)
 *
 * This 2-bit field identifies the format of the Rx FIFO ID Filter Table
 * elements. Note that all elements of the table are configured at the same time by this
 * field (they are all the same format). See Section "Rx FIFO Structure". This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes.
 *
 * Values:
 * - 0b00 - Format A: One full ID (standard and extended) per ID Filter Table
 *     element.
 * - 0b01 - Format B: Two full standard IDs or two partial 14-bit (standard and
 *     extended) IDs per ID Filter Table element.
 * - 0b10 - Format C: Four partial 8-bit Standard IDs per ID Filter Table
 *     element.
 * - 0b11 - Format D: All frames rejected.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_IDAM field. */
#define CAN_RD_MCR_IDAM(base) ((CAN_MCR_REG(base) & CAN_MCR_IDAM_MASK) >> CAN_MCR_IDAM_SHIFT)
#define CAN_BRD_MCR_IDAM(base) (CAN_RD_MCR_IDAM(base))

/*! @brief Set the IDAM field to a new value. */
#define CAN_WR_MCR_IDAM(base, value) (CAN_RMW_MCR(base, CAN_MCR_IDAM_MASK, CAN_MCR_IDAM(value)))
#define CAN_BWR_MCR_IDAM(base, value) (CAN_WR_MCR_IDAM(base, value))
/*@}*/

/*!
 * @name Register CAN_MCR, field FDEN[11] (RW)
 *
 * This bit enables the CAN with Flexible Data rate (CAN FD) operation. This bit
 * can be written in Freeze mode only.The Rx FIFO Enable (RFEN) bit cannot be
 * set if FDEN is asserted.
 *
 * Values:
 * - 0b1 - CAN FD is enabled. FlexCAN is able to receive and transmit messages
 *     in both CAN FD and CAN 2.0 formats.
 * - 0b0 - CAN FD is disabled. FlexCAN is able to receive and transmit messages
 *     in CAN 2.0 format.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_FDEN field. */
#define CAN_RD_MCR_FDEN(base) ((CAN_MCR_REG(base) & CAN_MCR_FDEN_MASK) >> CAN_MCR_FDEN_SHIFT)
#define CAN_BRD_MCR_FDEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FDEN_SHIFT))

/*! @brief Set the FDEN field to a new value. */
#define CAN_WR_MCR_FDEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_FDEN_MASK, CAN_MCR_FDEN(value)))
#define CAN_BWR_MCR_FDEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FDEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field AEN[12] (RW)
 *
 * When asserted, this bit enables the Tx abort mechanism. This mechanism
 * guarantees a safe procedure for aborting a pending transmission, so that no frame is
 * sent in the CAN bus without notification. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes. When CAN_MCR[AEN]
 * is asserted, only the abort mechanism (see Transmission abort mechanism) must
 * be used for updating Mailboxes configured for transmission. Writing the Abort
 * code into Rx Mailboxes can cause unpredictable results when the CAN_MCR[AEN] is
 * asserted.
 *
 * Values:
 * - 0b0 - Abort disabled.
 * - 0b1 - Abort enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_AEN field. */
#define CAN_RD_MCR_AEN(base) ((CAN_MCR_REG(base) & CAN_MCR_AEN_MASK) >> CAN_MCR_AEN_SHIFT)
#define CAN_BRD_MCR_AEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_AEN_SHIFT))

/*! @brief Set the AEN field to a new value. */
#define CAN_WR_MCR_AEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_AEN_MASK, CAN_MCR_AEN(value)))
#define CAN_BWR_MCR_AEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_AEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPRIOEN[13] (RW)
 *
 * This bit is provided for backwards compatibility with legacy applications. It
 * controls whether the local priority feature is enabled or not. It is used to
 * expand the ID used during the arbitration process. With this expanded ID
 * concept, the arbitration process is done based on the full 32-bit word, but the
 * actual transmitted ID still has 11-bit for standard frames and 29-bit for
 * extended frames. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes.
 *
 * Values:
 * - 0b0 - Local Priority disabled.
 * - 0b1 - Local Priority enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_LPRIOEN field. */
#define CAN_RD_MCR_LPRIOEN(base) ((CAN_MCR_REG(base) & CAN_MCR_LPRIOEN_MASK) >> CAN_MCR_LPRIOEN_SHIFT)
#define CAN_BRD_MCR_LPRIOEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_LPRIOEN_SHIFT))

/*! @brief Set the LPRIOEN field to a new value. */
#define CAN_WR_MCR_LPRIOEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_LPRIOEN_MASK, CAN_MCR_LPRIOEN(value)))
#define CAN_BWR_MCR_LPRIOEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_LPRIOEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field PNET_EN[14] (RW)
 *
 * This bit enables the Pretended Networking functionality. Once in Doze mode or
 * Stop mode, CAN_PE sub-block is kept operational, able to process Rx message
 * filtering as defined by the Pretended Networking configuration registers. See
 * Receive Process under Pretended Networking Mode. This bit can be written in
 * Freeze mode only.
 *
 * Values:
 * - 0b0 - Pretended Networking mode is disabled.
 * - 0b1 - Pretended Networking mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_PNET_EN field. */
#define CAN_RD_MCR_PNET_EN(base) ((CAN_MCR_REG(base) & CAN_MCR_PNET_EN_MASK) >> CAN_MCR_PNET_EN_SHIFT)
#define CAN_BRD_MCR_PNET_EN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_PNET_EN_SHIFT))

/*! @brief Set the PNET_EN field to a new value. */
#define CAN_WR_MCR_PNET_EN(base, value) (CAN_RMW_MCR(base, CAN_MCR_PNET_EN_MASK, CAN_MCR_PNET_EN(value)))
#define CAN_BWR_MCR_PNET_EN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_PNET_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field DMA[15] (RW)
 *
 * The DMA Enable bit controls whether the DMA feature is enabled or not. The
 * DMA feature can only be used in Rx FIFO, consequently the bit CAN_MCR[RFEN] must
 * be asserted. When DMA and RFEN are set, the CAN_IFLAG1[BUF5I] generates the
 * DMA request and no RX FIFO interrupt is generated. This bit can be written in
 * Freeze mode only as it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - DMA feature for RX FIFO disabled.
 * - 0b1 - DMA feature for RX FIFO enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_DMA field. */
#define CAN_RD_MCR_DMA(base) ((CAN_MCR_REG(base) & CAN_MCR_DMA_MASK) >> CAN_MCR_DMA_SHIFT)
#define CAN_BRD_MCR_DMA(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define CAN_WR_MCR_DMA(base, value) (CAN_RMW_MCR(base, CAN_MCR_DMA_MASK, CAN_MCR_DMA(value)))
#define CAN_BWR_MCR_DMA(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field IRMQ[16] (RW)
 *
 * This bit indicates whether Rx matching process will be based either on
 * individual masking and queue or on masking scheme with CAN_RXMGMASK, CAN_RX14MASK,
 * CAN_RX15MASK and CAN_RXFGMASK. This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Individual Rx masking and queue feature are disabled. For backward
 *     compatibility with legacy applications, the reading of C/S word locks the MB
 *     even if it is EMPTY.
 * - 0b1 - Individual Rx masking and queue feature are enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_IRMQ field. */
#define CAN_RD_MCR_IRMQ(base) ((CAN_MCR_REG(base) & CAN_MCR_IRMQ_MASK) >> CAN_MCR_IRMQ_SHIFT)
#define CAN_BRD_MCR_IRMQ(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_IRMQ_SHIFT))

/*! @brief Set the IRMQ field to a new value. */
#define CAN_WR_MCR_IRMQ(base, value) (CAN_RMW_MCR(base, CAN_MCR_IRMQ_MASK, CAN_MCR_IRMQ(value)))
#define CAN_BWR_MCR_IRMQ(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_IRMQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field SRXDIS[17] (RW)
 *
 * This bit defines whether FlexCAN is allowed to receive frames transmitted by
 * itself. If this bit is asserted, frames transmitted by the module will not be
 * stored in any MB, regardless if the MB is programmed with an ID that matches
 * the transmitted frame, and no interrupt flag or interrupt signal will be
 * generated due to the frame reception. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Self reception enabled.
 * - 0b1 - Self reception disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SRXDIS field. */
#define CAN_RD_MCR_SRXDIS(base) ((CAN_MCR_REG(base) & CAN_MCR_SRXDIS_MASK) >> CAN_MCR_SRXDIS_SHIFT)
#define CAN_BRD_MCR_SRXDIS(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SRXDIS_SHIFT))

/*! @brief Set the SRXDIS field to a new value. */
#define CAN_WR_MCR_SRXDIS(base, value) (CAN_RMW_MCR(base, CAN_MCR_SRXDIS_MASK, CAN_MCR_SRXDIS(value)))
#define CAN_BWR_MCR_SRXDIS(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SRXDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKSRC[19] (RW)
 *
 * This bit defines whether the integrated low-pass filter is applied to protect
 * the Rx CAN input from spurious wake up. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - FlexCAN uses the unfiltered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 * - 0b1 - FlexCAN uses the filtered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WAKSRC field. */
#define CAN_RD_MCR_WAKSRC(base) ((CAN_MCR_REG(base) & CAN_MCR_WAKSRC_MASK) >> CAN_MCR_WAKSRC_SHIFT)
#define CAN_BRD_MCR_WAKSRC(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKSRC_SHIFT))

/*! @brief Set the WAKSRC field to a new value. */
#define CAN_WR_MCR_WAKSRC(base, value) (CAN_RMW_MCR(base, CAN_MCR_WAKSRC_MASK, CAN_MCR_WAKSRC(value)))
#define CAN_BWR_MCR_WAKSRC(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPMACK[20] (RO)
 *
 * This read-only bit indicates that FlexCAN is in a low-power mode (Disable
 * mode, Stop mode). A low-power mode cannot be entered until all current
 * transmission or reception processes have finished, so the CPU can poll the LPMACK bit to
 * know when FlexCAN has actually entered low power mode. This bit is not
 * affected by soft reset. LPMACK will be asserted within 180 CAN bits from the
 * low-power mode request by the CPU, and negated within 2 CAN bits after the low-power
 * mode request removal (see Section "Protocol Timing"). When FlexCAN is in
 * Pretended Networking mode LPMACK will be negated within 180 CAN bits after the
 * low-power mode request removal.
 *
 * Values:
 * - 0b0 - FlexCAN is not in a low-power mode.
 * - 0b1 - FlexCAN is in a low-power mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_LPMACK field. */
#define CAN_RD_MCR_LPMACK(base) ((CAN_MCR_REG(base) & CAN_MCR_LPMACK_MASK) >> CAN_MCR_LPMACK_SHIFT)
#define CAN_BRD_MCR_LPMACK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_LPMACK_SHIFT))
/*@}*/

/*!
 * @name Register CAN_MCR, field WRNEN[21] (RW)
 *
 * When asserted, this bit enables the generation of the TWRNINT and RWRNINT
 * flags in the Error and Status Register 1 (ESR1). If WRNEN is negated, the TWRNINT
 * and RWRNINT flags will always be zero, independent of the values of the error
 * counters, and no warning interrupt will ever be generated. This bit can be
 * written in Freeze mode only because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - TWRNINT and RWRNINT bits are zero, independent of the values in the
 *     error counters.
 * - 0b1 - TWRNINT and RWRNINT bits are set when the respective error counter
 *     transitions from less than 96 to greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WRNEN field. */
#define CAN_RD_MCR_WRNEN(base) ((CAN_MCR_REG(base) & CAN_MCR_WRNEN_MASK) >> CAN_MCR_WRNEN_SHIFT)
#define CAN_BRD_MCR_WRNEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WRNEN_SHIFT))

/*! @brief Set the WRNEN field to a new value. */
#define CAN_WR_MCR_WRNEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_WRNEN_MASK, CAN_MCR_WRNEN(value)))
#define CAN_BWR_MCR_WRNEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WRNEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field SLFWAK[22] (RW)
 *
 * This bit enables the Self Wake Up feature when FlexCAN is in a low-power mode
 * other than Disable mode. When this feature is enabled, the FlexCAN module
 * monitors the bus for wake up event, that is, a recessive-to-dominant transition.
 * If a wake up event is detected during Stop mode, then FlexCAN generates, if
 * enabled to do so, a Wake Up interrupt to the CPU so that it can exit Stop mode
 * globally and FlexCAN can request to resume the clocks. When FlexCAN is in a
 * low-power mode other than Disable mode, this bit cannot be written as it is
 * blocked by hardware. When Pretended Networking mode is set, this feature must be
 * disabled.
 *
 * Values:
 * - 0b0 - FlexCAN Self Wake Up feature is disabled.
 * - 0b1 - FlexCAN Self Wake Up feature is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SLFWAK field. */
#define CAN_RD_MCR_SLFWAK(base) ((CAN_MCR_REG(base) & CAN_MCR_SLFWAK_MASK) >> CAN_MCR_SLFWAK_SHIFT)
#define CAN_BRD_MCR_SLFWAK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SLFWAK_SHIFT))

/*! @brief Set the SLFWAK field to a new value. */
#define CAN_WR_MCR_SLFWAK(base, value) (CAN_RMW_MCR(base, CAN_MCR_SLFWAK_MASK, CAN_MCR_SLFWAK(value)))
#define CAN_BWR_MCR_SLFWAK(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SLFWAK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field SUPV[23] (RW)
 *
 * This bit configures the FlexCAN to be either in Supervisor or User mode. The
 * registers affected by this bit are marked as S/U in the Access Type column of
 * the module memory map. Reset value of this bit is 1, so the affected registers
 * start with Supervisor access allowance only. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - FlexCAN is in User mode. Affected registers allow both Supervisor and
 *     Unrestricted accesses.
 * - 0b1 - FlexCAN is in Supervisor mode. Affected registers allow only
 *     Supervisor access. Unrestricted access behaves as though the access was done to an
 *     unimplemented register location.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SUPV field. */
#define CAN_RD_MCR_SUPV(base) ((CAN_MCR_REG(base) & CAN_MCR_SUPV_MASK) >> CAN_MCR_SUPV_SHIFT)
#define CAN_BRD_MCR_SUPV(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SUPV_SHIFT))

/*! @brief Set the SUPV field to a new value. */
#define CAN_WR_MCR_SUPV(base, value) (CAN_RMW_MCR(base, CAN_MCR_SUPV_MASK, CAN_MCR_SUPV(value)))
#define CAN_BWR_MCR_SUPV(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SUPV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZACK[24] (RO)
 *
 * This read-only bit indicates that FlexCAN is in Freeze mode and its prescaler
 * is stopped. The Freeze mode request cannot be granted until current
 * transmission or reception processes have finished. Therefore the software can poll the
 * FRZACK bit to know when FlexCAN has actually entered Freeze mode. If Freeze
 * Mode request is negated, then this bit is negated after the FlexCAN prescaler is
 * running again. If Freeze mode is requested while FlexCAN is in a low power
 * mode, then the FRZACK bit will be set only when the low-power mode is exited.
 * See Section "Freeze Mode". This bit is not affected by soft reset. FRZACK will
 * be asserted within 178 CAN bits from the freeze mode request by the CPU, and
 * negated within 2 CAN bits after the freeze mode request removal (see Section
 * "Protocol Timing").
 *
 * Values:
 * - 0b0 - FlexCAN not in Freeze mode, prescaler running.
 * - 0b1 - FlexCAN in Freeze mode, prescaler stopped.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_FRZACK field. */
#define CAN_RD_MCR_FRZACK(base) ((CAN_MCR_REG(base) & CAN_MCR_FRZACK_MASK) >> CAN_MCR_FRZACK_SHIFT)
#define CAN_BRD_MCR_FRZACK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FRZACK_SHIFT))
/*@}*/

/*!
 * @name Register CAN_MCR, field SOFTRST[25] (RW)
 *
 * When this bit is asserted, FlexCAN resets its internal state machines and
 * some of the memory mapped registers. The SOFTRST bit can be asserted directly by
 * the CPU when it writes to the MCR Register. Because soft reset is synchronous
 * and has to follow a request/acknowledge procedure across clock domains, it may
 * take some time to fully propagate its effect. The SOFTRST bit remains
 * asserted while reset is pending, and is automatically negated when reset completes.
 * Therefore, software can poll this bit to know when the soft reset has
 * completed. Soft reset cannot be applied while clocks are shut down in a low power mode.
 * The module should be first removed from low power mode, and then soft reset
 * can be applied. This bit is not affected by soft reset.
 *
 * Values:
 * - 0b0 - No reset request.
 * - 0b1 - Resets the registers affected by soft reset.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SOFTRST field. */
#define CAN_RD_MCR_SOFTRST(base) ((CAN_MCR_REG(base) & CAN_MCR_SOFTRST_MASK) >> CAN_MCR_SOFTRST_SHIFT)
#define CAN_BRD_MCR_SOFTRST(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SOFTRST_SHIFT))

/*! @brief Set the SOFTRST field to a new value. */
#define CAN_WR_MCR_SOFTRST(base, value) (CAN_RMW_MCR(base, CAN_MCR_SOFTRST_MASK, CAN_MCR_SOFTRST(value)))
#define CAN_BWR_MCR_SOFTRST(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SOFTRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKMSK[26] (RW)
 *
 * This bit enables the Wake Up Interrupt generation under Self Wake Up
 * mechanism.
 *
 * Values:
 * - 0b0 - Wake Up Interrupt is disabled.
 * - 0b1 - Wake Up Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WAKMSK field. */
#define CAN_RD_MCR_WAKMSK(base) ((CAN_MCR_REG(base) & CAN_MCR_WAKMSK_MASK) >> CAN_MCR_WAKMSK_SHIFT)
#define CAN_BRD_MCR_WAKMSK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKMSK_SHIFT))

/*! @brief Set the WAKMSK field to a new value. */
#define CAN_WR_MCR_WAKMSK(base, value) (CAN_RMW_MCR(base, CAN_MCR_WAKMSK_MASK, CAN_MCR_WAKMSK(value)))
#define CAN_BWR_MCR_WAKMSK(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field NOTRDY[27] (RO)
 *
 * This read-only bit indicates that FlexCAN is either in Disable mode, Stop
 * mode or Freeze mode. It is negated once FlexCAN has exited these modes. This bit
 * is not affected by soft reset.
 *
 * Values:
 * - 0b0 - FlexCAN module is either in Normal mode, Listen-Only mode or
 *     Loop-Back mode.
 * - 0b1 - FlexCAN module is either in Disable mode, Stop mode or Freeze mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_NOTRDY field. */
#define CAN_RD_MCR_NOTRDY(base) ((CAN_MCR_REG(base) & CAN_MCR_NOTRDY_MASK) >> CAN_MCR_NOTRDY_SHIFT)
#define CAN_BRD_MCR_NOTRDY(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_NOTRDY_SHIFT))
/*@}*/

/*!
 * @name Register CAN_MCR, field HALT[28] (RW)
 *
 * Assertion of this bit puts the FlexCAN module into Freeze mode. The CPU
 * should clear it after initializing the Message Buffers and the Control Registers
 * CAN_CTRL1 and CAN_CTRL2. No reception or transmission is performed by FlexCAN
 * before this bit is cleared. Freeze mode cannot be entered while FlexCAN is in a
 * low power mode. The HALT bit is set by hardware when a non-correctable error
 * is detected and NCEFAFRZ bit in CAN_MECR register is asserted.
 *
 * Values:
 * - 0b0 - No Freeze mode request.
 * - 0b1 - Enters Freeze mode if the FRZ bit is asserted.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_HALT field. */
#define CAN_RD_MCR_HALT(base) ((CAN_MCR_REG(base) & CAN_MCR_HALT_MASK) >> CAN_MCR_HALT_SHIFT)
#define CAN_BRD_MCR_HALT(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_HALT_SHIFT))

/*! @brief Set the HALT field to a new value. */
#define CAN_WR_MCR_HALT(base, value) (CAN_RMW_MCR(base, CAN_MCR_HALT_MASK, CAN_MCR_HALT(value)))
#define CAN_BWR_MCR_HALT(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_HALT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field RFEN[29] (RW)
 *
 * This bit controls whether the Rx FIFO feature is enabled or not. When RFEN is
 * set, MBs 0 to 5 cannot be used for normal reception and transmission because
 * the corresponding memory region (0x80-0xDC) is used by the FIFO engine as well
 * as additional MBs (up to 32, depending on CAN_CTRL2[RFFN] setting) which are
 * used as Rx FIFO ID Filter Table elements. RFEN also impacts the definition of
 * the minimum number of peripheral clocks per CAN bit as described in the table
 * "Minimum Ratio Between Peripheral Clock Frequency and CAN Bit Rate" (see
 * Arbitration and matching timing). This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.This bit cannot be set when CAN FD
 * operation is enabled (see FDEN bit).
 *
 * Values:
 * - 0b0 - Rx FIFO not enabled.
 * - 0b1 - Rx FIFO enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_RFEN field. */
#define CAN_RD_MCR_RFEN(base) ((CAN_MCR_REG(base) & CAN_MCR_RFEN_MASK) >> CAN_MCR_RFEN_SHIFT)
#define CAN_BRD_MCR_RFEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_RFEN_SHIFT))

/*! @brief Set the RFEN field to a new value. */
#define CAN_WR_MCR_RFEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_RFEN_MASK, CAN_MCR_RFEN(value)))
#define CAN_BWR_MCR_RFEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_RFEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZ[30] (RW)
 *
 * The FRZ bit specifies the FlexCAN behavior when the HALT bit in the CAN_MCR
 * Register is set or when Debug mode is requested at MCU level. When FRZ is
 * asserted, FlexCAN is enabled to enter Freeze mode. Negation of this bit field
 * causes FlexCAN to exit from Freeze mode. This bit is set by hardware when a
 * non-correctable error is detected and NCEFAFRZ bit in CAN_MECR register is asserted.
 *
 * Values:
 * - 0b0 - Not enabled to enter Freeze mode.
 * - 0b1 - Enabled to enter Freeze mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_FRZ field. */
#define CAN_RD_MCR_FRZ(base) ((CAN_MCR_REG(base) & CAN_MCR_FRZ_MASK) >> CAN_MCR_FRZ_SHIFT)
#define CAN_BRD_MCR_FRZ(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FRZ_SHIFT))

/*! @brief Set the FRZ field to a new value. */
#define CAN_WR_MCR_FRZ(base, value) (CAN_RMW_MCR(base, CAN_MCR_FRZ_MASK, CAN_MCR_FRZ(value)))
#define CAN_BWR_MCR_FRZ(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FRZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field MDIS[31] (RW)
 *
 * This bit controls whether FlexCAN is enabled or not. When disabled, FlexCAN
 * disables the clocks to the CAN Protocol Engine and Controller Host Interface
 * sub-modules. This bit is not affected by soft reset.
 *
 * Values:
 * - 0b0 - Enable the FlexCAN module.
 * - 0b1 - Disable the FlexCAN module.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_MDIS field. */
#define CAN_RD_MCR_MDIS(base) ((CAN_MCR_REG(base) & CAN_MCR_MDIS_MASK) >> CAN_MCR_MDIS_SHIFT)
#define CAN_BRD_MCR_MDIS(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_MDIS_SHIFT))

/*! @brief Set the MDIS field to a new value. */
#define CAN_WR_MCR_MDIS(base, value) (CAN_RMW_MCR(base, CAN_MCR_MDIS_MASK, CAN_MCR_MDIS(value)))
#define CAN_BWR_MCR_MDIS(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_MDIS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_CTRL1 - Control 1 register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL1 - Control 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is defined for specific FlexCAN control features related to the
 * CAN bus, such as bit-rate, programmable sampling point within an Rx bit, Loop
 * Back mode, Listen-Only mode, Bus Off recovery behavior and interrupt enabling
 * (Bus-Off, Error, Warning). It also determines the Division Factor for the
 * clock prescaler. The CAN bit timing variables (PRESDIV, PROPSEG, PSEG1, PSEG2 and
 * RJW) can also be configured in CAN_CBT register, which extends the range of
 * all these variables. If CAN_CBT[BTF] is set, PRESDIV, PROPSEG, PSEG1, PSEG2 and
 * RJW fields of CAN_CTRL1 become read only. The contents of this register are
 * not affected by soft reset. The CAN bit variables in CAN_CTRL1 and in CAN_CBT
 * are stored in the same register.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL1 register
 */
/*@{*/
#define CAN_RD_CTRL1(base)       (CAN_CTRL1_REG(base))
#define CAN_WR_CTRL1(base, value) (CAN_CTRL1_REG(base) = (value))
#define CAN_RMW_CTRL1(base, mask, value) (CAN_WR_CTRL1(base, (CAN_RD_CTRL1(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL1(base, value) (CAN_WR_CTRL1(base, CAN_RD_CTRL1(base) |  (value)))
#define CAN_CLR_CTRL1(base, value) (CAN_WR_CTRL1(base, CAN_RD_CTRL1(base) & ~(value)))
#define CAN_TOG_CTRL1(base, value) (CAN_WR_CTRL1(base, CAN_RD_CTRL1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL1 bitfields
 */

/*!
 * @name Register CAN_CTRL1, field PROPSEG[2:0] (RW)
 *
 * This 3-bit field defines the length of the Propagation Segment in the bit
 * time. The valid programmable values are 0-7. This field can be written only in
 * Freeze mode because it is blocked by hardware in other modes. Propagation
 * Segment Time = (PROPSEG + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PROPSEG field. */
#define CAN_RD_CTRL1_PROPSEG(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PROPSEG_MASK) >> CAN_CTRL1_PROPSEG_SHIFT)
#define CAN_BRD_CTRL1_PROPSEG(base) (CAN_RD_CTRL1_PROPSEG(base))

/*! @brief Set the PROPSEG field to a new value. */
#define CAN_WR_CTRL1_PROPSEG(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PROPSEG_MASK, CAN_CTRL1_PROPSEG(value)))
#define CAN_BWR_CTRL1_PROPSEG(base, value) (CAN_WR_CTRL1_PROPSEG(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LOM[3] (RW)
 *
 * This bit configures FlexCAN to operate in Listen-Only mode. In this mode,
 * transmission is disabled, all error counters described in CAN_ECR register are
 * frozen and the module operates in a CAN Error Passive mode. Only messages
 * acknowledged by another CAN station will be received. If FlexCAN detects a message
 * that has not been acknowledged, it will flag a BIT0 error without changing the
 * receive error counter (RXERRCNT) in CAN_ECR register, as if it was trying to
 * acknowledge the message. Listen-Only mode is acknowledged by the state of
 * CAN_ESR1[FLTCONF] field indicating Passive Error. There can be some delay between
 * the Listen-Only mode request and acknowledge. This bit can be written in Freeze
 * mode only because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Listen-Only mode is deactivated.
 * - 0b1 - FlexCAN module operates in Listen-Only mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LOM field. */
#define CAN_RD_CTRL1_LOM(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LOM_MASK) >> CAN_CTRL1_LOM_SHIFT)
#define CAN_BRD_CTRL1_LOM(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LOM_SHIFT))

/*! @brief Set the LOM field to a new value. */
#define CAN_WR_CTRL1_LOM(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LOM_MASK, CAN_CTRL1_LOM(value)))
#define CAN_BWR_CTRL1_LOM(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LBUF[4] (RW)
 *
 * This bit defines the ordering mechanism for Message Buffer transmission. When
 * asserted, the CAN_MCR[LPRIOEN] bit does not affect the priority arbitration.
 * This bit can be written in Freeze mode only because it is blocked by hardware
 * in other modes.
 *
 * Values:
 * - 0b0 - Buffer with highest priority is transmitted first.
 * - 0b1 - Lowest number buffer is transmitted first.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LBUF field. */
#define CAN_RD_CTRL1_LBUF(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LBUF_MASK) >> CAN_CTRL1_LBUF_SHIFT)
#define CAN_BRD_CTRL1_LBUF(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LBUF_SHIFT))

/*! @brief Set the LBUF field to a new value. */
#define CAN_WR_CTRL1_LBUF(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LBUF_MASK, CAN_CTRL1_LBUF(value)))
#define CAN_BWR_CTRL1_LBUF(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LBUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TSYN[5] (RW)
 *
 * This bit enables a mechanism that resets the free-running timer each time a
 * message is received in Message Buffer 0. This feature provides means to
 * synchronize multiple FlexCAN stations with a special "SYNC" message, that is, global
 * network time. If the RFEN bit in CAN_MCR is set (Rx FIFO enabled), the first
 * available Mailbox, according to CAN_CTRL2[RFFN] setting, is used for timer
 * synchronization instead of MB0. This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Timer Sync feature disabled
 * - 0b1 - Timer Sync feature enabled
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_TSYN field. */
#define CAN_RD_CTRL1_TSYN(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_TSYN_MASK) >> CAN_CTRL1_TSYN_SHIFT)
#define CAN_BRD_CTRL1_TSYN(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TSYN_SHIFT))

/*! @brief Set the TSYN field to a new value. */
#define CAN_WR_CTRL1_TSYN(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_TSYN_MASK, CAN_CTRL1_TSYN(value)))
#define CAN_BWR_CTRL1_TSYN(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TSYN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFREC[6] (RW)
 *
 * This bit defines how FlexCAN recovers from Bus Off state. If this bit is
 * negated, automatic recovering from Bus Off state occurs according to the CAN
 * Specification 2.0B. If the bit is asserted, automatic recovering from Bus Off is
 * disabled and the module remains in Bus Off state until the bit is negated by the
 * user. If the negation occurs before 128 sequences of 11 recessive bits are
 * detected on the CAN bus, then Bus Off recovery happens as if the BOFFREC bit had
 * never been asserted. If the negation occurs after 128 sequences of 11
 * recessive bits occurred, then FlexCAN will re-synchronize to the bus by waiting for
 * 11 recessive bits before joining the bus. After negation, the BOFFREC bit can
 * be re-asserted again during Bus Off, but it will be effective only the next
 * time the module enters Bus Off. If BOFFREC was negated when the module entered
 * Bus Off, asserting it during Bus Off will not be effective for the current Bus
 * Off recovery.
 *
 * Values:
 * - 0b0 - Automatic recovering from Bus Off state enabled.
 * - 0b1 - Automatic recovering from Bus Off state disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_BOFFREC field. */
#define CAN_RD_CTRL1_BOFFREC(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_BOFFREC_MASK) >> CAN_CTRL1_BOFFREC_SHIFT)
#define CAN_BRD_CTRL1_BOFFREC(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFREC_SHIFT))

/*! @brief Set the BOFFREC field to a new value. */
#define CAN_WR_CTRL1_BOFFREC(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_BOFFREC_MASK, CAN_CTRL1_BOFFREC(value)))
#define CAN_BWR_CTRL1_BOFFREC(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFREC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field SMP[7] (RW)
 *
 * This bit defines the sampling mode of CAN bits at the Rx input. It can be
 * written in Freeze mode only because it is blocked by hardware in other modes. For
 * proper operation, to assert SMP it is necessary to guarantee a minimum value
 * of 2 TQs in CAN_CTRL1[PSEG1] (or CAN_CBT[EPSEG1]).This bit cannot be asserted
 * when CAN FD is enabled (CAN_MCR[FDEN] = 1).
 *
 * Values:
 * - 0b0 - Just one sample is used to determine the bit value.
 * - 0b1 - Three samples are used to determine the value of the received bit:
 *     the regular one (sample point) and 2 preceding samples; a majority rule is
 *     used.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_SMP field. */
#define CAN_RD_CTRL1_SMP(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_SMP_MASK) >> CAN_CTRL1_SMP_SHIFT)
#define CAN_BRD_CTRL1_SMP(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_SMP_SHIFT))

/*! @brief Set the SMP field to a new value. */
#define CAN_WR_CTRL1_SMP(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_SMP_MASK, CAN_CTRL1_SMP(value)))
#define CAN_BWR_CTRL1_SMP(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_SMP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RWRNMSK[10] (RW)
 *
 * This bit provides a mask for the Rx Warning Interrupt associated with the
 * RWRNINT flag in the Error and Status Register 1 (ESR1). This bit is read as zero
 * when CAN_MCR[WRNEN] bit is negated. This bit can be written only if
 * CAN_MCR[WRNEN] bit is asserted.
 *
 * Values:
 * - 0b0 - Rx Warning Interrupt disabled.
 * - 0b1 - Rx Warning Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_RWRNMSK field. */
#define CAN_RD_CTRL1_RWRNMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_RWRNMSK_MASK) >> CAN_CTRL1_RWRNMSK_SHIFT)
#define CAN_BRD_CTRL1_RWRNMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_RWRNMSK_SHIFT))

/*! @brief Set the RWRNMSK field to a new value. */
#define CAN_WR_CTRL1_RWRNMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_RWRNMSK_MASK, CAN_CTRL1_RWRNMSK(value)))
#define CAN_BWR_CTRL1_RWRNMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_RWRNMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TWRNMSK[11] (RW)
 *
 * This bit provides a mask for the Tx Warning Interrupt associated with the
 * TWRNINT flag in the Error and Status Register 1 (ESR1). This bit is read as zero
 * when CAN_MCR[WRNEN] bit is negated. This bit can be written only if
 * CAN_MCR[WRNEN] bit is asserted.
 *
 * Values:
 * - 0b0 - Tx Warning Interrupt disabled.
 * - 0b1 - Tx Warning Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_TWRNMSK field. */
#define CAN_RD_CTRL1_TWRNMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_TWRNMSK_MASK) >> CAN_CTRL1_TWRNMSK_SHIFT)
#define CAN_BRD_CTRL1_TWRNMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TWRNMSK_SHIFT))

/*! @brief Set the TWRNMSK field to a new value. */
#define CAN_WR_CTRL1_TWRNMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_TWRNMSK_MASK, CAN_CTRL1_TWRNMSK(value)))
#define CAN_BWR_CTRL1_TWRNMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TWRNMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LPB[12] (RW)
 *
 * This bit configures FlexCAN to operate in Loop-Back mode. In this mode,
 * FlexCAN performs an internal loop back that can be used for self test operation.
 * The bit stream output of the transmitter is fed back internally to the receiver
 * input. The Rx CAN input pin is ignored and the Tx CAN output goes to the
 * recessive state (logic 1). FlexCAN behaves as it normally does when transmitting,
 * and treats its own transmitted message as a message received from a remote
 * node. In this mode, FlexCAN ignores the bit sent during the ACK slot in the CAN
 * frame acknowledge field, generating an internal acknowledge bit to ensure proper
 * reception of its own message. Both transmit and receive interrupts are
 * generated. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes. In this mode, the CAN_MCR[SRXDIS] cannot be asserted
 * because this will impede the self reception of a transmitted message. The TDCEN
 * bit in CAN_FDCTRL register must be disabled when LPB is asserted.
 *
 * Values:
 * - 0b0 - Loop Back disabled.
 * - 0b1 - Loop Back enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LPB field. */
#define CAN_RD_CTRL1_LPB(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LPB_MASK) >> CAN_CTRL1_LPB_SHIFT)
#define CAN_BRD_CTRL1_LPB(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LPB_SHIFT))

/*! @brief Set the LPB field to a new value. */
#define CAN_WR_CTRL1_LPB(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LPB_MASK, CAN_CTRL1_LPB(value)))
#define CAN_BWR_CTRL1_LPB(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LPB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field CLKSRC[13] (RW)
 *
 * This bit selects the clock source to the CAN Protocol Engine (PE) to be
 * either the peripheral clock or the oscillator clock. The selected clock is the one
 * fed to the prescaler to generate the Serial Clock (Sclock). In order to
 * guarantee reliable operation, this bit can be written only in Disable mode because
 * it is blocked by hardware in other modes. See Protocol timing".
 *
 * Values:
 * - 0b0 - The CAN engine clock source is the oscillator clock. Under this
 *     condition, the oscillator clock frequency must be lower than the bus clock.
 * - 0b1 - The CAN engine clock source is the peripheral clock.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_CLKSRC field. */
#define CAN_RD_CTRL1_CLKSRC(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_CLKSRC_MASK) >> CAN_CTRL1_CLKSRC_SHIFT)
#define CAN_BRD_CTRL1_CLKSRC(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_CLKSRC_SHIFT))

/*! @brief Set the CLKSRC field to a new value. */
#define CAN_WR_CTRL1_CLKSRC(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_CLKSRC_MASK, CAN_CTRL1_CLKSRC(value)))
#define CAN_BWR_CTRL1_CLKSRC(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_CLKSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field ERRMSK[14] (RW)
 *
 * This bit provides a mask for the Error Interrupt ERRINT in the CAN_ESR1
 * register.
 *
 * Values:
 * - 0b0 - Error interrupt disabled.
 * - 0b1 - Error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_ERRMSK field. */
#define CAN_RD_CTRL1_ERRMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_ERRMSK_MASK) >> CAN_CTRL1_ERRMSK_SHIFT)
#define CAN_BRD_CTRL1_ERRMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_ERRMSK_SHIFT))

/*! @brief Set the ERRMSK field to a new value. */
#define CAN_WR_CTRL1_ERRMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_ERRMSK_MASK, CAN_CTRL1_ERRMSK(value)))
#define CAN_BWR_CTRL1_ERRMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_ERRMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFMSK[15] (RW)
 *
 * This bit provides a mask for the Bus Off Interrupt BOFFINT in CAN_ESR1
 * register.
 *
 * Values:
 * - 0b0 - Bus Off interrupt disabled.
 * - 0b1 - Bus Off interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_BOFFMSK field. */
#define CAN_RD_CTRL1_BOFFMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_BOFFMSK_MASK) >> CAN_CTRL1_BOFFMSK_SHIFT)
#define CAN_BRD_CTRL1_BOFFMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFMSK_SHIFT))

/*! @brief Set the BOFFMSK field to a new value. */
#define CAN_WR_CTRL1_BOFFMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_BOFFMSK_MASK, CAN_CTRL1_BOFFMSK(value)))
#define CAN_BWR_CTRL1_BOFFMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG2[18:16] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 2 in the bit time. The
 * valid programmable values are 1-7. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Phase Buffer Segment 2 =
 * (PSEG2 + 1) * Time-Quanta.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PSEG2 field. */
#define CAN_RD_CTRL1_PSEG2(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PSEG2_MASK) >> CAN_CTRL1_PSEG2_SHIFT)
#define CAN_BRD_CTRL1_PSEG2(base) (CAN_RD_CTRL1_PSEG2(base))

/*! @brief Set the PSEG2 field to a new value. */
#define CAN_WR_CTRL1_PSEG2(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PSEG2_MASK, CAN_CTRL1_PSEG2(value)))
#define CAN_BWR_CTRL1_PSEG2(base, value) (CAN_WR_CTRL1_PSEG2(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG1[21:19] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 1 in the bit time. The
 * valid programmable values are 0-7. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Phase Buffer Segment 1 =
 * (PSEG1 + 1) * Time-Quanta.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PSEG1 field. */
#define CAN_RD_CTRL1_PSEG1(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PSEG1_MASK) >> CAN_CTRL1_PSEG1_SHIFT)
#define CAN_BRD_CTRL1_PSEG1(base) (CAN_RD_CTRL1_PSEG1(base))

/*! @brief Set the PSEG1 field to a new value. */
#define CAN_WR_CTRL1_PSEG1(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PSEG1_MASK, CAN_CTRL1_PSEG1(value)))
#define CAN_BWR_CTRL1_PSEG1(base, value) (CAN_WR_CTRL1_PSEG1(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RJW[23:22] (RW)
 *
 * This 2-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization. One time quantum is equal to the
 * Sclock period. The valid programmable values are 0-3. This field can be written
 * only in Freeze mode because it is blocked by hardware in other modes. Resync Jump
 * Width = RJW + 1.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_RJW field. */
#define CAN_RD_CTRL1_RJW(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_RJW_MASK) >> CAN_CTRL1_RJW_SHIFT)
#define CAN_BRD_CTRL1_RJW(base) (CAN_RD_CTRL1_RJW(base))

/*! @brief Set the RJW field to a new value. */
#define CAN_WR_CTRL1_RJW(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_RJW_MASK, CAN_CTRL1_RJW(value)))
#define CAN_BWR_CTRL1_RJW(base, value) (CAN_WR_CTRL1_RJW(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PRESDIV[31:24] (RW)
 *
 * This 8-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency. The Sclock period defines the time quantum of
 * the CAN protocol. For the reset value, the Sclock frequency is equal to the PE
 * clock frequency. The Maximum value of this field is 0xFF, that gives a minimum
 * Sclock frequency equal to the PE clock frequency divided by 256. See Section
 * "Protocol Timing". This field can be written only in Freeze mode because it is
 * blocked by hardware in other modes. Sclock frequency = PE clock frequency /
 * (PRESDIV + 1)
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PRESDIV field. */
#define CAN_RD_CTRL1_PRESDIV(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PRESDIV_MASK) >> CAN_CTRL1_PRESDIV_SHIFT)
#define CAN_BRD_CTRL1_PRESDIV(base) (CAN_RD_CTRL1_PRESDIV(base))

/*! @brief Set the PRESDIV field to a new value. */
#define CAN_WR_CTRL1_PRESDIV(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PRESDIV_MASK, CAN_CTRL1_PRESDIV(value)))
#define CAN_BWR_CTRL1_PRESDIV(base, value) (CAN_WR_CTRL1_PRESDIV(base, value))
/*@}*/

/*******************************************************************************
 * CAN_TIMER - Free Running Timer
 ******************************************************************************/

/*!
 * @brief CAN_TIMER - Free Running Timer (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register represents a 16-bit free running counter that can be read and
 * written by the CPU. The timer starts from 0x0 after Reset, counts linearly to
 * 0xFFFF, and wraps around. When the TIMER_SRC in CAN_CTRL2 register is asserted,
 * the timer is continuously incremented by an external time tick. The time tick
 * must be synchronous to the Peripheral Clock, with a minimum pulse width of
 * one clock cycle. When the TIMER_SRC bit in CAN_CTRL2 register is negated, the
 * timer is incremented by the CAN bit clock, which defines the baud rate on the
 * CAN bus. During a message transmission/reception, it increments by one for each
 * bit that is received or transmitted. When there is no message on the bus, it
 * counts using the previously programmed baud rate. The timer is not incremented
 * during Disable, Stop , Pretended Networking and Freeze modes. The timer value
 * is captured when the second bit of the identifier field of any frame is on the
 * CAN bus. This captured value is written into the Time Stamp entry in a
 * message buffer after a successful reception or transmission of a message. If bit
 * CAN_CTRL1[TSYN] is asserted, the Timer is reset whenever a message is received in
 * the first available Mailbox, according to CAN_CTRL2[RFFN] setting. The CPU
 * can write to this register anytime. However, if the write occurs at the same
 * time that the Timer is being reset by a reception in the first Mailbox, then the
 * write value is discarded. Reading this register affects the Mailbox Unlocking
 * procedure, see Section "Mailbox Lock Mechanism".
 */
/*!
 * @name Constants and macros for entire CAN_TIMER register
 */
/*@{*/
#define CAN_RD_TIMER(base)       (CAN_TIMER_REG(base))
#define CAN_WR_TIMER(base, value) (CAN_TIMER_REG(base) = (value))
#define CAN_RMW_TIMER(base, mask, value) (CAN_WR_TIMER(base, (CAN_RD_TIMER(base) & ~(mask)) | (value)))
#define CAN_SET_TIMER(base, value) (CAN_WR_TIMER(base, CAN_RD_TIMER(base) |  (value)))
#define CAN_CLR_TIMER(base, value) (CAN_WR_TIMER(base, CAN_RD_TIMER(base) & ~(value)))
#define CAN_TOG_TIMER(base, value) (CAN_WR_TIMER(base, CAN_RD_TIMER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_TIMER bitfields
 */

/*!
 * @name Register CAN_TIMER, field TIMER[15:0] (RW)
 *
 * Contains the free-running counter value.
 */
/*@{*/
/*! @brief Read current value of the CAN_TIMER_TIMER field. */
#define CAN_RD_TIMER_TIMER(base) ((CAN_TIMER_REG(base) & CAN_TIMER_TIMER_MASK) >> CAN_TIMER_TIMER_SHIFT)
#define CAN_BRD_TIMER_TIMER(base) (CAN_RD_TIMER_TIMER(base))

/*! @brief Set the TIMER field to a new value. */
#define CAN_WR_TIMER_TIMER(base, value) (CAN_RMW_TIMER(base, CAN_TIMER_TIMER_MASK, CAN_TIMER_TIMER(value)))
#define CAN_BWR_TIMER_TIMER(base, value) (CAN_WR_TIMER_TIMER(base, value))
/*@}*/

/*******************************************************************************
 * CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 ******************************************************************************/

/*!
 * @brief CAN_RXMGMASK - Rx Mailboxes Global Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RXMGMASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is negated, RXMGMASK is always in effect
 * (the bits in the MG field will mask the Mailbox filter bits). When the
 * CAN_MCR[IRMQ] bit is asserted, RXMGMASK has no effect (the bits in the MG field will
 * not mask the Mailbox filter bits). RXMGMASK is used to mask the filter fields
 * of all Rx MBs, excluding MBs 14-15, which have individual mask registers. This
 * register can only be written in Freeze mode as it is blocked by hardware in
 * other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RXMGMASK register
 */
/*@{*/
#define CAN_RD_RXMGMASK(base)    (CAN_RXMGMASK_REG(base))
#define CAN_WR_RXMGMASK(base, value) (CAN_RXMGMASK_REG(base) = (value))
#define CAN_RMW_RXMGMASK(base, mask, value) (CAN_WR_RXMGMASK(base, (CAN_RD_RXMGMASK(base) & ~(mask)) | (value)))
#define CAN_SET_RXMGMASK(base, value) (CAN_WR_RXMGMASK(base, CAN_RD_RXMGMASK(base) |  (value)))
#define CAN_CLR_RXMGMASK(base, value) (CAN_WR_RXMGMASK(base, CAN_RD_RXMGMASK(base) & ~(value)))
#define CAN_TOG_RXMGMASK(base, value) (CAN_WR_RXMGMASK(base, CAN_RD_RXMGMASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_RX14MASK - Rx 14 Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RX14MASK - Rx 14 Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RX14MASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is asserted, RX14MASK has no effect.
 * RX14MASK is used to mask the filter fields of Message Buffer 14. This register can
 * only be programmed while the module is in Freeze mode as it is blocked by
 * hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RX14MASK register
 */
/*@{*/
#define CAN_RD_RX14MASK(base)    (CAN_RX14MASK_REG(base))
#define CAN_WR_RX14MASK(base, value) (CAN_RX14MASK_REG(base) = (value))
#define CAN_RMW_RX14MASK(base, mask, value) (CAN_WR_RX14MASK(base, (CAN_RD_RX14MASK(base) & ~(mask)) | (value)))
#define CAN_SET_RX14MASK(base, value) (CAN_WR_RX14MASK(base, CAN_RD_RX14MASK(base) |  (value)))
#define CAN_CLR_RX14MASK(base, value) (CAN_WR_RX14MASK(base, CAN_RD_RX14MASK(base) & ~(value)))
#define CAN_TOG_RX14MASK(base, value) (CAN_WR_RX14MASK(base, CAN_RD_RX14MASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_RX15MASK - Rx 15 Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RX15MASK - Rx 15 Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RX15MASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is asserted, RX15MASK has no effect.
 * RX15MASK is used to mask the filter fields of Message Buffer 15. This register can
 * be programmed only while the module is in Freeze mode because it is blocked by
 * hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RX15MASK register
 */
/*@{*/
#define CAN_RD_RX15MASK(base)    (CAN_RX15MASK_REG(base))
#define CAN_WR_RX15MASK(base, value) (CAN_RX15MASK_REG(base) = (value))
#define CAN_RMW_RX15MASK(base, mask, value) (CAN_WR_RX15MASK(base, (CAN_RD_RX15MASK(base) & ~(mask)) | (value)))
#define CAN_SET_RX15MASK(base, value) (CAN_WR_RX15MASK(base, CAN_RD_RX15MASK(base) |  (value)))
#define CAN_CLR_RX15MASK(base, value) (CAN_WR_RX15MASK(base, CAN_RD_RX15MASK(base) & ~(value)))
#define CAN_TOG_RX15MASK(base, value) (CAN_WR_RX15MASK(base, CAN_RD_RX15MASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_ECR - Error Counter
 ******************************************************************************/

/*!
 * @brief CAN_ECR - Error Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has four 8-bit fields reflecting the value of the FlexCAN error
 * counters: Transmit Error Counter (TXERRCNT field) Receive Error Counter
 * (RXERRCNT field) Transmit Error Counter for errors detected in the Data Phase of
 * CAN FD messages with the BRS bit set (TXERRCNT_FAST field) Receive Error Counter
 * for errors detected in the Data Phase of CAN FD messages with the BRS bit set
 * (RXERRCNT_FAST field) The TXERRCNT and RXERRCNT counters take into account
 * all errors in both CAN FD and non-FD message formats. TXERRCNT_FAST and
 * RXERRCNT_FAST are dedicated to count only the errors occurred in the Data Phase of CAN
 * FD frames with the BRS bit set. The Fault Confinement State (FLTCONF field in
 * Error and Status Register 1 - CAN_ESR1) is updated based on TXERRCNT and
 * RXERRCNT counters only. TXERRCNT and RXERRCNT counters can be written in Freeze
 * mode only. TXERRCNT_FAST and RXERRCNT_FAST counters are read-only except in
 * Freeze mode where the CPU can write value zero. The rules for increasing and
 * decreasing these counters are described in the CAN protocol and are completely
 * implemented in the FlexCAN module. The following are the basic rules for FlexCAN
 * bus state transitions: If the value of TXERRCNT or RXERRCNT increases to be
 * greater than or equal to 128, the FLTCONF field in the Error and Status Register
 * is updated to reflect "Error Passive" state. If the FlexCAN state is "Error
 * Passive", and either TXERRCNT or RXERRCNT decrements to a value less than or
 * equal to 127 while the other already satisfies this condition, the FLTCONF field
 * in the Error and Status Register is updated to reflect "Error Active" state.
 * If the value of TXERRCNT increases to be greater than 255, the FLTCONF field in
 * the Error and Status Register is updated to reflect "Bus Off" state, and an
 * interrupt may be issued. The value of TXERRCNT is then reset to zero. If
 * FlexCAN is in "Bus Off' state, then TXERRCNT is cascaded together with another
 * internal counter to count the 128th occurrences of 11 consecutive recessive bits on
 * the bus. Hence, TXERRCNT is reset to zero and counts in a manner where the
 * internal counter counts 11 such bits and then wraps around while incrementing
 * the TXERRCNT. When TXERRCNT reaches the value of 128, the FLTCONF field in the
 * Error and Status Register is updated to be "Error Active" and both error
 * counters are reset to zero. At any instance of dominant bit following a stream of
 * less than 11 consecutive recessive bits, the internal counter resets itself to
 * zero without affecting the TXERRCNT value. The TXERRCNT_FAST counter is frozen
 * during busoff. If during system start-up, only one node is operating, then its
 * TXERRCNT increases in each message it is trying to transmit, as a result of
 * acknowledge errors (indicated by the ACKERR bit in the Error and Status
 * Register). After the transition to "Error Passive" state, the TXERRCNT does not
 * increment anymore by acknowledge errors. Therefore the device never goes to the
 * "Bus Off" state. If the RXERRCNT increases to a value greater than 127, it is not
 * incremented further, even if more errors are detected while being a receiver.
 * At the next successful message reception, the counter is set to a value
 * between 119 and 127 to resume to "Error Active" state. TXERRCNT_FAST and
 * RXERRCNT_FAST error counters values increment and decrement based on errors detected
 * only in the Data Phase of CAN FD frames with the BRS bit set, following the same
 * increment and decrement rules as TXERRCNT and RXERRCNT counters. These
 * counters do not wrap around and get stuck at their maximum value (255). They stop
 * counting and keep their values frozen while FlexCAN is in "Bus Off" state. They
 * are reset when FlexCAN leaves "Bus Off" state and restart counting once FlexCAN
 * resumes to "Error Active" state. When FlexCAN is in Pretended Networking
 * mode, the RXERRCNT and RXERRCNT_FAST keep counting errors and error flags are
 * stored. The TXERRCNT and TXERRCNT_FAST preserve their values and do not change,
 * since no transmission occurs under Pretended Networking mode. Error counters and
 * error flags that changed values while in Pretended Networking mode are
 * updated in CAN_ECR and CAN_ESR1 when FlexCAN resumes back to Normal mode. The FAST
 * error flags in CAN_ESR1 register will not be set if FlexCAN is in Pretended
 * Networking mode.
 */
/*!
 * @name Constants and macros for entire CAN_ECR register
 */
/*@{*/
#define CAN_RD_ECR(base)         (CAN_ECR_REG(base))
#define CAN_WR_ECR(base, value)  (CAN_ECR_REG(base) = (value))
#define CAN_RMW_ECR(base, mask, value) (CAN_WR_ECR(base, (CAN_RD_ECR(base) & ~(mask)) | (value)))
#define CAN_SET_ECR(base, value) (CAN_WR_ECR(base, CAN_RD_ECR(base) |  (value)))
#define CAN_CLR_ECR(base, value) (CAN_WR_ECR(base, CAN_RD_ECR(base) & ~(value)))
#define CAN_TOG_ECR(base, value) (CAN_WR_ECR(base, CAN_RD_ECR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ECR bitfields
 */

/*!
 * @name Register CAN_ECR, field TXERRCNT[7:0] (RW)
 *
 * Transmit Error Counter for all errors detected in transmitted messages. The
 * TXERRCNT counter is read-only except in Freeze mode, where it can be written by
 * the CPU.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_TXERRCNT field. */
#define CAN_RD_ECR_TXERRCNT(base) ((CAN_ECR_REG(base) & CAN_ECR_TXERRCNT_MASK) >> CAN_ECR_TXERRCNT_SHIFT)
#define CAN_BRD_ECR_TXERRCNT(base) (CAN_RD_ECR_TXERRCNT(base))

/*! @brief Set the TXERRCNT field to a new value. */
#define CAN_WR_ECR_TXERRCNT(base, value) (CAN_RMW_ECR(base, CAN_ECR_TXERRCNT_MASK, CAN_ECR_TXERRCNT(value)))
#define CAN_BWR_ECR_TXERRCNT(base, value) (CAN_WR_ECR_TXERRCNT(base, value))
/*@}*/

/*!
 * @name Register CAN_ECR, field RXERRCNT[15:8] (RW)
 *
 * Receive Error Counter for all errors detected in received messages. The
 * RXERRCNT counter is read-only except in Freeze mode, where it can be written by the
 * CPU.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_RXERRCNT field. */
#define CAN_RD_ECR_RXERRCNT(base) ((CAN_ECR_REG(base) & CAN_ECR_RXERRCNT_MASK) >> CAN_ECR_RXERRCNT_SHIFT)
#define CAN_BRD_ECR_RXERRCNT(base) (CAN_RD_ECR_RXERRCNT(base))

/*! @brief Set the RXERRCNT field to a new value. */
#define CAN_WR_ECR_RXERRCNT(base, value) (CAN_RMW_ECR(base, CAN_ECR_RXERRCNT_MASK, CAN_ECR_RXERRCNT(value)))
#define CAN_BWR_ECR_RXERRCNT(base, value) (CAN_WR_ECR_RXERRCNT(base, value))
/*@}*/

/*!
 * @name Register CAN_ECR, field TXERRCNT_FAST[23:16] (RW)
 *
 * Transmit Error Counter for errors detected in the Data Phase of transmitted
 * CAN FD messages with the BRS bit set. The TXERRCNT_FAST counter is read-only
 * except in Freeze mode, where the CPU can write a 8-bit zero value only.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_TXERRCNT_FAST field. */
#define CAN_RD_ECR_TXERRCNT_FAST(base) ((CAN_ECR_REG(base) & CAN_ECR_TXERRCNT_FAST_MASK) >> CAN_ECR_TXERRCNT_FAST_SHIFT)
#define CAN_BRD_ECR_TXERRCNT_FAST(base) (CAN_RD_ECR_TXERRCNT_FAST(base))

/*! @brief Set the TXERRCNT_FAST field to a new value. */
#define CAN_WR_ECR_TXERRCNT_FAST(base, value) (CAN_RMW_ECR(base, CAN_ECR_TXERRCNT_FAST_MASK, CAN_ECR_TXERRCNT_FAST(value)))
#define CAN_BWR_ECR_TXERRCNT_FAST(base, value) (CAN_WR_ECR_TXERRCNT_FAST(base, value))
/*@}*/

/*!
 * @name Register CAN_ECR, field RXERRCNT_FAST[31:24] (RW)
 *
 * Receive Error Counter for errors detected in the Data Phase of received CAN
 * FD messages with the BRS bit set. The RXERRCNT_FAST counter is read-only except
 * in Freeze mode, where the CPU can write a 8-bit zero value only.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_RXERRCNT_FAST field. */
#define CAN_RD_ECR_RXERRCNT_FAST(base) ((CAN_ECR_REG(base) & CAN_ECR_RXERRCNT_FAST_MASK) >> CAN_ECR_RXERRCNT_FAST_SHIFT)
#define CAN_BRD_ECR_RXERRCNT_FAST(base) (CAN_RD_ECR_RXERRCNT_FAST(base))

/*! @brief Set the RXERRCNT_FAST field to a new value. */
#define CAN_WR_ECR_RXERRCNT_FAST(base, value) (CAN_RMW_ECR(base, CAN_ECR_RXERRCNT_FAST_MASK, CAN_ECR_RXERRCNT_FAST(value)))
#define CAN_BWR_ECR_RXERRCNT_FAST(base, value) (CAN_WR_ECR_RXERRCNT_FAST(base, value))
/*@}*/

/*******************************************************************************
 * CAN_ESR1 - Error and Status 1 register
 ******************************************************************************/

/*!
 * @brief CAN_ESR1 - Error and Status 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register reports various error conditions detected in the reception and
 * transmission of a CAN frame, some general status of the device and it is the
 * source of some interrupts to the CPU. The reported error conditions are
 * BIT1ERR, BIT0ERR, ACKKERR, CRCERR, FRMERR and STFERR, for errors detected in CAN
 * frames of any format, and BIT1ERR_FAST, BIT0ERR_FAST, CRCERR_FAST, FRMERR_FAST and
 * STFERR_FAST for errors detected in the Data Phase of CAN FD frames with the
 * BRS bit set only. An error detected in a single CAN frame may be reported by
 * one or more error flags. Also, error reporting is cummulative in case more error
 * events happen in the next frames while the CPU does not attempt to read this
 * register. TXWRN, RXWRN, IDLE, TX, FLTCONF, RX and SYNCH are status bits.
 * BOFFINT, BOFFDONEINT, ERRINT, ERRINT_FAST , WAKINT, TWRNINT and RWRNINT are
 * interrupt bits. It is recommended the CPU to use the following procedure when
 * servicing interrupt requests generated by these bits: Read this register to capture
 * all error condition and status bits. This action clear the respective bits that
 * were set since the last read access. Write 1 to clear the interrupt bit that
 * has triggered the interrupt request. Write 1 to clear the ERR_OVR bit if it is
 * set. Starting from all error flags cleared, a first error event sets either
 * the ERRINT or the ERRINT_FAST (provided the corresponding mask bit is
 * asserted). If other error events in subsequent frames happen before the CPU to serve
 * the interrupt request, the ERR_OVR bit is set to indicate that errors from
 * different frames had accumulated. SYNCH IDLE TX RX FlexCAN State 0 0 0 0 Not
 * synchronized to CAN bus 1 1 x x Idle 1 0 1 0 Transmitting 1 0 0 1 Receiving
 */
/*!
 * @name Constants and macros for entire CAN_ESR1 register
 */
/*@{*/
#define CAN_RD_ESR1(base)        (CAN_ESR1_REG(base))
#define CAN_WR_ESR1(base, value) (CAN_ESR1_REG(base) = (value))
#define CAN_RMW_ESR1(base, mask, value) (CAN_WR_ESR1(base, (CAN_RD_ESR1(base) & ~(mask)) | (value)))
#define CAN_SET_ESR1(base, value) (CAN_WR_ESR1(base, CAN_RD_ESR1(base) |  (value)))
#define CAN_CLR_ESR1(base, value) (CAN_WR_ESR1(base, CAN_RD_ESR1(base) & ~(value)))
#define CAN_TOG_ESR1(base, value) (CAN_WR_ESR1(base, CAN_RD_ESR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ESR1 bitfields
 */

/*!
 * @name Register CAN_ESR1, field WAKINT[0] (W1C)
 *
 * This field applies when FlexCAN is in low-power mode under Self Wake Up
 * mechanism: Stop mode When a recessive-to-dominant transition is detected on the CAN
 * bus and if the CAN_MCR[WAKMSK] bit is set, an interrupt is generated to the
 * CPU. This bit is cleared by writing it to 1. When CAN_MCR[SLFWAK] is negated,
 * this flag is masked. The CPU must clear this flag before disabling the bit.
 * Otherwise it will be set when the SLFWAK is set again. Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - Indicates a recessive to dominant transition was received on the CAN
 *     bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_WAKINT field. */
#define CAN_RD_ESR1_WAKINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_WAKINT_MASK) >> CAN_ESR1_WAKINT_SHIFT)
#define CAN_BRD_ESR1_WAKINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_WAKINT_SHIFT))

/*! @brief Set the WAKINT field to a new value. */
#define CAN_WR_ESR1_WAKINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERRINT_FAST_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_WAKINT(value)))
#define CAN_BWR_ESR1_WAKINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_WAKINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERRINT[1] (W1C)
 *
 * This bit indicates that at least one of the Error Bits (BIT1ERR, BIT0ERR,
 * ACKERR. CRCERR, FRMERR or STFERR) is set. If the corresponding mask bit
 * CAN_CTRL1[ERRMSK] is set, an interrupt is generated to the CPU. This bit is cleared by
 * writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - Indicates setting of any Error Bit in the Error and Status Register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ERRINT field. */
#define CAN_RD_ESR1_ERRINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ERRINT_MASK) >> CAN_ESR1_ERRINT_SHIFT)
#define CAN_BRD_ESR1_ERRINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERRINT_SHIFT))

/*! @brief Set the ERRINT field to a new value. */
#define CAN_WR_ESR1_ERRINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_ERRINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERRINT_FAST_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_ERRINT(value)))
#define CAN_BWR_ESR1_ERRINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERRINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BOFFINT[2] (W1C)
 *
 * This bit is set when FlexCAN enters 'Bus Off' state. If the corresponding
 * mask bit in the Control Register 1 (CAN_CTRL1[BOFFMSK]) is set, an interrupt is
 * generated to the CPU. This bit is cleared by writing it to 1. Writing 0 has no
 * effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - FlexCAN module entered Bus Off state.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BOFFINT field. */
#define CAN_RD_ESR1_BOFFINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BOFFINT_MASK) >> CAN_ESR1_BOFFINT_SHIFT)
#define CAN_BRD_ESR1_BOFFINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFINT_SHIFT))

/*! @brief Set the BOFFINT field to a new value. */
#define CAN_WR_ESR1_BOFFINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_BOFFINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERRINT_FAST_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_BOFFINT(value)))
#define CAN_BWR_ESR1_BOFFINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RX[3] (RO)
 *
 * This bit indicates if FlexCAN is receiving a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - FlexCAN is not receiving a message.
 * - 0b1 - FlexCAN is receiving a message.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RX field. */
#define CAN_RD_ESR1_RX(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RX_MASK) >> CAN_ESR1_RX_SHIFT)
#define CAN_BRD_ESR1_RX(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RX_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FLTCONF[5:4] (RO)
 *
 * This 2-bit field indicates the Confinement State of the FlexCAN module. If
 * the LOM bit in the Control Register 1 is asserted, after some delay that depends
 * on the CAN bit timing the FLTCONF field will indicate "Error Passive". The
 * very same delay affects the way how FLTCONF reflects an update to CAN_ECR
 * register by the CPU. It may be necessary up to one CAN bit time to get them coherent
 * again. This bit field is affected by soft reset, but if the LOM bit is
 * asserted, its reset value lasts just one CAN bit. After this time, FLTCONF reports
 * "Error Passive".
 *
 * Values:
 * - 0b00 - Error Active
 * - 0b01 - Error Passive
 * - 0b1x - Bus Off
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_FLTCONF field. */
#define CAN_RD_ESR1_FLTCONF(base) ((CAN_ESR1_REG(base) & CAN_ESR1_FLTCONF_MASK) >> CAN_ESR1_FLTCONF_SHIFT)
#define CAN_BRD_ESR1_FLTCONF(base) (CAN_RD_ESR1_FLTCONF(base))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TX[6] (RO)
 *
 * This bit indicates if FlexCAN is transmitting a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - FlexCAN is not transmitting a message.
 * - 0b1 - FlexCAN is transmitting a message.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TX field. */
#define CAN_RD_ESR1_TX(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TX_MASK) >> CAN_ESR1_TX_SHIFT)
#define CAN_BRD_ESR1_TX(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TX_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field IDLE[7] (RO)
 *
 * This bit indicates when CAN bus is in IDLE state. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - CAN bus is now IDLE.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_IDLE field. */
#define CAN_RD_ESR1_IDLE(base) ((CAN_ESR1_REG(base) & CAN_ESR1_IDLE_MASK) >> CAN_ESR1_IDLE_SHIFT)
#define CAN_BRD_ESR1_IDLE(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_IDLE_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RXWRN[8] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * reception and is affected by the value of RXERRCNT in CAN_ECR register only. This
 * bit is not updated during Freeze mode. Additionally, it is updated when FlexCAN
 * returns to Normal mode from Pretended Networking mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - RXERRCNT is greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RXWRN field. */
#define CAN_RD_ESR1_RXWRN(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RXWRN_MASK) >> CAN_ESR1_RXWRN_SHIFT)
#define CAN_BRD_ESR1_RXWRN(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RXWRN_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TXWRN[9] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * transmission and is affected by the value of TXERRCNT in CAN_ECR register only. This
 * bit is not updated during Freeze mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - TXERRCNT is greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TXWRN field. */
#define CAN_RD_ESR1_TXWRN(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TXWRN_MASK) >> CAN_ESR1_TXWRN_SHIFT)
#define CAN_BRD_ESR1_TXWRN(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TXWRN_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field STFERR[10] (RO)
 *
 * This bit indicates that a Stuffing Error has been detected either in a non-FD
 * message or in the slow rate part of a FD by the receiver node. This bit is
 * updated when FlexCAN returns to Normal mode from Pretended Network mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A Stuffing Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_STFERR field. */
#define CAN_RD_ESR1_STFERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_STFERR_MASK) >> CAN_ESR1_STFERR_SHIFT)
#define CAN_BRD_ESR1_STFERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_STFERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FRMERR[11] (RO)
 *
 * This bit indicates that a Form Error has been detected in either a non-FD
 * message or in the slow rate part of a FD message by the receiver node, that is, a
 * fixed-form bit field contains at least one illegal bit. This bit is updated
 * when FlexCAN returns to Normal mode from Pretended Network mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A Form Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_FRMERR field. */
#define CAN_RD_ESR1_FRMERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_FRMERR_MASK) >> CAN_ESR1_FRMERR_SHIFT)
#define CAN_BRD_ESR1_FRMERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_FRMERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field CRCERR[12] (RO)
 *
 * This bit indicates that a CRC Error has been detected by the receiver node
 * either in a non-FD message or in the Arbitration Phase of a frame in CAN FD
 * format, that is, the calculated CRC is different from the received. This bit is
 * updated when FlexCAN returns to Normal mode from Pretended Network mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A CRC error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_CRCERR field. */
#define CAN_RD_ESR1_CRCERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_CRCERR_MASK) >> CAN_ESR1_CRCERR_SHIFT)
#define CAN_BRD_ESR1_CRCERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_CRCERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ACKERR[13] (RO)
 *
 * This bit indicates that an Acknowledge Error has been detected by the
 * transmitter node, that is, a dominant bit has not been detected during the ACK SLOT.
 * This bit is updated when FlexCAN returns to Normal mode from Pretended Network
 * mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - An ACK error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ACKERR field. */
#define CAN_RD_ESR1_ACKERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ACKERR_MASK) >> CAN_ESR1_ACKERR_SHIFT)
#define CAN_BRD_ESR1_ACKERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ACKERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT0ERR[14] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a non-CAN FD message or in the Arbitration Phase of a CAN
 * FD message. This bit is updated when FlexCAN returns to Normal mode from
 * Pretended Network mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - At least one bit sent as dominant is received as recessive.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT0ERR field. */
#define CAN_RD_ESR1_BIT0ERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT0ERR_MASK) >> CAN_ESR1_BIT0ERR_SHIFT)
#define CAN_BRD_ESR1_BIT0ERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BIT0ERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT1ERR[15] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a non-CAN FD message or in the Arbitration Phase of a CAN
 * FD message. This bit is updated when FlexCAN returns to Normal mode from
 * Pretended Network mode. This bit is not set by a transmitter in case of arbitration
 * field or ACK slot, or in case of a node sending a passive error flag that
 * detects dominant bits.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - At least one bit sent as recessive is received as dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT1ERR field. */
#define CAN_RD_ESR1_BIT1ERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT1ERR_MASK) >> CAN_ESR1_BIT1ERR_SHIFT)
#define CAN_BRD_ESR1_BIT1ERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BIT1ERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RWRNINT[16] (W1C)
 *
 * If the WRNEN bit in CAN_MCR is asserted, the RWRNINT bit is set when the
 * RXWRN flag transitions from 0 to 1, meaning that the Rx error counters reached 96.
 * If the corresponding mask bit in the Control 1 Register (CAN_CTRL1[RWRNMSK])
 * is set, an interrupt is generated to the CPU. This bit is cleared by writing
 * it to 1. When WRNEN is negated, this flag is masked. CPU must clear this flag
 * before disabling the bit. Otherwise it will be set when the WRNEN is set again.
 * Writing 0 has no effect. This bit is not updated during Freeze mode. When
 * FlexCAN returns to Normal mode from Pretended Network mode (see Receive Process
 * under Pretended Networking Mode), this bit is updated to reflect the Rx error
 * counter state.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - The Rx error counter transitioned from less than 96 to greater than
 *     or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RWRNINT field. */
#define CAN_RD_ESR1_RWRNINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RWRNINT_MASK) >> CAN_ESR1_RWRNINT_SHIFT)
#define CAN_BRD_ESR1_RWRNINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RWRNINT_SHIFT))

/*! @brief Set the RWRNINT field to a new value. */
#define CAN_WR_ESR1_RWRNINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_RWRNINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERRINT_FAST_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_RWRNINT(value)))
#define CAN_BWR_ESR1_RWRNINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RWRNINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TWRNINT[17] (W1C)
 *
 * If the WRNEN bit in CAN_MCR is asserted, the TWRNINT bit is set when the
 * TXWRN flag transitions from 0 to 1, meaning that the Tx error counter reached 96.
 * If the corresponding mask bit in the Control 1 Register (CAN_CTRL1[TWRNMSK])
 * is set, an interrupt is generated to the CPU. This bit is cleared by writing it
 * to 1. When WRNEN is negated, this flag is masked. CPU must clear this flag
 * before disabling the bit. Otherwise it will be set when the WRNEN is set again.
 * Writing 0 has no effect. This flag is not generated during Bus Off state. This
 * bit is not updated during Freeze mode. When FlexCAN returns to Normal mode
 * from Pretended Network mode (see Receive Process under Pretended Networking
 * Mode), this bit is not updated.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - The Tx error counter transitioned from less than 96 to greater than
 *     or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TWRNINT field. */
#define CAN_RD_ESR1_TWRNINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TWRNINT_MASK) >> CAN_ESR1_TWRNINT_SHIFT)
#define CAN_BRD_ESR1_TWRNINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TWRNINT_SHIFT))

/*! @brief Set the TWRNINT field to a new value. */
#define CAN_WR_ESR1_TWRNINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_TWRNINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERRINT_FAST_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_TWRNINT(value)))
#define CAN_BWR_ESR1_TWRNINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TWRNINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field SYNCH[18] (RO)
 *
 * This read-only flag indicates whether the FlexCAN is synchronized to the CAN
 * bus and able to participate in the communication process. It is set and
 * cleared by the FlexCAN. See the table in the overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - FlexCAN is not synchronized to the CAN bus.
 * - 0b1 - FlexCAN is synchronized to the CAN bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_SYNCH field. */
#define CAN_RD_ESR1_SYNCH(base) ((CAN_ESR1_REG(base) & CAN_ESR1_SYNCH_MASK) >> CAN_ESR1_SYNCH_SHIFT)
#define CAN_BRD_ESR1_SYNCH(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_SYNCH_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BOFFDONEINT[19] (W1C)
 *
 * This bit is set when the Tx Error Counter (TXERRCNT) has finished counting
 * 128 occurrences of 11 consecutive recessive bits on the CAN bus and is ready to
 * leave Bus Off. If the corresponding mask bit in the Control 2 Register
 * (BOFFDONEMSK) is set, an interrupt is generated to the CPU. This bit is cleared by
 * writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - FlexCAN module has completed Bus Off process.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BOFFDONEINT field. */
#define CAN_RD_ESR1_BOFFDONEINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BOFFDONEINT_MASK) >> CAN_ESR1_BOFFDONEINT_SHIFT)
#define CAN_BRD_ESR1_BOFFDONEINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFDONEINT_SHIFT))

/*! @brief Set the BOFFDONEINT field to a new value. */
#define CAN_WR_ESR1_BOFFDONEINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_ERRINT_FAST_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_BOFFDONEINT(value)))
#define CAN_BWR_ESR1_BOFFDONEINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFDONEINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERRINT_FAST[20] (W1C)
 *
 * This bit indicates that at least one of the Error Bits detected in the Data
 * Phase of CAN FD frames with the BRS bit set (BIT1ERR_FAST, BIT0ERR_FAST,
 * CRCERR_FAST, FRMERR_FAST or STFERR_FAST) is set. If the corresponding mask bit
 * CAN_CTRL2[ERRMSK_FAST] is set, an interrupt is generated to the CPU. This bit is
 * cleared by writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - Indicates setting of any Error Bit detected in the Data Phase of CAN
 *     FD frames with the BRS bit set.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ERRINT_FAST field. */
#define CAN_RD_ESR1_ERRINT_FAST(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ERRINT_FAST_MASK) >> CAN_ESR1_ERRINT_FAST_SHIFT)
#define CAN_BRD_ESR1_ERRINT_FAST(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERRINT_FAST_SHIFT))

/*! @brief Set the ERRINT_FAST field to a new value. */
#define CAN_WR_ESR1_ERRINT_FAST(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_ERRINT_FAST_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_ERRINT_FAST(value)))
#define CAN_BWR_ESR1_ERRINT_FAST(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERRINT_FAST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERROVR[21] (W1C)
 *
 * This bit indicates that an error condition occurred when any error flag is
 * already set. This bit is cleared by writing it to 1.
 *
 * Values:
 * - 0b0 - Overrun has not occurred.
 * - 0b1 - Overrun has occured.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ERROVR field. */
#define CAN_RD_ESR1_ERROVR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ERROVR_MASK) >> CAN_ESR1_ERROVR_SHIFT)
#define CAN_BRD_ESR1_ERROVR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERROVR_SHIFT))

/*! @brief Set the ERROVR field to a new value. */
#define CAN_WR_ESR1_ERROVR(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_ERROVR_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERRINT_FAST_MASK), CAN_ESR1_ERROVR(value)))
#define CAN_BWR_ESR1_ERROVR(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERROVR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field STFERR_FAST[26] (RO)
 *
 * This bit indicates that a Stuffing Error has been detected in the Data Phase
 * of CAN FD frames with the BRS bit set.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A Stuffing Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_STFERR_FAST field. */
#define CAN_RD_ESR1_STFERR_FAST(base) ((CAN_ESR1_REG(base) & CAN_ESR1_STFERR_FAST_MASK) >> CAN_ESR1_STFERR_FAST_SHIFT)
#define CAN_BRD_ESR1_STFERR_FAST(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_STFERR_FAST_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FRMERR_FAST[27] (RO)
 *
 * This bit indicates that a Form Error has been detected by the receiver node
 * in the Data Phase of CAN FD frames with the BRS bit set, that is, a fixed-form
 * bit field contains at least one illegal bit.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A Form Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_FRMERR_FAST field. */
#define CAN_RD_ESR1_FRMERR_FAST(base) ((CAN_ESR1_REG(base) & CAN_ESR1_FRMERR_FAST_MASK) >> CAN_ESR1_FRMERR_FAST_SHIFT)
#define CAN_BRD_ESR1_FRMERR_FAST(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_FRMERR_FAST_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field CRCERR_FAST[28] (RO)
 *
 * This bit indicates that a CRC Error has been detected by the receiver node in
 * the CRC field of CAN FD frames with the BRS bit set, that is, the calculated
 * CRC is different from the received.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A CRC error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_CRCERR_FAST field. */
#define CAN_RD_ESR1_CRCERR_FAST(base) ((CAN_ESR1_REG(base) & CAN_ESR1_CRCERR_FAST_MASK) >> CAN_ESR1_CRCERR_FAST_SHIFT)
#define CAN_BRD_ESR1_CRCERR_FAST(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_CRCERR_FAST_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT0ERR_FAST[30] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in the Data Phase of CAN FD frames with the BRS bit set.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - At least one bit sent as dominant is received as recessive.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT0ERR_FAST field. */
#define CAN_RD_ESR1_BIT0ERR_FAST(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT0ERR_FAST_MASK) >> CAN_ESR1_BIT0ERR_FAST_SHIFT)
#define CAN_BRD_ESR1_BIT0ERR_FAST(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BIT0ERR_FAST_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT1ERR_FAST[31] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in the Data Phase of CAN FD frames with the BRS bit set.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - At least one bit sent as recessive is received as dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT1ERR_FAST field. */
#define CAN_RD_ESR1_BIT1ERR_FAST(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT1ERR_FAST_MASK) >> CAN_ESR1_BIT1ERR_FAST_SHIFT)
#define CAN_BRD_ESR1_BIT1ERR_FAST(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BIT1ERR_FAST_SHIFT))
/*@}*/

/*******************************************************************************
 * CAN_IMASK1 - Interrupt Masks 1 register
 ******************************************************************************/

/*!
 * @brief CAN_IMASK1 - Interrupt Masks 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register allows any number of a range of the 32 Message Buffer
 * Interrupts to be enabled or disabled for MB31 to MB0. It contains one interrupt mask
 * bit per buffer, enabling the CPU to determine which buffer generates an
 * interrupt after a successful transmission or reception, that is, when the
 * corresponding CAN_IFLAG1 bit is set.
 */
/*!
 * @name Constants and macros for entire CAN_IMASK1 register
 */
/*@{*/
#define CAN_RD_IMASK1(base)      (CAN_IMASK1_REG(base))
#define CAN_WR_IMASK1(base, value) (CAN_IMASK1_REG(base) = (value))
#define CAN_RMW_IMASK1(base, mask, value) (CAN_WR_IMASK1(base, (CAN_RD_IMASK1(base) & ~(mask)) | (value)))
#define CAN_SET_IMASK1(base, value) (CAN_WR_IMASK1(base, CAN_RD_IMASK1(base) |  (value)))
#define CAN_CLR_IMASK1(base, value) (CAN_WR_IMASK1(base, CAN_RD_IMASK1(base) & ~(value)))
#define CAN_TOG_IMASK1(base, value) (CAN_WR_IMASK1(base, CAN_RD_IMASK1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_IFLAG1 - Interrupt Flags 1 register
 ******************************************************************************/

/*!
 * @brief CAN_IFLAG1 - Interrupt Flags 1 register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the flags for the32 Message Buffer interrupts for MB31
 * to MB0. It contains one interrupt flag bit per buffer. Each successful
 * transmission or reception sets the corresponding CAN_IFLAG1 bit. If the corresponding
 * CAN_IMASK1 bit is set, an interrupt will be generated. The interrupt flag
 * must be cleared by writing 1 to it. Writing 0 has no effect. There is an
 * exception when DMA for Rx FIFO is enabled, as described below. The BUF7I to BUF5I
 * flags are also used to represent FIFO interrupts when the Rx FIFO is enabled. When
 * the bit CAN_MCR[RFEN] is set and the bit CAN_MCR[DMA] is negated, the
 * function of the 8 least significant interrupt flags changes: BUF7I, BUF6I and BUF5I
 * indicate operating conditions of the FIFO, BUF0I is used to empty FIFO, and
 * BUF4I to BUF1I bits are reserved. Before enabling the CAN_MCR[RFEN], the CPU must
 * service the IFLAG bits asserted in the Rx FIFO region; see Section "Rx FIFO".
 * Otherwise, these IFLAG bits will mistakenly show the related MBs now
 * belonging to FIFO as having contents to be serviced. When the CAN_MCR[RFEN] bit is
 * negated, the FIFO flags must be cleared. The same care must be taken when an
 * CAN_CTRL2[RFFN] value is selected extending Rx FIFO filters beyond MB7. For
 * example, when RFFN is 0x8, the MB0-23 range is occupied by Rx FIFO filters and
 * related IFLAG bits must be cleared. When both the CAN_MCR[RFEN] and CAN_MCR[DMA]
 * bits are asserted (DMA feature for Rx FIFO enabled), the function of the 8 least
 * significant interrupt flags (BUF7I - BUF0I) are changed to support the DMA
 * operation. BUF7I and BUF6I are not used, as well as, BUF4I to BUF1I. BUF5I
 * indicates operating condition of FIFO, and BUF0I is used to empty FIFO. Moreover,
 * BUF5I does not generate a CPU interrupt, but generates a DMA request. IMASK1
 * bits in Rx FIFO region are not considered when bit CAN_MCR[DMA] is enabled. In
 * addition the CPU must not clear the flag BUF5I when DMA is enabled. Before
 * enabling the bit CAN_MCR[DMA], the CPU must service the IFLAGs asserted in the Rx
 * FIFO region. When the bit CAN_MCR[DMA] is negated, the FIFO must be empty.
 * FIFO must be disabled when FDEN bit in CAN_MCR register is enabled. Before
 * updating CAN_MCR[MAXMB] field, CPU must service the CAN_IFLAG1 bits whose MB value
 * is greater than the CAN_MCR[MAXMB] to be updated; otherwise, they will remain
 * set and be inconsistent with the number of MBs available.
 */
/*!
 * @name Constants and macros for entire CAN_IFLAG1 register
 */
/*@{*/
#define CAN_RD_IFLAG1(base)      (CAN_IFLAG1_REG(base))
#define CAN_WR_IFLAG1(base, value) (CAN_IFLAG1_REG(base) = (value))
#define CAN_RMW_IFLAG1(base, mask, value) (CAN_WR_IFLAG1(base, (CAN_RD_IFLAG1(base) & ~(mask)) | (value)))
#define CAN_SET_IFLAG1(base, value) (CAN_WR_IFLAG1(base, CAN_RD_IFLAG1(base) |  (value)))
#define CAN_CLR_IFLAG1(base, value) (CAN_WR_IFLAG1(base, CAN_RD_IFLAG1(base) & ~(value)))
#define CAN_TOG_IFLAG1(base, value) (CAN_WR_IFLAG1(base, CAN_RD_IFLAG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_IFLAG1 bitfields
 */

/*!
 * @name Register CAN_IFLAG1, field BUF0I[0] (W1C)
 *
 * When the RFEN bit in MCR is cleared (Rx FIFO disabled), this bit flags the
 * interrupt for MB0. If the Rx FIFO is enabled, this bit is used to trigger the
 * clear FIFO operation. This operation empties FIFO contents. Before performing
 * this operation the CPU must service all FIFO related IFLAGs. When the bit
 * MCR[DMA] is enabled this operation also clears the BUF5I flag and consequently abort
 * the DMA request. The clear FIFO operation occurs when the CPU writes 1 in
 * BUF0I. It is only allowed in Freeze Mode and is blocked by hardware in other
 * conditions.
 *
 * Values:
 * - 0b0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception when MCR[RFEN]=0.
 * - 0b1 - The corresponding buffer has successfully completed transmission or
 *     reception when MCR[RFEN]=0.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF0I field. */
#define CAN_RD_IFLAG1_BUF0I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF0I_MASK) >> CAN_IFLAG1_BUF0I_SHIFT)
#define CAN_BRD_IFLAG1_BUF0I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF0I_SHIFT))

/*! @brief Set the BUF0I field to a new value. */
#define CAN_WR_IFLAG1_BUF0I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF0I(value)))
#define CAN_BWR_IFLAG1_BUF0I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF0I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF4TO1I[4:1] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled),
 * these bits flag the interrupts for MB4 to MB1. These flags are cleared by the
 * FlexCAN whenever the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF4TO1I
 * flags are reserved when CAN_MCR[RFEN] is set.
 *
 * Values:
 * - 0b0000 - The corresponding buffer has no occurrence of successfully
 *     completed transmission or reception when MCR[RFEN]=0.
 * - 0b0001 - The corresponding buffer has successfully completed transmission
 *     or reception when MCR[RFEN]=0.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF4TO1I field. */
#define CAN_RD_IFLAG1_BUF4TO1I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF4TO1I_MASK) >> CAN_IFLAG1_BUF4TO1I_SHIFT)
#define CAN_BRD_IFLAG1_BUF4TO1I(base) (CAN_RD_IFLAG1_BUF4TO1I(base))

/*! @brief Set the BUF4TO1I field to a new value. */
#define CAN_WR_IFLAG1_BUF4TO1I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF4TO1I(value)))
#define CAN_BWR_IFLAG1_BUF4TO1I(base, value) (CAN_WR_IFLAG1_BUF4TO1I(base, value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF5I[5] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), this bit flags
 * the interrupt for MB5. This flag is cleared by the FlexCAN whenever the bit
 * MCR[RFEN] is changed by CPU writes. When MCR[RFEN] is set (Rx FIFO enabled), the
 * BUF5I flag represents "Frames available in Rx FIFO" and indicates that at least
 * one frame is available to be read from the Rx FIFO. When the MCR[DMA] bit is
 * enabled, this flag generates a DMA request and the CPU must not clear this bit
 * by writing 1 in BUF5I.
 *
 * Values:
 * - 0b0 - No occurrence of MB5 completing transmission/reception when
 *     MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
 * - 0b1 - MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s)
 *     available in the Rx FIFO when MCR[RFEN]=1. It generates a DMA request in
 *     case of MCR[RFEN] and MCR[DMA] are enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF5I field. */
#define CAN_RD_IFLAG1_BUF5I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF5I_MASK) >> CAN_IFLAG1_BUF5I_SHIFT)
#define CAN_BRD_IFLAG1_BUF5I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF5I_SHIFT))

/*! @brief Set the BUF5I field to a new value. */
#define CAN_WR_IFLAG1_BUF5I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF5I(value)))
#define CAN_BWR_IFLAG1_BUF5I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF5I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF6I[6] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled), this
 * bit flags the interrupt for MB6. This flag is cleared by the FlexCAN whenever
 * the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF6I flag represents "Rx
 * FIFO Warning" when CAN_MCR[RFEN] is set. In this case, the flag indicates
 * when the number of unread messages within the Rx FIFO is increased to 5 from 4
 * due to the reception of a new one, meaning that the Rx FIFO is almost full. Note
 * that if the flag is cleared while the number of unread messages is greater
 * than 4, it does not assert again until the number of unread messages within the
 * Rx FIFO is decreased to be equal to or less than 4.
 *
 * Values:
 * - 0b0 - No occurrence of MB6 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
 * - 0b1 - MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     almost full when MCR[RFEN]=1
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF6I field. */
#define CAN_RD_IFLAG1_BUF6I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF6I_MASK) >> CAN_IFLAG1_BUF6I_SHIFT)
#define CAN_BRD_IFLAG1_BUF6I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF6I_SHIFT))

/*! @brief Set the BUF6I field to a new value. */
#define CAN_WR_IFLAG1_BUF6I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF6I(value)))
#define CAN_BWR_IFLAG1_BUF6I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF6I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF7I[7] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled), this
 * bit flags the interrupt for MB7. This flag is cleared by the FlexCAN whenever
 * the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF7I flag represents "Rx
 * FIFO Overflow" when CAN_MCR[RFEN] is set. In this case, the flag indicates
 * that a message was lost because the Rx FIFO is full. Note that the flag will not
 * be asserted when the Rx FIFO is full and the message was captured by a
 * Mailbox.
 *
 * Values:
 * - 0b0 - No occurrence of MB7 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
 * - 0b1 - MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     overflow when MCR[RFEN]=1
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF7I field. */
#define CAN_RD_IFLAG1_BUF7I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF7I_MASK) >> CAN_IFLAG1_BUF7I_SHIFT)
#define CAN_BRD_IFLAG1_BUF7I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF7I_SHIFT))

/*! @brief Set the BUF7I field to a new value. */
#define CAN_WR_IFLAG1_BUF7I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF7I(value)))
#define CAN_BWR_IFLAG1_BUF7I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF7I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF31TO8I[31:8] (W1C)
 *
 * Each bit flags the corresponding FlexCAN Message Buffer interrupt for MB15 to
 * MB8.
 *
 * Values:
 * - 0b000000000000000000000000 - The corresponding buffer has no occurrence of
 *     successfully completed transmission or reception.
 * - 0b000000000000000000000001 - The corresponding buffer has successfully
 *     completed transmission or reception.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF31TO8I field. */
#define CAN_RD_IFLAG1_BUF31TO8I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF31TO8I_MASK) >> CAN_IFLAG1_BUF31TO8I_SHIFT)
#define CAN_BRD_IFLAG1_BUF31TO8I(base) (CAN_RD_IFLAG1_BUF31TO8I(base))

/*! @brief Set the BUF31TO8I field to a new value. */
#define CAN_WR_IFLAG1_BUF31TO8I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF31TO8I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK), CAN_IFLAG1_BUF31TO8I(value)))
#define CAN_BWR_IFLAG1_BUF31TO8I(base, value) (CAN_WR_IFLAG1_BUF31TO8I(base, value))
/*@}*/

/*******************************************************************************
 * CAN_CTRL2 - Control 2 register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL2 - Control 2 register (RW)
 *
 * Reset value: 0x00B00000U
 *
 * This register complements Control1 Register providing control bits for memory
 * write access in Freeze Mode, for extending FIFO filter quantity, and for
 * adjust the operation of internal FlexCAN processes like matching and arbitration.
 * The contents of this register are not affected by soft reset.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL2 register
 */
/*@{*/
#define CAN_RD_CTRL2(base)       (CAN_CTRL2_REG(base))
#define CAN_WR_CTRL2(base, value) (CAN_CTRL2_REG(base) = (value))
#define CAN_RMW_CTRL2(base, mask, value) (CAN_WR_CTRL2(base, (CAN_RD_CTRL2(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL2(base, value) (CAN_WR_CTRL2(base, CAN_RD_CTRL2(base) |  (value)))
#define CAN_CLR_CTRL2(base, value) (CAN_WR_CTRL2(base, CAN_RD_CTRL2(base) & ~(value)))
#define CAN_TOG_CTRL2(base, value) (CAN_WR_CTRL2(base, CAN_RD_CTRL2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL2 bitfields
 */

/*!
 * @name Register CAN_CTRL2, field EDFLTDIS[11] (RW)
 *
 * This bit disables the Edge Filter used during the bus integration state. When
 * the Edge Filter is enabled, two consecutive nominal time quanta with dominant
 * bus state are required to detect an edge that causes synchronization. When
 * synchronization occurs, the counting of the sequence of eleven consecutive
 * recessive bits is restarted. The Edge Filter prevents the dominant pulses that are
 * shorter than a nominal bit time (present during the data phase of an FD Frame)
 * from being mistaken for an idle condition.
 *
 * Values:
 * - 0b0 - Edge Filter is enabled.
 * - 0b1 - Edge Filter is disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_EDFLTDIS field. */
#define CAN_RD_CTRL2_EDFLTDIS(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_EDFLTDIS_MASK) >> CAN_CTRL2_EDFLTDIS_SHIFT)
#define CAN_BRD_CTRL2_EDFLTDIS(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_EDFLTDIS_SHIFT))

/*! @brief Set the EDFLTDIS field to a new value. */
#define CAN_WR_CTRL2_EDFLTDIS(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_EDFLTDIS_MASK, CAN_CTRL2_EDFLTDIS(value)))
#define CAN_BWR_CTRL2_EDFLTDIS(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_EDFLTDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field STFCNTEN[12] (RW)
 *
 * This bit enables the count of variable stuff bits inserted from the Start of
 * Frame bit to the last bit of Data field. Also, the modulo 8 count of variable
 * stuff bits plus the respective parity bit (even parity calculated over the
 * 3-bit modulo 8 count) are combined as the 4-bit Stuff Count field and inserted
 * before the CRC Sequence field. CRC calculation extends beyound the end of Data
 * field and takes the Stuff Count field bits into account.
 *
 * Values:
 * - 0b0 - Stuff Count feature is disabled. Stuff Count bit field is not
 *     inserted before the CRC Sequence field.
 * - 0b1 - Stuff Count feature is enabled. Stuff Count bit field is inserted
 *     before the CRC Sequence field.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_STFCNTEN field. */
#define CAN_RD_CTRL2_STFCNTEN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_STFCNTEN_MASK) >> CAN_CTRL2_STFCNTEN_SHIFT)
#define CAN_BRD_CTRL2_STFCNTEN(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_STFCNTEN_SHIFT))

/*! @brief Set the STFCNTEN field to a new value. */
#define CAN_WR_CTRL2_STFCNTEN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_STFCNTEN_MASK, CAN_CTRL2_STFCNTEN(value)))
#define CAN_BWR_CTRL2_STFCNTEN(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_STFCNTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field PREXCEN[14] (RW)
 *
 * This bit enables the Protocol Exception feature.
 *
 * Values:
 * - 0b0 - Protocol Exception is disabled.
 * - 0b1 - Protocol Exception is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_PREXCEN field. */
#define CAN_RD_CTRL2_PREXCEN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_PREXCEN_MASK) >> CAN_CTRL2_PREXCEN_SHIFT)
#define CAN_BRD_CTRL2_PREXCEN(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_PREXCEN_SHIFT))

/*! @brief Set the PREXCEN field to a new value. */
#define CAN_WR_CTRL2_PREXCEN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_PREXCEN_MASK, CAN_CTRL2_PREXCEN(value)))
#define CAN_BWR_CTRL2_PREXCEN(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_PREXCEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field TIMER_SRC[15] (RW)
 *
 * Selects the time tick source used for incrementing the Free Running Timer
 * counter. This bit can be written in Freeze mode only.
 *
 * Values:
 * - 0b0 - The Free Running Timer is clocked by the CAN bit clock, which defines
 *     the baud rate on the CAN bus.
 * - 0b1 - The Free Running Timer is clocked by an external time tick. The
 *     period can be either adjusted to be equal to the baud rate on the CAN bus, or a
 *     different value as required. See the device specific section for details
 *     about the external time tick.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_TIMER_SRC field. */
#define CAN_RD_CTRL2_TIMER_SRC(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_TIMER_SRC_MASK) >> CAN_CTRL2_TIMER_SRC_SHIFT)
#define CAN_BRD_CTRL2_TIMER_SRC(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_TIMER_SRC_SHIFT))

/*! @brief Set the TIMER_SRC field to a new value. */
#define CAN_WR_CTRL2_TIMER_SRC(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_TIMER_SRC_MASK, CAN_CTRL2_TIMER_SRC(value)))
#define CAN_BWR_CTRL2_TIMER_SRC(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_TIMER_SRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field EACEN[16] (RW)
 *
 * This bit controls the comparison of IDE and RTR bits within Rx Mailboxes
 * filters with their corresponding bits in the incoming frame by the matching
 * process. This bit does not affect matching for Rx FIFO. This bit can be written only
 * in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Rx Mailbox filter's IDE bit is always compared and RTR is never
 *     compared despite mask bits.
 * - 0b1 - Enables the comparison of both Rx Mailbox filter's IDE and RTR bit
 *     with their corresponding bits within the incoming frame. Mask bits do apply.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_EACEN field. */
#define CAN_RD_CTRL2_EACEN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_EACEN_MASK) >> CAN_CTRL2_EACEN_SHIFT)
#define CAN_BRD_CTRL2_EACEN(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_EACEN_SHIFT))

/*! @brief Set the EACEN field to a new value. */
#define CAN_WR_CTRL2_EACEN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_EACEN_MASK, CAN_CTRL2_EACEN(value)))
#define CAN_BWR_CTRL2_EACEN(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_EACEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RRS[17] (RW)
 *
 * If this bit is asserted Remote Request Frame is submitted to a matching
 * process and stored in the corresponding Message Buffer in the same fashion of a
 * Data Frame. No automatic Remote Response Frame will be generated. If this bit is
 * negated the Remote Request Frame is submitted to a matching process and an
 * automatic Remote Response Frame is generated if a Message Buffer with CODE=0b1010
 * is found with the same ID. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Remote Response Frame is generated.
 * - 0b1 - Remote Request Frame is stored.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_RRS field. */
#define CAN_RD_CTRL2_RRS(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_RRS_MASK) >> CAN_CTRL2_RRS_SHIFT)
#define CAN_BRD_CTRL2_RRS(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_RRS_SHIFT))

/*! @brief Set the RRS field to a new value. */
#define CAN_WR_CTRL2_RRS(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_RRS_MASK, CAN_CTRL2_RRS(value)))
#define CAN_BWR_CTRL2_RRS(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_RRS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field MRP[18] (RW)
 *
 * If this bit is set the matching process starts from the Mailboxes and if no
 * match occurs the matching continues on the Rx FIFO. This bit can be written
 * only in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Matching starts from Rx FIFO and continues on Mailboxes.
 * - 0b1 - Matching starts from Mailboxes and continues on Rx FIFO.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_MRP field. */
#define CAN_RD_CTRL2_MRP(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_MRP_MASK) >> CAN_CTRL2_MRP_SHIFT)
#define CAN_BRD_CTRL2_MRP(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_MRP_SHIFT))

/*! @brief Set the MRP field to a new value. */
#define CAN_WR_CTRL2_MRP(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_MRP_MASK, CAN_CTRL2_MRP(value)))
#define CAN_BWR_CTRL2_MRP(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_MRP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field TASD[23:19] (RW)
 *
 * This 5-bit field indicates how many CAN bits the Tx arbitration process start
 * point can be delayed from the first bit of CRC field on CAN bus. See Tx
 * Arbitration start delay for more details. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_TASD field. */
#define CAN_RD_CTRL2_TASD(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_TASD_MASK) >> CAN_CTRL2_TASD_SHIFT)
#define CAN_BRD_CTRL2_TASD(base) (CAN_RD_CTRL2_TASD(base))

/*! @brief Set the TASD field to a new value. */
#define CAN_WR_CTRL2_TASD(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_TASD_MASK, CAN_CTRL2_TASD(value)))
#define CAN_BWR_CTRL2_TASD(base, value) (CAN_WR_CTRL2_TASD(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RFFN[27:24] (RW)
 *
 * This 4-bit field defines the number of Rx FIFO filters, as shown in the
 * following table. The maximum selectable number of filters is determined by the MCU.
 * This field can only be written in Freeze mode as it is blocked by hardware in
 * other modes. This field must not be programmed with values that make the
 * number of Message Buffers occupied by Rx FIFO and ID Filter exceed the number of
 * Mailboxes present, defined by CAN_MCR[MAXMB]. Each group of eight filters
 * occupies a memory space equivalent to two Message Buffers which means that the more
 * filters are implemented the less Mailboxes will be available. Considering
 * that the Rx FIFO occupies the memory space originally reserved for MB0-5, RFFN
 * should be programmed with a value corresponding to a number of filters not
 * greater than the number of available memory words which can be calculated as
 * follows: (SETUP_MB - 6) * 4 where SETUP_MB is the least between the parameter
 * NUMBER_OF_MB and CAN_MCR[MAXMB]. The number of remaining Mailboxes available will
 * be: (SETUP_MB - 8) - (RFFN * 2) If the Number of Rx FIFO Filters programmed
 * through RFFN exceeds the SETUP_MB value (memory space available) the exceeding
 * ones will not be functional. The number of the last remaining available mailboxes
 * is defined by the least value between the NUMBER_OF_MB minus 1 and the
 * CAN_MCR[MAXMB] field. If Rx Individual Mask Registers are not enabled then all Rx
 * FIFO filters are affected by the Rx FIFO Global Mask. RFFN[3:0] Number of Rx
 * FIFO filter elements Message Buffers occupied by Rx FIFO and ID Filter Table
 * Remaining Available Mailboxes Rx FIFO ID Filter Table Elements Affected by Rx
 * Individual Masks Rx FIFO ID Filter Table Elements Affected by Rx FIFO Global Mask
 * 0x0 8 MB 0-7 MB 8-63 Elements 0-7 none 0x1 16 MB 0-9 MB 10-63 Elements 0-9
 * Elements 10-15 0x2 24 MB 0-11 MB 12-63 Elements 0-11 Elements 12-23 0x3 32 MB
 * 0-13 MB 14-63 Elements 0-13 Elements 14-31 0x4 40 MB 0-15 MB 16-63 Elements 0-15
 * Elements 16-39 0x5 48 MB 0-17 MB 18-63 Elements 0-17 Elements 18-47 0x6 56 MB
 * 0-19 MB 20-63 Elements 0-19 Elements 20-55 0x7 64 MB 0-21 MB 22-63 Elements
 * 0-21 Elements 22-63 0x8 72 MB 0-23 MB 24-63 Elements 0-23 Elements 24-71 0x9 80
 * MB 0-25 MB 26-63 Elements 0-25 Elements 26-79 0xA 88 MB 0-27 MB 28-63 Elements
 * 0-27 Elements 28-87 0xB 96 MB 0-29 MB 30-63 Elements 0-29 Elements 30-95 0xC
 * 104 MB 0-31 MB 32-63 Elements 0-31 Elements 32-103 0xD 112 MB 0-33 MB 34-63
 * Elements 0-31 Elements 32-111 0xE 120 MB 0-35 MB 36-63 Elements 0-31 Elements
 * 32-119 0xF 128 MB 0-37 MB 38-63 Elements 0-31 Elements 32-127
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_RFFN field. */
#define CAN_RD_CTRL2_RFFN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT)
#define CAN_BRD_CTRL2_RFFN(base) (CAN_RD_CTRL2_RFFN(base))

/*! @brief Set the RFFN field to a new value. */
#define CAN_WR_CTRL2_RFFN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_RFFN_MASK, CAN_CTRL2_RFFN(value)))
#define CAN_BWR_CTRL2_RFFN(base, value) (CAN_WR_CTRL2_RFFN(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field BOFFDONEMSK[30] (RW)
 *
 * This bit provides a mask for the Bus Off Done Interrupt in CAN_ESR1 register.
 *
 * Values:
 * - 0b0 - Bus Off Done interrupt disabled.
 * - 0b1 - Bus Off Done interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_BOFFDONEMSK field. */
#define CAN_RD_CTRL2_BOFFDONEMSK(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_BOFFDONEMSK_MASK) >> CAN_CTRL2_BOFFDONEMSK_SHIFT)
#define CAN_BRD_CTRL2_BOFFDONEMSK(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_BOFFDONEMSK_SHIFT))

/*! @brief Set the BOFFDONEMSK field to a new value. */
#define CAN_WR_CTRL2_BOFFDONEMSK(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_BOFFDONEMSK_MASK, CAN_CTRL2_BOFFDONEMSK(value)))
#define CAN_BWR_CTRL2_BOFFDONEMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_BOFFDONEMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field ERRMSK_FAST[31] (RW)
 *
 * This bit provides a mask for the ERRINT_FAST Interrupt in CAN_ESR1 register.
 *
 * Values:
 * - 0b0 - ERRINT_FAST Error interrupt disabled.
 * - 0b1 - ERRINT_FAST Error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_ERRMSK_FAST field. */
#define CAN_RD_CTRL2_ERRMSK_FAST(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_ERRMSK_FAST_MASK) >> CAN_CTRL2_ERRMSK_FAST_SHIFT)
#define CAN_BRD_CTRL2_ERRMSK_FAST(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_ERRMSK_FAST_SHIFT))

/*! @brief Set the ERRMSK_FAST field to a new value. */
#define CAN_WR_CTRL2_ERRMSK_FAST(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_ERRMSK_FAST_MASK, CAN_CTRL2_ERRMSK_FAST(value)))
#define CAN_BWR_CTRL2_ERRMSK_FAST(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_ERRMSK_FAST_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_ESR2 - Error and Status 2 register
 ******************************************************************************/

/*!
 * @brief CAN_ESR2 - Error and Status 2 register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register reports some general status information.
 */
/*!
 * @name Constants and macros for entire CAN_ESR2 register
 */
/*@{*/
#define CAN_RD_ESR2(base)        (CAN_ESR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_ESR2 bitfields
 */

/*!
 * @name Register CAN_ESR2, field IMB[13] (RO)
 *
 * If ESR2[VPS] is asserted, this bit indicates whether there is any inactive
 * Mailbox (CODE field is either 0b1000 or 0b0000). This bit is asserted in the
 * following cases: During arbitration, if an CAN_ESR2[LPTM] is found and it is
 * inactive. If CAN_ESR2[IMB] is not asserted and a frame is transmitted
 * successfully. This bit is cleared in all start of arbitration (see Section "Arbitration
 * process"). CAN_ESR2[LPTM] mechanism have the following behavior: if an MB is
 * successfully transmitted and CAN_ESR2[IMB]=0 (no inactive Mailbox), then
 * CAN_ESR2[VPS] and CAN_ESR2[IMB] are asserted and the index related to the MB just
 * transmitted is loaded into CAN_ESR2[LPTM].
 *
 * Values:
 * - 0b0 - If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
 * - 0b1 - If ESR2[VPS] is asserted, there is at least one inactive Mailbox.
 *     LPTM content is the number of the first one.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_IMB field. */
#define CAN_RD_ESR2_IMB(base) ((CAN_ESR2_REG(base) & CAN_ESR2_IMB_MASK) >> CAN_ESR2_IMB_SHIFT)
#define CAN_BRD_ESR2_IMB(base) (BITBAND_ACCESS32(&CAN_ESR2_REG(base), CAN_ESR2_IMB_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR2, field VPS[14] (RO)
 *
 * This bit indicates whether CAN_ESR2[IMB] and CAN_ESR2[LPTM] contents are
 * currently valid or not. It is asserted upon every complete Tx arbitration process
 * unless the CPU writes to Control and Status word of a Mailbox that has already
 * been scanned, that is, it is behind Tx Arbitration Pointer, during the Tx
 * arbitration process. If there is no inactive Mailbox and only one Tx Mailbox that
 * is being transmitted then VPS is not asserted. This bit is negated upon the
 * start of every Tx arbitration process or upon a write to Control and Status
 * word of any Mailbox. CAN_ESR2[VPS] is not affected by any CPU write into Control
 * Status (C/S) of a MB thatis blocked by abort mechanism. When CAN_MCR[AEN] is
 * asserted, the abort code write in C/S of a MB that is being transmitted
 * (pending abort), or any write attempt into a Tx MB with CAN_IFLAG set is blocked.
 *
 * Values:
 * - 0b0 - Contents of IMB and LPTM are invalid.
 * - 0b1 - Contents of IMB and LPTM are valid.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_VPS field. */
#define CAN_RD_ESR2_VPS(base) ((CAN_ESR2_REG(base) & CAN_ESR2_VPS_MASK) >> CAN_ESR2_VPS_SHIFT)
#define CAN_BRD_ESR2_VPS(base) (BITBAND_ACCESS32(&CAN_ESR2_REG(base), CAN_ESR2_VPS_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR2, field LPTM[22:16] (RO)
 *
 * If CAN_ESR2[VPS] is asserted, this field indicates the lowest number inactive
 * Mailbox (see the CAN_ESR2[IMB] bit description). If there is no inactive
 * Mailbox then the Mailbox indicated depends on CAN_CTRL1[LBUF] bit value. If
 * CAN_CTRL1[LBUF] bit is negated then the Mailbox indicated is the one that has the
 * greatest arbitration value (see the "Highest priority Mailbox first" section).
 * If CAN_CTRL1[LBUF] bit is asserted then the Mailbox indicated is the highest
 * number active Tx Mailbox. If a Tx Mailbox is being transmitted it is not
 * considered in LPTM calculation. If CAN_ESR2[IMB] is not asserted and a frame is
 * transmitted successfully, LPTM is updated with its Mailbox number.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_LPTM field. */
#define CAN_RD_ESR2_LPTM(base) ((CAN_ESR2_REG(base) & CAN_ESR2_LPTM_MASK) >> CAN_ESR2_LPTM_SHIFT)
#define CAN_BRD_ESR2_LPTM(base) (CAN_RD_ESR2_LPTM(base))
/*@}*/

/*******************************************************************************
 * CAN_CRCR - CRC Register
 ******************************************************************************/

/*!
 * @brief CAN_CRCR - CRC Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register provides information about the CRC of transmitted messages for
 * non FD messages. This register only reports the 15 low order bits of CRC
 * calculations for messages in CAN FD format that require either 17 or 21 bits. For
 * CAN FD format frames, the CAN_FDCRC register must be used. This register is
 * updated at the same time the Tx Interrupt Flag is asserted.
 */
/*!
 * @name Constants and macros for entire CAN_CRCR register
 */
/*@{*/
#define CAN_RD_CRCR(base)        (CAN_CRCR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_CRCR bitfields
 */

/*!
 * @name Register CAN_CRCR, field TXCRC[14:0] (RO)
 *
 * This field indicates the CRC value of the last transmitted messagefor non-FD
 * frames. For FD frames, CRC value is reported in CAN_FDCRC register.
 */
/*@{*/
/*! @brief Read current value of the CAN_CRCR_TXCRC field. */
#define CAN_RD_CRCR_TXCRC(base) ((CAN_CRCR_REG(base) & CAN_CRCR_TXCRC_MASK) >> CAN_CRCR_TXCRC_SHIFT)
#define CAN_BRD_CRCR_TXCRC(base) (CAN_RD_CRCR_TXCRC(base))
/*@}*/

/*!
 * @name Register CAN_CRCR, field MBCRC[22:16] (RO)
 *
 * This field indicates the number of the Mailbox corresponding to the value in
 * CAN_CRCR[TXCRC] field.
 */
/*@{*/
/*! @brief Read current value of the CAN_CRCR_MBCRC field. */
#define CAN_RD_CRCR_MBCRC(base) ((CAN_CRCR_REG(base) & CAN_CRCR_MBCRC_MASK) >> CAN_CRCR_MBCRC_SHIFT)
#define CAN_BRD_CRCR_MBCRC(base) (CAN_RD_CRCR_MBCRC(base))
/*@}*/

/*******************************************************************************
 * CAN_RXFGMASK - Rx FIFO Global Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RXFGMASK - Rx FIFO Global Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. If Rx FIFO is enabled, RXFGMASK is used to
 * mask the Rx FIFO ID Filter Table elements that do not have a corresponding
 * RXIMR according to CAN_CTRL2[RFFN] field setting. This register can only be
 * written in Freeze mode as it is blocked by hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RXFGMASK register
 */
/*@{*/
#define CAN_RD_RXFGMASK(base)    (CAN_RXFGMASK_REG(base))
#define CAN_WR_RXFGMASK(base, value) (CAN_RXFGMASK_REG(base) = (value))
#define CAN_RMW_RXFGMASK(base, mask, value) (CAN_WR_RXFGMASK(base, (CAN_RD_RXFGMASK(base) & ~(mask)) | (value)))
#define CAN_SET_RXFGMASK(base, value) (CAN_WR_RXFGMASK(base, CAN_RD_RXFGMASK(base) |  (value)))
#define CAN_CLR_RXFGMASK(base, value) (CAN_WR_RXFGMASK(base, CAN_RD_RXFGMASK(base) & ~(value)))
#define CAN_TOG_RXFGMASK(base, value) (CAN_WR_RXFGMASK(base, CAN_RD_RXFGMASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_RXFIR - Rx FIFO Information Register
 ******************************************************************************/

/*!
 * @brief CAN_RXFIR - Rx FIFO Information Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFIR provides information on Rx FIFO. This register is the port through
 * which the CPU accesses the output of the RXFIR FIFO located in RAM. The RXFIR FIFO
 * is written by the FlexCAN whenever a new message is moved into the Rx FIFO as
 * well as its output is updated whenever the output of the Rx FIFO is updated
 * with the next message. See Section "Rx FIFO" for instructions on reading this
 * register.
 */
/*!
 * @name Constants and macros for entire CAN_RXFIR register
 */
/*@{*/
#define CAN_RD_RXFIR(base)       (CAN_RXFIR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_RXFIR bitfields
 */

/*!
 * @name Register CAN_RXFIR, field IDHIT[8:0] (RO)
 *
 * This field indicates which Identifier Acceptance Filter was hit by the
 * received message that is in the output of the Rx FIFO. If multiple filters match the
 * incoming message ID then the first matching IDAF found (lowest number) by the
 * matching process is indicated. This field is valid only while the
 * CAN_IFLAG1[BUF5I] is asserted.
 */
/*@{*/
/*! @brief Read current value of the CAN_RXFIR_IDHIT field. */
#define CAN_RD_RXFIR_IDHIT(base) ((CAN_RXFIR_REG(base) & CAN_RXFIR_IDHIT_MASK) >> CAN_RXFIR_IDHIT_SHIFT)
#define CAN_BRD_RXFIR_IDHIT(base) (CAN_RD_RXFIR_IDHIT(base))
/*@}*/

/*******************************************************************************
 * CAN_CBT - CAN Bit Timing Register
 ******************************************************************************/

/*!
 * @brief CAN_CBT - CAN Bit Timing Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is an alternative way to store the CAN bit timing variables
 * described in CAN_CTRL1 register. EPRESDIV, EPROPSEG, EPSEG1, EPSEG2 and ERJW are
 * extended versions of PRESDIV, PROPSEG, PSEG1, PSEG2 and RJW bit fields
 * respectively. The BTF bit selects the use of the timing variables defined in this
 * register. The contents of this register are not affected by soft reset. The CAN
 * bit variables in CAN_CTRL1 and in CAN_CBT are stored in the same register.
 */
/*!
 * @name Constants and macros for entire CAN_CBT register
 */
/*@{*/
#define CAN_RD_CBT(base)         (CAN_CBT_REG(base))
#define CAN_WR_CBT(base, value)  (CAN_CBT_REG(base) = (value))
#define CAN_RMW_CBT(base, mask, value) (CAN_WR_CBT(base, (CAN_RD_CBT(base) & ~(mask)) | (value)))
#define CAN_SET_CBT(base, value) (CAN_WR_CBT(base, CAN_RD_CBT(base) |  (value)))
#define CAN_CLR_CBT(base, value) (CAN_WR_CBT(base, CAN_RD_CBT(base) & ~(value)))
#define CAN_TOG_CBT(base, value) (CAN_WR_CBT(base, CAN_RD_CBT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CBT bitfields
 */

/*!
 * @name Register CAN_CBT, field EPSEG2[4:0] (RW)
 *
 * This 5-bit field defines the length of Phase Segment 2 in the bit time when
 * CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends the
 * CAN_CTRL1[PSEG2] value range. This field can be written only in Freeze mode because
 * it is blocked by hardware in other modes. Phase Buffer Segment 1 = (EPSEG2 +
 * 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPSEG2 field. */
#define CAN_RD_CBT_EPSEG2(base) ((CAN_CBT_REG(base) & CAN_CBT_EPSEG2_MASK) >> CAN_CBT_EPSEG2_SHIFT)
#define CAN_BRD_CBT_EPSEG2(base) (CAN_RD_CBT_EPSEG2(base))

/*! @brief Set the EPSEG2 field to a new value. */
#define CAN_WR_CBT_EPSEG2(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPSEG2_MASK, CAN_CBT_EPSEG2(value)))
#define CAN_BWR_CBT_EPSEG2(base, value) (CAN_WR_CBT_EPSEG2(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPSEG1[9:5] (RW)
 *
 * This 5-bit field defines the length of Phase Segment 1 in the bit time when
 * CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends the
 * CAN_CTRL1[PSEG1] value range. This field can be written only in Freeze mode because
 * it is blocked by hardware in other modes. Phase Buffer Segment 1 = (EPSEG1 +
 * 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPSEG1 field. */
#define CAN_RD_CBT_EPSEG1(base) ((CAN_CBT_REG(base) & CAN_CBT_EPSEG1_MASK) >> CAN_CBT_EPSEG1_SHIFT)
#define CAN_BRD_CBT_EPSEG1(base) (CAN_RD_CBT_EPSEG1(base))

/*! @brief Set the EPSEG1 field to a new value. */
#define CAN_WR_CBT_EPSEG1(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPSEG1_MASK, CAN_CBT_EPSEG1(value)))
#define CAN_BWR_CBT_EPSEG1(base, value) (CAN_WR_CBT_EPSEG1(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPROPSEG[15:10] (RW)
 *
 * This 6-bit field defines the length of the Propagation Segment in the bit
 * time when CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends
 * the CAN_CTRL1[PROPSEG] value range. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Propagation Segment Time =
 * (EPROPSEG + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPROPSEG field. */
#define CAN_RD_CBT_EPROPSEG(base) ((CAN_CBT_REG(base) & CAN_CBT_EPROPSEG_MASK) >> CAN_CBT_EPROPSEG_SHIFT)
#define CAN_BRD_CBT_EPROPSEG(base) (CAN_RD_CBT_EPROPSEG(base))

/*! @brief Set the EPROPSEG field to a new value. */
#define CAN_WR_CBT_EPROPSEG(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPROPSEG_MASK, CAN_CBT_EPROPSEG(value)))
#define CAN_BWR_CBT_EPROPSEG(base, value) (CAN_WR_CBT_EPROPSEG(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field ERJW[20:16] (RW)
 *
 * This 5-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization when CAN_CBT[BTF] bit is asserted,
 * otherwise it has no effect. It extends the CAN_CTRL1[RJW] value range. One time
 * quantum is equal to the Sclock period. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Resync Jump Width =
 * ERJW + 1.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_ERJW field. */
#define CAN_RD_CBT_ERJW(base) ((CAN_CBT_REG(base) & CAN_CBT_ERJW_MASK) >> CAN_CBT_ERJW_SHIFT)
#define CAN_BRD_CBT_ERJW(base) (CAN_RD_CBT_ERJW(base))

/*! @brief Set the ERJW field to a new value. */
#define CAN_WR_CBT_ERJW(base, value) (CAN_RMW_CBT(base, CAN_CBT_ERJW_MASK, CAN_CBT_ERJW(value)))
#define CAN_BWR_CBT_ERJW(base, value) (CAN_WR_CBT_ERJW(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPRESDIV[30:21] (RW)
 *
 * This 10-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency when CAN_CBT[BTF] bit is asserted, otherwise it
 * has no effect. It extends the CAN_CTRL1[PRESDIV] value range. The Sclock
 * period defines the time quantum of the CAN protocol. For the reset value, the
 * Sclock frequency is equal to the PE clock frequency (see Protocol timing). This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes. Sclock frequency = PE clock frequency / (EPRESDIV + 1)
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPRESDIV field. */
#define CAN_RD_CBT_EPRESDIV(base) ((CAN_CBT_REG(base) & CAN_CBT_EPRESDIV_MASK) >> CAN_CBT_EPRESDIV_SHIFT)
#define CAN_BRD_CBT_EPRESDIV(base) (CAN_RD_CBT_EPRESDIV(base))

/*! @brief Set the EPRESDIV field to a new value. */
#define CAN_WR_CBT_EPRESDIV(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPRESDIV_MASK, CAN_CBT_EPRESDIV(value)))
#define CAN_BWR_CBT_EPRESDIV(base, value) (CAN_WR_CBT_EPRESDIV(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field BTF[31] (RW)
 *
 * Enables the use of extended CAN bit timing fields EPRESDIV, EPROPSEG, EPSEG1,
 * EPSEG2 and ERJW replacing the CAN bit timing variables defined in CAN_CTRL1
 * register. This field can be written in Freeze mode only.
 *
 * Values:
 * - 0b0 - Extended bit time definitions disabled.
 * - 0b1 - Extended bit time definitions enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_BTF field. */
#define CAN_RD_CBT_BTF(base) ((CAN_CBT_REG(base) & CAN_CBT_BTF_MASK) >> CAN_CBT_BTF_SHIFT)
#define CAN_BRD_CBT_BTF(base) (BITBAND_ACCESS32(&CAN_CBT_REG(base), CAN_CBT_BTF_SHIFT))

/*! @brief Set the BTF field to a new value. */
#define CAN_WR_CBT_BTF(base, value) (CAN_RMW_CBT(base, CAN_CBT_BTF_MASK, CAN_CBT_BTF(value)))
#define CAN_BWR_CBT_BTF(base, value) (BITBAND_ACCESS32(&CAN_CBT_REG(base), CAN_CBT_BTF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_RXIMR - Rx Individual Mask Registers
 ******************************************************************************/

/*!
 * @brief CAN_RXIMR - Rx Individual Mask Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RX Individual Mask Registers are used to store the acceptance masks for
 * ID filtering in Rx MBs and the Rx FIFO. When the Rx FIFO is disabled
 * (CAN_MCR[RFEN] bit is negated), an individual mask is provided for each available Rx
 * Mailbox on a one-to-one correspondence. When the Rx FIFO is enabled
 * (CAN_MCR[RFEN] bit is asserted), an individual mask is provided for each Rx FIFO ID Filter
 * Table Element on a one-to-one correspondence depending on the setting of
 * CAN_CTRL2[RFFN] (see Rx FIFO). CAN_RXIMR0 stores the individual mask associated to
 * either MB0 or ID Filter Table Element 0, CAN_RXIMR1 stores the individual mask
 * associated to either MB1 or ID Filter Table Element 1 and so on. CAN_RXIMR
 * registers can only be accessed by the CPU while the module is in Freeze mode,
 * otherwise, they are blocked by hardware. These registers are not affected by
 * reset. They are located in RAM and must be explicitly initialized prior to any
 * reception.
 */
/*!
 * @name Constants and macros for entire CAN_RXIMR register
 */
/*@{*/
#define CAN_RD_RXIMR(base, index) (CAN_RXIMR_REG(base, index))
#define CAN_WR_RXIMR(base, index, value) (CAN_RXIMR_REG(base, index) = (value))
#define CAN_RMW_RXIMR(base, index, mask, value) (CAN_WR_RXIMR(base, index, (CAN_RD_RXIMR(base, index) & ~(mask)) | (value)))
#define CAN_SET_RXIMR(base, index, value) (CAN_WR_RXIMR(base, index, CAN_RD_RXIMR(base, index) |  (value)))
#define CAN_CLR_RXIMR(base, index, value) (CAN_WR_RXIMR(base, index, CAN_RD_RXIMR(base, index) & ~(value)))
#define CAN_TOG_RXIMR(base, index, value) (CAN_WR_RXIMR(base, index, CAN_RD_RXIMR(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_CTRL1_PN - Pretended Networking Control 1 Register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL1_PN - Pretended Networking Control 1 Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * This register contains control bits for Pretended Networking mode filtering
 * selection. Configure this register with the filter criteria to be used to
 * receive wake up messages. It can be written in Freeze mode only, except WTOF_MSK
 * and WUMF_MSK bits.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL1_PN register
 */
/*@{*/
#define CAN_RD_CTRL1_PN(base)    (CAN_CTRL1_PN_REG(base))
#define CAN_WR_CTRL1_PN(base, value) (CAN_CTRL1_PN_REG(base) = (value))
#define CAN_RMW_CTRL1_PN(base, mask, value) (CAN_WR_CTRL1_PN(base, (CAN_RD_CTRL1_PN(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL1_PN(base, value) (CAN_WR_CTRL1_PN(base, CAN_RD_CTRL1_PN(base) |  (value)))
#define CAN_CLR_CTRL1_PN(base, value) (CAN_WR_CTRL1_PN(base, CAN_RD_CTRL1_PN(base) & ~(value)))
#define CAN_TOG_CTRL1_PN(base, value) (CAN_WR_CTRL1_PN(base, CAN_RD_CTRL1_PN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL1_PN bitfields
 */

/*!
 * @name Register CAN_CTRL1_PN, field FCS[1:0] (RW)
 *
 * This 2-bit field selects the filtering criteria to be applied when FlexCAN is
 * under Pretended Networking mode. See Receive Process under Pretended
 * Networking Mode for more details.
 *
 * Values:
 * - 0b00 - Message ID filtering only
 * - 0b01 - Message ID filtering and payload filtering
 * - 0b10 - Message ID filtering occurring a specified number of times.
 * - 0b11 - Message ID filtering and payload filtering a specified number of
 *     times
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PN_FCS field. */
#define CAN_RD_CTRL1_PN_FCS(base) ((CAN_CTRL1_PN_REG(base) & CAN_CTRL1_PN_FCS_MASK) >> CAN_CTRL1_PN_FCS_SHIFT)
#define CAN_BRD_CTRL1_PN_FCS(base) (CAN_RD_CTRL1_PN_FCS(base))

/*! @brief Set the FCS field to a new value. */
#define CAN_WR_CTRL1_PN_FCS(base, value) (CAN_RMW_CTRL1_PN(base, CAN_CTRL1_PN_FCS_MASK, CAN_CTRL1_PN_FCS(value)))
#define CAN_BWR_CTRL1_PN_FCS(base, value) (CAN_WR_CTRL1_PN_FCS(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1_PN, field IDFS[3:2] (RW)
 *
 * This 2-bit field selects the level of ID filtering to be applied when FlexCAN
 * is under Pretended Networking mode. In ID filtering, the IDE and RTR bits are
 * also considered as part of reception filter if IDE_MSK and RTR_MSK bits inthe
 * CAN_FLT_ID2_IDMASK register are set.
 *
 * Values:
 * - 0b00 - Match upon a ID contents against an exact target value
 * - 0b01 - Match upon a ID value greater than or equal to a specified target
 *     value
 * - 0b10 - Match upon a ID value smaller than or equal to a specified target
 *     value
 * - 0b11 - Match upon a ID value inside a range, greater than or equal to a
 *     specified lower limit and smaller than or equal a specified upper limit
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PN_IDFS field. */
#define CAN_RD_CTRL1_PN_IDFS(base) ((CAN_CTRL1_PN_REG(base) & CAN_CTRL1_PN_IDFS_MASK) >> CAN_CTRL1_PN_IDFS_SHIFT)
#define CAN_BRD_CTRL1_PN_IDFS(base) (CAN_RD_CTRL1_PN_IDFS(base))

/*! @brief Set the IDFS field to a new value. */
#define CAN_WR_CTRL1_PN_IDFS(base, value) (CAN_RMW_CTRL1_PN(base, CAN_CTRL1_PN_IDFS_MASK, CAN_CTRL1_PN_IDFS(value)))
#define CAN_BWR_CTRL1_PN_IDFS(base, value) (CAN_WR_CTRL1_PN_IDFS(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1_PN, field PLFS[5:4] (RW)
 *
 * This 2-bit field selects the level of payload filtering to be applied when
 * FlexCAN is under Pretended Networking mode. Filtering does not accept remote
 * messages (RTR=1) when payload filtering is active.
 *
 * Values:
 * - 0b00 - Match upon a payload contents against an exact target value
 * - 0b01 - Match upon a payload value greater than or equal to a specified
 *     target value
 * - 0b10 - Match upon a payload value smaller than or equal to a specified
 *     target value
 * - 0b11 - Match upon a payload value inside a range, greater than or equal to
 *     a specified lower limit and smaller than or equal a specified upper limit
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PN_PLFS field. */
#define CAN_RD_CTRL1_PN_PLFS(base) ((CAN_CTRL1_PN_REG(base) & CAN_CTRL1_PN_PLFS_MASK) >> CAN_CTRL1_PN_PLFS_SHIFT)
#define CAN_BRD_CTRL1_PN_PLFS(base) (CAN_RD_CTRL1_PN_PLFS(base))

/*! @brief Set the PLFS field to a new value. */
#define CAN_WR_CTRL1_PN_PLFS(base, value) (CAN_RMW_CTRL1_PN(base, CAN_CTRL1_PN_PLFS_MASK, CAN_CTRL1_PN_PLFS(value)))
#define CAN_BWR_CTRL1_PN_PLFS(base, value) (CAN_WR_CTRL1_PN_PLFS(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1_PN, field NMATCH[15:8] (RW)
 *
 * This 8-bit field defines the number of times a given message must match the
 * predefined filtering criteria for ID and/or PL before generating a wake up
 * event. This quantity can be configured in the 1 to 255 range by using values from
 * 0x01 to 0xFF, respectively.
 *
 * Values:
 * - 0b00000001 - Received message must match the predefined filtering criteria
 *     for ID and/or PL once before generating a wake up event.
 * - 0b00000010 - Received message must match the predefined filtering criteria
 *     for ID and/or PL twice before generating a wake up event.
 * - 0b11111111 - Received message must match the predefined filtering criteria
 *     for ID and/or PL 255 times before generating a wake up event.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PN_NMATCH field. */
#define CAN_RD_CTRL1_PN_NMATCH(base) ((CAN_CTRL1_PN_REG(base) & CAN_CTRL1_PN_NMATCH_MASK) >> CAN_CTRL1_PN_NMATCH_SHIFT)
#define CAN_BRD_CTRL1_PN_NMATCH(base) (CAN_RD_CTRL1_PN_NMATCH(base))

/*! @brief Set the NMATCH field to a new value. */
#define CAN_WR_CTRL1_PN_NMATCH(base, value) (CAN_RMW_CTRL1_PN(base, CAN_CTRL1_PN_NMATCH_MASK, CAN_CTRL1_PN_NMATCH(value)))
#define CAN_BWR_CTRL1_PN_NMATCH(base, value) (CAN_WR_CTRL1_PN_NMATCH(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1_PN, field WUMF_MSK[16] (RW)
 *
 * This bit masks the generation of a wake up event originated by a successful
 * filtered Rx message.
 *
 * Values:
 * - 0b0 - Wake up match event is disabled
 * - 0b1 - Wake up match event is enabled
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PN_WUMF_MSK field. */
#define CAN_RD_CTRL1_PN_WUMF_MSK(base) ((CAN_CTRL1_PN_REG(base) & CAN_CTRL1_PN_WUMF_MSK_MASK) >> CAN_CTRL1_PN_WUMF_MSK_SHIFT)
#define CAN_BRD_CTRL1_PN_WUMF_MSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_PN_REG(base), CAN_CTRL1_PN_WUMF_MSK_SHIFT))

/*! @brief Set the WUMF_MSK field to a new value. */
#define CAN_WR_CTRL1_PN_WUMF_MSK(base, value) (CAN_RMW_CTRL1_PN(base, CAN_CTRL1_PN_WUMF_MSK_MASK, CAN_CTRL1_PN_WUMF_MSK(value)))
#define CAN_BWR_CTRL1_PN_WUMF_MSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_PN_REG(base), CAN_CTRL1_PN_WUMF_MSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1_PN, field WTOF_MSK[17] (RW)
 *
 * This bit masks the generation of a wake up event originated by a timeout.
 *
 * Values:
 * - 0b0 - Timeout wake up event is disabled
 * - 0b1 - Timeout wake up event is enabled
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PN_WTOF_MSK field. */
#define CAN_RD_CTRL1_PN_WTOF_MSK(base) ((CAN_CTRL1_PN_REG(base) & CAN_CTRL1_PN_WTOF_MSK_MASK) >> CAN_CTRL1_PN_WTOF_MSK_SHIFT)
#define CAN_BRD_CTRL1_PN_WTOF_MSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_PN_REG(base), CAN_CTRL1_PN_WTOF_MSK_SHIFT))

/*! @brief Set the WTOF_MSK field to a new value. */
#define CAN_WR_CTRL1_PN_WTOF_MSK(base, value) (CAN_RMW_CTRL1_PN(base, CAN_CTRL1_PN_WTOF_MSK_MASK, CAN_CTRL1_PN_WTOF_MSK(value)))
#define CAN_BWR_CTRL1_PN_WTOF_MSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_PN_REG(base), CAN_CTRL1_PN_WTOF_MSK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_CTRL2_PN - Pretended Networking Control 2 Register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL2_PN - Pretended Networking Control 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains configuration bits for the timeout value under
 * Pretended Networking mode. It can be written in Freeze mode only.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL2_PN register
 */
/*@{*/
#define CAN_RD_CTRL2_PN(base)    (CAN_CTRL2_PN_REG(base))
#define CAN_WR_CTRL2_PN(base, value) (CAN_CTRL2_PN_REG(base) = (value))
#define CAN_RMW_CTRL2_PN(base, mask, value) (CAN_WR_CTRL2_PN(base, (CAN_RD_CTRL2_PN(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL2_PN(base, value) (CAN_WR_CTRL2_PN(base, CAN_RD_CTRL2_PN(base) |  (value)))
#define CAN_CLR_CTRL2_PN(base, value) (CAN_WR_CTRL2_PN(base, CAN_RD_CTRL2_PN(base) & ~(value)))
#define CAN_TOG_CTRL2_PN(base, value) (CAN_WR_CTRL2_PN(base, CAN_RD_CTRL2_PN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL2_PN bitfields
 */

/*!
 * @name Register CAN_CTRL2_PN, field MATCHTO[15:0] (RW)
 *
 * This 16-bit field defines a timeout value that generates a wake up event if
 * CAN_MCR[PNET_EN] is asserted. If the timeout counter reaches the target value,
 * when FlexCAN is under Pretended Networking mode, then a wake up event is
 * generated. The timeout limit can be configured from 1 to 65535 to control an
 * internal 16-bit up-count timer to produce a trigger upon reaching this configured
 * value. The internal timer is incremented based on periodic time ticks, which
 * period is 64 times the CAN Bit Time unit. When MATCHTO is configured with 0x0000
 * the timeout is disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_PN_MATCHTO field. */
#define CAN_RD_CTRL2_PN_MATCHTO(base) ((CAN_CTRL2_PN_REG(base) & CAN_CTRL2_PN_MATCHTO_MASK) >> CAN_CTRL2_PN_MATCHTO_SHIFT)
#define CAN_BRD_CTRL2_PN_MATCHTO(base) (CAN_RD_CTRL2_PN_MATCHTO(base))

/*! @brief Set the MATCHTO field to a new value. */
#define CAN_WR_CTRL2_PN_MATCHTO(base, value) (CAN_RMW_CTRL2_PN(base, CAN_CTRL2_PN_MATCHTO_MASK, CAN_CTRL2_PN_MATCHTO(value)))
#define CAN_BWR_CTRL2_PN_MATCHTO(base, value) (CAN_WR_CTRL2_PN_MATCHTO(base, value))
/*@}*/

/*******************************************************************************
 * CAN_WU_MTC - Pretended Networking Wake Up Match Register
 ******************************************************************************/

/*!
 * @brief CAN_WU_MTC - Pretended Networking Wake Up Match Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This read-only register contains wake up information related to the matching
 * processes performed while FlexCAN receives frames under Pretended Networking
 * mode.
 */
/*!
 * @name Constants and macros for entire CAN_WU_MTC register
 */
/*@{*/
#define CAN_RD_WU_MTC(base)      (CAN_WU_MTC_REG(base))
#define CAN_WR_WU_MTC(base, value) (CAN_WU_MTC_REG(base) = (value))
#define CAN_RMW_WU_MTC(base, mask, value) (CAN_WR_WU_MTC(base, (CAN_RD_WU_MTC(base) & ~(mask)) | (value)))
#define CAN_SET_WU_MTC(base, value) (CAN_WR_WU_MTC(base, CAN_RD_WU_MTC(base) |  (value)))
#define CAN_CLR_WU_MTC(base, value) (CAN_WR_WU_MTC(base, CAN_RD_WU_MTC(base) & ~(value)))
#define CAN_TOG_WU_MTC(base, value) (CAN_WR_WU_MTC(base, CAN_RD_WU_MTC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_WU_MTC bitfields
 */

/*!
 * @name Register CAN_WU_MTC, field MCOUNTER[15:8] (RO)
 *
 * This 8-bit field reports the number of times a given message have been
 * matched the predefined filtering criteria for ID and/or PL before a wake up event.
 * This register is reset by FlexCAN when it enters in Pretended Networing mode,
 * and is not affected by soft reset.
 */
/*@{*/
/*! @brief Read current value of the CAN_WU_MTC_MCOUNTER field. */
#define CAN_RD_WU_MTC_MCOUNTER(base) ((CAN_WU_MTC_REG(base) & CAN_WU_MTC_MCOUNTER_MASK) >> CAN_WU_MTC_MCOUNTER_SHIFT)
#define CAN_BRD_WU_MTC_MCOUNTER(base) (CAN_RD_WU_MTC_MCOUNTER(base))
/*@}*/

/*!
 * @name Register CAN_WU_MTC, field WUMF[16] (W1C)
 *
 * This bit identifies whether the FlexCAN has detected a matching Rx incoming
 * message, which passed the filtering criteria specified in CAN_CTRL1_PN
 * register. This flag generates a wake up event if CAN_CTRL1_PN[WUMF_MSK] is enabled.
 *
 * Values:
 * - 0b0 - No wake up by match event detected
 * - 0b1 - Wake up by match event detected
 */
/*@{*/
/*! @brief Read current value of the CAN_WU_MTC_WUMF field. */
#define CAN_RD_WU_MTC_WUMF(base) ((CAN_WU_MTC_REG(base) & CAN_WU_MTC_WUMF_MASK) >> CAN_WU_MTC_WUMF_SHIFT)
#define CAN_BRD_WU_MTC_WUMF(base) (BITBAND_ACCESS32(&CAN_WU_MTC_REG(base), CAN_WU_MTC_WUMF_SHIFT))

/*! @brief Set the WUMF field to a new value. */
#define CAN_WR_WU_MTC_WUMF(base, value) (CAN_RMW_WU_MTC(base, (CAN_WU_MTC_WUMF_MASK | CAN_WU_MTC_WTOF_MASK), CAN_WU_MTC_WUMF(value)))
#define CAN_BWR_WU_MTC_WUMF(base, value) (BITBAND_ACCESS32(&CAN_WU_MTC_REG(base), CAN_WU_MTC_WUMF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_WU_MTC, field WTOF[17] (W1C)
 *
 * This bit identifies whether the FlexCAN has detected a timeout event during a
 * time interval defined by CAN_CTRL2_PN[MATCHTO]. This flag generates a wake up
 * event if CAN_CTRL1_PN[WTOF_MSK] is enabled.
 *
 * Values:
 * - 0b0 - No wake up by timeout event detected
 * - 0b1 - Wake up by timeout event detected
 */
/*@{*/
/*! @brief Read current value of the CAN_WU_MTC_WTOF field. */
#define CAN_RD_WU_MTC_WTOF(base) ((CAN_WU_MTC_REG(base) & CAN_WU_MTC_WTOF_MASK) >> CAN_WU_MTC_WTOF_SHIFT)
#define CAN_BRD_WU_MTC_WTOF(base) (BITBAND_ACCESS32(&CAN_WU_MTC_REG(base), CAN_WU_MTC_WTOF_SHIFT))

/*! @brief Set the WTOF field to a new value. */
#define CAN_WR_WU_MTC_WTOF(base, value) (CAN_RMW_WU_MTC(base, (CAN_WU_MTC_WTOF_MASK | CAN_WU_MTC_WUMF_MASK), CAN_WU_MTC_WTOF(value)))
#define CAN_BWR_WU_MTC_WTOF(base, value) (BITBAND_ACCESS32(&CAN_WU_MTC_REG(base), CAN_WU_MTC_WTOF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_FLT_ID1 - Pretended Networking ID Filter 1 Register
 ******************************************************************************/

/*!
 * @brief CAN_FLT_ID1 - Pretended Networking ID Filter 1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains FLT_ID1 target value, as well as, IDE and RTR target
 * values used to filter incoming message ID. The FLT_ID1 is used either for equal
 * to, smaller than, greater than comparisons, or as the lower limit value in a
 * ID range detection. It can be written in Freeze mode only.
 */
/*!
 * @name Constants and macros for entire CAN_FLT_ID1 register
 */
/*@{*/
#define CAN_RD_FLT_ID1(base)     (CAN_FLT_ID1_REG(base))
#define CAN_WR_FLT_ID1(base, value) (CAN_FLT_ID1_REG(base) = (value))
#define CAN_RMW_FLT_ID1(base, mask, value) (CAN_WR_FLT_ID1(base, (CAN_RD_FLT_ID1(base) & ~(mask)) | (value)))
#define CAN_SET_FLT_ID1(base, value) (CAN_WR_FLT_ID1(base, CAN_RD_FLT_ID1(base) |  (value)))
#define CAN_CLR_FLT_ID1(base, value) (CAN_WR_FLT_ID1(base, CAN_RD_FLT_ID1(base) & ~(value)))
#define CAN_TOG_FLT_ID1(base, value) (CAN_WR_FLT_ID1(base, CAN_RD_FLT_ID1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_FLT_ID1 bitfields
 */

/*!
 * @name Register CAN_FLT_ID1, field FLT_ID1[28:0] (RW)
 *
 * This 29-bit field defines either the 29 bits of a extended frame format,
 * considering all bits, or the 11 bits of a standard frame format, considering just
 * the 11 leftmost bits.
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_ID1_FLT_ID1 field. */
#define CAN_RD_FLT_ID1_FLT_ID1(base) ((CAN_FLT_ID1_REG(base) & CAN_FLT_ID1_FLT_ID1_MASK) >> CAN_FLT_ID1_FLT_ID1_SHIFT)
#define CAN_BRD_FLT_ID1_FLT_ID1(base) (CAN_RD_FLT_ID1_FLT_ID1(base))

/*! @brief Set the FLT_ID1 field to a new value. */
#define CAN_WR_FLT_ID1_FLT_ID1(base, value) (CAN_RMW_FLT_ID1(base, CAN_FLT_ID1_FLT_ID1_MASK, CAN_FLT_ID1_FLT_ID1(value)))
#define CAN_BWR_FLT_ID1_FLT_ID1(base, value) (CAN_WR_FLT_ID1_FLT_ID1(base, value))
/*@}*/

/*!
 * @name Register CAN_FLT_ID1, field FLT_RTR[29] (RW)
 *
 * This bit identifies whether the frame is remote or not. It is used as part of
 * the ID reception filter.
 *
 * Values:
 * - 0b0 - Reject remote frame (accept data frame)
 * - 0b1 - Accept remote frame
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_ID1_FLT_RTR field. */
#define CAN_RD_FLT_ID1_FLT_RTR(base) ((CAN_FLT_ID1_REG(base) & CAN_FLT_ID1_FLT_RTR_MASK) >> CAN_FLT_ID1_FLT_RTR_SHIFT)
#define CAN_BRD_FLT_ID1_FLT_RTR(base) (BITBAND_ACCESS32(&CAN_FLT_ID1_REG(base), CAN_FLT_ID1_FLT_RTR_SHIFT))

/*! @brief Set the FLT_RTR field to a new value. */
#define CAN_WR_FLT_ID1_FLT_RTR(base, value) (CAN_RMW_FLT_ID1(base, CAN_FLT_ID1_FLT_RTR_MASK, CAN_FLT_ID1_FLT_RTR(value)))
#define CAN_BWR_FLT_ID1_FLT_RTR(base, value) (BITBAND_ACCESS32(&CAN_FLT_ID1_REG(base), CAN_FLT_ID1_FLT_RTR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_FLT_ID1, field FLT_IDE[30] (RW)
 *
 * This bit identifies whether the frame format is standard or extended. It is
 * used as part of the ID reception filter.
 *
 * Values:
 * - 0b0 - Accept standard frame format
 * - 0b1 - Accept extended frame format
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_ID1_FLT_IDE field. */
#define CAN_RD_FLT_ID1_FLT_IDE(base) ((CAN_FLT_ID1_REG(base) & CAN_FLT_ID1_FLT_IDE_MASK) >> CAN_FLT_ID1_FLT_IDE_SHIFT)
#define CAN_BRD_FLT_ID1_FLT_IDE(base) (BITBAND_ACCESS32(&CAN_FLT_ID1_REG(base), CAN_FLT_ID1_FLT_IDE_SHIFT))

/*! @brief Set the FLT_IDE field to a new value. */
#define CAN_WR_FLT_ID1_FLT_IDE(base, value) (CAN_RMW_FLT_ID1(base, CAN_FLT_ID1_FLT_IDE_MASK, CAN_FLT_ID1_FLT_IDE(value)))
#define CAN_BWR_FLT_ID1_FLT_IDE(base, value) (BITBAND_ACCESS32(&CAN_FLT_ID1_REG(base), CAN_FLT_ID1_FLT_IDE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_FLT_DLC - Pretended Networking DLC Filter Register
 ******************************************************************************/

/*!
 * @brief CAN_FLT_DLC - Pretended Networking DLC Filter Register (RW)
 *
 * Reset value: 0x00000008U
 *
 * This register contains the DLC inside range target values (FLT_DLC_LO and
 * FLT_DLC_HI) used to filter incoming message. The DLC range is used only for
 * payload filtering. It can be written in Freeze mode only. When a fixed quantity of
 * data bytes is required, both FLT_DLC_LO and FLT_DLC_HI need to be configured
 * with the same value, otherwise a range of DLC is considered for filtering (see
 * Receive Process under Pretended Networking Mode).
 */
/*!
 * @name Constants and macros for entire CAN_FLT_DLC register
 */
/*@{*/
#define CAN_RD_FLT_DLC(base)     (CAN_FLT_DLC_REG(base))
#define CAN_WR_FLT_DLC(base, value) (CAN_FLT_DLC_REG(base) = (value))
#define CAN_RMW_FLT_DLC(base, mask, value) (CAN_WR_FLT_DLC(base, (CAN_RD_FLT_DLC(base) & ~(mask)) | (value)))
#define CAN_SET_FLT_DLC(base, value) (CAN_WR_FLT_DLC(base, CAN_RD_FLT_DLC(base) |  (value)))
#define CAN_CLR_FLT_DLC(base, value) (CAN_WR_FLT_DLC(base, CAN_RD_FLT_DLC(base) & ~(value)))
#define CAN_TOG_FLT_DLC(base, value) (CAN_WR_FLT_DLC(base, CAN_RD_FLT_DLC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_FLT_DLC bitfields
 */

/*!
 * @name Register CAN_FLT_DLC, field FLT_DLC_HI[3:0] (RW)
 *
 * This field specifies the upper limit for the number of data bytes considered
 * valid for payload comparison. It is used as part of payload reception filter.
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_DLC_FLT_DLC_HI field. */
#define CAN_RD_FLT_DLC_FLT_DLC_HI(base) ((CAN_FLT_DLC_REG(base) & CAN_FLT_DLC_FLT_DLC_HI_MASK) >> CAN_FLT_DLC_FLT_DLC_HI_SHIFT)
#define CAN_BRD_FLT_DLC_FLT_DLC_HI(base) (CAN_RD_FLT_DLC_FLT_DLC_HI(base))

/*! @brief Set the FLT_DLC_HI field to a new value. */
#define CAN_WR_FLT_DLC_FLT_DLC_HI(base, value) (CAN_RMW_FLT_DLC(base, CAN_FLT_DLC_FLT_DLC_HI_MASK, CAN_FLT_DLC_FLT_DLC_HI(value)))
#define CAN_BWR_FLT_DLC_FLT_DLC_HI(base, value) (CAN_WR_FLT_DLC_FLT_DLC_HI(base, value))
/*@}*/

/*!
 * @name Register CAN_FLT_DLC, field FLT_DLC_LO[19:16] (RW)
 *
 * This field specifies the lower limit for the number of data bytes considered
 * valid for payload comparison. It is used as part of payload reception filter.
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_DLC_FLT_DLC_LO field. */
#define CAN_RD_FLT_DLC_FLT_DLC_LO(base) ((CAN_FLT_DLC_REG(base) & CAN_FLT_DLC_FLT_DLC_LO_MASK) >> CAN_FLT_DLC_FLT_DLC_LO_SHIFT)
#define CAN_BRD_FLT_DLC_FLT_DLC_LO(base) (CAN_RD_FLT_DLC_FLT_DLC_LO(base))

/*! @brief Set the FLT_DLC_LO field to a new value. */
#define CAN_WR_FLT_DLC_FLT_DLC_LO(base, value) (CAN_RMW_FLT_DLC(base, CAN_FLT_DLC_FLT_DLC_LO_MASK, CAN_FLT_DLC_FLT_DLC_LO(value)))
#define CAN_BWR_FLT_DLC_FLT_DLC_LO(base, value) (CAN_WR_FLT_DLC_FLT_DLC_LO(base, value))
/*@}*/

/*******************************************************************************
 * CAN_PL1_LO - Pretended Networking Payload Low Filter 1 Register
 ******************************************************************************/

/*!
 * @brief CAN_PL1_LO - Pretended Networking Payload Low Filter 1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains Payload Filter 1 low order bits of the target value
 * used to filter incoming message payload. It is used either for "equal to",
 * "smaller than or equal", "greater than or equal" comparisons, or as the lower limit
 * value in a payload range detection. It can be written in Freeze mode only.
 */
/*!
 * @name Constants and macros for entire CAN_PL1_LO register
 */
/*@{*/
#define CAN_RD_PL1_LO(base)      (CAN_PL1_LO_REG(base))
#define CAN_WR_PL1_LO(base, value) (CAN_PL1_LO_REG(base) = (value))
#define CAN_RMW_PL1_LO(base, mask, value) (CAN_WR_PL1_LO(base, (CAN_RD_PL1_LO(base) & ~(mask)) | (value)))
#define CAN_SET_PL1_LO(base, value) (CAN_WR_PL1_LO(base, CAN_RD_PL1_LO(base) |  (value)))
#define CAN_CLR_PL1_LO(base, value) (CAN_WR_PL1_LO(base, CAN_RD_PL1_LO(base) & ~(value)))
#define CAN_TOG_PL1_LO(base, value) (CAN_WR_PL1_LO(base, CAN_RD_PL1_LO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_PL1_LO bitfields
 */

/*!
 * @name Register CAN_PL1_LO, field Data_byte_3[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_LO_Data_byte_3 field. */
#define CAN_RD_PL1_LO_Data_byte_3(base) ((CAN_PL1_LO_REG(base) & CAN_PL1_LO_Data_byte_3_MASK) >> CAN_PL1_LO_Data_byte_3_SHIFT)
#define CAN_BRD_PL1_LO_Data_byte_3(base) (CAN_RD_PL1_LO_Data_byte_3(base))

/*! @brief Set the Data_byte_3 field to a new value. */
#define CAN_WR_PL1_LO_Data_byte_3(base, value) (CAN_RMW_PL1_LO(base, CAN_PL1_LO_Data_byte_3_MASK, CAN_PL1_LO_Data_byte_3(value)))
#define CAN_BWR_PL1_LO_Data_byte_3(base, value) (CAN_WR_PL1_LO_Data_byte_3(base, value))
/*@}*/

/*!
 * @name Register CAN_PL1_LO, field Data_byte_2[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_LO_Data_byte_2 field. */
#define CAN_RD_PL1_LO_Data_byte_2(base) ((CAN_PL1_LO_REG(base) & CAN_PL1_LO_Data_byte_2_MASK) >> CAN_PL1_LO_Data_byte_2_SHIFT)
#define CAN_BRD_PL1_LO_Data_byte_2(base) (CAN_RD_PL1_LO_Data_byte_2(base))

/*! @brief Set the Data_byte_2 field to a new value. */
#define CAN_WR_PL1_LO_Data_byte_2(base, value) (CAN_RMW_PL1_LO(base, CAN_PL1_LO_Data_byte_2_MASK, CAN_PL1_LO_Data_byte_2(value)))
#define CAN_BWR_PL1_LO_Data_byte_2(base, value) (CAN_WR_PL1_LO_Data_byte_2(base, value))
/*@}*/

/*!
 * @name Register CAN_PL1_LO, field Data_byte_1[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_LO_Data_byte_1 field. */
#define CAN_RD_PL1_LO_Data_byte_1(base) ((CAN_PL1_LO_REG(base) & CAN_PL1_LO_Data_byte_1_MASK) >> CAN_PL1_LO_Data_byte_1_SHIFT)
#define CAN_BRD_PL1_LO_Data_byte_1(base) (CAN_RD_PL1_LO_Data_byte_1(base))

/*! @brief Set the Data_byte_1 field to a new value. */
#define CAN_WR_PL1_LO_Data_byte_1(base, value) (CAN_RMW_PL1_LO(base, CAN_PL1_LO_Data_byte_1_MASK, CAN_PL1_LO_Data_byte_1(value)))
#define CAN_BWR_PL1_LO_Data_byte_1(base, value) (CAN_WR_PL1_LO_Data_byte_1(base, value))
/*@}*/

/*!
 * @name Register CAN_PL1_LO, field Data_byte_0[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_LO_Data_byte_0 field. */
#define CAN_RD_PL1_LO_Data_byte_0(base) ((CAN_PL1_LO_REG(base) & CAN_PL1_LO_Data_byte_0_MASK) >> CAN_PL1_LO_Data_byte_0_SHIFT)
#define CAN_BRD_PL1_LO_Data_byte_0(base) (CAN_RD_PL1_LO_Data_byte_0(base))

/*! @brief Set the Data_byte_0 field to a new value. */
#define CAN_WR_PL1_LO_Data_byte_0(base, value) (CAN_RMW_PL1_LO(base, CAN_PL1_LO_Data_byte_0_MASK, CAN_PL1_LO_Data_byte_0(value)))
#define CAN_BWR_PL1_LO_Data_byte_0(base, value) (CAN_WR_PL1_LO_Data_byte_0(base, value))
/*@}*/

/*******************************************************************************
 * CAN_PL1_HI - Pretended Networking Payload High Filter 1 Register
 ******************************************************************************/

/*!
 * @brief CAN_PL1_HI - Pretended Networking Payload High Filter 1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains Payload Filter 1 high order bits of the target value
 * used to filter incoming message payload. It is used either for "equal to",
 * "smaller than or equal to", "greater than or equal to" comparisons, or as the
 * lower limit value in a payload range detection. It can be written in Freeze mode
 * only.
 */
/*!
 * @name Constants and macros for entire CAN_PL1_HI register
 */
/*@{*/
#define CAN_RD_PL1_HI(base)      (CAN_PL1_HI_REG(base))
#define CAN_WR_PL1_HI(base, value) (CAN_PL1_HI_REG(base) = (value))
#define CAN_RMW_PL1_HI(base, mask, value) (CAN_WR_PL1_HI(base, (CAN_RD_PL1_HI(base) & ~(mask)) | (value)))
#define CAN_SET_PL1_HI(base, value) (CAN_WR_PL1_HI(base, CAN_RD_PL1_HI(base) |  (value)))
#define CAN_CLR_PL1_HI(base, value) (CAN_WR_PL1_HI(base, CAN_RD_PL1_HI(base) & ~(value)))
#define CAN_TOG_PL1_HI(base, value) (CAN_WR_PL1_HI(base, CAN_RD_PL1_HI(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_PL1_HI bitfields
 */

/*!
 * @name Register CAN_PL1_HI, field Data_byte_7[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_HI_Data_byte_7 field. */
#define CAN_RD_PL1_HI_Data_byte_7(base) ((CAN_PL1_HI_REG(base) & CAN_PL1_HI_Data_byte_7_MASK) >> CAN_PL1_HI_Data_byte_7_SHIFT)
#define CAN_BRD_PL1_HI_Data_byte_7(base) (CAN_RD_PL1_HI_Data_byte_7(base))

/*! @brief Set the Data_byte_7 field to a new value. */
#define CAN_WR_PL1_HI_Data_byte_7(base, value) (CAN_RMW_PL1_HI(base, CAN_PL1_HI_Data_byte_7_MASK, CAN_PL1_HI_Data_byte_7(value)))
#define CAN_BWR_PL1_HI_Data_byte_7(base, value) (CAN_WR_PL1_HI_Data_byte_7(base, value))
/*@}*/

/*!
 * @name Register CAN_PL1_HI, field Data_byte_6[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_HI_Data_byte_6 field. */
#define CAN_RD_PL1_HI_Data_byte_6(base) ((CAN_PL1_HI_REG(base) & CAN_PL1_HI_Data_byte_6_MASK) >> CAN_PL1_HI_Data_byte_6_SHIFT)
#define CAN_BRD_PL1_HI_Data_byte_6(base) (CAN_RD_PL1_HI_Data_byte_6(base))

/*! @brief Set the Data_byte_6 field to a new value. */
#define CAN_WR_PL1_HI_Data_byte_6(base, value) (CAN_RMW_PL1_HI(base, CAN_PL1_HI_Data_byte_6_MASK, CAN_PL1_HI_Data_byte_6(value)))
#define CAN_BWR_PL1_HI_Data_byte_6(base, value) (CAN_WR_PL1_HI_Data_byte_6(base, value))
/*@}*/

/*!
 * @name Register CAN_PL1_HI, field Data_byte_5[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_HI_Data_byte_5 field. */
#define CAN_RD_PL1_HI_Data_byte_5(base) ((CAN_PL1_HI_REG(base) & CAN_PL1_HI_Data_byte_5_MASK) >> CAN_PL1_HI_Data_byte_5_SHIFT)
#define CAN_BRD_PL1_HI_Data_byte_5(base) (CAN_RD_PL1_HI_Data_byte_5(base))

/*! @brief Set the Data_byte_5 field to a new value. */
#define CAN_WR_PL1_HI_Data_byte_5(base, value) (CAN_RMW_PL1_HI(base, CAN_PL1_HI_Data_byte_5_MASK, CAN_PL1_HI_Data_byte_5(value)))
#define CAN_BWR_PL1_HI_Data_byte_5(base, value) (CAN_WR_PL1_HI_Data_byte_5(base, value))
/*@}*/

/*!
 * @name Register CAN_PL1_HI, field Data_byte_4[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL1_HI_Data_byte_4 field. */
#define CAN_RD_PL1_HI_Data_byte_4(base) ((CAN_PL1_HI_REG(base) & CAN_PL1_HI_Data_byte_4_MASK) >> CAN_PL1_HI_Data_byte_4_SHIFT)
#define CAN_BRD_PL1_HI_Data_byte_4(base) (CAN_RD_PL1_HI_Data_byte_4(base))

/*! @brief Set the Data_byte_4 field to a new value. */
#define CAN_WR_PL1_HI_Data_byte_4(base, value) (CAN_RMW_PL1_HI(base, CAN_PL1_HI_Data_byte_4_MASK, CAN_PL1_HI_Data_byte_4(value)))
#define CAN_BWR_PL1_HI_Data_byte_4(base, value) (CAN_WR_PL1_HI_Data_byte_4(base, value))
/*@}*/

/*******************************************************************************
 * CAN_FLT_ID2_IDMASK - Pretended Networking ID Filter 2 Register / ID Mask Register
 ******************************************************************************/

/*!
 * @brief CAN_FLT_ID2_IDMASK - Pretended Networking ID Filter 2 Register / ID Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains FLT_ID2 target value used only as the upper limit
 * value in ID range detection. Also, when exact ID filtering criteria is selected,
 * this register is used to store the ID mask. IDE_MSK and RTR_MSK bits are used
 * in both ID filtering (exact and range) to enable FLT_IDE and FLT_RTR
 * respectively to be used as part of ID reception filter. This register can be written in
 * Freeze mode only.
 */
/*!
 * @name Constants and macros for entire CAN_FLT_ID2_IDMASK register
 */
/*@{*/
#define CAN_RD_FLT_ID2_IDMASK(base) (CAN_FLT_ID2_IDMASK_REG(base))
#define CAN_WR_FLT_ID2_IDMASK(base, value) (CAN_FLT_ID2_IDMASK_REG(base) = (value))
#define CAN_RMW_FLT_ID2_IDMASK(base, mask, value) (CAN_WR_FLT_ID2_IDMASK(base, (CAN_RD_FLT_ID2_IDMASK(base) & ~(mask)) | (value)))
#define CAN_SET_FLT_ID2_IDMASK(base, value) (CAN_WR_FLT_ID2_IDMASK(base, CAN_RD_FLT_ID2_IDMASK(base) |  (value)))
#define CAN_CLR_FLT_ID2_IDMASK(base, value) (CAN_WR_FLT_ID2_IDMASK(base, CAN_RD_FLT_ID2_IDMASK(base) & ~(value)))
#define CAN_TOG_FLT_ID2_IDMASK(base, value) (CAN_WR_FLT_ID2_IDMASK(base, CAN_RD_FLT_ID2_IDMASK(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_FLT_ID2_IDMASK bitfields
 */

/*!
 * @name Register CAN_FLT_ID2_IDMASK, field FLT_ID2_IDMASK[28:0] (RW)
 *
 * This register is used to define either the ID filter value in extended frame
 * format (29 bits), considering the FLT_ID2[28:0], or the ID filter value in
 * standard frame format (11 bits), considering the FLT_ID2[28:18] (other bits in
 * the [17:0] range have no meaning). Used only in range of ID filtering. It can
 * also be used to define either the mask values for the extended frame format (29
 * bits), considering the IDMASK[28:0], or for the standard frame format (11
 * bits), considering the IDMASK[28:18] (other bits in the [17:0] range have no
 * meaning). Used only in exact ID filtering.
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK field. */
#define CAN_RD_FLT_ID2_IDMASK_FLT_ID2_IDMASK(base) ((CAN_FLT_ID2_IDMASK_REG(base) & CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_MASK) >> CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_SHIFT)
#define CAN_BRD_FLT_ID2_IDMASK_FLT_ID2_IDMASK(base) (CAN_RD_FLT_ID2_IDMASK_FLT_ID2_IDMASK(base))

/*! @brief Set the FLT_ID2_IDMASK field to a new value. */
#define CAN_WR_FLT_ID2_IDMASK_FLT_ID2_IDMASK(base, value) (CAN_RMW_FLT_ID2_IDMASK(base, CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_MASK, CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK(value)))
#define CAN_BWR_FLT_ID2_IDMASK_FLT_ID2_IDMASK(base, value) (CAN_WR_FLT_ID2_IDMASK_FLT_ID2_IDMASK(base, value))
/*@}*/

/*!
 * @name Register CAN_FLT_ID2_IDMASK, field RTR_MSK[29] (RW)
 *
 * This bit indicates whether the frame type (data / remote) is part of the ID
 * reception filter.
 *
 * Values:
 * - 0b0 - The corresponding bit in the filter is "don't care"
 * - 0b1 - The corresponding bit in the filter is checked
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_ID2_IDMASK_RTR_MSK field. */
#define CAN_RD_FLT_ID2_IDMASK_RTR_MSK(base) ((CAN_FLT_ID2_IDMASK_REG(base) & CAN_FLT_ID2_IDMASK_RTR_MSK_MASK) >> CAN_FLT_ID2_IDMASK_RTR_MSK_SHIFT)
#define CAN_BRD_FLT_ID2_IDMASK_RTR_MSK(base) (BITBAND_ACCESS32(&CAN_FLT_ID2_IDMASK_REG(base), CAN_FLT_ID2_IDMASK_RTR_MSK_SHIFT))

/*! @brief Set the RTR_MSK field to a new value. */
#define CAN_WR_FLT_ID2_IDMASK_RTR_MSK(base, value) (CAN_RMW_FLT_ID2_IDMASK(base, CAN_FLT_ID2_IDMASK_RTR_MSK_MASK, CAN_FLT_ID2_IDMASK_RTR_MSK(value)))
#define CAN_BWR_FLT_ID2_IDMASK_RTR_MSK(base, value) (BITBAND_ACCESS32(&CAN_FLT_ID2_IDMASK_REG(base), CAN_FLT_ID2_IDMASK_RTR_MSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_FLT_ID2_IDMASK, field IDE_MSK[30] (RW)
 *
 * This bit indicates whether the frame format (standard / extended) is used as
 * part of the ID reception filter.
 *
 * Values:
 * - 0b0 - The corresponding bit in the filter is "don't care"
 * - 0b1 - The corresponding bit in the filter is checked
 */
/*@{*/
/*! @brief Read current value of the CAN_FLT_ID2_IDMASK_IDE_MSK field. */
#define CAN_RD_FLT_ID2_IDMASK_IDE_MSK(base) ((CAN_FLT_ID2_IDMASK_REG(base) & CAN_FLT_ID2_IDMASK_IDE_MSK_MASK) >> CAN_FLT_ID2_IDMASK_IDE_MSK_SHIFT)
#define CAN_BRD_FLT_ID2_IDMASK_IDE_MSK(base) (BITBAND_ACCESS32(&CAN_FLT_ID2_IDMASK_REG(base), CAN_FLT_ID2_IDMASK_IDE_MSK_SHIFT))

/*! @brief Set the IDE_MSK field to a new value. */
#define CAN_WR_FLT_ID2_IDMASK_IDE_MSK(base, value) (CAN_RMW_FLT_ID2_IDMASK(base, CAN_FLT_ID2_IDMASK_IDE_MSK_MASK, CAN_FLT_ID2_IDMASK_IDE_MSK(value)))
#define CAN_BWR_FLT_ID2_IDMASK_IDE_MSK(base, value) (BITBAND_ACCESS32(&CAN_FLT_ID2_IDMASK_REG(base), CAN_FLT_ID2_IDMASK_IDE_MSK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_PL2_PLMASK_LO - Pretended Networking Payload Low Filter 2 Register / Payload Low Mask Register
 ******************************************************************************/

/*!
 * @brief CAN_PL2_PLMASK_LO - Pretended Networking Payload Low Filter 2 Register / Payload Low Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has two functions. First, it contains the low order bits for
 * the Payload Filter 2 used only as the upper limit value in a payload range
 * detection. Second, when exact payload filtering criteria is selected, this register
 * is used as payload mask. Otherwise, this register is unused. It can be
 * written in Freeze mode only.
 */
/*!
 * @name Constants and macros for entire CAN_PL2_PLMASK_LO register
 */
/*@{*/
#define CAN_RD_PL2_PLMASK_LO(base) (CAN_PL2_PLMASK_LO_REG(base))
#define CAN_WR_PL2_PLMASK_LO(base, value) (CAN_PL2_PLMASK_LO_REG(base) = (value))
#define CAN_RMW_PL2_PLMASK_LO(base, mask, value) (CAN_WR_PL2_PLMASK_LO(base, (CAN_RD_PL2_PLMASK_LO(base) & ~(mask)) | (value)))
#define CAN_SET_PL2_PLMASK_LO(base, value) (CAN_WR_PL2_PLMASK_LO(base, CAN_RD_PL2_PLMASK_LO(base) |  (value)))
#define CAN_CLR_PL2_PLMASK_LO(base, value) (CAN_WR_PL2_PLMASK_LO(base, CAN_RD_PL2_PLMASK_LO(base) & ~(value)))
#define CAN_TOG_PL2_PLMASK_LO(base, value) (CAN_WR_PL2_PLMASK_LO(base, CAN_RD_PL2_PLMASK_LO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_PL2_PLMASK_LO bitfields
 */

/*!
 * @name Register CAN_PL2_PLMASK_LO, field Data_byte_3[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_LO_Data_byte_3 field. */
#define CAN_RD_PL2_PLMASK_LO_Data_byte_3(base) ((CAN_PL2_PLMASK_LO_REG(base) & CAN_PL2_PLMASK_LO_Data_byte_3_MASK) >> CAN_PL2_PLMASK_LO_Data_byte_3_SHIFT)
#define CAN_BRD_PL2_PLMASK_LO_Data_byte_3(base) (CAN_RD_PL2_PLMASK_LO_Data_byte_3(base))

/*! @brief Set the Data_byte_3 field to a new value. */
#define CAN_WR_PL2_PLMASK_LO_Data_byte_3(base, value) (CAN_RMW_PL2_PLMASK_LO(base, CAN_PL2_PLMASK_LO_Data_byte_3_MASK, CAN_PL2_PLMASK_LO_Data_byte_3(value)))
#define CAN_BWR_PL2_PLMASK_LO_Data_byte_3(base, value) (CAN_WR_PL2_PLMASK_LO_Data_byte_3(base, value))
/*@}*/

/*!
 * @name Register CAN_PL2_PLMASK_LO, field Data_byte_2[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_LO_Data_byte_2 field. */
#define CAN_RD_PL2_PLMASK_LO_Data_byte_2(base) ((CAN_PL2_PLMASK_LO_REG(base) & CAN_PL2_PLMASK_LO_Data_byte_2_MASK) >> CAN_PL2_PLMASK_LO_Data_byte_2_SHIFT)
#define CAN_BRD_PL2_PLMASK_LO_Data_byte_2(base) (CAN_RD_PL2_PLMASK_LO_Data_byte_2(base))

/*! @brief Set the Data_byte_2 field to a new value. */
#define CAN_WR_PL2_PLMASK_LO_Data_byte_2(base, value) (CAN_RMW_PL2_PLMASK_LO(base, CAN_PL2_PLMASK_LO_Data_byte_2_MASK, CAN_PL2_PLMASK_LO_Data_byte_2(value)))
#define CAN_BWR_PL2_PLMASK_LO_Data_byte_2(base, value) (CAN_WR_PL2_PLMASK_LO_Data_byte_2(base, value))
/*@}*/

/*!
 * @name Register CAN_PL2_PLMASK_LO, field Data_byte_1[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_LO_Data_byte_1 field. */
#define CAN_RD_PL2_PLMASK_LO_Data_byte_1(base) ((CAN_PL2_PLMASK_LO_REG(base) & CAN_PL2_PLMASK_LO_Data_byte_1_MASK) >> CAN_PL2_PLMASK_LO_Data_byte_1_SHIFT)
#define CAN_BRD_PL2_PLMASK_LO_Data_byte_1(base) (CAN_RD_PL2_PLMASK_LO_Data_byte_1(base))

/*! @brief Set the Data_byte_1 field to a new value. */
#define CAN_WR_PL2_PLMASK_LO_Data_byte_1(base, value) (CAN_RMW_PL2_PLMASK_LO(base, CAN_PL2_PLMASK_LO_Data_byte_1_MASK, CAN_PL2_PLMASK_LO_Data_byte_1(value)))
#define CAN_BWR_PL2_PLMASK_LO_Data_byte_1(base, value) (CAN_WR_PL2_PLMASK_LO_Data_byte_1(base, value))
/*@}*/

/*!
 * @name Register CAN_PL2_PLMASK_LO, field Data_byte_0[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_LO_Data_byte_0 field. */
#define CAN_RD_PL2_PLMASK_LO_Data_byte_0(base) ((CAN_PL2_PLMASK_LO_REG(base) & CAN_PL2_PLMASK_LO_Data_byte_0_MASK) >> CAN_PL2_PLMASK_LO_Data_byte_0_SHIFT)
#define CAN_BRD_PL2_PLMASK_LO_Data_byte_0(base) (CAN_RD_PL2_PLMASK_LO_Data_byte_0(base))

/*! @brief Set the Data_byte_0 field to a new value. */
#define CAN_WR_PL2_PLMASK_LO_Data_byte_0(base, value) (CAN_RMW_PL2_PLMASK_LO(base, CAN_PL2_PLMASK_LO_Data_byte_0_MASK, CAN_PL2_PLMASK_LO_Data_byte_0(value)))
#define CAN_BWR_PL2_PLMASK_LO_Data_byte_0(base, value) (CAN_WR_PL2_PLMASK_LO_Data_byte_0(base, value))
/*@}*/

/*******************************************************************************
 * CAN_PL2_PLMASK_HI - Pretended Networking Payload High Filter 2 low order bits / Payload High Mask Register
 ******************************************************************************/

/*!
 * @brief CAN_PL2_PLMASK_HI - Pretended Networking Payload High Filter 2 low order bits / Payload High Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has two functions. First, it contains the high order bits for
 * the Payload Filter 2 used only as the upper limit value in a payload range
 * detection. Second, when exact payload filtering criteria is selected, this
 * register is used as payload mask. Otherwise, this register is unused. It can be
 * written in Freeze mode only.
 */
/*!
 * @name Constants and macros for entire CAN_PL2_PLMASK_HI register
 */
/*@{*/
#define CAN_RD_PL2_PLMASK_HI(base) (CAN_PL2_PLMASK_HI_REG(base))
#define CAN_WR_PL2_PLMASK_HI(base, value) (CAN_PL2_PLMASK_HI_REG(base) = (value))
#define CAN_RMW_PL2_PLMASK_HI(base, mask, value) (CAN_WR_PL2_PLMASK_HI(base, (CAN_RD_PL2_PLMASK_HI(base) & ~(mask)) | (value)))
#define CAN_SET_PL2_PLMASK_HI(base, value) (CAN_WR_PL2_PLMASK_HI(base, CAN_RD_PL2_PLMASK_HI(base) |  (value)))
#define CAN_CLR_PL2_PLMASK_HI(base, value) (CAN_WR_PL2_PLMASK_HI(base, CAN_RD_PL2_PLMASK_HI(base) & ~(value)))
#define CAN_TOG_PL2_PLMASK_HI(base, value) (CAN_WR_PL2_PLMASK_HI(base, CAN_RD_PL2_PLMASK_HI(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_PL2_PLMASK_HI bitfields
 */

/*!
 * @name Register CAN_PL2_PLMASK_HI, field Data_byte_7[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_HI_Data_byte_7 field. */
#define CAN_RD_PL2_PLMASK_HI_Data_byte_7(base) ((CAN_PL2_PLMASK_HI_REG(base) & CAN_PL2_PLMASK_HI_Data_byte_7_MASK) >> CAN_PL2_PLMASK_HI_Data_byte_7_SHIFT)
#define CAN_BRD_PL2_PLMASK_HI_Data_byte_7(base) (CAN_RD_PL2_PLMASK_HI_Data_byte_7(base))

/*! @brief Set the Data_byte_7 field to a new value. */
#define CAN_WR_PL2_PLMASK_HI_Data_byte_7(base, value) (CAN_RMW_PL2_PLMASK_HI(base, CAN_PL2_PLMASK_HI_Data_byte_7_MASK, CAN_PL2_PLMASK_HI_Data_byte_7(value)))
#define CAN_BWR_PL2_PLMASK_HI_Data_byte_7(base, value) (CAN_WR_PL2_PLMASK_HI_Data_byte_7(base, value))
/*@}*/

/*!
 * @name Register CAN_PL2_PLMASK_HI, field Data_byte_6[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_HI_Data_byte_6 field. */
#define CAN_RD_PL2_PLMASK_HI_Data_byte_6(base) ((CAN_PL2_PLMASK_HI_REG(base) & CAN_PL2_PLMASK_HI_Data_byte_6_MASK) >> CAN_PL2_PLMASK_HI_Data_byte_6_SHIFT)
#define CAN_BRD_PL2_PLMASK_HI_Data_byte_6(base) (CAN_RD_PL2_PLMASK_HI_Data_byte_6(base))

/*! @brief Set the Data_byte_6 field to a new value. */
#define CAN_WR_PL2_PLMASK_HI_Data_byte_6(base, value) (CAN_RMW_PL2_PLMASK_HI(base, CAN_PL2_PLMASK_HI_Data_byte_6_MASK, CAN_PL2_PLMASK_HI_Data_byte_6(value)))
#define CAN_BWR_PL2_PLMASK_HI_Data_byte_6(base, value) (CAN_WR_PL2_PLMASK_HI_Data_byte_6(base, value))
/*@}*/

/*!
 * @name Register CAN_PL2_PLMASK_HI, field Data_byte_5[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_HI_Data_byte_5 field. */
#define CAN_RD_PL2_PLMASK_HI_Data_byte_5(base) ((CAN_PL2_PLMASK_HI_REG(base) & CAN_PL2_PLMASK_HI_Data_byte_5_MASK) >> CAN_PL2_PLMASK_HI_Data_byte_5_SHIFT)
#define CAN_BRD_PL2_PLMASK_HI_Data_byte_5(base) (CAN_RD_PL2_PLMASK_HI_Data_byte_5(base))

/*! @brief Set the Data_byte_5 field to a new value. */
#define CAN_WR_PL2_PLMASK_HI_Data_byte_5(base, value) (CAN_RMW_PL2_PLMASK_HI(base, CAN_PL2_PLMASK_HI_Data_byte_5_MASK, CAN_PL2_PLMASK_HI_Data_byte_5(value)))
#define CAN_BWR_PL2_PLMASK_HI_Data_byte_5(base, value) (CAN_WR_PL2_PLMASK_HI_Data_byte_5(base, value))
/*@}*/

/*!
 * @name Register CAN_PL2_PLMASK_HI, field Data_byte_4[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_PL2_PLMASK_HI_Data_byte_4 field. */
#define CAN_RD_PL2_PLMASK_HI_Data_byte_4(base) ((CAN_PL2_PLMASK_HI_REG(base) & CAN_PL2_PLMASK_HI_Data_byte_4_MASK) >> CAN_PL2_PLMASK_HI_Data_byte_4_SHIFT)
#define CAN_BRD_PL2_PLMASK_HI_Data_byte_4(base) (CAN_RD_PL2_PLMASK_HI_Data_byte_4(base))

/*! @brief Set the Data_byte_4 field to a new value. */
#define CAN_WR_PL2_PLMASK_HI_Data_byte_4(base, value) (CAN_RMW_PL2_PLMASK_HI(base, CAN_PL2_PLMASK_HI_Data_byte_4_MASK, CAN_PL2_PLMASK_HI_Data_byte_4(value)))
#define CAN_BWR_PL2_PLMASK_HI_Data_byte_4(base, value) (CAN_WR_PL2_PLMASK_HI_Data_byte_4(base, value))
/*@}*/

/*******************************************************************************
 * CAN_WMB0_CS - Wake Up Message Buffer Register for C/S
 ******************************************************************************/

/*!
 * @brief CAN_WMB0_CS - Wake Up Message Buffer Register for C/S (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the Control Status (C/S)
 * information (IDE, RTR and DLC fields) of an incoming Rx message. The C/S
 * registers are located at 0xB40 for WMB0, 0xB50 for WMB1, 0xB60 for WMB2, and 0xB70
 * for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB0_CS register
 */
/*@{*/
#define CAN_RD_WMB0_CS(base)     (CAN_WMB0_CS_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB0_CS bitfields
 */

/*!
 * @name Register CAN_WMB0_CS, field DLC[19:16] (RO)
 *
 * This 4-bit field is the length (in bytes) of the Rx data received when
 * FlexCAN is in Pretended Networking mode. This 4-bit field is written by the FlexCAN
 * module, copied from the DLC (Data Length Code) field of the received frame.
 * The DLC field indicates which data bytes are valid.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_CS_DLC field. */
#define CAN_RD_WMB0_CS_DLC(base) ((CAN_WMB0_CS_REG(base) & CAN_WMB0_CS_DLC_MASK) >> CAN_WMB0_CS_DLC_SHIFT)
#define CAN_BRD_WMB0_CS_DLC(base) (CAN_RD_WMB0_CS_DLC(base))
/*@}*/

/*!
 * @name Register CAN_WMB0_CS, field RTR[20] (RO)
 *
 * This bit identifies whether the frame is remote or not.
 *
 * Values:
 * - 0b0 - Frame is data one (not remote)
 * - 0b1 - Frame is a remote one
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_CS_RTR field. */
#define CAN_RD_WMB0_CS_RTR(base) ((CAN_WMB0_CS_REG(base) & CAN_WMB0_CS_RTR_MASK) >> CAN_WMB0_CS_RTR_SHIFT)
#define CAN_BRD_WMB0_CS_RTR(base) (BITBAND_ACCESS32(&CAN_WMB0_CS_REG(base), CAN_WMB0_CS_RTR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB0_CS, field IDE[21] (RO)
 *
 * This bit identifies whether the frame format is standard or extended
 *
 * Values:
 * - 0b0 - Frame format is standard
 * - 0b1 - Frame format is extended
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_CS_IDE field. */
#define CAN_RD_WMB0_CS_IDE(base) ((CAN_WMB0_CS_REG(base) & CAN_WMB0_CS_IDE_MASK) >> CAN_WMB0_CS_IDE_SHIFT)
#define CAN_BRD_WMB0_CS_IDE(base) (BITBAND_ACCESS32(&CAN_WMB0_CS_REG(base), CAN_WMB0_CS_IDE_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB0_CS, field SRR[22] (RO)
 *
 * This bit can be received either recessive or dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_CS_SRR field. */
#define CAN_RD_WMB0_CS_SRR(base) ((CAN_WMB0_CS_REG(base) & CAN_WMB0_CS_SRR_MASK) >> CAN_WMB0_CS_SRR_SHIFT)
#define CAN_BRD_WMB0_CS_SRR(base) (BITBAND_ACCESS32(&CAN_WMB0_CS_REG(base), CAN_WMB0_CS_SRR_SHIFT))
/*@}*/

/*******************************************************************************
 * CAN_WMB0_ID - Wake Up Message Buffer Register for ID
 ******************************************************************************/

/*!
 * @brief CAN_WMB0_ID - Wake Up Message Buffer Register for ID (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the ID information of an
 * incoming Rx message. The ID registers are located at 0xB44 for WMB0, 0xB54 for
 * WMB1, 0xB64 for WMB2, and 0xB74 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB0_ID register
 */
/*@{*/
#define CAN_RD_WMB0_ID(base)     (CAN_WMB0_ID_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB0_ID bitfields
 */

/*!
 * @name Register CAN_WMB0_ID, field ID[28:0] (RO)
 *
 * This register stores either the 29 bits of the extended frame format
 * (considering the ID[28:0] field), or the 11 bits of the standard frame format
 * (considering the ID[28:18] field only, the remaining bits in the ID[17:0] range have
 * no meaning).
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_ID_ID field. */
#define CAN_RD_WMB0_ID_ID(base) ((CAN_WMB0_ID_REG(base) & CAN_WMB0_ID_ID_MASK) >> CAN_WMB0_ID_ID_SHIFT)
#define CAN_BRD_WMB0_ID_ID(base) (CAN_RD_WMB0_ID_ID(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB0_D03 - Wake Up Message Buffer Register for Data 0-3
 ******************************************************************************/

/*!
 * @brief CAN_WMB0_D03 - Wake Up Message Buffer Register for Data 0-3 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 0 to 3 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 0-3 registers are located at 0xB48 for WMB0,
 * 0xB58 for WMB1, 0xB68 for WMB2, and 0xB78 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB0_D03 register
 */
/*@{*/
#define CAN_RD_WMB0_D03(base)    (CAN_WMB0_D03_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB0_D03 bitfields
 */

/*!
 * @name Register CAN_WMB0_D03, field Data_byte_3[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D03_Data_byte_3 field. */
#define CAN_RD_WMB0_D03_Data_byte_3(base) ((CAN_WMB0_D03_REG(base) & CAN_WMB0_D03_Data_byte_3_MASK) >> CAN_WMB0_D03_Data_byte_3_SHIFT)
#define CAN_BRD_WMB0_D03_Data_byte_3(base) (CAN_RD_WMB0_D03_Data_byte_3(base))
/*@}*/

/*!
 * @name Register CAN_WMB0_D03, field Data_byte_2[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D03_Data_byte_2 field. */
#define CAN_RD_WMB0_D03_Data_byte_2(base) ((CAN_WMB0_D03_REG(base) & CAN_WMB0_D03_Data_byte_2_MASK) >> CAN_WMB0_D03_Data_byte_2_SHIFT)
#define CAN_BRD_WMB0_D03_Data_byte_2(base) (CAN_RD_WMB0_D03_Data_byte_2(base))
/*@}*/

/*!
 * @name Register CAN_WMB0_D03, field Data_byte_1[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D03_Data_byte_1 field. */
#define CAN_RD_WMB0_D03_Data_byte_1(base) ((CAN_WMB0_D03_REG(base) & CAN_WMB0_D03_Data_byte_1_MASK) >> CAN_WMB0_D03_Data_byte_1_SHIFT)
#define CAN_BRD_WMB0_D03_Data_byte_1(base) (CAN_RD_WMB0_D03_Data_byte_1(base))
/*@}*/

/*!
 * @name Register CAN_WMB0_D03, field Data_byte_0[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D03_Data_byte_0 field. */
#define CAN_RD_WMB0_D03_Data_byte_0(base) ((CAN_WMB0_D03_REG(base) & CAN_WMB0_D03_Data_byte_0_MASK) >> CAN_WMB0_D03_Data_byte_0_SHIFT)
#define CAN_BRD_WMB0_D03_Data_byte_0(base) (CAN_RD_WMB0_D03_Data_byte_0(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB0_D47 - Wake Up Message Buffer Register Data 4-7
 ******************************************************************************/

/*!
 * @brief CAN_WMB0_D47 - Wake Up Message Buffer Register Data 4-7 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 4 to 7 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 4-7 registers are located at 0xB4C for WMB0,
 * 0xB5C for WMB1, 0xB6C for WMB2, and 0xB7C for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB0_D47 register
 */
/*@{*/
#define CAN_RD_WMB0_D47(base)    (CAN_WMB0_D47_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB0_D47 bitfields
 */

/*!
 * @name Register CAN_WMB0_D47, field Data_byte_7[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D47_Data_byte_7 field. */
#define CAN_RD_WMB0_D47_Data_byte_7(base) ((CAN_WMB0_D47_REG(base) & CAN_WMB0_D47_Data_byte_7_MASK) >> CAN_WMB0_D47_Data_byte_7_SHIFT)
#define CAN_BRD_WMB0_D47_Data_byte_7(base) (CAN_RD_WMB0_D47_Data_byte_7(base))
/*@}*/

/*!
 * @name Register CAN_WMB0_D47, field Data_byte_6[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D47_Data_byte_6 field. */
#define CAN_RD_WMB0_D47_Data_byte_6(base) ((CAN_WMB0_D47_REG(base) & CAN_WMB0_D47_Data_byte_6_MASK) >> CAN_WMB0_D47_Data_byte_6_SHIFT)
#define CAN_BRD_WMB0_D47_Data_byte_6(base) (CAN_RD_WMB0_D47_Data_byte_6(base))
/*@}*/

/*!
 * @name Register CAN_WMB0_D47, field Data_byte_5[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D47_Data_byte_5 field. */
#define CAN_RD_WMB0_D47_Data_byte_5(base) ((CAN_WMB0_D47_REG(base) & CAN_WMB0_D47_Data_byte_5_MASK) >> CAN_WMB0_D47_Data_byte_5_SHIFT)
#define CAN_BRD_WMB0_D47_Data_byte_5(base) (CAN_RD_WMB0_D47_Data_byte_5(base))
/*@}*/

/*!
 * @name Register CAN_WMB0_D47, field Data_byte_4[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB0_D47_Data_byte_4 field. */
#define CAN_RD_WMB0_D47_Data_byte_4(base) ((CAN_WMB0_D47_REG(base) & CAN_WMB0_D47_Data_byte_4_MASK) >> CAN_WMB0_D47_Data_byte_4_SHIFT)
#define CAN_BRD_WMB0_D47_Data_byte_4(base) (CAN_RD_WMB0_D47_Data_byte_4(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB1_CS - Wake Up Message Buffer Register for C/S
 ******************************************************************************/

/*!
 * @brief CAN_WMB1_CS - Wake Up Message Buffer Register for C/S (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the Control Status (C/S)
 * information (IDE, RTR and DLC fields) of an incoming Rx message. The C/S
 * registers are located at 0xB40 for WMB0, 0xB50 for WMB1, 0xB60 for WMB2, and 0xB70
 * for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB1_CS register
 */
/*@{*/
#define CAN_RD_WMB1_CS(base)     (CAN_WMB1_CS_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB1_CS bitfields
 */

/*!
 * @name Register CAN_WMB1_CS, field DLC[19:16] (RO)
 *
 * This 4-bit field is the length (in bytes) of the Rx data received when
 * FlexCAN is in Pretended Networking mode. This 4-bit field is written by the FlexCAN
 * module, copied from the DLC (Data Length Code) field of the received frame.
 * The DLC field indicates which data bytes are valid.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_CS_DLC field. */
#define CAN_RD_WMB1_CS_DLC(base) ((CAN_WMB1_CS_REG(base) & CAN_WMB1_CS_DLC_MASK) >> CAN_WMB1_CS_DLC_SHIFT)
#define CAN_BRD_WMB1_CS_DLC(base) (CAN_RD_WMB1_CS_DLC(base))
/*@}*/

/*!
 * @name Register CAN_WMB1_CS, field RTR[20] (RO)
 *
 * This bit identifies whether the frame is remote or not.
 *
 * Values:
 * - 0b0 - Frame is data one (not remote)
 * - 0b1 - Frame is a remote one
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_CS_RTR field. */
#define CAN_RD_WMB1_CS_RTR(base) ((CAN_WMB1_CS_REG(base) & CAN_WMB1_CS_RTR_MASK) >> CAN_WMB1_CS_RTR_SHIFT)
#define CAN_BRD_WMB1_CS_RTR(base) (BITBAND_ACCESS32(&CAN_WMB1_CS_REG(base), CAN_WMB1_CS_RTR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB1_CS, field IDE[21] (RO)
 *
 * This bit identifies whether the frame format is standard or extended
 *
 * Values:
 * - 0b0 - Frame format is standard
 * - 0b1 - Frame format is extended
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_CS_IDE field. */
#define CAN_RD_WMB1_CS_IDE(base) ((CAN_WMB1_CS_REG(base) & CAN_WMB1_CS_IDE_MASK) >> CAN_WMB1_CS_IDE_SHIFT)
#define CAN_BRD_WMB1_CS_IDE(base) (BITBAND_ACCESS32(&CAN_WMB1_CS_REG(base), CAN_WMB1_CS_IDE_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB1_CS, field SRR[22] (RO)
 *
 * This bit can be received either recessive or dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_CS_SRR field. */
#define CAN_RD_WMB1_CS_SRR(base) ((CAN_WMB1_CS_REG(base) & CAN_WMB1_CS_SRR_MASK) >> CAN_WMB1_CS_SRR_SHIFT)
#define CAN_BRD_WMB1_CS_SRR(base) (BITBAND_ACCESS32(&CAN_WMB1_CS_REG(base), CAN_WMB1_CS_SRR_SHIFT))
/*@}*/

/*******************************************************************************
 * CAN_WMB1_ID - Wake Up Message Buffer Register for ID
 ******************************************************************************/

/*!
 * @brief CAN_WMB1_ID - Wake Up Message Buffer Register for ID (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the ID information of an
 * incoming Rx message. The ID registers are located at 0xB44 for WMB0, 0xB54 for
 * WMB1, 0xB64 for WMB2, and 0xB74 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB1_ID register
 */
/*@{*/
#define CAN_RD_WMB1_ID(base)     (CAN_WMB1_ID_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB1_ID bitfields
 */

/*!
 * @name Register CAN_WMB1_ID, field ID[28:0] (RO)
 *
 * This register stores either the 29 bits of the extended frame format
 * (considering the ID[28:0] field), or the 11 bits of the standard frame format
 * (considering the ID[28:18] field only, the remaining bits in the ID[17:0] range have
 * no meaning).
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_ID_ID field. */
#define CAN_RD_WMB1_ID_ID(base) ((CAN_WMB1_ID_REG(base) & CAN_WMB1_ID_ID_MASK) >> CAN_WMB1_ID_ID_SHIFT)
#define CAN_BRD_WMB1_ID_ID(base) (CAN_RD_WMB1_ID_ID(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB1_D03 - Wake Up Message Buffer Register for Data 0-3
 ******************************************************************************/

/*!
 * @brief CAN_WMB1_D03 - Wake Up Message Buffer Register for Data 0-3 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 0 to 3 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 0-3 registers are located at 0xB48 for WMB0,
 * 0xB58 for WMB1, 0xB68 for WMB2, and 0xB78 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB1_D03 register
 */
/*@{*/
#define CAN_RD_WMB1_D03(base)    (CAN_WMB1_D03_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB1_D03 bitfields
 */

/*!
 * @name Register CAN_WMB1_D03, field Data_byte_3[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D03_Data_byte_3 field. */
#define CAN_RD_WMB1_D03_Data_byte_3(base) ((CAN_WMB1_D03_REG(base) & CAN_WMB1_D03_Data_byte_3_MASK) >> CAN_WMB1_D03_Data_byte_3_SHIFT)
#define CAN_BRD_WMB1_D03_Data_byte_3(base) (CAN_RD_WMB1_D03_Data_byte_3(base))
/*@}*/

/*!
 * @name Register CAN_WMB1_D03, field Data_byte_2[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D03_Data_byte_2 field. */
#define CAN_RD_WMB1_D03_Data_byte_2(base) ((CAN_WMB1_D03_REG(base) & CAN_WMB1_D03_Data_byte_2_MASK) >> CAN_WMB1_D03_Data_byte_2_SHIFT)
#define CAN_BRD_WMB1_D03_Data_byte_2(base) (CAN_RD_WMB1_D03_Data_byte_2(base))
/*@}*/

/*!
 * @name Register CAN_WMB1_D03, field Data_byte_1[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D03_Data_byte_1 field. */
#define CAN_RD_WMB1_D03_Data_byte_1(base) ((CAN_WMB1_D03_REG(base) & CAN_WMB1_D03_Data_byte_1_MASK) >> CAN_WMB1_D03_Data_byte_1_SHIFT)
#define CAN_BRD_WMB1_D03_Data_byte_1(base) (CAN_RD_WMB1_D03_Data_byte_1(base))
/*@}*/

/*!
 * @name Register CAN_WMB1_D03, field Data_byte_0[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D03_Data_byte_0 field. */
#define CAN_RD_WMB1_D03_Data_byte_0(base) ((CAN_WMB1_D03_REG(base) & CAN_WMB1_D03_Data_byte_0_MASK) >> CAN_WMB1_D03_Data_byte_0_SHIFT)
#define CAN_BRD_WMB1_D03_Data_byte_0(base) (CAN_RD_WMB1_D03_Data_byte_0(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB1_D47 - Wake Up Message Buffer Register Data 4-7
 ******************************************************************************/

/*!
 * @brief CAN_WMB1_D47 - Wake Up Message Buffer Register Data 4-7 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 4 to 7 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 4-7 registers are located at 0xB4C for WMB0,
 * 0xB5C for WMB1, 0xB6C for WMB2, and 0xB7C for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB1_D47 register
 */
/*@{*/
#define CAN_RD_WMB1_D47(base)    (CAN_WMB1_D47_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB1_D47 bitfields
 */

/*!
 * @name Register CAN_WMB1_D47, field Data_byte_7[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D47_Data_byte_7 field. */
#define CAN_RD_WMB1_D47_Data_byte_7(base) ((CAN_WMB1_D47_REG(base) & CAN_WMB1_D47_Data_byte_7_MASK) >> CAN_WMB1_D47_Data_byte_7_SHIFT)
#define CAN_BRD_WMB1_D47_Data_byte_7(base) (CAN_RD_WMB1_D47_Data_byte_7(base))
/*@}*/

/*!
 * @name Register CAN_WMB1_D47, field Data_byte_6[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D47_Data_byte_6 field. */
#define CAN_RD_WMB1_D47_Data_byte_6(base) ((CAN_WMB1_D47_REG(base) & CAN_WMB1_D47_Data_byte_6_MASK) >> CAN_WMB1_D47_Data_byte_6_SHIFT)
#define CAN_BRD_WMB1_D47_Data_byte_6(base) (CAN_RD_WMB1_D47_Data_byte_6(base))
/*@}*/

/*!
 * @name Register CAN_WMB1_D47, field Data_byte_5[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D47_Data_byte_5 field. */
#define CAN_RD_WMB1_D47_Data_byte_5(base) ((CAN_WMB1_D47_REG(base) & CAN_WMB1_D47_Data_byte_5_MASK) >> CAN_WMB1_D47_Data_byte_5_SHIFT)
#define CAN_BRD_WMB1_D47_Data_byte_5(base) (CAN_RD_WMB1_D47_Data_byte_5(base))
/*@}*/

/*!
 * @name Register CAN_WMB1_D47, field Data_byte_4[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB1_D47_Data_byte_4 field. */
#define CAN_RD_WMB1_D47_Data_byte_4(base) ((CAN_WMB1_D47_REG(base) & CAN_WMB1_D47_Data_byte_4_MASK) >> CAN_WMB1_D47_Data_byte_4_SHIFT)
#define CAN_BRD_WMB1_D47_Data_byte_4(base) (CAN_RD_WMB1_D47_Data_byte_4(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB2_CS - Wake Up Message Buffer Register for C/S
 ******************************************************************************/

/*!
 * @brief CAN_WMB2_CS - Wake Up Message Buffer Register for C/S (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the Control Status (C/S)
 * information (IDE, RTR and DLC fields) of an incoming Rx message. The C/S
 * registers are located at 0xB40 for WMB0, 0xB50 for WMB1, 0xB60 for WMB2, and 0xB70
 * for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB2_CS register
 */
/*@{*/
#define CAN_RD_WMB2_CS(base)     (CAN_WMB2_CS_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB2_CS bitfields
 */

/*!
 * @name Register CAN_WMB2_CS, field DLC[19:16] (RO)
 *
 * This 4-bit field is the length (in bytes) of the Rx data received when
 * FlexCAN is in Pretended Networking mode. This 4-bit field is written by the FlexCAN
 * module, copied from the DLC (Data Length Code) field of the received frame.
 * The DLC field indicates which data bytes are valid.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_CS_DLC field. */
#define CAN_RD_WMB2_CS_DLC(base) ((CAN_WMB2_CS_REG(base) & CAN_WMB2_CS_DLC_MASK) >> CAN_WMB2_CS_DLC_SHIFT)
#define CAN_BRD_WMB2_CS_DLC(base) (CAN_RD_WMB2_CS_DLC(base))
/*@}*/

/*!
 * @name Register CAN_WMB2_CS, field RTR[20] (RO)
 *
 * This bit identifies whether the frame is remote or not.
 *
 * Values:
 * - 0b0 - Frame is data one (not remote)
 * - 0b1 - Frame is a remote one
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_CS_RTR field. */
#define CAN_RD_WMB2_CS_RTR(base) ((CAN_WMB2_CS_REG(base) & CAN_WMB2_CS_RTR_MASK) >> CAN_WMB2_CS_RTR_SHIFT)
#define CAN_BRD_WMB2_CS_RTR(base) (BITBAND_ACCESS32(&CAN_WMB2_CS_REG(base), CAN_WMB2_CS_RTR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB2_CS, field IDE[21] (RO)
 *
 * This bit identifies whether the frame format is standard or extended
 *
 * Values:
 * - 0b0 - Frame format is standard
 * - 0b1 - Frame format is extended
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_CS_IDE field. */
#define CAN_RD_WMB2_CS_IDE(base) ((CAN_WMB2_CS_REG(base) & CAN_WMB2_CS_IDE_MASK) >> CAN_WMB2_CS_IDE_SHIFT)
#define CAN_BRD_WMB2_CS_IDE(base) (BITBAND_ACCESS32(&CAN_WMB2_CS_REG(base), CAN_WMB2_CS_IDE_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB2_CS, field SRR[22] (RO)
 *
 * This bit can be received either recessive or dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_CS_SRR field. */
#define CAN_RD_WMB2_CS_SRR(base) ((CAN_WMB2_CS_REG(base) & CAN_WMB2_CS_SRR_MASK) >> CAN_WMB2_CS_SRR_SHIFT)
#define CAN_BRD_WMB2_CS_SRR(base) (BITBAND_ACCESS32(&CAN_WMB2_CS_REG(base), CAN_WMB2_CS_SRR_SHIFT))
/*@}*/

/*******************************************************************************
 * CAN_WMB2_ID - Wake Up Message Buffer Register for ID
 ******************************************************************************/

/*!
 * @brief CAN_WMB2_ID - Wake Up Message Buffer Register for ID (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the ID information of an
 * incoming Rx message. The ID registers are located at 0xB44 for WMB0, 0xB54 for
 * WMB1, 0xB64 for WMB2, and 0xB74 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB2_ID register
 */
/*@{*/
#define CAN_RD_WMB2_ID(base)     (CAN_WMB2_ID_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB2_ID bitfields
 */

/*!
 * @name Register CAN_WMB2_ID, field ID[28:0] (RO)
 *
 * This register stores either the 29 bits of the extended frame format
 * (considering the ID[28:0] field), or the 11 bits of the standard frame format
 * (considering the ID[28:18] field only, the remaining bits in the ID[17:0] range have
 * no meaning).
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_ID_ID field. */
#define CAN_RD_WMB2_ID_ID(base) ((CAN_WMB2_ID_REG(base) & CAN_WMB2_ID_ID_MASK) >> CAN_WMB2_ID_ID_SHIFT)
#define CAN_BRD_WMB2_ID_ID(base) (CAN_RD_WMB2_ID_ID(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB2_D03 - Wake Up Message Buffer Register for Data 0-3
 ******************************************************************************/

/*!
 * @brief CAN_WMB2_D03 - Wake Up Message Buffer Register for Data 0-3 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 0 to 3 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 0-3 registers are located at 0xB48 for WMB0,
 * 0xB58 for WMB1, 0xB68 for WMB2, and 0xB78 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB2_D03 register
 */
/*@{*/
#define CAN_RD_WMB2_D03(base)    (CAN_WMB2_D03_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB2_D03 bitfields
 */

/*!
 * @name Register CAN_WMB2_D03, field Data_byte_3[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D03_Data_byte_3 field. */
#define CAN_RD_WMB2_D03_Data_byte_3(base) ((CAN_WMB2_D03_REG(base) & CAN_WMB2_D03_Data_byte_3_MASK) >> CAN_WMB2_D03_Data_byte_3_SHIFT)
#define CAN_BRD_WMB2_D03_Data_byte_3(base) (CAN_RD_WMB2_D03_Data_byte_3(base))
/*@}*/

/*!
 * @name Register CAN_WMB2_D03, field Data_byte_2[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D03_Data_byte_2 field. */
#define CAN_RD_WMB2_D03_Data_byte_2(base) ((CAN_WMB2_D03_REG(base) & CAN_WMB2_D03_Data_byte_2_MASK) >> CAN_WMB2_D03_Data_byte_2_SHIFT)
#define CAN_BRD_WMB2_D03_Data_byte_2(base) (CAN_RD_WMB2_D03_Data_byte_2(base))
/*@}*/

/*!
 * @name Register CAN_WMB2_D03, field Data_byte_1[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D03_Data_byte_1 field. */
#define CAN_RD_WMB2_D03_Data_byte_1(base) ((CAN_WMB2_D03_REG(base) & CAN_WMB2_D03_Data_byte_1_MASK) >> CAN_WMB2_D03_Data_byte_1_SHIFT)
#define CAN_BRD_WMB2_D03_Data_byte_1(base) (CAN_RD_WMB2_D03_Data_byte_1(base))
/*@}*/

/*!
 * @name Register CAN_WMB2_D03, field Data_byte_0[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D03_Data_byte_0 field. */
#define CAN_RD_WMB2_D03_Data_byte_0(base) ((CAN_WMB2_D03_REG(base) & CAN_WMB2_D03_Data_byte_0_MASK) >> CAN_WMB2_D03_Data_byte_0_SHIFT)
#define CAN_BRD_WMB2_D03_Data_byte_0(base) (CAN_RD_WMB2_D03_Data_byte_0(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB2_D47 - Wake Up Message Buffer Register Data 4-7
 ******************************************************************************/

/*!
 * @brief CAN_WMB2_D47 - Wake Up Message Buffer Register Data 4-7 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 4 to 7 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 4-7 registers are located at 0xB4C for WMB0,
 * 0xB5C for WMB1, 0xB6C for WMB2, and 0xB7C for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB2_D47 register
 */
/*@{*/
#define CAN_RD_WMB2_D47(base)    (CAN_WMB2_D47_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB2_D47 bitfields
 */

/*!
 * @name Register CAN_WMB2_D47, field Data_byte_7[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D47_Data_byte_7 field. */
#define CAN_RD_WMB2_D47_Data_byte_7(base) ((CAN_WMB2_D47_REG(base) & CAN_WMB2_D47_Data_byte_7_MASK) >> CAN_WMB2_D47_Data_byte_7_SHIFT)
#define CAN_BRD_WMB2_D47_Data_byte_7(base) (CAN_RD_WMB2_D47_Data_byte_7(base))
/*@}*/

/*!
 * @name Register CAN_WMB2_D47, field Data_byte_6[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D47_Data_byte_6 field. */
#define CAN_RD_WMB2_D47_Data_byte_6(base) ((CAN_WMB2_D47_REG(base) & CAN_WMB2_D47_Data_byte_6_MASK) >> CAN_WMB2_D47_Data_byte_6_SHIFT)
#define CAN_BRD_WMB2_D47_Data_byte_6(base) (CAN_RD_WMB2_D47_Data_byte_6(base))
/*@}*/

/*!
 * @name Register CAN_WMB2_D47, field Data_byte_5[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D47_Data_byte_5 field. */
#define CAN_RD_WMB2_D47_Data_byte_5(base) ((CAN_WMB2_D47_REG(base) & CAN_WMB2_D47_Data_byte_5_MASK) >> CAN_WMB2_D47_Data_byte_5_SHIFT)
#define CAN_BRD_WMB2_D47_Data_byte_5(base) (CAN_RD_WMB2_D47_Data_byte_5(base))
/*@}*/

/*!
 * @name Register CAN_WMB2_D47, field Data_byte_4[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB2_D47_Data_byte_4 field. */
#define CAN_RD_WMB2_D47_Data_byte_4(base) ((CAN_WMB2_D47_REG(base) & CAN_WMB2_D47_Data_byte_4_MASK) >> CAN_WMB2_D47_Data_byte_4_SHIFT)
#define CAN_BRD_WMB2_D47_Data_byte_4(base) (CAN_RD_WMB2_D47_Data_byte_4(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB3_CS - Wake Up Message Buffer Register for C/S
 ******************************************************************************/

/*!
 * @brief CAN_WMB3_CS - Wake Up Message Buffer Register for C/S (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the Control Status (C/S)
 * information (IDE, RTR and DLC fields) of an incoming Rx message. The C/S
 * registers are located at 0xB40 for WMB0, 0xB50 for WMB1, 0xB60 for WMB2, and 0xB70
 * for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB3_CS register
 */
/*@{*/
#define CAN_RD_WMB3_CS(base)     (CAN_WMB3_CS_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB3_CS bitfields
 */

/*!
 * @name Register CAN_WMB3_CS, field DLC[19:16] (RO)
 *
 * This 4-bit field is the length (in bytes) of the Rx data received when
 * FlexCAN is in Pretended Networking mode. This 4-bit field is written by the FlexCAN
 * module, copied from the DLC (Data Length Code) field of the received frame.
 * The DLC field indicates which data bytes are valid.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_CS_DLC field. */
#define CAN_RD_WMB3_CS_DLC(base) ((CAN_WMB3_CS_REG(base) & CAN_WMB3_CS_DLC_MASK) >> CAN_WMB3_CS_DLC_SHIFT)
#define CAN_BRD_WMB3_CS_DLC(base) (CAN_RD_WMB3_CS_DLC(base))
/*@}*/

/*!
 * @name Register CAN_WMB3_CS, field RTR[20] (RO)
 *
 * This bit identifies whether the frame is remote or not.
 *
 * Values:
 * - 0b0 - Frame is data one (not remote)
 * - 0b1 - Frame is a remote one
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_CS_RTR field. */
#define CAN_RD_WMB3_CS_RTR(base) ((CAN_WMB3_CS_REG(base) & CAN_WMB3_CS_RTR_MASK) >> CAN_WMB3_CS_RTR_SHIFT)
#define CAN_BRD_WMB3_CS_RTR(base) (BITBAND_ACCESS32(&CAN_WMB3_CS_REG(base), CAN_WMB3_CS_RTR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB3_CS, field IDE[21] (RO)
 *
 * This bit identifies whether the frame format is standard or extended
 *
 * Values:
 * - 0b0 - Frame format is standard
 * - 0b1 - Frame format is extended
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_CS_IDE field. */
#define CAN_RD_WMB3_CS_IDE(base) ((CAN_WMB3_CS_REG(base) & CAN_WMB3_CS_IDE_MASK) >> CAN_WMB3_CS_IDE_SHIFT)
#define CAN_BRD_WMB3_CS_IDE(base) (BITBAND_ACCESS32(&CAN_WMB3_CS_REG(base), CAN_WMB3_CS_IDE_SHIFT))
/*@}*/

/*!
 * @name Register CAN_WMB3_CS, field SRR[22] (RO)
 *
 * This bit can be received either recessive or dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_CS_SRR field. */
#define CAN_RD_WMB3_CS_SRR(base) ((CAN_WMB3_CS_REG(base) & CAN_WMB3_CS_SRR_MASK) >> CAN_WMB3_CS_SRR_SHIFT)
#define CAN_BRD_WMB3_CS_SRR(base) (BITBAND_ACCESS32(&CAN_WMB3_CS_REG(base), CAN_WMB3_CS_SRR_SHIFT))
/*@}*/

/*******************************************************************************
 * CAN_WMB3_ID - Wake Up Message Buffer Register for ID
 ******************************************************************************/

/*!
 * @brief CAN_WMB3_ID - Wake Up Message Buffer Register for ID (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the ID information of an
 * incoming Rx message. The ID registers are located at 0xB44 for WMB0, 0xB54 for
 * WMB1, 0xB64 for WMB2, and 0xB74 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB3_ID register
 */
/*@{*/
#define CAN_RD_WMB3_ID(base)     (CAN_WMB3_ID_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB3_ID bitfields
 */

/*!
 * @name Register CAN_WMB3_ID, field ID[28:0] (RO)
 *
 * This register stores either the 29 bits of the extended frame format
 * (considering the ID[28:0] field), or the 11 bits of the standard frame format
 * (considering the ID[28:18] field only, the remaining bits in the ID[17:0] range have
 * no meaning).
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_ID_ID field. */
#define CAN_RD_WMB3_ID_ID(base) ((CAN_WMB3_ID_REG(base) & CAN_WMB3_ID_ID_MASK) >> CAN_WMB3_ID_ID_SHIFT)
#define CAN_BRD_WMB3_ID_ID(base) (CAN_RD_WMB3_ID_ID(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB3_D03 - Wake Up Message Buffer Register for Data 0-3
 ******************************************************************************/

/*!
 * @brief CAN_WMB3_D03 - Wake Up Message Buffer Register for Data 0-3 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 0 to 3 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 0-3 registers are located at 0xB48 for WMB0,
 * 0xB58 for WMB1, 0xB68 for WMB2, and 0xB78 for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB3_D03 register
 */
/*@{*/
#define CAN_RD_WMB3_D03(base)    (CAN_WMB3_D03_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB3_D03 bitfields
 */

/*!
 * @name Register CAN_WMB3_D03, field Data_byte_3[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D03_Data_byte_3 field. */
#define CAN_RD_WMB3_D03_Data_byte_3(base) ((CAN_WMB3_D03_REG(base) & CAN_WMB3_D03_Data_byte_3_MASK) >> CAN_WMB3_D03_Data_byte_3_SHIFT)
#define CAN_BRD_WMB3_D03_Data_byte_3(base) (CAN_RD_WMB3_D03_Data_byte_3(base))
/*@}*/

/*!
 * @name Register CAN_WMB3_D03, field Data_byte_2[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D03_Data_byte_2 field. */
#define CAN_RD_WMB3_D03_Data_byte_2(base) ((CAN_WMB3_D03_REG(base) & CAN_WMB3_D03_Data_byte_2_MASK) >> CAN_WMB3_D03_Data_byte_2_SHIFT)
#define CAN_BRD_WMB3_D03_Data_byte_2(base) (CAN_RD_WMB3_D03_Data_byte_2(base))
/*@}*/

/*!
 * @name Register CAN_WMB3_D03, field Data_byte_1[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D03_Data_byte_1 field. */
#define CAN_RD_WMB3_D03_Data_byte_1(base) ((CAN_WMB3_D03_REG(base) & CAN_WMB3_D03_Data_byte_1_MASK) >> CAN_WMB3_D03_Data_byte_1_SHIFT)
#define CAN_BRD_WMB3_D03_Data_byte_1(base) (CAN_RD_WMB3_D03_Data_byte_1(base))
/*@}*/

/*!
 * @name Register CAN_WMB3_D03, field Data_byte_0[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D03_Data_byte_0 field. */
#define CAN_RD_WMB3_D03_Data_byte_0(base) ((CAN_WMB3_D03_REG(base) & CAN_WMB3_D03_Data_byte_0_MASK) >> CAN_WMB3_D03_Data_byte_0_SHIFT)
#define CAN_BRD_WMB3_D03_Data_byte_0(base) (CAN_RD_WMB3_D03_Data_byte_0(base))
/*@}*/

/*******************************************************************************
 * CAN_WMB3_D47 - Wake Up Message Buffer Register Data 4-7
 ******************************************************************************/

/*!
 * @brief CAN_WMB3_D47 - Wake Up Message Buffer Register Data 4-7 (RO)
 *
 * Reset value: 0x00000000U
 *
 * Each of the four WMBs contains a register to store the data bytes 4 to 7 of
 * the payload information of an incoming Rx message. This resgister's content is
 * cleared when the incoming matched message is either a remote frame (RTR=1) or
 * a data frame with DLC=0. The Data 4-7 registers are located at 0xB4C for WMB0,
 * 0xB5C for WMB1, 0xB6C for WMB2, and 0xB7C for WMB3.
 */
/*!
 * @name Constants and macros for entire CAN_WMB3_D47 register
 */
/*@{*/
#define CAN_RD_WMB3_D47(base)    (CAN_WMB3_D47_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_WMB3_D47 bitfields
 */

/*!
 * @name Register CAN_WMB3_D47, field Data_byte_7[7:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D47_Data_byte_7 field. */
#define CAN_RD_WMB3_D47_Data_byte_7(base) ((CAN_WMB3_D47_REG(base) & CAN_WMB3_D47_Data_byte_7_MASK) >> CAN_WMB3_D47_Data_byte_7_SHIFT)
#define CAN_BRD_WMB3_D47_Data_byte_7(base) (CAN_RD_WMB3_D47_Data_byte_7(base))
/*@}*/

/*!
 * @name Register CAN_WMB3_D47, field Data_byte_6[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D47_Data_byte_6 field. */
#define CAN_RD_WMB3_D47_Data_byte_6(base) ((CAN_WMB3_D47_REG(base) & CAN_WMB3_D47_Data_byte_6_MASK) >> CAN_WMB3_D47_Data_byte_6_SHIFT)
#define CAN_BRD_WMB3_D47_Data_byte_6(base) (CAN_RD_WMB3_D47_Data_byte_6(base))
/*@}*/

/*!
 * @name Register CAN_WMB3_D47, field Data_byte_5[23:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D47_Data_byte_5 field. */
#define CAN_RD_WMB3_D47_Data_byte_5(base) ((CAN_WMB3_D47_REG(base) & CAN_WMB3_D47_Data_byte_5_MASK) >> CAN_WMB3_D47_Data_byte_5_SHIFT)
#define CAN_BRD_WMB3_D47_Data_byte_5(base) (CAN_RD_WMB3_D47_Data_byte_5(base))
/*@}*/

/*!
 * @name Register CAN_WMB3_D47, field Data_byte_4[31:24] (RO)
 */
/*@{*/
/*! @brief Read current value of the CAN_WMB3_D47_Data_byte_4 field. */
#define CAN_RD_WMB3_D47_Data_byte_4(base) ((CAN_WMB3_D47_REG(base) & CAN_WMB3_D47_Data_byte_4_MASK) >> CAN_WMB3_D47_Data_byte_4_SHIFT)
#define CAN_BRD_WMB3_D47_Data_byte_4(base) (CAN_RD_WMB3_D47_Data_byte_4(base))
/*@}*/

/*******************************************************************************
 * CAN_FDCTRL - CAN FD Control Register
 ******************************************************************************/

/*!
 * @brief CAN_FDCTRL - CAN FD Control Register (RW)
 *
 * Reset value: 0x80000100U
 *
 * This register contains control bits for the CAN FD operation. It also defines
 * the data size of Message Buffers allocated in different partitions of RAM
 * (memory blocks) as described in the table below. When 8 bytes payload is
 * selected: Block R0 allocates MB0 to MB31. Block R1 allocates MB32 to MB63. When more
 * then 8 bytes payload is selected, the maximum number of MBs in a block is
 * limited as described below: Number of Message Buffers Payload Size Maximum number
 * of Message Buffers per RAM block 8 bytes 32 16 bytes 21 32 bytes 12 64 bytes 7
 * One memory block fits exactly 32 MBs with 8 bytes payload. For the other
 * options of payload sizes, empty memory may exist between last MB in a block and the
 * beginning of the next block. This empty memory corresponds to less than one
 * MB, and must not be used. The contents of this register are not affected by
 * soft reset.
 */
/*!
 * @name Constants and macros for entire CAN_FDCTRL register
 */
/*@{*/
#define CAN_RD_FDCTRL(base)      (CAN_FDCTRL_REG(base))
#define CAN_WR_FDCTRL(base, value) (CAN_FDCTRL_REG(base) = (value))
#define CAN_RMW_FDCTRL(base, mask, value) (CAN_WR_FDCTRL(base, (CAN_RD_FDCTRL(base) & ~(mask)) | (value)))
#define CAN_SET_FDCTRL(base, value) (CAN_WR_FDCTRL(base, CAN_RD_FDCTRL(base) |  (value)))
#define CAN_CLR_FDCTRL(base, value) (CAN_WR_FDCTRL(base, CAN_RD_FDCTRL(base) & ~(value)))
#define CAN_TOG_FDCTRL(base, value) (CAN_WR_FDCTRL(base, CAN_RD_FDCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_FDCTRL bitfields
 */

/*!
 * @name Register CAN_FDCTRL, field TDCVAL[5:0] (RO)
 *
 * This register contains the value of the transceiver loop delay measured from
 * the transmitted EDL to R0 transition edge to the respective received one added
 * to the TDCOFF value specified in the CAN_FDCTRL register. This value is an
 * integer multiple of the Protocol Engine (PE) Clock period (CANCLK). See Protocol
 * timing for more details on how the loop delay measurement is performed.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCTRL_TDCVAL field. */
#define CAN_RD_FDCTRL_TDCVAL(base) ((CAN_FDCTRL_REG(base) & CAN_FDCTRL_TDCVAL_MASK) >> CAN_FDCTRL_TDCVAL_SHIFT)
#define CAN_BRD_FDCTRL_TDCVAL(base) (CAN_RD_FDCTRL_TDCVAL(base))
/*@}*/

/*!
 * @name Register CAN_FDCTRL, field TDCOFF[12:8] (RW)
 *
 * This bit field contains the offset value to be added to the measured
 * transceiver's loop delay in order to define the position of the delayed comparison
 * point when bit rate switching is active. See Transceiver Delay Compensation for
 * more details on how the loop delay measurement is performed. TDCOFF can be
 * written in Freeze mode only. Its value can be defined in Protocol Engine (PE)
 * Clock periods (CANCLK, see Protocol timing for more details), and must be selected
 * to be smaller than the CAN bit duration in the data bit rate for proper
 * operation. It is not recommended to use TDCOFF equal to zero.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCTRL_TDCOFF field. */
#define CAN_RD_FDCTRL_TDCOFF(base) ((CAN_FDCTRL_REG(base) & CAN_FDCTRL_TDCOFF_MASK) >> CAN_FDCTRL_TDCOFF_SHIFT)
#define CAN_BRD_FDCTRL_TDCOFF(base) (CAN_RD_FDCTRL_TDCOFF(base))

/*! @brief Set the TDCOFF field to a new value. */
#define CAN_WR_FDCTRL_TDCOFF(base, value) (CAN_RMW_FDCTRL(base, (CAN_FDCTRL_TDCOFF_MASK | CAN_FDCTRL_TDCFAIL_MASK), CAN_FDCTRL_TDCOFF(value)))
#define CAN_BWR_FDCTRL_TDCOFF(base, value) (CAN_WR_FDCTRL_TDCOFF(base, value))
/*@}*/

/*!
 * @name Register CAN_FDCTRL, field TDCFAIL[14] (W1C)
 *
 * This bit indicates when the Transceiver Delay Compensation (TDC) mechanism is
 * out of range, unable to compensate the transceiver's loop delay and
 * successfully compare the delayed received bits to the transmitted ones (see Transceiver
 * Delay Compensation. TDCFAIL sets in the first time FlexCAN detects the out of
 * range condition. The CPU needs to write 1 to clear it.
 *
 * Values:
 * - 0b0 - Measured loop delay is in range.
 * - 0b1 - Measured loop delay is out of range.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCTRL_TDCFAIL field. */
#define CAN_RD_FDCTRL_TDCFAIL(base) ((CAN_FDCTRL_REG(base) & CAN_FDCTRL_TDCFAIL_MASK) >> CAN_FDCTRL_TDCFAIL_SHIFT)
#define CAN_BRD_FDCTRL_TDCFAIL(base) (BITBAND_ACCESS32(&CAN_FDCTRL_REG(base), CAN_FDCTRL_TDCFAIL_SHIFT))

/*! @brief Set the TDCFAIL field to a new value. */
#define CAN_WR_FDCTRL_TDCFAIL(base, value) (CAN_RMW_FDCTRL(base, CAN_FDCTRL_TDCFAIL_MASK, CAN_FDCTRL_TDCFAIL(value)))
#define CAN_BWR_FDCTRL_TDCFAIL(base, value) (BITBAND_ACCESS32(&CAN_FDCTRL_REG(base), CAN_FDCTRL_TDCFAIL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_FDCTRL, field TDCEN[15] (RW)
 *
 * This bit can be used to enable and disable the TDC feature. It can be written
 * in Freeze mode only. TDC must be disabled when the Loop Back Mode is enabled
 * (see CAN_CTRL1[LPB] register).
 *
 * Values:
 * - 0b0 - TDC is disabled
 * - 0b1 - TDC is enabled
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCTRL_TDCEN field. */
#define CAN_RD_FDCTRL_TDCEN(base) ((CAN_FDCTRL_REG(base) & CAN_FDCTRL_TDCEN_MASK) >> CAN_FDCTRL_TDCEN_SHIFT)
#define CAN_BRD_FDCTRL_TDCEN(base) (BITBAND_ACCESS32(&CAN_FDCTRL_REG(base), CAN_FDCTRL_TDCEN_SHIFT))

/*! @brief Set the TDCEN field to a new value. */
#define CAN_WR_FDCTRL_TDCEN(base, value) (CAN_RMW_FDCTRL(base, (CAN_FDCTRL_TDCEN_MASK | CAN_FDCTRL_TDCFAIL_MASK), CAN_FDCTRL_TDCEN(value)))
#define CAN_BWR_FDCTRL_TDCEN(base, value) (BITBAND_ACCESS32(&CAN_FDCTRL_REG(base), CAN_FDCTRL_TDCEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_FDCTRL, field MBDSR0[17:16] (RW)
 *
 * This two bit field selects the data size (8, 16, 32 or 64 bytes) for the
 * region R0 of Message Buffers allocated in RAM. It can be written in Freeze Mode
 * only.
 *
 * Values:
 * - 0b00 - Selects 8 bytes per Message Buffer.
 * - 0b01 - Selects 16 bytes per Message Buffer.
 * - 0b10 - Selects 32 bytes per Message Buffer.
 * - 0b11 - Selects 64 bytes per Message Buffer.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCTRL_MBDSR0 field. */
#define CAN_RD_FDCTRL_MBDSR0(base) ((CAN_FDCTRL_REG(base) & CAN_FDCTRL_MBDSR0_MASK) >> CAN_FDCTRL_MBDSR0_SHIFT)
#define CAN_BRD_FDCTRL_MBDSR0(base) (CAN_RD_FDCTRL_MBDSR0(base))

/*! @brief Set the MBDSR0 field to a new value. */
#define CAN_WR_FDCTRL_MBDSR0(base, value) (CAN_RMW_FDCTRL(base, (CAN_FDCTRL_MBDSR0_MASK | CAN_FDCTRL_TDCFAIL_MASK), CAN_FDCTRL_MBDSR0(value)))
#define CAN_BWR_FDCTRL_MBDSR0(base, value) (CAN_WR_FDCTRL_MBDSR0(base, value))
/*@}*/

/*!
 * @name Register CAN_FDCTRL, field MBDSR1[20:19] (RW)
 *
 * This two bit field selects the data size (8, 16, 32 or 64 bytes) for the
 * region R1 of Message Buffers allocated in RAM. It can be written in Freeze Mode
 * only.
 *
 * Values:
 * - 0b00 - Selects 8 bytes per Message Buffer.
 * - 0b01 - Selects 16 bytes per Message Buffer.
 * - 0b10 - Selects 32 bytes per Message Buffer.
 * - 0b11 - Selects 64 bytes per Message Buffer.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCTRL_MBDSR1 field. */
#define CAN_RD_FDCTRL_MBDSR1(base) ((CAN_FDCTRL_REG(base) & CAN_FDCTRL_MBDSR1_MASK) >> CAN_FDCTRL_MBDSR1_SHIFT)
#define CAN_BRD_FDCTRL_MBDSR1(base) (CAN_RD_FDCTRL_MBDSR1(base))

/*! @brief Set the MBDSR1 field to a new value. */
#define CAN_WR_FDCTRL_MBDSR1(base, value) (CAN_RMW_FDCTRL(base, (CAN_FDCTRL_MBDSR1_MASK | CAN_FDCTRL_TDCFAIL_MASK), CAN_FDCTRL_MBDSR1(value)))
#define CAN_BWR_FDCTRL_MBDSR1(base, value) (CAN_WR_FDCTRL_MBDSR1(base, value))
/*@}*/

/*!
 * @name Register CAN_FDCTRL, field FDRATE[31] (RW)
 *
 * This bit enables the effect of the Bit Rate Switch (BRS bit) during the data
 * phase of Tx messages. The CPU can write this bit any time. However, its effect
 * turns active only when the CAN bus is in Wait for Bus Idle, Bus Idle or Bus
 * Off state, or when the current frame under reception or transmission reaches
 * the interframe space. By negating the CAN_FDCTRL[FDRATE] bit, the CPU can force
 * all bits in CAN FD messages to be transmitted in nominal bit rate, despite of
 * the value in the BRS bit of the Tx MBs.
 *
 * Values:
 * - 0b0 - Transmit a frame in nominal rate. The BRS bit in the Tx MB has no
 *     effect.
 * - 0b1 - Transmit a frame with bit rate switching if the BRS bit in the Tx MB
 *     is recessive.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCTRL_FDRATE field. */
#define CAN_RD_FDCTRL_FDRATE(base) ((CAN_FDCTRL_REG(base) & CAN_FDCTRL_FDRATE_MASK) >> CAN_FDCTRL_FDRATE_SHIFT)
#define CAN_BRD_FDCTRL_FDRATE(base) (BITBAND_ACCESS32(&CAN_FDCTRL_REG(base), CAN_FDCTRL_FDRATE_SHIFT))

/*! @brief Set the FDRATE field to a new value. */
#define CAN_WR_FDCTRL_FDRATE(base, value) (CAN_RMW_FDCTRL(base, (CAN_FDCTRL_FDRATE_MASK | CAN_FDCTRL_TDCFAIL_MASK), CAN_FDCTRL_FDRATE(value)))
#define CAN_BWR_FDCTRL_FDRATE(base, value) (BITBAND_ACCESS32(&CAN_FDCTRL_REG(base), CAN_FDCTRL_FDRATE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_FDCBT - CAN FD Bit Timing Register
 ******************************************************************************/

/*!
 * @brief CAN_FDCBT - CAN FD Bit Timing Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register stores the CAN bit timing variables used in the data phase of
 * CAN FD messages when the CAN_FDCTRL[FDRATE] is set, compatible with CAN FD
 * specification. FPRESDIV, FPROPSEG, FPSEG1, FPSEG2 and FRJW are used to define the
 * time quantum duration, the number of time quanta per CAN bit and the sample
 * point position for the data bit rate portion of a CAN FD message with the BRS
 * bit set. The contents of this register are not affected by soft reset.
 */
/*!
 * @name Constants and macros for entire CAN_FDCBT register
 */
/*@{*/
#define CAN_RD_FDCBT(base)       (CAN_FDCBT_REG(base))
#define CAN_WR_FDCBT(base, value) (CAN_FDCBT_REG(base) = (value))
#define CAN_RMW_FDCBT(base, mask, value) (CAN_WR_FDCBT(base, (CAN_RD_FDCBT(base) & ~(mask)) | (value)))
#define CAN_SET_FDCBT(base, value) (CAN_WR_FDCBT(base, CAN_RD_FDCBT(base) |  (value)))
#define CAN_CLR_FDCBT(base, value) (CAN_WR_FDCBT(base, CAN_RD_FDCBT(base) & ~(value)))
#define CAN_TOG_FDCBT(base, value) (CAN_WR_FDCBT(base, CAN_RD_FDCBT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_FDCBT bitfields
 */

/*!
 * @name Register CAN_FDCBT, field FPSEG2[2:0] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 2 in the data bit rate
 * portion of a CAN FD message with the BRS bit set. This field can be written
 * only in Freeze mode because it is blocked by hardware in other modes. Phase
 * Segment 2 = (FPSEG2 + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCBT_FPSEG2 field. */
#define CAN_RD_FDCBT_FPSEG2(base) ((CAN_FDCBT_REG(base) & CAN_FDCBT_FPSEG2_MASK) >> CAN_FDCBT_FPSEG2_SHIFT)
#define CAN_BRD_FDCBT_FPSEG2(base) (CAN_RD_FDCBT_FPSEG2(base))

/*! @brief Set the FPSEG2 field to a new value. */
#define CAN_WR_FDCBT_FPSEG2(base, value) (CAN_RMW_FDCBT(base, CAN_FDCBT_FPSEG2_MASK, CAN_FDCBT_FPSEG2(value)))
#define CAN_BWR_FDCBT_FPSEG2(base, value) (CAN_WR_FDCBT_FPSEG2(base, value))
/*@}*/

/*!
 * @name Register CAN_FDCBT, field FPSEG1[7:5] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 1 in the bit time in the
 * data bit rate portion of a CAN FD message with the BRS bit set. This field
 * can be written only in Freeze mode because it is blocked by hardware in other
 * modes. Phase Segment 1 = (FPSEG1 + 1) * Time-Quanta. Time-Quantum = one Sclock
 * period.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCBT_FPSEG1 field. */
#define CAN_RD_FDCBT_FPSEG1(base) ((CAN_FDCBT_REG(base) & CAN_FDCBT_FPSEG1_MASK) >> CAN_FDCBT_FPSEG1_SHIFT)
#define CAN_BRD_FDCBT_FPSEG1(base) (CAN_RD_FDCBT_FPSEG1(base))

/*! @brief Set the FPSEG1 field to a new value. */
#define CAN_WR_FDCBT_FPSEG1(base, value) (CAN_RMW_FDCBT(base, CAN_FDCBT_FPSEG1_MASK, CAN_FDCBT_FPSEG1(value)))
#define CAN_BWR_FDCBT_FPSEG1(base, value) (CAN_WR_FDCBT_FPSEG1(base, value))
/*@}*/

/*!
 * @name Register CAN_FDCBT, field FPROPSEG[14:10] (RW)
 *
 * This 5-bit field defines the length of the Propagation Segment in the bit
 * time in the data bit rate portion of a CAN FD message with the BRS bit set. This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes. Propagation Segment Time = FPROPSEG * Time-Quanta. Time-Quantum =
 * one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCBT_FPROPSEG field. */
#define CAN_RD_FDCBT_FPROPSEG(base) ((CAN_FDCBT_REG(base) & CAN_FDCBT_FPROPSEG_MASK) >> CAN_FDCBT_FPROPSEG_SHIFT)
#define CAN_BRD_FDCBT_FPROPSEG(base) (CAN_RD_FDCBT_FPROPSEG(base))

/*! @brief Set the FPROPSEG field to a new value. */
#define CAN_WR_FDCBT_FPROPSEG(base, value) (CAN_RMW_FDCBT(base, CAN_FDCBT_FPROPSEG_MASK, CAN_FDCBT_FPROPSEG(value)))
#define CAN_BWR_FDCBT_FPROPSEG(base, value) (CAN_WR_FDCBT_FPROPSEG(base, value))
/*@}*/

/*!
 * @name Register CAN_FDCBT, field FRJW[18:16] (RW)
 *
 * This 3-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization in the data bit rate portion of a CAN
 * FD message with the BRS bit set. One time quantum is equal to the Sclock
 * period. This field can be written only in Freeze mode because it is blocked by
 * hardware in other modes. Resync Jump Width = FSJW + 1.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCBT_FRJW field. */
#define CAN_RD_FDCBT_FRJW(base) ((CAN_FDCBT_REG(base) & CAN_FDCBT_FRJW_MASK) >> CAN_FDCBT_FRJW_SHIFT)
#define CAN_BRD_FDCBT_FRJW(base) (CAN_RD_FDCBT_FRJW(base))

/*! @brief Set the FRJW field to a new value. */
#define CAN_WR_FDCBT_FRJW(base, value) (CAN_RMW_FDCBT(base, CAN_FDCBT_FRJW_MASK, CAN_FDCBT_FRJW(value)))
#define CAN_BWR_FDCBT_FRJW(base, value) (CAN_WR_FDCBT_FRJW(base, value))
/*@}*/

/*!
 * @name Register CAN_FDCBT, field FPRESDIV[29:20] (RW)
 *
 * This 10-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency in the data bit rate portion of a CAN FD message
 * with the BRS bit set. The Sclock period defines the time quantum of the CAN
 * FD protocol for the data bit rate. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Sclock frequency = PE
 * clock frequency / (FPRESDIV + 1)
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCBT_FPRESDIV field. */
#define CAN_RD_FDCBT_FPRESDIV(base) ((CAN_FDCBT_REG(base) & CAN_FDCBT_FPRESDIV_MASK) >> CAN_FDCBT_FPRESDIV_SHIFT)
#define CAN_BRD_FDCBT_FPRESDIV(base) (CAN_RD_FDCBT_FPRESDIV(base))

/*! @brief Set the FPRESDIV field to a new value. */
#define CAN_WR_FDCBT_FPRESDIV(base, value) (CAN_RMW_FDCBT(base, CAN_FDCBT_FPRESDIV_MASK, CAN_FDCBT_FPRESDIV(value)))
#define CAN_BWR_FDCBT_FPRESDIV(base, value) (CAN_WR_FDCBT_FPRESDIV(base, value))
/*@}*/

/*******************************************************************************
 * CAN_FDCRC - CAN FD CRC Register
 ******************************************************************************/

/*!
 * @brief CAN_FDCRC - CAN FD CRC Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register provides information about the CRC of transmitted messages.
 * FlexCAN uses different CRC polynomials for different frame formats, as shown
 * below. The CRC_15 polynomial is used for all frames in CAN format. The CRC_17
 * polynomial is used for frames in CAN FD format with a DATA FIELD up to sixteen
 * bytes. The CRC_21 polynomial is used for frames in CAN FD format with a DATA
 * FIELD longer than sixteen bytes. Each polynomial shown below results in a Hamming
 * Distance of 6. This register is updated at the same time the Tx Interrupt Flag
 * is asserted.
 */
/*!
 * @name Constants and macros for entire CAN_FDCRC register
 */
/*@{*/
#define CAN_RD_FDCRC(base)       (CAN_FDCRC_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_FDCRC bitfields
 */

/*!
 * @name Register CAN_FDCRC, field FD_TXCRC[20:0] (RO)
 *
 * This 21-bit field contains the CRC value calculated over the most recent
 * transmitted message. Different CRC polynomials are used for different frame
 * formats. A 15-bit polynomial, CRC_15, is used for all frames in CAN format. The
 * second 17-bit polynomial, CRC_17, is used for frames in CAN FD format with a data
 * field up to sixteen bytes long. The third 21-bit polynomial, CRC_21, is used
 * for frames in CAN FD format with a data field longer than sixteen bytes. For
 * CRC_15 and CRC_17, the 6 most significant bits and the 4 most significant bits
 * are reported as zeros, respectively. For CRC_15, this register has the same
 * content as CRC Register.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCRC_FD_TXCRC field. */
#define CAN_RD_FDCRC_FD_TXCRC(base) ((CAN_FDCRC_REG(base) & CAN_FDCRC_FD_TXCRC_MASK) >> CAN_FDCRC_FD_TXCRC_SHIFT)
#define CAN_BRD_FDCRC_FD_TXCRC(base) (CAN_RD_FDCRC_FD_TXCRC(base))
/*@}*/

/*!
 * @name Register CAN_FDCRC, field FD_MBCRC[30:24] (RO)
 *
 * This field indicates the number of the Mailbox corresponding to the value in
 * FD_TXCRC field, for both FD and non-FD frames. It reports the same information
 * as in MBCRC bit field in CAN_CRCR register.
 */
/*@{*/
/*! @brief Read current value of the CAN_FDCRC_FD_MBCRC field. */
#define CAN_RD_FDCRC_FD_MBCRC(base) ((CAN_FDCRC_REG(base) & CAN_FDCRC_FD_MBCRC_MASK) >> CAN_FDCRC_FD_MBCRC_SHIFT)
#define CAN_BRD_FDCRC_FD_MBCRC(base) (CAN_RD_FDCRC_FD_MBCRC(base))
/*@}*/

/*
 * S32K144 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_C0 - CMP Control Register 0
 * - CMP_C1 - CMP Control Register 1
 * - CMP_C2 - CMP Control Register 2
 */

#define CMP_INSTANCE_COUNT (1U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */

/*******************************************************************************
 * CMP_C0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_C0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Access: Supervisor read/write User read/write
 */
/*!
 * @name Constants and macros for entire CMP_C0 register
 */
/*@{*/
#define CMP_RD_C0(base)          (CMP_C0_REG(base))
#define CMP_WR_C0(base, value)   (CMP_C0_REG(base) = (value))
#define CMP_RMW_C0(base, mask, value) (CMP_WR_C0(base, (CMP_RD_C0(base) & ~(mask)) | (value)))
#define CMP_SET_C0(base, value)  (CMP_WR_C0(base, CMP_RD_C0(base) |  (value)))
#define CMP_CLR_C0(base, value)  (CMP_WR_C0(base, CMP_RD_C0(base) & ~(value)))
#define CMP_TOG_C0(base, value)  (CMP_WR_C0(base, CMP_RD_C0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_C0 bitfields
 */

/*!
 * @name Register CMP_C0, field HYSTCTR[1:0] (RW)
 *
 * Values:
 * - 0b00 - The hard block output has level 0 hysteresis internally.
 * - 0b01 - The hard block output has level 1 hysteresis internally.
 * - 0b10 - The hard block output has level 2 hysteresis internally.
 * - 0b11 - The hard block output has level 3 hysteresis internally.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_HYSTCTR field. */
#define CMP_RD_C0_HYSTCTR(base) ((CMP_C0_REG(base) & CMP_C0_HYSTCTR_MASK) >> CMP_C0_HYSTCTR_SHIFT)
#define CMP_BRD_C0_HYSTCTR(base) (CMP_RD_C0_HYSTCTR(base))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_C0_HYSTCTR(base, value) (CMP_RMW_C0(base, (CMP_C0_HYSTCTR_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_HYSTCTR(value)))
#define CMP_BWR_C0_HYSTCTR(base, value) (CMP_WR_C0_HYSTCTR(base, value))
/*@}*/

/*!
 * @name Register CMP_C0, field OFFSET[2] (RW)
 *
 * If OFFSET = 1, then there will be no hysteresis in the case of INP crossing
 * INN in the positive direction (or INN crossing INP in the negative direction).
 * Hysteresis still exists for INP crossing INN in the falling direction. If
 * OFFSET = 0, then the hysteresis selected by HYSTCTR is valid for both directions.
 *
 * Values:
 * - 0b0 - The comparator hard block output has level 0 offset internally.
 * - 0b1 - The comparator hard block output has level 1 offset internally.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_OFFSET field. */
#define CMP_RD_C0_OFFSET(base) ((CMP_C0_REG(base) & CMP_C0_OFFSET_MASK) >> CMP_C0_OFFSET_SHIFT)
#define CMP_BRD_C0_OFFSET(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_OFFSET_SHIFT))

/*! @brief Set the OFFSET field to a new value. */
#define CMP_WR_C0_OFFSET(base, value) (CMP_RMW_C0(base, (CMP_C0_OFFSET_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_OFFSET(value)))
#define CMP_BWR_C0_OFFSET(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_OFFSET_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field FILTER_CNT[6:4] (RW)
 *
 * This field specifies the number of consecutive samples that must agree prior
 * to the comparator ouput filter accepting a new output state. For information
 * regarding filter programming and latency, please see the Functional Description.
 *
 * Values:
 * - 0b000 - Filter is disabled. If SE = 1, then COUT is a logic zero (this is
 *     not a legal state, and is not recommended). If SE = 0, COUT = COUTA.
 * - 0b001 - 1 consecutive sample must agree (comparator output is simply
 *     sampled).
 * - 0b010 - 2 consecutive samples must agree.
 * - 0b011 - 3 consecutive samples must agree.
 * - 0b100 - 4 consecutive samples must agree.
 * - 0b101 - 5 consecutive samples must agree.
 * - 0b110 - 6 consecutive samples must agree.
 * - 0b111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_FILTER_CNT field. */
#define CMP_RD_C0_FILTER_CNT(base) ((CMP_C0_REG(base) & CMP_C0_FILTER_CNT_MASK) >> CMP_C0_FILTER_CNT_SHIFT)
#define CMP_BRD_C0_FILTER_CNT(base) (CMP_RD_C0_FILTER_CNT(base))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_C0_FILTER_CNT(base, value) (CMP_RMW_C0(base, (CMP_C0_FILTER_CNT_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_FILTER_CNT(value)))
#define CMP_BWR_C0_FILTER_CNT(base, value) (CMP_WR_C0_FILTER_CNT(base, value))
/*@}*/

/*!
 * @name Register CMP_C0, field EN[8] (RW)
 *
 * The EN bit enables the Analog Comparator Module. When the module is not
 * enabled, the analog part remains in the off state, and consumes no power. When the
 * same input is selected from analog mux to the positive and negative port, the
 * comparator is disabled automatically.
 *
 * Values:
 * - 0b0 - Analog Comparator is disabled.
 * - 0b1 - Analog Comparator is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_EN field. */
#define CMP_RD_C0_EN(base)   ((CMP_C0_REG(base) & CMP_C0_EN_MASK) >> CMP_C0_EN_SHIFT)
#define CMP_BRD_C0_EN(base)  (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_EN_SHIFT))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_C0_EN(base, value) (CMP_RMW_C0(base, (CMP_C0_EN_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_EN(value)))
#define CMP_BWR_C0_EN(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field OPE[9] (RW)
 *
 * The OPE bit enables the path from the comparator output to a selected pin.
 *
 * Values:
 * - 0b0 - When OPE is 0, the comparator output (after window/filter settings
 *     dependent on software configuration) is not available to a packaged pin.
 * - 0b1 - When OPE is 1, and if the software has configured the comparator to
 *     own a packaged pin, the comparator is available in a packaged pin.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_OPE field. */
#define CMP_RD_C0_OPE(base)  ((CMP_C0_REG(base) & CMP_C0_OPE_MASK) >> CMP_C0_OPE_SHIFT)
#define CMP_BRD_C0_OPE(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_OPE_SHIFT))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_C0_OPE(base, value) (CMP_RMW_C0(base, (CMP_C0_OPE_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_OPE(value)))
#define CMP_BWR_C0_OPE(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_OPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field COS[10] (RW)
 *
 * Values:
 * - 0b0 - Set CMPO to equal COUT (filtered comparator output).
 * - 0b1 - Set CMPO to equal COUTA (unfiltered comparator output).
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_COS field. */
#define CMP_RD_C0_COS(base)  ((CMP_C0_REG(base) & CMP_C0_COS_MASK) >> CMP_C0_COS_SHIFT)
#define CMP_BRD_C0_COS(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_COS_SHIFT))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_C0_COS(base, value) (CMP_RMW_C0(base, (CMP_C0_COS_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_COS(value)))
#define CMP_BWR_C0_COS(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_COS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field INVT[11] (RW)
 *
 * This bit allows selecting the polarity of the analog comparator function. It
 * is also driven to the COUT output (on both the device pin and as C0[COUT])
 * when CR1[OPE]=0.
 *
 * Values:
 * - 0b0 - Does not invert the comparator output.
 * - 0b1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_INVT field. */
#define CMP_RD_C0_INVT(base) ((CMP_C0_REG(base) & CMP_C0_INVT_MASK) >> CMP_C0_INVT_SHIFT)
#define CMP_BRD_C0_INVT(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_INVT_SHIFT))

/*! @brief Set the INVT field to a new value. */
#define CMP_WR_C0_INVT(base, value) (CMP_RMW_C0(base, (CMP_C0_INVT_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_INVT(value)))
#define CMP_BWR_C0_INVT(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_INVT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field PMODE[12] (RW)
 *
 * Values:
 * - 0b0 - Low Speed (LS) comparison mode is selected.
 * - 0b1 - High Speed (HS) comparison mode is selected, in VLPx (low power mode,
 *     low speed compute mode).
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_PMODE field. */
#define CMP_RD_C0_PMODE(base) ((CMP_C0_REG(base) & CMP_C0_PMODE_MASK) >> CMP_C0_PMODE_SHIFT)
#define CMP_BRD_C0_PMODE(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_PMODE_SHIFT))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_C0_PMODE(base, value) (CMP_RMW_C0(base, (CMP_C0_PMODE_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_PMODE(value)))
#define CMP_BWR_C0_PMODE(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_PMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field WE[14] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * ones to both bit locations because this "11" case is reserved.
 *
 * Values:
 * - 0b0 - Windowing mode is not selected.
 * - 0b1 - Windowing mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_WE field. */
#define CMP_RD_C0_WE(base)   ((CMP_C0_REG(base) & CMP_C0_WE_MASK) >> CMP_C0_WE_SHIFT)
#define CMP_BRD_C0_WE(base)  (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_WE_SHIFT))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_C0_WE(base, value) (CMP_RMW_C0(base, (CMP_C0_WE_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_WE(value)))
#define CMP_BWR_C0_WE(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field SE[15] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * ones to both bit locations because this "11" case is reserved.
 *
 * Values:
 * - 0b0 - Sampling mode is not selected.
 * - 0b1 - Sampling mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_SE field. */
#define CMP_RD_C0_SE(base)   ((CMP_C0_REG(base) & CMP_C0_SE_MASK) >> CMP_C0_SE_SHIFT)
#define CMP_BRD_C0_SE(base)  (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_SE_SHIFT))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_C0_SE(base, value) (CMP_RMW_C0(base, (CMP_C0_SE_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_SE(value)))
#define CMP_BWR_C0_SE(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_SE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field FPR[23:16] (RW)
 *
 * Specifies the sampling period, in bus clock cycles, of the comparator output
 * filter, when C1[SE] = 0. Setting FPR to 0x0 disables the filter. Filter
 * programming and latency details are provided in the CMP functional description. This
 * field has no effect when C0[SE ]= 1. In that case, the external SAMPLE signal
 * is used to determine the sampling period.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_FPR field. */
#define CMP_RD_C0_FPR(base)  ((CMP_C0_REG(base) & CMP_C0_FPR_MASK) >> CMP_C0_FPR_SHIFT)
#define CMP_BRD_C0_FPR(base) (CMP_RD_C0_FPR(base))

/*! @brief Set the FPR field to a new value. */
#define CMP_WR_C0_FPR(base, value) (CMP_RMW_C0(base, (CMP_C0_FPR_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_FPR(value)))
#define CMP_BWR_C0_FPR(base, value) (CMP_WR_C0_FPR(base, value))
/*@}*/

/*!
 * @name Register CMP_C0, field COUT[24] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as C0[INVT] when the Analog Comparator module
 * is disabled, that is, when C0[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_COUT field. */
#define CMP_RD_C0_COUT(base) ((CMP_C0_REG(base) & CMP_C0_COUT_MASK) >> CMP_C0_COUT_SHIFT)
#define CMP_BRD_C0_COUT(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_COUT_SHIFT))
/*@}*/

/*!
 * @name Register CMP_C0, field CFF[25] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is level senstive .
 *
 * Values:
 * - 0b0 - A falling edge has not been detected on COUT.
 * - 0b1 - A falling edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_CFF field. */
#define CMP_RD_C0_CFF(base)  ((CMP_C0_REG(base) & CMP_C0_CFF_MASK) >> CMP_C0_CFF_SHIFT)
#define CMP_BRD_C0_CFF(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_CFF_SHIFT))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_C0_CFF(base, value) (CMP_RMW_C0(base, (CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_CFF(value)))
#define CMP_BWR_C0_CFF(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_CFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field CFR[26] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is level sensitive
 *
 * Values:
 * - 0b0 - A rising edge has not been detected on COUT.
 * - 0b1 - A rising edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_CFR field. */
#define CMP_RD_C0_CFR(base)  ((CMP_C0_REG(base) & CMP_C0_CFR_MASK) >> CMP_C0_CFR_SHIFT)
#define CMP_BRD_C0_CFR(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_CFR_SHIFT))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_C0_CFR(base, value) (CMP_RMW_C0(base, (CMP_C0_CFR_MASK | CMP_C0_CFF_MASK), CMP_C0_CFR(value)))
#define CMP_BWR_C0_CFR(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_CFR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field IEF[27] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_IEF field. */
#define CMP_RD_C0_IEF(base)  ((CMP_C0_REG(base) & CMP_C0_IEF_MASK) >> CMP_C0_IEF_SHIFT)
#define CMP_BRD_C0_IEF(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_IEF_SHIFT))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_C0_IEF(base, value) (CMP_RMW_C0(base, (CMP_C0_IEF_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_IEF(value)))
#define CMP_BWR_C0_IEF(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_IEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field IER[28] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_IER field. */
#define CMP_RD_C0_IER(base)  ((CMP_C0_REG(base) & CMP_C0_IER_MASK) >> CMP_C0_IER_SHIFT)
#define CMP_BRD_C0_IER(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_IER_SHIFT))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_C0_IER(base, value) (CMP_RMW_C0(base, (CMP_C0_IER_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_IER(value)))
#define CMP_BWR_C0_IER(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_IER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C0, field DMAEN[30] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_C0_DMAEN field. */
#define CMP_RD_C0_DMAEN(base) ((CMP_C0_REG(base) & CMP_C0_DMAEN_MASK) >> CMP_C0_DMAEN_SHIFT)
#define CMP_BRD_C0_DMAEN(base) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_C0_DMAEN(base, value) (CMP_RMW_C0(base, (CMP_C0_DMAEN_MASK | CMP_C0_CFF_MASK | CMP_C0_CFR_MASK), CMP_C0_DMAEN(value)))
#define CMP_BWR_C0_DMAEN(base, value) (BITBAND_ACCESS32(&CMP_C0_REG(base), CMP_C0_DMAEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_C1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_C1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Access: Supervisor read/write User read/write
 */
/*!
 * @name Constants and macros for entire CMP_C1 register
 */
/*@{*/
#define CMP_RD_C1(base)          (CMP_C1_REG(base))
#define CMP_WR_C1(base, value)   (CMP_C1_REG(base) = (value))
#define CMP_RMW_C1(base, mask, value) (CMP_WR_C1(base, (CMP_RD_C1(base) & ~(mask)) | (value)))
#define CMP_SET_C1(base, value)  (CMP_WR_C1(base, CMP_RD_C1(base) |  (value)))
#define CMP_CLR_C1(base, value)  (CMP_WR_C1(base, CMP_RD_C1(base) & ~(value)))
#define CMP_TOG_C1(base, value)  (CMP_WR_C1(base, CMP_RD_C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_C1 bitfields
 */

/*!
 * @name Register CMP_C1, field VOSEL[7:0] (RW)
 *
 * This bit selects an output voltage from one of 256 distinct levels. DACO =
 * (Vin/256) * (VOSEL[7:0] + 1), so the DACO range is from Vin/256 to Vin.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_VOSEL field. */
#define CMP_RD_C1_VOSEL(base) ((CMP_C1_REG(base) & CMP_C1_VOSEL_MASK) >> CMP_C1_VOSEL_SHIFT)
#define CMP_BRD_C1_VOSEL(base) (CMP_RD_C1_VOSEL(base))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_C1_VOSEL(base, value) (CMP_RMW_C1(base, CMP_C1_VOSEL_MASK, CMP_C1_VOSEL(value)))
#define CMP_BWR_C1_VOSEL(base, value) (CMP_WR_C1_VOSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_C1, field MSEL[10:8] (RW)
 *
 * Determines which input is selected for the minus mux. NOTE: These bits are
 * used to select the external 8 inputs for the minus mux, the actual input to the
 * negative port of the comparator is selected between this mux out and other
 * inputs finally, see the definition in INNSEL. Note: For the round robin mode of
 * operation, the MSEL and PSEL bitfields in CMPx_C1 register must have different
 * values.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_MSEL field. */
#define CMP_RD_C1_MSEL(base) ((CMP_C1_REG(base) & CMP_C1_MSEL_MASK) >> CMP_C1_MSEL_SHIFT)
#define CMP_BRD_C1_MSEL(base) (CMP_RD_C1_MSEL(base))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_C1_MSEL(base, value) (CMP_RMW_C1(base, CMP_C1_MSEL_MASK, CMP_C1_MSEL(value)))
#define CMP_BWR_C1_MSEL(base, value) (CMP_WR_C1_MSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_C1, field PSEL[13:11] (RW)
 *
 * Determines which input is selected for the plus mux. NOTE: These bits are
 * used to selecte the external 8 inputs for the plus mux, the actual input to the
 * positive port of the comparator is selected between this mux out and other
 * inputs finally, see the definition in INPSEL. Note: For the round robin mode of
 * operation, the MSEL and PSEL bitfields in CMPx_C1 register must have different
 * values.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_PSEL field. */
#define CMP_RD_C1_PSEL(base) ((CMP_C1_REG(base) & CMP_C1_PSEL_MASK) >> CMP_C1_PSEL_SHIFT)
#define CMP_BRD_C1_PSEL(base) (CMP_RD_C1_PSEL(base))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_C1_PSEL(base, value) (CMP_RMW_C1(base, CMP_C1_PSEL_MASK, CMP_C1_PSEL(value)))
#define CMP_BWR_C1_PSEL(base, value) (CMP_WR_C1_PSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_C1, field VRSEL[14] (RW)
 *
 * Values:
 * - 0b0 - Vin1 is selected as resistor ladder network supply reference Vin.
 * - 0b1 - Vin2 is selected as resistor ladder network supply reference Vin.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_VRSEL field. */
#define CMP_RD_C1_VRSEL(base) ((CMP_C1_REG(base) & CMP_C1_VRSEL_MASK) >> CMP_C1_VRSEL_SHIFT)
#define CMP_BRD_C1_VRSEL(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_VRSEL_SHIFT))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_C1_VRSEL(base, value) (CMP_RMW_C1(base, CMP_C1_VRSEL_MASK, CMP_C1_VRSEL(value)))
#define CMP_BWR_C1_VRSEL(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_VRSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field DACEN[15] (RW)
 *
 * This bit is used to enable the DAC. When the DAC is disabled, it is powered
 * down to conserve power.
 *
 * Values:
 * - 0b0 - DAC is disabled.
 * - 0b1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_DACEN field. */
#define CMP_RD_C1_DACEN(base) ((CMP_C1_REG(base) & CMP_C1_DACEN_MASK) >> CMP_C1_DACEN_SHIFT)
#define CMP_BRD_C1_DACEN(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_DACEN_SHIFT))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_C1_DACEN(base, value) (CMP_RMW_C1(base, CMP_C1_DACEN_MASK, CMP_C1_DACEN(value)))
#define CMP_BWR_C1_DACEN(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_DACEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN0[16] (RW)
 *
 * Channel 0 of the input enable for the round-robin checker. If CHN0 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN0 field. */
#define CMP_RD_C1_CHN0(base) ((CMP_C1_REG(base) & CMP_C1_CHN0_MASK) >> CMP_C1_CHN0_SHIFT)
#define CMP_BRD_C1_CHN0(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN0_SHIFT))

/*! @brief Set the CHN0 field to a new value. */
#define CMP_WR_C1_CHN0(base, value) (CMP_RMW_C1(base, CMP_C1_CHN0_MASK, CMP_C1_CHN0(value)))
#define CMP_BWR_C1_CHN0(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN1[17] (RW)
 *
 * Channel 1 of the input enable for the round-robin checker. If CHN1 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN1 field. */
#define CMP_RD_C1_CHN1(base) ((CMP_C1_REG(base) & CMP_C1_CHN1_MASK) >> CMP_C1_CHN1_SHIFT)
#define CMP_BRD_C1_CHN1(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN1_SHIFT))

/*! @brief Set the CHN1 field to a new value. */
#define CMP_WR_C1_CHN1(base, value) (CMP_RMW_C1(base, CMP_C1_CHN1_MASK, CMP_C1_CHN1(value)))
#define CMP_BWR_C1_CHN1(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN2[18] (RW)
 *
 * Channel 2 of the input enable for the round-robin checker. If CHN2 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN2 field. */
#define CMP_RD_C1_CHN2(base) ((CMP_C1_REG(base) & CMP_C1_CHN2_MASK) >> CMP_C1_CHN2_SHIFT)
#define CMP_BRD_C1_CHN2(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN2_SHIFT))

/*! @brief Set the CHN2 field to a new value. */
#define CMP_WR_C1_CHN2(base, value) (CMP_RMW_C1(base, CMP_C1_CHN2_MASK, CMP_C1_CHN2(value)))
#define CMP_BWR_C1_CHN2(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN3[19] (RW)
 *
 * Channel 3 of the input enable for the round-robin checker. If CHN3 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN3 field. */
#define CMP_RD_C1_CHN3(base) ((CMP_C1_REG(base) & CMP_C1_CHN3_MASK) >> CMP_C1_CHN3_SHIFT)
#define CMP_BRD_C1_CHN3(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN3_SHIFT))

/*! @brief Set the CHN3 field to a new value. */
#define CMP_WR_C1_CHN3(base, value) (CMP_RMW_C1(base, CMP_C1_CHN3_MASK, CMP_C1_CHN3(value)))
#define CMP_BWR_C1_CHN3(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN4[20] (RW)
 *
 * Channel 4 of the input enable for the round-robin checker. If CHN4 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN4 field. */
#define CMP_RD_C1_CHN4(base) ((CMP_C1_REG(base) & CMP_C1_CHN4_MASK) >> CMP_C1_CHN4_SHIFT)
#define CMP_BRD_C1_CHN4(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN4_SHIFT))

/*! @brief Set the CHN4 field to a new value. */
#define CMP_WR_C1_CHN4(base, value) (CMP_RMW_C1(base, CMP_C1_CHN4_MASK, CMP_C1_CHN4(value)))
#define CMP_BWR_C1_CHN4(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN5[21] (RW)
 *
 * Channel 5 of the input enable for the round-robin checker. If CHN5 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN5 field. */
#define CMP_RD_C1_CHN5(base) ((CMP_C1_REG(base) & CMP_C1_CHN5_MASK) >> CMP_C1_CHN5_SHIFT)
#define CMP_BRD_C1_CHN5(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN5_SHIFT))

/*! @brief Set the CHN5 field to a new value. */
#define CMP_WR_C1_CHN5(base, value) (CMP_RMW_C1(base, CMP_C1_CHN5_MASK, CMP_C1_CHN5(value)))
#define CMP_BWR_C1_CHN5(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN6[22] (RW)
 *
 * Channel 6 of the input enable for the round-robin checker. If CHN6 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN6 field. */
#define CMP_RD_C1_CHN6(base) ((CMP_C1_REG(base) & CMP_C1_CHN6_MASK) >> CMP_C1_CHN6_SHIFT)
#define CMP_BRD_C1_CHN6(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN6_SHIFT))

/*! @brief Set the CHN6 field to a new value. */
#define CMP_WR_C1_CHN6(base, value) (CMP_RMW_C1(base, CMP_C1_CHN6_MASK, CMP_C1_CHN6(value)))
#define CMP_BWR_C1_CHN6(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field CHN7[23] (RW)
 *
 * Channel 7 of the input enable for the round-robin checker. If CHN7 is set,
 * then the corresponding channel to the non-fixed mux port is enabled to check its
 * voltage value in the round-robin mode. If the same channel is selected as the
 * reference voltage, this bit has no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_CHN7 field. */
#define CMP_RD_C1_CHN7(base) ((CMP_C1_REG(base) & CMP_C1_CHN7_MASK) >> CMP_C1_CHN7_SHIFT)
#define CMP_BRD_C1_CHN7(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN7_SHIFT))

/*! @brief Set the CHN7 field to a new value. */
#define CMP_WR_C1_CHN7(base, value) (CMP_RMW_C1(base, CMP_C1_CHN7_MASK, CMP_C1_CHN7(value)))
#define CMP_BWR_C1_CHN7(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_CHN7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C1, field INNSEL[25:24] (RW)
 *
 * Determines which input is selected for the plus input of the comparator.
 * NOTE: These selections is used to select the final negative input to the
 * comparator. Note: For the round robin mode of operation, the MSEL and PSEL bitfields in
 * CMPx_C1 register must have different values.
 *
 * Values:
 * - 0b00 - IN0, from the 6b DAC output
 * - 0b01 - IN1, from the analog 8-1 mux
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_INNSEL field. */
#define CMP_RD_C1_INNSEL(base) ((CMP_C1_REG(base) & CMP_C1_INNSEL_MASK) >> CMP_C1_INNSEL_SHIFT)
#define CMP_BRD_C1_INNSEL(base) (CMP_RD_C1_INNSEL(base))

/*! @brief Set the INNSEL field to a new value. */
#define CMP_WR_C1_INNSEL(base, value) (CMP_RMW_C1(base, CMP_C1_INNSEL_MASK, CMP_C1_INNSEL(value)))
#define CMP_BWR_C1_INNSEL(base, value) (CMP_WR_C1_INNSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_C1, field INPSEL[28:27] (RW)
 *
 * Determines which input is selected for the plus input of the comparator.
 * NOTE: These selections is used to select the final positive input to the
 * comparator. Note: For the round robin mode of operation, the MSEL and PSEL bitfields in
 * CMPx_C1 register must have different values.
 *
 * Values:
 * - 0b00 - IN0, from the 6b DAC output
 * - 0b01 - IN1, from the analog 8-1 mux
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_INPSEL field. */
#define CMP_RD_C1_INPSEL(base) ((CMP_C1_REG(base) & CMP_C1_INPSEL_MASK) >> CMP_C1_INPSEL_SHIFT)
#define CMP_BRD_C1_INPSEL(base) (CMP_RD_C1_INPSEL(base))

/*! @brief Set the INPSEL field to a new value. */
#define CMP_WR_C1_INPSEL(base, value) (CMP_RMW_C1(base, CMP_C1_INPSEL_MASK, CMP_C1_INPSEL(value)))
#define CMP_BWR_C1_INPSEL(base, value) (CMP_WR_C1_INPSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_C1, field DACOE[29] (RW)
 *
 * This bit is used to enable the output of DAC to outside of this block. When
 * this bit is set, the 6b DAC output will be available for other peripheral usage.
 *
 * Values:
 * - 0b0 - DAC output is disabled to go outside.
 * - 0b1 - DAC output is enabled to go outside.
 */
/*@{*/
/*! @brief Read current value of the CMP_C1_DACOE field. */
#define CMP_RD_C1_DACOE(base) ((CMP_C1_REG(base) & CMP_C1_DACOE_MASK) >> CMP_C1_DACOE_SHIFT)
#define CMP_BRD_C1_DACOE(base) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_DACOE_SHIFT))

/*! @brief Set the DACOE field to a new value. */
#define CMP_WR_C1_DACOE(base, value) (CMP_RMW_C1(base, CMP_C1_DACOE_MASK, CMP_C1_DACOE(value)))
#define CMP_BWR_C1_DACOE(base, value) (BITBAND_ACCESS32(&CMP_C1_REG(base), CMP_C1_DACOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_C2 - CMP Control Register 2
 ******************************************************************************/

/*!
 * @brief CMP_C2 - CMP Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Access: Supervisor read/write User read/write
 */
/*!
 * @name Constants and macros for entire CMP_C2 register
 */
/*@{*/
#define CMP_RD_C2(base)          (CMP_C2_REG(base))
#define CMP_WR_C2(base, value)   (CMP_C2_REG(base) = (value))
#define CMP_RMW_C2(base, mask, value) (CMP_WR_C2(base, (CMP_RD_C2(base) & ~(mask)) | (value)))
#define CMP_SET_C2(base, value)  (CMP_WR_C2(base, CMP_RD_C2(base) |  (value)))
#define CMP_CLR_C2(base, value)  (CMP_WR_C2(base, CMP_RD_C2(base) & ~(value)))
#define CMP_TOG_C2(base, value)  (CMP_WR_C2(base, CMP_RD_C2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_C2 bitfields
 */

/*!
 * @name Register CMP_C2, field ACOn[7:0] (RW)
 *
 * The result of the input comparison for channel n . This field stores the
 * latest comparison result of the input channel n with the fixed mux port. Reading
 * this bit returns the latest comparison result. Writing this field defines the
 * pre-set state of channel n.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_ACOn field. */
#define CMP_RD_C2_ACOn(base) ((CMP_C2_REG(base) & CMP_C2_ACOn_MASK) >> CMP_C2_ACOn_SHIFT)
#define CMP_BRD_C2_ACOn(base) (CMP_RD_C2_ACOn(base))

/*! @brief Set the ACOn field to a new value. */
#define CMP_WR_C2_ACOn(base, value) (CMP_RMW_C2(base, (CMP_C2_ACOn_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_ACOn(value)))
#define CMP_BWR_C2_ACOn(base, value) (CMP_WR_C2_ACOn(base, value))
/*@}*/

/*!
 * @name Register CMP_C2, field INITMOD[13:8] (RW)
 *
 * These values specify the round robin clock cycles used to determine the
 * comparator and DAC initialization delays specified by the datasheet. For example
 * the initialization delay is 80us and the round robin clock is 100kHz, then
 * INITMOD should be set to 80us/10us = 8.
 *
 * Values:
 * - 0b000000 - The modulus is set to 64(same with 111111).
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_INITMOD field. */
#define CMP_RD_C2_INITMOD(base) ((CMP_C2_REG(base) & CMP_C2_INITMOD_MASK) >> CMP_C2_INITMOD_SHIFT)
#define CMP_BRD_C2_INITMOD(base) (CMP_RD_C2_INITMOD(base))

/*! @brief Set the INITMOD field to a new value. */
#define CMP_WR_C2_INITMOD(base, value) (CMP_RMW_C2(base, (CMP_C2_INITMOD_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_INITMOD(value)))
#define CMP_BWR_C2_INITMOD(base, value) (CMP_WR_C2_INITMOD(base, value))
/*@}*/

/*!
 * @name Register CMP_C2, field NSAM[15:14] (RW)
 *
 * For a given channel, this field specifies how many round-robin clock cycles
 * later the sample takes place.
 *
 * Values:
 * - 0b00 - The comparison result is sampled as soon as the active channel is
 *     scanned in one round-robin clock.
 * - 0b01 - The sampling takes place 1 round-robin clock cycle after the next
 *     cycle of the round-robin clock.
 * - 0b10 - The sampling takes place 2 round-robin clock cycles after the next
 *     cycle of the round-robin clock.
 * - 0b11 - The sampling takes place 3 round-robin clock cycles after the next
 *     cycle of the round-robin clock.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_NSAM field. */
#define CMP_RD_C2_NSAM(base) ((CMP_C2_REG(base) & CMP_C2_NSAM_MASK) >> CMP_C2_NSAM_SHIFT)
#define CMP_BRD_C2_NSAM(base) (CMP_RD_C2_NSAM(base))

/*! @brief Set the NSAM field to a new value. */
#define CMP_WR_C2_NSAM(base, value) (CMP_RMW_C2(base, (CMP_C2_NSAM_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_NSAM(value)))
#define CMP_BWR_C2_NSAM(base, value) (CMP_WR_C2_NSAM(base, value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH0F[16] (W1C)
 *
 * Channel 0 input changed flag. This bit is set If the channel 0 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH0F field. */
#define CMP_RD_C2_CH0F(base) ((CMP_C2_REG(base) & CMP_C2_CH0F_MASK) >> CMP_C2_CH0F_SHIFT)
#define CMP_BRD_C2_CH0F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH0F_SHIFT))

/*! @brief Set the CH0F field to a new value. */
#define CMP_WR_C2_CH0F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_CH0F(value)))
#define CMP_BWR_C2_CH0F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH0F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH1F[17] (W1C)
 *
 * Channel 1 input changed flag. This bit is set If the channel 1 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH1F field. */
#define CMP_RD_C2_CH1F(base) ((CMP_C2_REG(base) & CMP_C2_CH1F_MASK) >> CMP_C2_CH1F_SHIFT)
#define CMP_BRD_C2_CH1F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH1F_SHIFT))

/*! @brief Set the CH1F field to a new value. */
#define CMP_WR_C2_CH1F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH1F_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_CH1F(value)))
#define CMP_BWR_C2_CH1F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH2F[18] (W1C)
 *
 * Channel 2 input changed flag. This bit is set If the channel 2 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH2F field. */
#define CMP_RD_C2_CH2F(base) ((CMP_C2_REG(base) & CMP_C2_CH2F_MASK) >> CMP_C2_CH2F_SHIFT)
#define CMP_BRD_C2_CH2F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH2F_SHIFT))

/*! @brief Set the CH2F field to a new value. */
#define CMP_WR_C2_CH2F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH2F_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_CH2F(value)))
#define CMP_BWR_C2_CH2F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH2F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH3F[19] (W1C)
 *
 * Channel 3 input changed flag. This bit is set If the channel 3 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH3F field. */
#define CMP_RD_C2_CH3F(base) ((CMP_C2_REG(base) & CMP_C2_CH3F_MASK) >> CMP_C2_CH3F_SHIFT)
#define CMP_BRD_C2_CH3F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH3F_SHIFT))

/*! @brief Set the CH3F field to a new value. */
#define CMP_WR_C2_CH3F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH3F_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_CH3F(value)))
#define CMP_BWR_C2_CH3F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH3F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH4F[20] (W1C)
 *
 * Channel 4 input changed flag. This bit is set If the channel 4 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH4F field. */
#define CMP_RD_C2_CH4F(base) ((CMP_C2_REG(base) & CMP_C2_CH4F_MASK) >> CMP_C2_CH4F_SHIFT)
#define CMP_BRD_C2_CH4F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH4F_SHIFT))

/*! @brief Set the CH4F field to a new value. */
#define CMP_WR_C2_CH4F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH4F_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_CH4F(value)))
#define CMP_BWR_C2_CH4F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH4F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH5F[21] (W1C)
 *
 * Channel 5 input changed flag. This bit is set If the channel 5 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH5F field. */
#define CMP_RD_C2_CH5F(base) ((CMP_C2_REG(base) & CMP_C2_CH5F_MASK) >> CMP_C2_CH5F_SHIFT)
#define CMP_BRD_C2_CH5F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH5F_SHIFT))

/*! @brief Set the CH5F field to a new value. */
#define CMP_WR_C2_CH5F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH5F_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_CH5F(value)))
#define CMP_BWR_C2_CH5F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH5F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH6F[22] (W1C)
 *
 * Channel 6 input changed flag. This bit is set If the channel 6 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH6F field. */
#define CMP_RD_C2_CH6F(base) ((CMP_C2_REG(base) & CMP_C2_CH6F_MASK) >> CMP_C2_CH6F_SHIFT)
#define CMP_BRD_C2_CH6F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH6F_SHIFT))

/*! @brief Set the CH6F field to a new value. */
#define CMP_WR_C2_CH6F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH6F_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH7F_MASK), CMP_C2_CH6F(value)))
#define CMP_BWR_C2_CH6F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH6F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field CH7F[23] (W1C)
 *
 * Channel 7 input changed flag. This bit is set If the channel 7 input changed
 * from the last comparison with the fixed mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_CH7F field. */
#define CMP_RD_C2_CH7F(base) ((CMP_C2_REG(base) & CMP_C2_CH7F_MASK) >> CMP_C2_CH7F_SHIFT)
#define CMP_BRD_C2_CH7F(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH7F_SHIFT))

/*! @brief Set the CH7F field to a new value. */
#define CMP_WR_C2_CH7F(base, value) (CMP_RMW_C2(base, (CMP_C2_CH7F_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK), CMP_C2_CH7F(value)))
#define CMP_BWR_C2_CH7F(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_CH7F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field FXMXCH[27:25] (RW)
 *
 * This field indicates which channel in the mux port is fixed in a given
 * round-robin mode. If FXDACI is set, FXMXCH has no effect.
 *
 * Values:
 * - 0b000 - Channel 0 is selected as the fixed reference input for the fixed
 *     mux port.
 * - 0b001 - Channel 1 is selected as the fixed reference input for the fixed
 *     mux port.
 * - 0b010 - Channel 2 is selected as the fixed reference input for the fixed
 *     mux port.
 * - 0b011 - Channel 3 is selected as the fixed reference input for the fixed
 *     mux port.
 * - 0b100 - Channel 4 is selected as the fixed reference input for the fixed
 *     mux port.
 * - 0b101 - Channel 5 is selected as the fixed reference input for the fixed
 *     mux port.
 * - 0b110 - Channel 6 is selected as the fixed reference input for the fixed
 *     mux port.
 * - 0b111 - Channel 7 is selected as the fixed reference input for the fixed
 *     mux port.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_FXMXCH field. */
#define CMP_RD_C2_FXMXCH(base) ((CMP_C2_REG(base) & CMP_C2_FXMXCH_MASK) >> CMP_C2_FXMXCH_SHIFT)
#define CMP_BRD_C2_FXMXCH(base) (CMP_RD_C2_FXMXCH(base))

/*! @brief Set the FXMXCH field to a new value. */
#define CMP_WR_C2_FXMXCH(base, value) (CMP_RMW_C2(base, (CMP_C2_FXMXCH_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_FXMXCH(value)))
#define CMP_BWR_C2_FXMXCH(base, value) (CMP_WR_C2_FXMXCH(base, value))
/*@}*/

/*!
 * @name Register CMP_C2, field FXMP[29] (RW)
 *
 * This bit is used to fix the analog mux port for the round-robin mode.
 *
 * Values:
 * - 0b0 - The Plus port is fixed. Only the inputs to the Minus port are swept
 *     in each round.
 * - 0b1 - The Minus port is fixed. Only the inputs to the Plus port are swept
 *     in each round.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_FXMP field. */
#define CMP_RD_C2_FXMP(base) ((CMP_C2_REG(base) & CMP_C2_FXMP_MASK) >> CMP_C2_FXMP_SHIFT)
#define CMP_BRD_C2_FXMP(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_FXMP_SHIFT))

/*! @brief Set the FXMP field to a new value. */
#define CMP_WR_C2_FXMP(base, value) (CMP_RMW_C2(base, (CMP_C2_FXMP_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_FXMP(value)))
#define CMP_BWR_C2_FXMP(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_FXMP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field RRIE[30] (RW)
 *
 * This bit enables the interrupt/wake-up when the comparison result changes for
 * a given channel.
 *
 * Values:
 * - 0b0 - The round-robin interrupt is disabled.
 * - 0b1 - The round-robin interrupt is enabled when a comparison result changes
 *     from the last sample.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_RRIE field. */
#define CMP_RD_C2_RRIE(base) ((CMP_C2_REG(base) & CMP_C2_RRIE_MASK) >> CMP_C2_RRIE_SHIFT)
#define CMP_BRD_C2_RRIE(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_RRIE_SHIFT))

/*! @brief Set the RRIE field to a new value. */
#define CMP_WR_C2_RRIE(base, value) (CMP_RMW_C2(base, (CMP_C2_RRIE_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_RRIE(value)))
#define CMP_BWR_C2_RRIE(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_RRIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_C2, field RRE[31] (RW)
 *
 * This bit enables the round-robin operation.
 *
 * Values:
 * - 0b0 - Round-robin operation is disabled.
 * - 0b1 - Round-robin operation is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_C2_RRE field. */
#define CMP_RD_C2_RRE(base)  ((CMP_C2_REG(base) & CMP_C2_RRE_MASK) >> CMP_C2_RRE_SHIFT)
#define CMP_BRD_C2_RRE(base) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_RRE_SHIFT))

/*! @brief Set the RRE field to a new value. */
#define CMP_WR_C2_RRE(base, value) (CMP_RMW_C2(base, (CMP_C2_RRE_MASK | CMP_C2_CH0F_MASK | CMP_C2_CH1F_MASK | CMP_C2_CH2F_MASK | CMP_C2_CH3F_MASK | CMP_C2_CH4F_MASK | CMP_C2_CH5F_MASK | CMP_C2_CH6F_MASK | CMP_C2_CH7F_MASK), CMP_C2_RRE(value)))
#define CMP_BWR_C2_RRE(base, value) (BITBAND_ACCESS32(&CMP_C2_REG(base), CMP_C2_RRE_SHIFT) = (value))
/*@}*/

/*
 * S32K144 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - CRC_DATA - CRC Data register
 * - CRC_GPOLY - CRC Polynomial register
 * - CRC_CTRL - CRC Control register
 */

#define CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define CRC_IDX (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * CRC_DATA - CRC Data register
 ******************************************************************************/

/*!
 * @brief CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC Data register contains the value of the seed, data, and checksum.
 * When CTRL[WAS] is set, any write to the data register is regarded as the seed
 * value. When CTRL[WAS] is cleared, any write to the data register is regarded as
 * data for general CRC computation. In 16-bit CRC mode, the HU and HL fields are
 * not used for programming the seed value, and reads of these fields return an
 * indeterminate value. In 32-bit CRC mode, all fields are used for programming
 * the seed value. When programming data values, the values can be written 8 bits,
 * 16 bits, or 32 bits at a time, provided all bytes are contiguous; with MSB of
 * data value written first. After all data values are written, the CRC result
 * can be read from this data register. In 16-bit CRC mode, the CRC result is
 * available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value,
 * provided the CRC module is configured.
 */
/*!
 * @name Constants and macros for entire CRC_DATA register
 */
/*@{*/
#define CRC_RD_DATA(base)        (CRC_DATA_REG(base))
#define CRC_WR_DATA(base, value) (CRC_DATA_REG(base) = (value))
#define CRC_RMW_DATA(base, mask, value) (CRC_WR_DATA(base, (CRC_RD_DATA(base) & ~(mask)) | (value)))
#define CRC_SET_DATA(base, value) (CRC_WR_DATA(base, CRC_RD_DATA(base) |  (value)))
#define CRC_CLR_DATA(base, value) (CRC_WR_DATA(base, CRC_RD_DATA(base) & ~(value)))
#define CRC_TOG_DATA(base, value) (CRC_WR_DATA(base, CRC_RD_DATA(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATA bitfields
 */

/*!
 * @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LL field. */
#define CRC_RD_DATA_LL(base) ((CRC_DATA_REG(base) & CRC_DATA_LL_MASK) >> CRC_DATA_LL_SHIFT)
#define CRC_BRD_DATA_LL(base) (CRC_RD_DATA_LL(base))

/*! @brief Set the LL field to a new value. */
#define CRC_WR_DATA_LL(base, value) (CRC_RMW_DATA(base, CRC_DATA_LL_MASK, CRC_DATA_LL(value)))
#define CRC_BWR_DATA_LL(base, value) (CRC_WR_DATA_LL(base, value))
/*@}*/

/*!
 * @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LU field. */
#define CRC_RD_DATA_LU(base) ((CRC_DATA_REG(base) & CRC_DATA_LU_MASK) >> CRC_DATA_LU_SHIFT)
#define CRC_BRD_DATA_LU(base) (CRC_RD_DATA_LU(base))

/*! @brief Set the LU field to a new value. */
#define CRC_WR_DATA_LU(base, value) (CRC_RMW_DATA(base, CRC_DATA_LU_MASK, CRC_DATA_LU(value)))
#define CRC_BWR_DATA_LU(base, value) (CRC_WR_DATA_LU(base, value))
/*@}*/

/*!
 * @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HL field. */
#define CRC_RD_DATA_HL(base) ((CRC_DATA_REG(base) & CRC_DATA_HL_MASK) >> CRC_DATA_HL_SHIFT)
#define CRC_BRD_DATA_HL(base) (CRC_RD_DATA_HL(base))

/*! @brief Set the HL field to a new value. */
#define CRC_WR_DATA_HL(base, value) (CRC_RMW_DATA(base, CRC_DATA_HL_MASK, CRC_DATA_HL(value)))
#define CRC_BWR_DATA_HL(base, value) (CRC_WR_DATA_HL(base, value))
/*@}*/

/*!
 * @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HU field. */
#define CRC_RD_DATA_HU(base) ((CRC_DATA_REG(base) & CRC_DATA_HU_MASK) >> CRC_DATA_HU_SHIFT)
#define CRC_BRD_DATA_HU(base) (CRC_RD_DATA_HU(base))

/*! @brief Set the HU field to a new value. */
#define CRC_WR_DATA_HU(base, value) (CRC_RMW_DATA(base, CRC_DATA_HU_MASK, CRC_DATA_HU(value)))
#define CRC_BWR_DATA_HU(base, value) (CRC_WR_DATA_HU(base, value))
/*@}*/

/*******************************************************************************
 * CRC_GPOLY - CRC Polynomial register
 ******************************************************************************/

/*!
 * @brief CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define CRC_RD_GPOLY(base)       (CRC_GPOLY_REG(base))
#define CRC_WR_GPOLY(base, value) (CRC_GPOLY_REG(base) = (value))
#define CRC_RMW_GPOLY(base, mask, value) (CRC_WR_GPOLY(base, (CRC_RD_GPOLY(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) |  (value)))
#define CRC_CLR_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) & ~(value)))
#define CRC_TOG_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define CRC_RD_GPOLY_LOW(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_LOW_MASK) >> CRC_GPOLY_LOW_SHIFT)
#define CRC_BRD_GPOLY_LOW(base) (CRC_RD_GPOLY_LOW(base))

/*! @brief Set the LOW field to a new value. */
#define CRC_WR_GPOLY_LOW(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_LOW_MASK, CRC_GPOLY_LOW(value)))
#define CRC_BWR_GPOLY_LOW(base, value) (CRC_WR_GPOLY_LOW(base, value))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not
 * writable in 16-bit CRC mode (CTRL[TCRC] is 0).
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define CRC_RD_GPOLY_HIGH(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_HIGH_MASK) >> CRC_GPOLY_HIGH_SHIFT)
#define CRC_BRD_GPOLY_HIGH(base) (CRC_RD_GPOLY_HIGH(base))

/*! @brief Set the HIGH field to a new value. */
#define CRC_WR_GPOLY_HIGH(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_HIGH_MASK, CRC_GPOLY_HIGH(value)))
#define CRC_BWR_GPOLY_HIGH(base, value) (CRC_WR_GPOLY_HIGH(base, value))
/*@}*/

/*******************************************************************************
 * CRC_CTRL - CRC Control register
 ******************************************************************************/

/*!
 * @brief CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting CTRL[WAS] and then writing the seed into
 * the CRC data register.
 */
/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define CRC_RD_CTRL(base)        (CRC_CTRL_REG(base))
#define CRC_WR_CTRL(base, value) (CRC_CTRL_REG(base) = (value))
#define CRC_RMW_CTRL(base, mask, value) (CRC_WR_CTRL(base, (CRC_RD_CTRL(base) & ~(mask)) | (value)))
#define CRC_SET_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) |  (value)))
#define CRC_CLR_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) & ~(value)))
#define CRC_TOG_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0b0 - 16-bit CRC protocol.
 * - 0b1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define CRC_RD_CTRL_TCRC(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TCRC_MASK) >> CRC_CTRL_TCRC_SHIFT)
#define CRC_BRD_CTRL_TCRC(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRL_TCRC(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TCRC_MASK, CRC_CTRL_TCRC(value)))
#define CRC_BWR_CTRL_TCRC(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed
 * value. When deasserted, a value written to the CRC data register is taken as
 * data for CRC computation.
 *
 * Values:
 * - 0b0 - Writes to the CRC data register are data values.
 * - 0b1 - Writes to the CRC data register are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define CRC_RD_CTRL_WAS(base) ((CRC_CTRL_REG(base) & CRC_CTRL_WAS_MASK) >> CRC_CTRL_WAS_SHIFT)
#define CRC_BRD_CTRL_WAS(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRL_WAS(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_WAS_MASK, CRC_CTRL_WAS(value)))
#define CRC_BWR_CTRL_WAS(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0b0 - No XOR on reading.
 * - 0b1 - Invert or complement the read value of the CRC Data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define CRC_RD_CTRL_FXOR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_FXOR_MASK) >> CRC_CTRL_FXOR_SHIFT)
#define CRC_BRD_CTRL_FXOR(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRL_FXOR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_FXOR_MASK, CRC_CTRL_FXOR(value)))
#define CRC_BWR_CTRL_FXOR(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * Identifies the transpose configuration of the value read from the CRC Data
 * register. See the description of the transpose feature for the available
 * transpose options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define CRC_RD_CTRL_TOTR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT)
#define CRC_BRD_CTRL_TOTR(base) (CRC_RD_CTRL_TOTR(base))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRL_TOTR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOTR_MASK, CRC_CTRL_TOTR(value)))
#define CRC_BWR_CTRL_TOTR(base, value) (CRC_WR_CTRL_TOTR(base, value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * Defines the transpose configuration of the data written to the CRC data
 * register. See the description of the transpose feature for the available transpose
 * options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define CRC_RD_CTRL_TOT(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOT_MASK) >> CRC_CTRL_TOT_SHIFT)
#define CRC_BRD_CTRL_TOT(base) (CRC_RD_CTRL_TOT(base))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRL_TOT(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOT_MASK, CRC_CTRL_TOT(value)))
#define CRC_BWR_CTRL_TOT(base, value) (CRC_WR_CTRL_TOT(base, value))
/*@}*/

/*
 * S32K144 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - DMA_CR - Control Register
 * - DMA_ES - Error Status Register
 * - DMA_ERQ - Enable Request Register
 * - DMA_EEI - Enable Error Interrupt Register
 * - DMA_CEEI - Clear Enable Error Interrupt Register
 * - DMA_SEEI - Set Enable Error Interrupt Register
 * - DMA_CERQ - Clear Enable Request Register
 * - DMA_SERQ - Set Enable Request Register
 * - DMA_CDNE - Clear DONE Status Bit Register
 * - DMA_SSRT - Set START Bit Register
 * - DMA_CERR - Clear Error Register
 * - DMA_CINT - Clear Interrupt Request Register
 * - DMA_INT - Interrupt Request Register
 * - DMA_ERR - Error Register
 * - DMA_HRS - Hardware Request Status Register
 * - DMA_EARS - Enable Asynchronous Request in Stop Register
 * - DMA_DCHPRI - Channel n Priority Register
 * - DMA_TCD0_SADDR - TCD Source Address
 * - DMA_TCD0_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD0_ATTR - TCD Transfer Attributes
 * - DMA_TCD0_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD0_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD0_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD0_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD0_DADDR - TCD Destination Address
 * - DMA_TCD0_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD0_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD0_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD0_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD0_CSR - TCD Control and Status
 * - DMA_TCD0_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD0_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD1_SADDR - TCD Source Address
 * - DMA_TCD1_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD1_ATTR - TCD Transfer Attributes
 * - DMA_TCD1_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD1_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD1_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD1_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD1_DADDR - TCD Destination Address
 * - DMA_TCD1_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD1_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD1_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD1_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD1_CSR - TCD Control and Status
 * - DMA_TCD1_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD1_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD2_SADDR - TCD Source Address
 * - DMA_TCD2_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD2_ATTR - TCD Transfer Attributes
 * - DMA_TCD2_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD2_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD2_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD2_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD2_DADDR - TCD Destination Address
 * - DMA_TCD2_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD2_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD2_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD2_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD2_CSR - TCD Control and Status
 * - DMA_TCD2_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD2_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD3_SADDR - TCD Source Address
 * - DMA_TCD3_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD3_ATTR - TCD Transfer Attributes
 * - DMA_TCD3_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD3_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD3_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD3_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD3_DADDR - TCD Destination Address
 * - DMA_TCD3_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD3_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD3_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD3_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD3_CSR - TCD Control and Status
 * - DMA_TCD3_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD3_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD4_SADDR - TCD Source Address
 * - DMA_TCD4_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD4_ATTR - TCD Transfer Attributes
 * - DMA_TCD4_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD4_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD4_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD4_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD4_DADDR - TCD Destination Address
 * - DMA_TCD4_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD4_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD4_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD4_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD4_CSR - TCD Control and Status
 * - DMA_TCD4_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD4_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD5_SADDR - TCD Source Address
 * - DMA_TCD5_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD5_ATTR - TCD Transfer Attributes
 * - DMA_TCD5_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD5_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD5_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD5_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD5_DADDR - TCD Destination Address
 * - DMA_TCD5_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD5_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD5_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD5_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD5_CSR - TCD Control and Status
 * - DMA_TCD5_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD5_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD6_SADDR - TCD Source Address
 * - DMA_TCD6_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD6_ATTR - TCD Transfer Attributes
 * - DMA_TCD6_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD6_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD6_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD6_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD6_DADDR - TCD Destination Address
 * - DMA_TCD6_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD6_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD6_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD6_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD6_CSR - TCD Control and Status
 * - DMA_TCD6_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD6_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD7_SADDR - TCD Source Address
 * - DMA_TCD7_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD7_ATTR - TCD Transfer Attributes
 * - DMA_TCD7_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD7_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD7_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD7_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD7_DADDR - TCD Destination Address
 * - DMA_TCD7_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD7_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD7_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD7_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD7_CSR - TCD Control and Status
 * - DMA_TCD7_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD7_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD8_SADDR - TCD Source Address
 * - DMA_TCD8_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD8_ATTR - TCD Transfer Attributes
 * - DMA_TCD8_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD8_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD8_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD8_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD8_DADDR - TCD Destination Address
 * - DMA_TCD8_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD8_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD8_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD8_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD8_CSR - TCD Control and Status
 * - DMA_TCD8_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD8_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD9_SADDR - TCD Source Address
 * - DMA_TCD9_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD9_ATTR - TCD Transfer Attributes
 * - DMA_TCD9_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD9_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD9_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD9_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD9_DADDR - TCD Destination Address
 * - DMA_TCD9_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD9_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD9_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD9_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD9_CSR - TCD Control and Status
 * - DMA_TCD9_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD9_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD10_SADDR - TCD Source Address
 * - DMA_TCD10_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD10_ATTR - TCD Transfer Attributes
 * - DMA_TCD10_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD10_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD10_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD10_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD10_DADDR - TCD Destination Address
 * - DMA_TCD10_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD10_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD10_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD10_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD10_CSR - TCD Control and Status
 * - DMA_TCD10_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD10_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD11_SADDR - TCD Source Address
 * - DMA_TCD11_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD11_ATTR - TCD Transfer Attributes
 * - DMA_TCD11_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD11_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD11_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD11_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD11_DADDR - TCD Destination Address
 * - DMA_TCD11_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD11_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD11_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD11_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD11_CSR - TCD Control and Status
 * - DMA_TCD11_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD11_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD12_SADDR - TCD Source Address
 * - DMA_TCD12_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD12_ATTR - TCD Transfer Attributes
 * - DMA_TCD12_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD12_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD12_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD12_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD12_DADDR - TCD Destination Address
 * - DMA_TCD12_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD12_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD12_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD12_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD12_CSR - TCD Control and Status
 * - DMA_TCD12_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD12_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD13_SADDR - TCD Source Address
 * - DMA_TCD13_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD13_ATTR - TCD Transfer Attributes
 * - DMA_TCD13_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD13_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD13_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD13_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD13_DADDR - TCD Destination Address
 * - DMA_TCD13_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD13_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD13_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD13_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD13_CSR - TCD Control and Status
 * - DMA_TCD13_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD13_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD14_SADDR - TCD Source Address
 * - DMA_TCD14_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD14_ATTR - TCD Transfer Attributes
 * - DMA_TCD14_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD14_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD14_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD14_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD14_DADDR - TCD Destination Address
 * - DMA_TCD14_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD14_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD14_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD14_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD14_CSR - TCD Control and Status
 * - DMA_TCD14_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD14_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD15_SADDR - TCD Source Address
 * - DMA_TCD15_SOFF - TCD Signed Source Address Offset
 * - DMA_TCD15_ATTR - TCD Transfer Attributes
 * - DMA_TCD15_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_TCD15_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_TCD15_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_TCD15_SLAST - TCD Last Source Address Adjustment
 * - DMA_TCD15_DADDR - TCD Destination Address
 * - DMA_TCD15_DOFF - TCD Signed Destination Address Offset
 * - DMA_TCD15_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD15_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_TCD15_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_TCD15_CSR - TCD Control and Status
 * - DMA_TCD15_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_TCD15_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 */

#define DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define DMA_IDX (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * DMA_CR - Control Register
 ******************************************************************************/

/*!
 * @brief DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CR defines the basic operating configuration of the DMA. Arbitration can
 * be configured to use either a fixed-priority or a round-robin scheme. For
 * fixed-priority arbitration, the highest priority channel requesting service is
 * selected to execute. The channel priority registers assign the priorities; see
 * the DCHPRIn registers. For round-robin arbitration, the channel priorities are
 * ignored and channels are cycled through (from high to low channel number)
 * without regard to priority. For correct operation, writes to the CR register must
 * be performed only when the DMA channels are inactive; that is, when
 * TCDn_CSR[ACTIVE] bits are cleared. Minor loop offsets are address offset values added to
 * the final source address (TCDn_SADDR) or destination address (TCDn_DADDR) upon
 * minor loop completion. When minor loop offsets are enabled, the minor loop
 * offset (MLOFF) is added to the final source address (TCDn_SADDR), to the final
 * destination address (TCDn_DADDR), or to both prior to the addresses being
 * written back into the TCD. If the major loop is complete, the minor loop offset is
 * ignored and the major loop address offsets (TCDn_SLAST and TCDn_DLAST_SGA) are
 * used to compute the next TCDn_SADDR and TCDn_DADDR values. When minor loop
 * mapping is enabled (EMLM is 1), TCDn word2 is redefined. A portion of TCDn word2
 * is used to specify multiple fields: a source enable bit (SMLOE) to specify
 * the minor loop offset should be applied to the source address (TCDn_SADDR) upon
 * minor loop completion, a destination enable bit (DMLOE) to specify the minor
 * loop offset should be applied to the destination address (TCDn_DADDR) upon
 * minor loop completion, and the sign extended minor loop offset value (MLOFF). The
 * same offset value (MLOFF) is used for both source and destination minor loop
 * offsets. When either minor loop offset is enabled (SMLOE set or DMLOE set), the
 * NBYTES field is reduced to 10 bits. When both minor loop offsets are disabled
 * (SMLOE cleared and DMLOE cleared), the NBYTES field is a 30-bit vector. When
 * minor loop mapping is disabled (EMLM is 0), all 32 bits of TCDn word2 are
 * assigned to the NBYTES field.
 */
/*!
 * @name Constants and macros for entire DMA_CR register
 */
/*@{*/
#define DMA_RD_CR(base)          (DMA_CR_REG(base))
#define DMA_WR_CR(base, value)   (DMA_CR_REG(base) = (value))
#define DMA_RMW_CR(base, mask, value) (DMA_WR_CR(base, (DMA_RD_CR(base) & ~(mask)) | (value)))
#define DMA_SET_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) |  (value)))
#define DMA_CLR_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) & ~(value)))
#define DMA_TOG_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CR bitfields
 */

/*!
 * @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0b0 - When in debug mode, the DMA continues to operate.
 * - 0b1 - When in debug mode, the DMA stalls the start of a new channel.
 *     Executing channels are allowed to complete. Channel execution resumes when the
 *     system exits debug mode or the EDBG bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EDBG field. */
#define DMA_RD_CR_EDBG(base) ((DMA_CR_REG(base) & DMA_CR_EDBG_MASK) >> DMA_CR_EDBG_SHIFT)
#define DMA_BRD_CR_EDBG(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT))

/*! @brief Set the EDBG field to a new value. */
#define DMA_WR_CR_EDBG(base, value) (DMA_RMW_CR(base, DMA_CR_EDBG_MASK, DMA_CR_EDBG(value)))
#define DMA_BWR_CR_EDBG(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0b0 - Fixed priority arbitration is used for channel selection .
 * - 0b1 - Round robin arbitration is used for channel selection .
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ERCA field. */
#define DMA_RD_CR_ERCA(base) ((DMA_CR_REG(base) & DMA_CR_ERCA_MASK) >> DMA_CR_ERCA_SHIFT)
#define DMA_BRD_CR_ERCA(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT))

/*! @brief Set the ERCA field to a new value. */
#define DMA_WR_CR_ERCA(base, value) (DMA_RMW_CR(base, DMA_CR_ERCA_MASK, DMA_CR_ERCA(value)))
#define DMA_BWR_CR_ERCA(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Any error causes the HALT bit to set. Subsequently, all service
 *     requests are ignored until the HALT bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HOE field. */
#define DMA_RD_CR_HOE(base)  ((DMA_CR_REG(base) & DMA_CR_HOE_MASK) >> DMA_CR_HOE_SHIFT)
#define DMA_BRD_CR_HOE(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT))

/*! @brief Set the HOE field to a new value. */
#define DMA_WR_CR_HOE(base, value) (DMA_RMW_CR(base, DMA_CR_HOE_MASK, DMA_CR_HOE(value)))
#define DMA_BWR_CR_HOE(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Stall the start of any new channels. Executing channels are allowed
 *     to complete. Channel execution resumes when this bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HALT field. */
#define DMA_RD_CR_HALT(base) ((DMA_CR_REG(base) & DMA_CR_HALT_MASK) >> DMA_CR_HALT_SHIFT)
#define DMA_BRD_CR_HALT(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT))

/*! @brief Set the HALT field to a new value. */
#define DMA_WR_CR_HALT(base, value) (DMA_RMW_CR(base, DMA_CR_HALT_MASK, DMA_CR_HALT(value)))
#define DMA_BWR_CR_HALT(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field CLM[6] (RW)
 *
 * Do not use continuous link mode with a channel linking to itself if there is
 * only one minor loop iteration per service request. If the channel's NBYTES
 * value is the same as either the source or destination size, do not use channel
 * linking to itself. The same data transfer profile can be achieved by simply
 * increasing the NBYTES value. A larger NBYTES value provides more efficient, faster
 * processing.
 *
 * Values:
 * - 0b0 - A minor loop channel link made to itself goes through channel
 *     arbitration before being activated again.
 * - 0b1 - A minor loop channel link made to itself does not go through channel
 *     arbitration before being activated again. Upon minor loop completion, the
 *     channel activates again if that channel has a minor loop channel link
 *     enabled and the link channel is itself. This effectively applies the minor
 *     loop offsets and restarts the next minor loop.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CLM field. */
#define DMA_RD_CR_CLM(base)  ((DMA_CR_REG(base) & DMA_CR_CLM_MASK) >> DMA_CR_CLM_SHIFT)
#define DMA_BRD_CR_CLM(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT))

/*! @brief Set the CLM field to a new value. */
#define DMA_WR_CR_CLM(base, value) (DMA_RMW_CR(base, DMA_CR_CLM_MASK, DMA_CR_CLM(value)))
#define DMA_BWR_CR_CLM(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0b0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 0b1 - Enabled. TCDn.word2 is redefined to include individual enable fields,
 *     an offset field, and the NBYTES field. The individual enable fields allow
 *     the minor loop offset to be applied to the source address, the
 *     destination address, or both. The NBYTES field is reduced when either offset is
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EMLM field. */
#define DMA_RD_CR_EMLM(base) ((DMA_CR_REG(base) & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT)
#define DMA_BRD_CR_EMLM(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT))

/*! @brief Set the EMLM field to a new value. */
#define DMA_WR_CR_EMLM(base, value) (DMA_RMW_CR(base, DMA_CR_EMLM_MASK, DMA_CR_EMLM(value)))
#define DMA_BWR_CR_EMLM(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Cancel the remaining data transfer in the same fashion as the CX bit.
 *     Stop the executing channel and force the minor loop to finish. The cancel
 *     takes effect after the last write of the current read/write sequence. The
 *     ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus
 *     updating the Error Status register (DMAx_ES) and generating an optional error
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ECX field. */
#define DMA_RD_CR_ECX(base)  ((DMA_CR_REG(base) & DMA_CR_ECX_MASK) >> DMA_CR_ECX_SHIFT)
#define DMA_BRD_CR_ECX(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT))

/*! @brief Set the ECX field to a new value. */
#define DMA_WR_CR_ECX(base, value) (DMA_RMW_CR(base, DMA_CR_ECX_MASK, DMA_CR_ECX(value)))
#define DMA_BWR_CR_ECX(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Cancel the remaining data transfer. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write
 *     of the current read/write sequence. The CX bit clears itself after the
 *     cancel has been honored. This cancel retires the channel normally as if the
 *     minor loop was completed.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CX field. */
#define DMA_RD_CR_CX(base)   ((DMA_CR_REG(base) & DMA_CR_CX_MASK) >> DMA_CR_CX_SHIFT)
#define DMA_BRD_CR_CX(base)  (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT))

/*! @brief Set the CX field to a new value. */
#define DMA_WR_CR_CX(base, value) (DMA_RMW_CR(base, DMA_CR_CX_MASK, DMA_CR_CX(value)))
#define DMA_BWR_CR_CX(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_ES - Error Status Register
 ******************************************************************************/

/*!
 * @brief DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error.
 * Channel errors can be caused by: A configuration error, that is: An illegal setting
 * in the transfer-control descriptor, or An illegal priority register setting
 * in fixed-arbitration An error termination to a bus master read or write cycle
 * See the Error Reporting and Handling section for more details.
 */
/*!
 * @name Constants and macros for entire DMA_ES register
 */
/*@{*/
#define DMA_RD_ES(base)          (DMA_ES_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_ES bitfields
 */

/*!
 * @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0b0 - No destination bus error
 * - 0b1 - The last recorded error was a bus error on a destination write
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DBE field. */
#define DMA_RD_ES_DBE(base)  ((DMA_ES_REG(base) & DMA_ES_DBE_MASK) >> DMA_ES_DBE_SHIFT)
#define DMA_BRD_ES_DBE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DBE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0b0 - No source bus error
 * - 0b1 - The last recorded error was a bus error on a source read
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SBE field. */
#define DMA_RD_ES_SBE(base)  ((DMA_ES_REG(base) & DMA_ES_SBE_MASK) >> DMA_ES_SBE_SHIFT)
#define DMA_BRD_ES_SBE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SBE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0b0 - No scatter/gather configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DLASTSGA field. This field is checked at the beginning of a
 *     scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled.
 *     TCDn_DLASTSGA is not on a 32 byte boundary.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SGE field. */
#define DMA_RD_ES_SGE(base)  ((DMA_ES_REG(base) & DMA_ES_SGE_MASK) >> DMA_ES_SGE_SHIFT)
#define DMA_BRD_ES_SGE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SGE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0b0 - No NBYTES/CITER configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of
 *     TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or
 *     TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_NCE field. */
#define DMA_RD_ES_NCE(base)  ((DMA_ES_REG(base) & DMA_ES_NCE_MASK) >> DMA_ES_NCE_SHIFT)
#define DMA_BRD_ES_NCE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_NCE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0b0 - No destination offset configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DOE field. */
#define DMA_RD_ES_DOE(base)  ((DMA_ES_REG(base) & DMA_ES_DOE_MASK) >> DMA_ES_DOE_SHIFT)
#define DMA_BRD_ES_DOE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DOE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0b0 - No destination address configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DAE field. */
#define DMA_RD_ES_DAE(base)  ((DMA_ES_REG(base) & DMA_ES_DAE_MASK) >> DMA_ES_DAE_SHIFT)
#define DMA_BRD_ES_DAE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DAE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0b0 - No source offset configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SOE field. */
#define DMA_RD_ES_SOE(base)  ((DMA_ES_REG(base) & DMA_ES_SOE_MASK) >> DMA_ES_SOE_SHIFT)
#define DMA_BRD_ES_SOE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SOE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0b0 - No source address configuration error.
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SAE field. */
#define DMA_RD_ES_SAE(base)  ((DMA_ES_REG(base) & DMA_ES_SAE_MASK) >> DMA_ES_SAE_SHIFT)
#define DMA_BRD_ES_SAE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SAE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field ERRCHN[11:8] (RO)
 *
 * The channel number of the last recorded error, excluding CPE errors, or last
 * recorded error canceled transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ERRCHN field. */
#define DMA_RD_ES_ERRCHN(base) ((DMA_ES_REG(base) & DMA_ES_ERRCHN_MASK) >> DMA_ES_ERRCHN_SHIFT)
#define DMA_BRD_ES_ERRCHN(base) (DMA_RD_ES_ERRCHN(base))
/*@}*/

/*!
 * @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0b0 - No channel priority error
 * - 0b1 - The last recorded error was a configuration error in the channel
 *     priorities . Channel priorities are not unique.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_CPE field. */
#define DMA_RD_ES_CPE(base)  ((DMA_ES_REG(base) & DMA_ES_CPE_MASK) >> DMA_ES_CPE_SHIFT)
#define DMA_BRD_ES_CPE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_CPE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0b0 - No canceled transfers
 * - 0b1 - The last recorded entry was a canceled transfer by the error cancel
 *     transfer input
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ECX field. */
#define DMA_RD_ES_ECX(base)  ((DMA_ES_REG(base) & DMA_ES_ECX_MASK) >> DMA_ES_ECX_SHIFT)
#define DMA_BRD_ES_ECX(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_ECX_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0b0 - No ERR bits are set.
 * - 0b1 - At least one ERR bit is set indicating a valid error exists that has
 *     not been cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_VLD field. */
#define DMA_RD_ES_VLD(base)  ((DMA_ES_REG(base) & DMA_ES_VLD_MASK) >> DMA_ES_VLD_SHIFT)
#define DMA_BRD_ES_VLD(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_VLD_SHIFT))
/*@}*/

/*******************************************************************************
 * DMA_ERQ - Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provides a bit map for the 16 channels to enable the request
 * signal for each channel. The state of any given channel enable is directly
 * affected by writes to this register; it is also affected by writes to the SERQ
 * and CERQ registers. These registers are provided so the request enable for a
 * single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable request
 * flag must be asserted before a channel's hardware service request is accepted.
 * The state of the DMA enable request flag does not affect a channel service
 * request made explicitly through software or a linked channel request.
 */
/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
/*@{*/
#define DMA_RD_ERQ(base)         (DMA_ERQ_REG(base))
#define DMA_WR_ERQ(base, value)  (DMA_ERQ_REG(base) = (value))
#define DMA_RMW_ERQ(base, mask, value) (DMA_WR_ERQ(base, (DMA_RD_ERQ(base) & ~(mask)) | (value)))
#define DMA_SET_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) |  (value)))
#define DMA_CLR_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) & ~(value)))
#define DMA_TOG_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERQ bitfields
 */

/*!
 * @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ0 field. */
#define DMA_RD_ERQ_ERQ0(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ0_MASK) >> DMA_ERQ_ERQ0_SHIFT)
#define DMA_BRD_ERQ_ERQ0(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT))

/*! @brief Set the ERQ0 field to a new value. */
#define DMA_WR_ERQ_ERQ0(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ0_MASK, DMA_ERQ_ERQ0(value)))
#define DMA_BWR_ERQ_ERQ0(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ1 field. */
#define DMA_RD_ERQ_ERQ1(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ1_MASK) >> DMA_ERQ_ERQ1_SHIFT)
#define DMA_BRD_ERQ_ERQ1(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT))

/*! @brief Set the ERQ1 field to a new value. */
#define DMA_WR_ERQ_ERQ1(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ1_MASK, DMA_ERQ_ERQ1(value)))
#define DMA_BWR_ERQ_ERQ1(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ2 field. */
#define DMA_RD_ERQ_ERQ2(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ2_MASK) >> DMA_ERQ_ERQ2_SHIFT)
#define DMA_BRD_ERQ_ERQ2(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT))

/*! @brief Set the ERQ2 field to a new value. */
#define DMA_WR_ERQ_ERQ2(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ2_MASK, DMA_ERQ_ERQ2(value)))
#define DMA_BWR_ERQ_ERQ2(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ3 field. */
#define DMA_RD_ERQ_ERQ3(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ3_MASK) >> DMA_ERQ_ERQ3_SHIFT)
#define DMA_BRD_ERQ_ERQ3(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT))

/*! @brief Set the ERQ3 field to a new value. */
#define DMA_WR_ERQ_ERQ3(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ3_MASK, DMA_ERQ_ERQ3(value)))
#define DMA_BWR_ERQ_ERQ3(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ4[4] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ4 field. */
#define DMA_RD_ERQ_ERQ4(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ4_MASK) >> DMA_ERQ_ERQ4_SHIFT)
#define DMA_BRD_ERQ_ERQ4(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ4_SHIFT))

/*! @brief Set the ERQ4 field to a new value. */
#define DMA_WR_ERQ_ERQ4(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ4_MASK, DMA_ERQ_ERQ4(value)))
#define DMA_BWR_ERQ_ERQ4(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ5[5] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ5 field. */
#define DMA_RD_ERQ_ERQ5(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ5_MASK) >> DMA_ERQ_ERQ5_SHIFT)
#define DMA_BRD_ERQ_ERQ5(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ5_SHIFT))

/*! @brief Set the ERQ5 field to a new value. */
#define DMA_WR_ERQ_ERQ5(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ5_MASK, DMA_ERQ_ERQ5(value)))
#define DMA_BWR_ERQ_ERQ5(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ6[6] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ6 field. */
#define DMA_RD_ERQ_ERQ6(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ6_MASK) >> DMA_ERQ_ERQ6_SHIFT)
#define DMA_BRD_ERQ_ERQ6(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ6_SHIFT))

/*! @brief Set the ERQ6 field to a new value. */
#define DMA_WR_ERQ_ERQ6(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ6_MASK, DMA_ERQ_ERQ6(value)))
#define DMA_BWR_ERQ_ERQ6(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ7[7] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ7 field. */
#define DMA_RD_ERQ_ERQ7(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ7_MASK) >> DMA_ERQ_ERQ7_SHIFT)
#define DMA_BRD_ERQ_ERQ7(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ7_SHIFT))

/*! @brief Set the ERQ7 field to a new value. */
#define DMA_WR_ERQ_ERQ7(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ7_MASK, DMA_ERQ_ERQ7(value)))
#define DMA_BWR_ERQ_ERQ7(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ8[8] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ8 field. */
#define DMA_RD_ERQ_ERQ8(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ8_MASK) >> DMA_ERQ_ERQ8_SHIFT)
#define DMA_BRD_ERQ_ERQ8(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ8_SHIFT))

/*! @brief Set the ERQ8 field to a new value. */
#define DMA_WR_ERQ_ERQ8(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ8_MASK, DMA_ERQ_ERQ8(value)))
#define DMA_BWR_ERQ_ERQ8(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ9[9] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ9 field. */
#define DMA_RD_ERQ_ERQ9(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ9_MASK) >> DMA_ERQ_ERQ9_SHIFT)
#define DMA_BRD_ERQ_ERQ9(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ9_SHIFT))

/*! @brief Set the ERQ9 field to a new value. */
#define DMA_WR_ERQ_ERQ9(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ9_MASK, DMA_ERQ_ERQ9(value)))
#define DMA_BWR_ERQ_ERQ9(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ10[10] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ10 field. */
#define DMA_RD_ERQ_ERQ10(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ10_MASK) >> DMA_ERQ_ERQ10_SHIFT)
#define DMA_BRD_ERQ_ERQ10(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ10_SHIFT))

/*! @brief Set the ERQ10 field to a new value. */
#define DMA_WR_ERQ_ERQ10(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ10_MASK, DMA_ERQ_ERQ10(value)))
#define DMA_BWR_ERQ_ERQ10(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ11[11] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ11 field. */
#define DMA_RD_ERQ_ERQ11(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ11_MASK) >> DMA_ERQ_ERQ11_SHIFT)
#define DMA_BRD_ERQ_ERQ11(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ11_SHIFT))

/*! @brief Set the ERQ11 field to a new value. */
#define DMA_WR_ERQ_ERQ11(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ11_MASK, DMA_ERQ_ERQ11(value)))
#define DMA_BWR_ERQ_ERQ11(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ12[12] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ12 field. */
#define DMA_RD_ERQ_ERQ12(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ12_MASK) >> DMA_ERQ_ERQ12_SHIFT)
#define DMA_BRD_ERQ_ERQ12(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ12_SHIFT))

/*! @brief Set the ERQ12 field to a new value. */
#define DMA_WR_ERQ_ERQ12(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ12_MASK, DMA_ERQ_ERQ12(value)))
#define DMA_BWR_ERQ_ERQ12(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ13[13] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ13 field. */
#define DMA_RD_ERQ_ERQ13(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ13_MASK) >> DMA_ERQ_ERQ13_SHIFT)
#define DMA_BRD_ERQ_ERQ13(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ13_SHIFT))

/*! @brief Set the ERQ13 field to a new value. */
#define DMA_WR_ERQ_ERQ13(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ13_MASK, DMA_ERQ_ERQ13(value)))
#define DMA_BWR_ERQ_ERQ13(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ14[14] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ14 field. */
#define DMA_RD_ERQ_ERQ14(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ14_MASK) >> DMA_ERQ_ERQ14_SHIFT)
#define DMA_BRD_ERQ_ERQ14(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ14_SHIFT))

/*! @brief Set the ERQ14 field to a new value. */
#define DMA_WR_ERQ_ERQ14(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ14_MASK, DMA_ERQ_ERQ14(value)))
#define DMA_BWR_ERQ_ERQ14(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ15[15] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ15 field. */
#define DMA_RD_ERQ_ERQ15(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ15_MASK) >> DMA_ERQ_ERQ15_SHIFT)
#define DMA_BRD_ERQ_ERQ15(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ15_SHIFT))

/*! @brief Set the ERQ15 field to a new value. */
#define DMA_WR_ERQ_ERQ15(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ15_MASK, DMA_ERQ_ERQ15(value)))
#define DMA_BWR_ERQ_ERQ15(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_EEI - Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 16 channels to enable the error
 * interrupt signal for each channel. The state of any given channel's error
 * interrupt enable is directly affected by writes to this register; it is also
 * affected by writes to the SEEI and CEEI. These registers are provided so that the
 * error interrupt enable for a single channel can easily be modified without the
 * need to perform a read-modify-write sequence to the EEI register. The DMA error
 * indicator and the error interrupt enable flag must be asserted before an
 * error interrupt request for a given channel is asserted to the interrupt
 * controller.
 */
/*!
 * @name Constants and macros for entire DMA_EEI register
 */
/*@{*/
#define DMA_RD_EEI(base)         (DMA_EEI_REG(base))
#define DMA_WR_EEI(base, value)  (DMA_EEI_REG(base) = (value))
#define DMA_RMW_EEI(base, mask, value) (DMA_WR_EEI(base, (DMA_RD_EEI(base) & ~(mask)) | (value)))
#define DMA_SET_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) |  (value)))
#define DMA_CLR_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) & ~(value)))
#define DMA_TOG_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EEI bitfields
 */

/*!
 * @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI0 field. */
#define DMA_RD_EEI_EEI0(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI0_MASK) >> DMA_EEI_EEI0_SHIFT)
#define DMA_BRD_EEI_EEI0(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT))

/*! @brief Set the EEI0 field to a new value. */
#define DMA_WR_EEI_EEI0(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI0_MASK, DMA_EEI_EEI0(value)))
#define DMA_BWR_EEI_EEI0(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI1 field. */
#define DMA_RD_EEI_EEI1(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI1_MASK) >> DMA_EEI_EEI1_SHIFT)
#define DMA_BRD_EEI_EEI1(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT))

/*! @brief Set the EEI1 field to a new value. */
#define DMA_WR_EEI_EEI1(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI1_MASK, DMA_EEI_EEI1(value)))
#define DMA_BWR_EEI_EEI1(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI2 field. */
#define DMA_RD_EEI_EEI2(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI2_MASK) >> DMA_EEI_EEI2_SHIFT)
#define DMA_BRD_EEI_EEI2(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT))

/*! @brief Set the EEI2 field to a new value. */
#define DMA_WR_EEI_EEI2(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI2_MASK, DMA_EEI_EEI2(value)))
#define DMA_BWR_EEI_EEI2(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI3 field. */
#define DMA_RD_EEI_EEI3(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI3_MASK) >> DMA_EEI_EEI3_SHIFT)
#define DMA_BRD_EEI_EEI3(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT))

/*! @brief Set the EEI3 field to a new value. */
#define DMA_WR_EEI_EEI3(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI3_MASK, DMA_EEI_EEI3(value)))
#define DMA_BWR_EEI_EEI3(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI4[4] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI4 field. */
#define DMA_RD_EEI_EEI4(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI4_MASK) >> DMA_EEI_EEI4_SHIFT)
#define DMA_BRD_EEI_EEI4(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI4_SHIFT))

/*! @brief Set the EEI4 field to a new value. */
#define DMA_WR_EEI_EEI4(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI4_MASK, DMA_EEI_EEI4(value)))
#define DMA_BWR_EEI_EEI4(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI5[5] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI5 field. */
#define DMA_RD_EEI_EEI5(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI5_MASK) >> DMA_EEI_EEI5_SHIFT)
#define DMA_BRD_EEI_EEI5(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI5_SHIFT))

/*! @brief Set the EEI5 field to a new value. */
#define DMA_WR_EEI_EEI5(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI5_MASK, DMA_EEI_EEI5(value)))
#define DMA_BWR_EEI_EEI5(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI6[6] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI6 field. */
#define DMA_RD_EEI_EEI6(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI6_MASK) >> DMA_EEI_EEI6_SHIFT)
#define DMA_BRD_EEI_EEI6(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI6_SHIFT))

/*! @brief Set the EEI6 field to a new value. */
#define DMA_WR_EEI_EEI6(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI6_MASK, DMA_EEI_EEI6(value)))
#define DMA_BWR_EEI_EEI6(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI7[7] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI7 field. */
#define DMA_RD_EEI_EEI7(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI7_MASK) >> DMA_EEI_EEI7_SHIFT)
#define DMA_BRD_EEI_EEI7(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI7_SHIFT))

/*! @brief Set the EEI7 field to a new value. */
#define DMA_WR_EEI_EEI7(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI7_MASK, DMA_EEI_EEI7(value)))
#define DMA_BWR_EEI_EEI7(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI8[8] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI8 field. */
#define DMA_RD_EEI_EEI8(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI8_MASK) >> DMA_EEI_EEI8_SHIFT)
#define DMA_BRD_EEI_EEI8(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI8_SHIFT))

/*! @brief Set the EEI8 field to a new value. */
#define DMA_WR_EEI_EEI8(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI8_MASK, DMA_EEI_EEI8(value)))
#define DMA_BWR_EEI_EEI8(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI9[9] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI9 field. */
#define DMA_RD_EEI_EEI9(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI9_MASK) >> DMA_EEI_EEI9_SHIFT)
#define DMA_BRD_EEI_EEI9(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI9_SHIFT))

/*! @brief Set the EEI9 field to a new value. */
#define DMA_WR_EEI_EEI9(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI9_MASK, DMA_EEI_EEI9(value)))
#define DMA_BWR_EEI_EEI9(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI10[10] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI10 field. */
#define DMA_RD_EEI_EEI10(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI10_MASK) >> DMA_EEI_EEI10_SHIFT)
#define DMA_BRD_EEI_EEI10(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI10_SHIFT))

/*! @brief Set the EEI10 field to a new value. */
#define DMA_WR_EEI_EEI10(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI10_MASK, DMA_EEI_EEI10(value)))
#define DMA_BWR_EEI_EEI10(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI11[11] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI11 field. */
#define DMA_RD_EEI_EEI11(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI11_MASK) >> DMA_EEI_EEI11_SHIFT)
#define DMA_BRD_EEI_EEI11(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI11_SHIFT))

/*! @brief Set the EEI11 field to a new value. */
#define DMA_WR_EEI_EEI11(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI11_MASK, DMA_EEI_EEI11(value)))
#define DMA_BWR_EEI_EEI11(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI12[12] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI12 field. */
#define DMA_RD_EEI_EEI12(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI12_MASK) >> DMA_EEI_EEI12_SHIFT)
#define DMA_BRD_EEI_EEI12(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI12_SHIFT))

/*! @brief Set the EEI12 field to a new value. */
#define DMA_WR_EEI_EEI12(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI12_MASK, DMA_EEI_EEI12(value)))
#define DMA_BWR_EEI_EEI12(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI13[13] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI13 field. */
#define DMA_RD_EEI_EEI13(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI13_MASK) >> DMA_EEI_EEI13_SHIFT)
#define DMA_BRD_EEI_EEI13(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI13_SHIFT))

/*! @brief Set the EEI13 field to a new value. */
#define DMA_WR_EEI_EEI13(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI13_MASK, DMA_EEI_EEI13(value)))
#define DMA_BWR_EEI_EEI13(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI14[14] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI14 field. */
#define DMA_RD_EEI_EEI14(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI14_MASK) >> DMA_EEI_EEI14_SHIFT)
#define DMA_BRD_EEI_EEI14(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI14_SHIFT))

/*! @brief Set the EEI14 field to a new value. */
#define DMA_WR_EEI_EEI14(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI14_MASK, DMA_EEI_EEI14(value)))
#define DMA_BWR_EEI_EEI14(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI15[15] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI15 field. */
#define DMA_RD_EEI_EEI15(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI15_MASK) >> DMA_EEI_EEI15_SHIFT)
#define DMA_BRD_EEI_EEI15(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI15_SHIFT))

/*! @brief Set the EEI15 field to a new value. */
#define DMA_WR_EEI_EEI15(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI15_MASK, DMA_EEI_EEI15(value)))
#define DMA_BWR_EEI_EEI15(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CEEI - Clear Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_CEEI - Clear Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in
 * the EEI to disable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be cleared. Setting
 * the CAEE bit provides a global clear function, forcing the EEI contents to be
 * cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word.
 * Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
/*@{*/
#define DMA_RD_CEEI(base)        (DMA_CEEI_REG(base))
#define DMA_WR_CEEI(base, value) (DMA_CEEI_REG(base) = (value))
#define DMA_RMW_CEEI(base, mask, value) (DMA_WR_CEEI(base, (DMA_RD_CEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CEEI bitfields
 */

/*!
 * @name Register DMA_CEEI, field CEEI[3:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the CEEI field to a new value. */
#define DMA_WR_CEEI_CEEI(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CEEI_MASK, DMA_CEEI_CEEI(value)))
#define DMA_BWR_CEEI_CEEI(base, value) (DMA_WR_CEEI_CEEI(base, value))
/*@}*/

/*!
 * @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the EEI bit specified in the CEEI field
 * - 0b1 - Clear all bits in EEI
 */
/*@{*/
/*! @brief Set the CAEE field to a new value. */
#define DMA_WR_CEEI_CAEE(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CAEE_MASK, DMA_CEEI_CAEE(value)))
#define DMA_BWR_CEEI_CAEE(base, value) (BITBAND_ACCESS8(&DMA_CEEI_REG(base), DMA_CEEI_CAEE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CEEI_NOP(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_NOP_MASK, DMA_CEEI_NOP(value)))
#define DMA_BWR_CEEI_NOP(base, value) (BITBAND_ACCESS8(&DMA_CEEI_REG(base), DMA_CEEI_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SEEI - Set Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_SEEI - Set Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the
 * EEI to enable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be set. Setting the
 * SAEE bit provides a global set function, forcing the entire EEI contents to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
/*@{*/
#define DMA_RD_SEEI(base)        (DMA_SEEI_REG(base))
#define DMA_WR_SEEI(base, value) (DMA_SEEI_REG(base) = (value))
#define DMA_RMW_SEEI(base, mask, value) (DMA_WR_SEEI(base, (DMA_RD_SEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SEEI bitfields
 */

/*!
 * @name Register DMA_SEEI, field SEEI[3:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the SEEI field to a new value. */
#define DMA_WR_SEEI_SEEI(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SEEI_MASK, DMA_SEEI_SEEI(value)))
#define DMA_BWR_SEEI_SEEI(base, value) (DMA_WR_SEEI_SEEI(base, value))
/*@}*/

/*!
 * @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the EEI bit specified in the SEEI field.
 * - 0b1 - Sets all bits in EEI
 */
/*@{*/
/*! @brief Set the SAEE field to a new value. */
#define DMA_WR_SEEI_SAEE(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SAEE_MASK, DMA_SEEI_SAEE(value)))
#define DMA_BWR_SEEI_SAEE(base, value) (BITBAND_ACCESS8(&DMA_SEEI_REG(base), DMA_SEEI_SAEE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SEEI_NOP(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_NOP_MASK, DMA_SEEI_NOP(value)))
#define DMA_BWR_SEEI_NOP(base, value) (BITBAND_ACCESS8(&DMA_SEEI_REG(base), DMA_SEEI_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CERQ - Clear Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CERQ - Clear Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in
 * the ERQ to disable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be cleared. Setting the
 * CAER bit provides a global clear function, forcing the entire contents of the
 * ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit
 * word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
/*@{*/
#define DMA_RD_CERQ(base)        (DMA_CERQ_REG(base))
#define DMA_WR_CERQ(base, value) (DMA_CERQ_REG(base) = (value))
#define DMA_RMW_CERQ(base, mask, value) (DMA_WR_CERQ(base, (DMA_RD_CERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERQ bitfields
 */

/*!
 * @name Register DMA_CERQ, field CERQ[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the CERQ field to a new value. */
#define DMA_WR_CERQ_CERQ(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CERQ_MASK, DMA_CERQ_CERQ(value)))
#define DMA_BWR_CERQ_CERQ(base, value) (DMA_WR_CERQ_CERQ(base, value))
/*@}*/

/*!
 * @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the ERQ bit specified in the CERQ field
 * - 0b1 - Clear all bits in ERQ
 */
/*@{*/
/*! @brief Set the CAER field to a new value. */
#define DMA_WR_CERQ_CAER(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CAER_MASK, DMA_CERQ_CAER(value)))
#define DMA_BWR_CERQ_CAER(base, value) (BITBAND_ACCESS8(&DMA_CERQ_REG(base), DMA_CERQ_CAER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERQ_NOP(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_NOP_MASK, DMA_CERQ_NOP(value)))
#define DMA_BWR_CERQ_NOP(base, value) (BITBAND_ACCESS8(&DMA_CERQ_REG(base), DMA_CERQ_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SERQ - Set Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_SERQ - Set Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the
 * ERQ to enable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be set. Setting the SAER
 * bit provides a global set function, forcing the entire contents of ERQ to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
/*@{*/
#define DMA_RD_SERQ(base)        (DMA_SERQ_REG(base))
#define DMA_WR_SERQ(base, value) (DMA_SERQ_REG(base) = (value))
#define DMA_RMW_SERQ(base, mask, value) (DMA_WR_SERQ(base, (DMA_RD_SERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SERQ bitfields
 */

/*!
 * @name Register DMA_SERQ, field SERQ[3:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the SERQ field to a new value. */
#define DMA_WR_SERQ_SERQ(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SERQ_MASK, DMA_SERQ_SERQ(value)))
#define DMA_BWR_SERQ_SERQ(base, value) (DMA_WR_SERQ_SERQ(base, value))
/*@}*/

/*!
 * @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the ERQ bit specified in the SERQ field
 * - 0b1 - Set all bits in ERQ
 */
/*@{*/
/*! @brief Set the SAER field to a new value. */
#define DMA_WR_SERQ_SAER(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SAER_MASK, DMA_SERQ_SAER(value)))
#define DMA_BWR_SERQ_SAER(base, value) (BITBAND_ACCESS8(&DMA_SERQ_REG(base), DMA_SERQ_SAER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SERQ_NOP(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_NOP_MASK, DMA_SERQ_NOP(value)))
#define DMA_BWR_SERQ_NOP(base, value) (BITBAND_ACCESS8(&DMA_SERQ_REG(base), DMA_SERQ_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CDNE - Clear DONE Status Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_CDNE - Clear DONE Status Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in
 * the TCD of the given channel. The data value on a register write causes the
 * DONE bit in the corresponding transfer control descriptor to be cleared. Setting
 * the CADN bit provides a global clear function, forcing all DONE bits to be
 * cleared. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
/*@{*/
#define DMA_RD_CDNE(base)        (DMA_CDNE_REG(base))
#define DMA_WR_CDNE(base, value) (DMA_CDNE_REG(base) = (value))
#define DMA_RMW_CDNE(base, mask, value) (DMA_WR_CDNE(base, (DMA_RD_CDNE(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CDNE bitfields
 */

/*!
 * @name Register DMA_CDNE, field CDNE[3:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CDNE field to a new value. */
#define DMA_WR_CDNE_CDNE(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CDNE_MASK, DMA_CDNE_CDNE(value)))
#define DMA_BWR_CDNE_CDNE(base, value) (DMA_WR_CDNE_CDNE(base, value))
/*@}*/

/*!
 * @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 0b1 - Clears all bits in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CADN field to a new value. */
#define DMA_WR_CDNE_CADN(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CADN_MASK, DMA_CDNE_CADN(value)))
#define DMA_BWR_CDNE_CADN(base, value) (BITBAND_ACCESS8(&DMA_CDNE_REG(base), DMA_CDNE_CADN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CDNE_NOP(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_NOP_MASK, DMA_CDNE_NOP(value)))
#define DMA_BWR_CDNE_NOP(base, value) (BITBAND_ACCESS8(&DMA_CDNE_REG(base), DMA_CDNE_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SSRT - Set START Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_SSRT - Set START Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in
 * the TCD of the given channel. The data value on a register write causes the
 * START bit in the corresponding transfer control descriptor to be set. Setting the
 * SAST bit provides a global set function, forcing all START bits to be set. If
 * the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
/*@{*/
#define DMA_RD_SSRT(base)        (DMA_SSRT_REG(base))
#define DMA_WR_SSRT(base, value) (DMA_SSRT_REG(base) = (value))
#define DMA_RMW_SSRT(base, mask, value) (DMA_WR_SSRT(base, (DMA_RD_SSRT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SSRT bitfields
 */

/*!
 * @name Register DMA_SSRT, field SSRT[3:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SSRT field to a new value. */
#define DMA_WR_SSRT_SSRT(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SSRT_MASK, DMA_SSRT_SSRT(value)))
#define DMA_BWR_SSRT_SSRT(base, value) (DMA_WR_SSRT_SSRT(base, value))
/*@}*/

/*!
 * @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 0b1 - Set all bits in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SAST field to a new value. */
#define DMA_WR_SSRT_SAST(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SAST_MASK, DMA_SSRT_SAST(value)))
#define DMA_BWR_SSRT_SAST(base, value) (BITBAND_ACCESS8(&DMA_SSRT_REG(base), DMA_SSRT_SAST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SSRT_NOP(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_NOP_MASK, DMA_SSRT_NOP(value)))
#define DMA_BWR_SSRT_NOP(base, value) (BITBAND_ACCESS8(&DMA_SSRT_REG(base), DMA_SSRT_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CERR - Clear Error Register
 ******************************************************************************/

/*!
 * @brief DMA_CERR - Clear Error Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in
 * the ERR to disable the error condition flag for a given channel. The given value
 * on a register write causes the corresponding bit in the ERR to be cleared.
 * Setting the CAEI bit provides a global clear function, forcing the ERR contents
 * to be cleared, clearing all channel error indicators. If the NOP bit is set,
 * the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERR register
 */
/*@{*/
#define DMA_RD_CERR(base)        (DMA_CERR_REG(base))
#define DMA_WR_CERR(base, value) (DMA_CERR_REG(base) = (value))
#define DMA_RMW_CERR(base, mask, value) (DMA_WR_CERR(base, (DMA_RD_CERR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERR bitfields
 */

/*!
 * @name Register DMA_CERR, field CERR[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
/*@{*/
/*! @brief Set the CERR field to a new value. */
#define DMA_WR_CERR_CERR(base, value) (DMA_RMW_CERR(base, DMA_CERR_CERR_MASK, DMA_CERR_CERR(value)))
#define DMA_BWR_CERR_CERR(base, value) (DMA_WR_CERR_CERR(base, value))
/*@}*/

/*!
 * @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the ERR bit specified in the CERR field
 * - 0b1 - Clear all bits in ERR
 */
/*@{*/
/*! @brief Set the CAEI field to a new value. */
#define DMA_WR_CERR_CAEI(base, value) (DMA_RMW_CERR(base, DMA_CERR_CAEI_MASK, DMA_CERR_CAEI(value)))
#define DMA_BWR_CERR_CAEI(base, value) (BITBAND_ACCESS8(&DMA_CERR_REG(base), DMA_CERR_CAEI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERR_NOP(base, value) (DMA_RMW_CERR(base, DMA_CERR_NOP_MASK, DMA_CERR_NOP(value)))
#define DMA_BWR_CERR_NOP(base, value) (BITBAND_ACCESS8(&DMA_CERR_REG(base), DMA_CERR_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CINT - Clear Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CINT - Clear Interrupt Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in
 * the INT to disable the interrupt request for a given channel. The given value
 * on a register write causes the corresponding bit in the INT to be cleared.
 * Setting the CAIR bit provides a global clear function, forcing the entire contents
 * of the INT to be cleared, disabling all DMA interrupt requests. If the NOP
 * bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CINT register
 */
/*@{*/
#define DMA_RD_CINT(base)        (DMA_CINT_REG(base))
#define DMA_WR_CINT(base, value) (DMA_CINT_REG(base) = (value))
#define DMA_RMW_CINT(base, mask, value) (DMA_WR_CINT(base, (DMA_RD_CINT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CINT bitfields
 */

/*!
 * @name Register DMA_CINT, field CINT[3:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
/*@{*/
/*! @brief Set the CINT field to a new value. */
#define DMA_WR_CINT_CINT(base, value) (DMA_RMW_CINT(base, DMA_CINT_CINT_MASK, DMA_CINT_CINT(value)))
#define DMA_BWR_CINT_CINT(base, value) (DMA_WR_CINT_CINT(base, value))
/*@}*/

/*!
 * @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the INT bit specified in the CINT field
 * - 0b1 - Clear all bits in INT
 */
/*@{*/
/*! @brief Set the CAIR field to a new value. */
#define DMA_WR_CINT_CAIR(base, value) (DMA_RMW_CINT(base, DMA_CINT_CAIR_MASK, DMA_CINT_CAIR(value)))
#define DMA_BWR_CINT_CAIR(base, value) (BITBAND_ACCESS8(&DMA_CINT_REG(base), DMA_CINT_CAIR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CINT_NOP(base, value) (DMA_RMW_CINT(base, DMA_CINT_NOP_MASK, DMA_CINT_NOP(value)))
#define DMA_BWR_CINT_NOP(base, value) (BITBAND_ACCESS8(&DMA_CINT_REG(base), DMA_CINT_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_INT - Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_INT - Interrupt Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 16 channels signaling the
 * presence of an interrupt request for each channel. Depending on the appropriate bit
 * setting in the transfer-control descriptors, the eDMA engine generates an
 * interrupt on data transfer completion. The outputs of this register are directly
 * routed to the interrupt controller. During the interrupt-service routine
 * associated with any given channel, it is the software's responsibility to clear the
 * appropriate bit, negating the interrupt request. Typically, a write to the CINT
 * register in the interrupt service routine is used for this purpose. The state
 * of any given channel's interrupt request is directly affected by writes to
 * this register; it is also affected by writes to the CINT register. On writes to
 * INT, a 1 in any bit position clears the corresponding channel's interrupt
 * request. A zero in any bit position has no affect on the corresponding channel's
 * current interrupt status. The CINT register is provided so the interrupt
 * request for a single channel can easily be cleared without the need to perform a
 * read-modify-write sequence to the INT register.
 */
/*!
 * @name Constants and macros for entire DMA_INT register
 */
/*@{*/
#define DMA_RD_INT(base)         (DMA_INT_REG(base))
#define DMA_WR_INT(base, value)  (DMA_INT_REG(base) = (value))
#define DMA_RMW_INT(base, mask, value) (DMA_WR_INT(base, (DMA_RD_INT(base) & ~(mask)) | (value)))
#define DMA_SET_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) |  (value)))
#define DMA_CLR_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) & ~(value)))
#define DMA_TOG_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_INT bitfields
 */

/*!
 * @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT0 field. */
#define DMA_RD_INT_INT0(base) ((DMA_INT_REG(base) & DMA_INT_INT0_MASK) >> DMA_INT_INT0_SHIFT)
#define DMA_BRD_INT_INT0(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT))

/*! @brief Set the INT0 field to a new value. */
#define DMA_WR_INT_INT0(base, value) (DMA_RMW_INT(base, (DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT0(value)))
#define DMA_BWR_INT_INT0(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT1 field. */
#define DMA_RD_INT_INT1(base) ((DMA_INT_REG(base) & DMA_INT_INT1_MASK) >> DMA_INT_INT1_SHIFT)
#define DMA_BRD_INT_INT1(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT))

/*! @brief Set the INT1 field to a new value. */
#define DMA_WR_INT_INT1(base, value) (DMA_RMW_INT(base, (DMA_INT_INT1_MASK | DMA_INT_INT0_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT1(value)))
#define DMA_BWR_INT_INT1(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT2 field. */
#define DMA_RD_INT_INT2(base) ((DMA_INT_REG(base) & DMA_INT_INT2_MASK) >> DMA_INT_INT2_SHIFT)
#define DMA_BRD_INT_INT2(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT))

/*! @brief Set the INT2 field to a new value. */
#define DMA_WR_INT_INT2(base, value) (DMA_RMW_INT(base, (DMA_INT_INT2_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT2(value)))
#define DMA_BWR_INT_INT2(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT3 field. */
#define DMA_RD_INT_INT3(base) ((DMA_INT_REG(base) & DMA_INT_INT3_MASK) >> DMA_INT_INT3_SHIFT)
#define DMA_BRD_INT_INT3(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT))

/*! @brief Set the INT3 field to a new value. */
#define DMA_WR_INT_INT3(base, value) (DMA_RMW_INT(base, (DMA_INT_INT3_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT3(value)))
#define DMA_BWR_INT_INT3(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT4[4] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT4 field. */
#define DMA_RD_INT_INT4(base) ((DMA_INT_REG(base) & DMA_INT_INT4_MASK) >> DMA_INT_INT4_SHIFT)
#define DMA_BRD_INT_INT4(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT4_SHIFT))

/*! @brief Set the INT4 field to a new value. */
#define DMA_WR_INT_INT4(base, value) (DMA_RMW_INT(base, (DMA_INT_INT4_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT4(value)))
#define DMA_BWR_INT_INT4(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT5[5] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT5 field. */
#define DMA_RD_INT_INT5(base) ((DMA_INT_REG(base) & DMA_INT_INT5_MASK) >> DMA_INT_INT5_SHIFT)
#define DMA_BRD_INT_INT5(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT5_SHIFT))

/*! @brief Set the INT5 field to a new value. */
#define DMA_WR_INT_INT5(base, value) (DMA_RMW_INT(base, (DMA_INT_INT5_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT5(value)))
#define DMA_BWR_INT_INT5(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT6[6] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT6 field. */
#define DMA_RD_INT_INT6(base) ((DMA_INT_REG(base) & DMA_INT_INT6_MASK) >> DMA_INT_INT6_SHIFT)
#define DMA_BRD_INT_INT6(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT6_SHIFT))

/*! @brief Set the INT6 field to a new value. */
#define DMA_WR_INT_INT6(base, value) (DMA_RMW_INT(base, (DMA_INT_INT6_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT6(value)))
#define DMA_BWR_INT_INT6(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT7[7] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT7 field. */
#define DMA_RD_INT_INT7(base) ((DMA_INT_REG(base) & DMA_INT_INT7_MASK) >> DMA_INT_INT7_SHIFT)
#define DMA_BRD_INT_INT7(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT7_SHIFT))

/*! @brief Set the INT7 field to a new value. */
#define DMA_WR_INT_INT7(base, value) (DMA_RMW_INT(base, (DMA_INT_INT7_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT7(value)))
#define DMA_BWR_INT_INT7(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT8[8] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT8 field. */
#define DMA_RD_INT_INT8(base) ((DMA_INT_REG(base) & DMA_INT_INT8_MASK) >> DMA_INT_INT8_SHIFT)
#define DMA_BRD_INT_INT8(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT8_SHIFT))

/*! @brief Set the INT8 field to a new value. */
#define DMA_WR_INT_INT8(base, value) (DMA_RMW_INT(base, (DMA_INT_INT8_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT8(value)))
#define DMA_BWR_INT_INT8(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT9[9] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT9 field. */
#define DMA_RD_INT_INT9(base) ((DMA_INT_REG(base) & DMA_INT_INT9_MASK) >> DMA_INT_INT9_SHIFT)
#define DMA_BRD_INT_INT9(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT9_SHIFT))

/*! @brief Set the INT9 field to a new value. */
#define DMA_WR_INT_INT9(base, value) (DMA_RMW_INT(base, (DMA_INT_INT9_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT9(value)))
#define DMA_BWR_INT_INT9(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT10[10] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT10 field. */
#define DMA_RD_INT_INT10(base) ((DMA_INT_REG(base) & DMA_INT_INT10_MASK) >> DMA_INT_INT10_SHIFT)
#define DMA_BRD_INT_INT10(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT10_SHIFT))

/*! @brief Set the INT10 field to a new value. */
#define DMA_WR_INT_INT10(base, value) (DMA_RMW_INT(base, (DMA_INT_INT10_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT10(value)))
#define DMA_BWR_INT_INT10(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT11[11] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT11 field. */
#define DMA_RD_INT_INT11(base) ((DMA_INT_REG(base) & DMA_INT_INT11_MASK) >> DMA_INT_INT11_SHIFT)
#define DMA_BRD_INT_INT11(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT11_SHIFT))

/*! @brief Set the INT11 field to a new value. */
#define DMA_WR_INT_INT11(base, value) (DMA_RMW_INT(base, (DMA_INT_INT11_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT11(value)))
#define DMA_BWR_INT_INT11(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT12[12] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT12 field. */
#define DMA_RD_INT_INT12(base) ((DMA_INT_REG(base) & DMA_INT_INT12_MASK) >> DMA_INT_INT12_SHIFT)
#define DMA_BRD_INT_INT12(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT12_SHIFT))

/*! @brief Set the INT12 field to a new value. */
#define DMA_WR_INT_INT12(base, value) (DMA_RMW_INT(base, (DMA_INT_INT12_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT12(value)))
#define DMA_BWR_INT_INT12(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT13[13] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT13 field. */
#define DMA_RD_INT_INT13(base) ((DMA_INT_REG(base) & DMA_INT_INT13_MASK) >> DMA_INT_INT13_SHIFT)
#define DMA_BRD_INT_INT13(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT13_SHIFT))

/*! @brief Set the INT13 field to a new value. */
#define DMA_WR_INT_INT13(base, value) (DMA_RMW_INT(base, (DMA_INT_INT13_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT13(value)))
#define DMA_BWR_INT_INT13(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT14[14] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT14 field. */
#define DMA_RD_INT_INT14(base) ((DMA_INT_REG(base) & DMA_INT_INT14_MASK) >> DMA_INT_INT14_SHIFT)
#define DMA_BRD_INT_INT14(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT14_SHIFT))

/*! @brief Set the INT14 field to a new value. */
#define DMA_WR_INT_INT14(base, value) (DMA_RMW_INT(base, (DMA_INT_INT14_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT15_MASK), DMA_INT_INT14(value)))
#define DMA_BWR_INT_INT14(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT15[15] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT15 field. */
#define DMA_RD_INT_INT15(base) ((DMA_INT_REG(base) & DMA_INT_INT15_MASK) >> DMA_INT_INT15_SHIFT)
#define DMA_BRD_INT_INT15(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT15_SHIFT))

/*! @brief Set the INT15 field to a new value. */
#define DMA_WR_INT_INT15(base, value) (DMA_RMW_INT(base, (DMA_INT_INT15_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK), DMA_INT_INT15(value)))
#define DMA_BWR_INT_INT15(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_ERR - Error Register
 ******************************************************************************/

/*!
 * @brief DMA_ERR - Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the 16 channels, signaling the presence of an
 * error for each channel. The eDMA engine signals the occurrence of an error
 * condition by setting the appropriate bit in this register. The outputs of this
 * register are enabled by the contents of the EEI, and then routed to the
 * interrupt controller. During the execution of the interrupt-service routine associated
 * with any DMA errors, it is software's responsibility to clear the appropriate
 * bit, negating the error-interrupt request. Typically, a write to the CERR in
 * the interrupt-service routine is used for this purpose. The normal DMA channel
 * completion indicators (setting the transfer control descriptor DONE flag and
 * the possible assertion of an interrupt request) are not affected when an error
 * is detected. The contents of this register can also be polled because a
 * non-zero value indicates the presence of a channel error regardless of the state of
 * the EEI. The state of any given channel's error indicators is affected by
 * writes to this register; it is also affected by writes to the CERR. On writes to
 * the ERR, a one in any bit position clears the corresponding channel's error
 * status. A zero in any bit position has no affect on the corresponding channel's
 * current error status. The CERR is provided so the error indicator for a single
 * channel can easily be cleared.
 */
/*!
 * @name Constants and macros for entire DMA_ERR register
 */
/*@{*/
#define DMA_RD_ERR(base)         (DMA_ERR_REG(base))
#define DMA_WR_ERR(base, value)  (DMA_ERR_REG(base) = (value))
#define DMA_RMW_ERR(base, mask, value) (DMA_WR_ERR(base, (DMA_RD_ERR(base) & ~(mask)) | (value)))
#define DMA_SET_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) |  (value)))
#define DMA_CLR_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) & ~(value)))
#define DMA_TOG_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERR bitfields
 */

/*!
 * @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR0 field. */
#define DMA_RD_ERR_ERR0(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR0_MASK) >> DMA_ERR_ERR0_SHIFT)
#define DMA_BRD_ERR_ERR0(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT))

/*! @brief Set the ERR0 field to a new value. */
#define DMA_WR_ERR_ERR0(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR0(value)))
#define DMA_BWR_ERR_ERR0(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR1 field. */
#define DMA_RD_ERR_ERR1(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR1_MASK) >> DMA_ERR_ERR1_SHIFT)
#define DMA_BRD_ERR_ERR1(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT))

/*! @brief Set the ERR1 field to a new value. */
#define DMA_WR_ERR_ERR1(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR1_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR1(value)))
#define DMA_BWR_ERR_ERR1(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR2 field. */
#define DMA_RD_ERR_ERR2(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR2_MASK) >> DMA_ERR_ERR2_SHIFT)
#define DMA_BRD_ERR_ERR2(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT))

/*! @brief Set the ERR2 field to a new value. */
#define DMA_WR_ERR_ERR2(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR2_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR2(value)))
#define DMA_BWR_ERR_ERR2(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR3 field. */
#define DMA_RD_ERR_ERR3(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR3_MASK) >> DMA_ERR_ERR3_SHIFT)
#define DMA_BRD_ERR_ERR3(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT))

/*! @brief Set the ERR3 field to a new value. */
#define DMA_WR_ERR_ERR3(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR3_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR3(value)))
#define DMA_BWR_ERR_ERR3(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR4[4] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR4 field. */
#define DMA_RD_ERR_ERR4(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR4_MASK) >> DMA_ERR_ERR4_SHIFT)
#define DMA_BRD_ERR_ERR4(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR4_SHIFT))

/*! @brief Set the ERR4 field to a new value. */
#define DMA_WR_ERR_ERR4(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR4_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR4(value)))
#define DMA_BWR_ERR_ERR4(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR5[5] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR5 field. */
#define DMA_RD_ERR_ERR5(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR5_MASK) >> DMA_ERR_ERR5_SHIFT)
#define DMA_BRD_ERR_ERR5(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR5_SHIFT))

/*! @brief Set the ERR5 field to a new value. */
#define DMA_WR_ERR_ERR5(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR5_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR5(value)))
#define DMA_BWR_ERR_ERR5(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR6[6] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR6 field. */
#define DMA_RD_ERR_ERR6(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR6_MASK) >> DMA_ERR_ERR6_SHIFT)
#define DMA_BRD_ERR_ERR6(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR6_SHIFT))

/*! @brief Set the ERR6 field to a new value. */
#define DMA_WR_ERR_ERR6(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR6_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR6(value)))
#define DMA_BWR_ERR_ERR6(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR7[7] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR7 field. */
#define DMA_RD_ERR_ERR7(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR7_MASK) >> DMA_ERR_ERR7_SHIFT)
#define DMA_BRD_ERR_ERR7(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR7_SHIFT))

/*! @brief Set the ERR7 field to a new value. */
#define DMA_WR_ERR_ERR7(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR7_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR7(value)))
#define DMA_BWR_ERR_ERR7(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR8[8] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR8 field. */
#define DMA_RD_ERR_ERR8(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR8_MASK) >> DMA_ERR_ERR8_SHIFT)
#define DMA_BRD_ERR_ERR8(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR8_SHIFT))

/*! @brief Set the ERR8 field to a new value. */
#define DMA_WR_ERR_ERR8(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR8_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR8(value)))
#define DMA_BWR_ERR_ERR8(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR9[9] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR9 field. */
#define DMA_RD_ERR_ERR9(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR9_MASK) >> DMA_ERR_ERR9_SHIFT)
#define DMA_BRD_ERR_ERR9(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR9_SHIFT))

/*! @brief Set the ERR9 field to a new value. */
#define DMA_WR_ERR_ERR9(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR9_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR9(value)))
#define DMA_BWR_ERR_ERR9(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR10[10] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR10 field. */
#define DMA_RD_ERR_ERR10(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR10_MASK) >> DMA_ERR_ERR10_SHIFT)
#define DMA_BRD_ERR_ERR10(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR10_SHIFT))

/*! @brief Set the ERR10 field to a new value. */
#define DMA_WR_ERR_ERR10(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR10_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR10(value)))
#define DMA_BWR_ERR_ERR10(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR11[11] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR11 field. */
#define DMA_RD_ERR_ERR11(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR11_MASK) >> DMA_ERR_ERR11_SHIFT)
#define DMA_BRD_ERR_ERR11(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR11_SHIFT))

/*! @brief Set the ERR11 field to a new value. */
#define DMA_WR_ERR_ERR11(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR11_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR11(value)))
#define DMA_BWR_ERR_ERR11(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR12[12] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR12 field. */
#define DMA_RD_ERR_ERR12(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR12_MASK) >> DMA_ERR_ERR12_SHIFT)
#define DMA_BRD_ERR_ERR12(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR12_SHIFT))

/*! @brief Set the ERR12 field to a new value. */
#define DMA_WR_ERR_ERR12(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR12_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR12(value)))
#define DMA_BWR_ERR_ERR12(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR13[13] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR13 field. */
#define DMA_RD_ERR_ERR13(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR13_MASK) >> DMA_ERR_ERR13_SHIFT)
#define DMA_BRD_ERR_ERR13(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR13_SHIFT))

/*! @brief Set the ERR13 field to a new value. */
#define DMA_WR_ERR_ERR13(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR13_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR13(value)))
#define DMA_BWR_ERR_ERR13(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR14[14] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR14 field. */
#define DMA_RD_ERR_ERR14(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR14_MASK) >> DMA_ERR_ERR14_SHIFT)
#define DMA_BRD_ERR_ERR14(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR14_SHIFT))

/*! @brief Set the ERR14 field to a new value. */
#define DMA_WR_ERR_ERR14(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR14_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR14(value)))
#define DMA_BWR_ERR_ERR14(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR15[15] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR15 field. */
#define DMA_RD_ERR_ERR15(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR15_MASK) >> DMA_ERR_ERR15_SHIFT)
#define DMA_BRD_ERR_ERR15(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR15_SHIFT))

/*! @brief Set the ERR15 field to a new value. */
#define DMA_WR_ERR_ERR15(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR15_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK), DMA_ERR_ERR15(value)))
#define DMA_BWR_ERR_ERR15(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_HRS - Hardware Request Status Register
 ******************************************************************************/

/*!
 * @brief DMA_HRS - Hardware Request Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The HRS register provides a bit map for the DMA channels, signaling the
 * presence of a hardware request for each channel. The hardware request status bits
 * reflect the current state of the register and qualified (via the ERQ fields)
 * DMA request signals as seen by the DMA's arbitration logic. This view into the
 * hardware request signals may be used for debug purposes. These bits reflect the
 * state of the request as seen by the arbitration logic. Therefore, this status
 * is affected by the ERQ bits.
 */
/*!
 * @name Constants and macros for entire DMA_HRS register
 */
/*@{*/
#define DMA_RD_HRS(base)         (DMA_HRS_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_HRS bitfields
 */

/*!
 * @name Register DMA_HRS, field HRS0[0] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 0 is not present
 * - 0b1 - A hardware service request for channel 0 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS0 field. */
#define DMA_RD_HRS_HRS0(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS0_MASK) >> DMA_HRS_HRS0_SHIFT)
#define DMA_BRD_HRS_HRS0(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS0_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS1[1] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 1 is not present
 * - 0b1 - A hardware service request for channel 1 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS1 field. */
#define DMA_RD_HRS_HRS1(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS1_MASK) >> DMA_HRS_HRS1_SHIFT)
#define DMA_BRD_HRS_HRS1(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS1_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS2[2] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 2 is not present
 * - 0b1 - A hardware service request for channel 2 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS2 field. */
#define DMA_RD_HRS_HRS2(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS2_MASK) >> DMA_HRS_HRS2_SHIFT)
#define DMA_BRD_HRS_HRS2(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS2_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS3[3] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 3 is not present
 * - 0b1 - A hardware service request for channel 3 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS3 field. */
#define DMA_RD_HRS_HRS3(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS3_MASK) >> DMA_HRS_HRS3_SHIFT)
#define DMA_BRD_HRS_HRS3(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS3_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS4[4] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 4 is not present
 * - 0b1 - A hardware service request for channel 4 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS4 field. */
#define DMA_RD_HRS_HRS4(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS4_MASK) >> DMA_HRS_HRS4_SHIFT)
#define DMA_BRD_HRS_HRS4(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS4_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS5[5] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 5 is not present
 * - 0b1 - A hardware service request for channel 5 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS5 field. */
#define DMA_RD_HRS_HRS5(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS5_MASK) >> DMA_HRS_HRS5_SHIFT)
#define DMA_BRD_HRS_HRS5(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS5_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS6[6] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 6 is not present
 * - 0b1 - A hardware service request for channel 6 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS6 field. */
#define DMA_RD_HRS_HRS6(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS6_MASK) >> DMA_HRS_HRS6_SHIFT)
#define DMA_BRD_HRS_HRS6(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS6_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS7[7] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 7 is not present
 * - 0b1 - A hardware service request for channel 7 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS7 field. */
#define DMA_RD_HRS_HRS7(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS7_MASK) >> DMA_HRS_HRS7_SHIFT)
#define DMA_BRD_HRS_HRS7(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS7_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS8[8] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 8 is not present
 * - 0b1 - A hardware service request for channel 8 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS8 field. */
#define DMA_RD_HRS_HRS8(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS8_MASK) >> DMA_HRS_HRS8_SHIFT)
#define DMA_BRD_HRS_HRS8(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS8_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS9[9] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 9 is not present
 * - 0b1 - A hardware service request for channel 9 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS9 field. */
#define DMA_RD_HRS_HRS9(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS9_MASK) >> DMA_HRS_HRS9_SHIFT)
#define DMA_BRD_HRS_HRS9(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS9_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS10[10] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 10 is not present
 * - 0b1 - A hardware service request for channel 10 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS10 field. */
#define DMA_RD_HRS_HRS10(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS10_MASK) >> DMA_HRS_HRS10_SHIFT)
#define DMA_BRD_HRS_HRS10(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS10_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS11[11] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 11 is not present
 * - 0b1 - A hardware service request for channel 11 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS11 field. */
#define DMA_RD_HRS_HRS11(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS11_MASK) >> DMA_HRS_HRS11_SHIFT)
#define DMA_BRD_HRS_HRS11(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS11_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS12[12] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 12 is not present
 * - 0b1 - A hardware service request for channel 12 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS12 field. */
#define DMA_RD_HRS_HRS12(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS12_MASK) >> DMA_HRS_HRS12_SHIFT)
#define DMA_BRD_HRS_HRS12(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS12_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS13[13] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 13 is not present
 * - 0b1 - A hardware service request for channel 13 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS13 field. */
#define DMA_RD_HRS_HRS13(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS13_MASK) >> DMA_HRS_HRS13_SHIFT)
#define DMA_BRD_HRS_HRS13(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS13_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS14[14] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 14 is not present
 * - 0b1 - A hardware service request for channel 14 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS14 field. */
#define DMA_RD_HRS_HRS14(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS14_MASK) >> DMA_HRS_HRS14_SHIFT)
#define DMA_BRD_HRS_HRS14(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS14_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS15[15] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 15 is not present
 * - 0b1 - A hardware service request for channel 15 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS15 field. */
#define DMA_RD_HRS_HRS15(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS15_MASK) >> DMA_HRS_HRS15_SHIFT)
#define DMA_BRD_HRS_HRS15(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS15_SHIFT))
/*@}*/

/*******************************************************************************
 * DMA_EARS - Enable Asynchronous Request in Stop Register
 ******************************************************************************/

/*!
 * @brief DMA_EARS - Enable Asynchronous Request in Stop Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_EARS register
 */
/*@{*/
#define DMA_RD_EARS(base)        (DMA_EARS_REG(base))
#define DMA_WR_EARS(base, value) (DMA_EARS_REG(base) = (value))
#define DMA_RMW_EARS(base, mask, value) (DMA_WR_EARS(base, (DMA_RD_EARS(base) & ~(mask)) | (value)))
#define DMA_SET_EARS(base, value) (DMA_WR_EARS(base, DMA_RD_EARS(base) |  (value)))
#define DMA_CLR_EARS(base, value) (DMA_WR_EARS(base, DMA_RD_EARS(base) & ~(value)))
#define DMA_TOG_EARS(base, value) (DMA_WR_EARS(base, DMA_RD_EARS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EARS bitfields
 */

/*!
 * @name Register DMA_EARS, field EDREQ_0[0] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 0.
 * - 0b1 - Enable asynchronous DMA request for channel 0.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_0 field. */
#define DMA_RD_EARS_EDREQ_0(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_0_MASK) >> DMA_EARS_EDREQ_0_SHIFT)
#define DMA_BRD_EARS_EDREQ_0(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_0_SHIFT))

/*! @brief Set the EDREQ_0 field to a new value. */
#define DMA_WR_EARS_EDREQ_0(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_0_MASK, DMA_EARS_EDREQ_0(value)))
#define DMA_BWR_EARS_EDREQ_0(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_1[1] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 1
 * - 0b1 - Enable asynchronous DMA request for channel 1.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_1 field. */
#define DMA_RD_EARS_EDREQ_1(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_1_MASK) >> DMA_EARS_EDREQ_1_SHIFT)
#define DMA_BRD_EARS_EDREQ_1(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_1_SHIFT))

/*! @brief Set the EDREQ_1 field to a new value. */
#define DMA_WR_EARS_EDREQ_1(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_1_MASK, DMA_EARS_EDREQ_1(value)))
#define DMA_BWR_EARS_EDREQ_1(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_2[2] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 2.
 * - 0b1 - Enable asynchronous DMA request for channel 2.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_2 field. */
#define DMA_RD_EARS_EDREQ_2(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_2_MASK) >> DMA_EARS_EDREQ_2_SHIFT)
#define DMA_BRD_EARS_EDREQ_2(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_2_SHIFT))

/*! @brief Set the EDREQ_2 field to a new value. */
#define DMA_WR_EARS_EDREQ_2(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_2_MASK, DMA_EARS_EDREQ_2(value)))
#define DMA_BWR_EARS_EDREQ_2(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_3[3] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 3.
 * - 0b1 - Enable asynchronous DMA request for channel 3.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_3 field. */
#define DMA_RD_EARS_EDREQ_3(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_3_MASK) >> DMA_EARS_EDREQ_3_SHIFT)
#define DMA_BRD_EARS_EDREQ_3(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_3_SHIFT))

/*! @brief Set the EDREQ_3 field to a new value. */
#define DMA_WR_EARS_EDREQ_3(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_3_MASK, DMA_EARS_EDREQ_3(value)))
#define DMA_BWR_EARS_EDREQ_3(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_4[4] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 4.
 * - 0b1 - Enable asynchronous DMA request for channel 4.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_4 field. */
#define DMA_RD_EARS_EDREQ_4(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_4_MASK) >> DMA_EARS_EDREQ_4_SHIFT)
#define DMA_BRD_EARS_EDREQ_4(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_4_SHIFT))

/*! @brief Set the EDREQ_4 field to a new value. */
#define DMA_WR_EARS_EDREQ_4(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_4_MASK, DMA_EARS_EDREQ_4(value)))
#define DMA_BWR_EARS_EDREQ_4(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_5[5] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 5.
 * - 0b1 - Enable asynchronous DMA request for channel 5.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_5 field. */
#define DMA_RD_EARS_EDREQ_5(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_5_MASK) >> DMA_EARS_EDREQ_5_SHIFT)
#define DMA_BRD_EARS_EDREQ_5(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_5_SHIFT))

/*! @brief Set the EDREQ_5 field to a new value. */
#define DMA_WR_EARS_EDREQ_5(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_5_MASK, DMA_EARS_EDREQ_5(value)))
#define DMA_BWR_EARS_EDREQ_5(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_6[6] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 6.
 * - 0b1 - Enable asynchronous DMA request for channel 6.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_6 field. */
#define DMA_RD_EARS_EDREQ_6(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_6_MASK) >> DMA_EARS_EDREQ_6_SHIFT)
#define DMA_BRD_EARS_EDREQ_6(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_6_SHIFT))

/*! @brief Set the EDREQ_6 field to a new value. */
#define DMA_WR_EARS_EDREQ_6(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_6_MASK, DMA_EARS_EDREQ_6(value)))
#define DMA_BWR_EARS_EDREQ_6(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_7[7] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 7.
 * - 0b1 - Enable asynchronous DMA request for channel 7.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_7 field. */
#define DMA_RD_EARS_EDREQ_7(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_7_MASK) >> DMA_EARS_EDREQ_7_SHIFT)
#define DMA_BRD_EARS_EDREQ_7(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_7_SHIFT))

/*! @brief Set the EDREQ_7 field to a new value. */
#define DMA_WR_EARS_EDREQ_7(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_7_MASK, DMA_EARS_EDREQ_7(value)))
#define DMA_BWR_EARS_EDREQ_7(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_8[8] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 8.
 * - 0b1 - Enable asynchronous DMA request for channel 8.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_8 field. */
#define DMA_RD_EARS_EDREQ_8(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_8_MASK) >> DMA_EARS_EDREQ_8_SHIFT)
#define DMA_BRD_EARS_EDREQ_8(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_8_SHIFT))

/*! @brief Set the EDREQ_8 field to a new value. */
#define DMA_WR_EARS_EDREQ_8(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_8_MASK, DMA_EARS_EDREQ_8(value)))
#define DMA_BWR_EARS_EDREQ_8(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_9[9] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 9.
 * - 0b1 - Enable asynchronous DMA request for channel 9.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_9 field. */
#define DMA_RD_EARS_EDREQ_9(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_9_MASK) >> DMA_EARS_EDREQ_9_SHIFT)
#define DMA_BRD_EARS_EDREQ_9(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_9_SHIFT))

/*! @brief Set the EDREQ_9 field to a new value. */
#define DMA_WR_EARS_EDREQ_9(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_9_MASK, DMA_EARS_EDREQ_9(value)))
#define DMA_BWR_EARS_EDREQ_9(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_10[10] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 10.
 * - 0b1 - Enable asynchronous DMA request for channel 10.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_10 field. */
#define DMA_RD_EARS_EDREQ_10(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_10_MASK) >> DMA_EARS_EDREQ_10_SHIFT)
#define DMA_BRD_EARS_EDREQ_10(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_10_SHIFT))

/*! @brief Set the EDREQ_10 field to a new value. */
#define DMA_WR_EARS_EDREQ_10(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_10_MASK, DMA_EARS_EDREQ_10(value)))
#define DMA_BWR_EARS_EDREQ_10(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_11[11] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 11.
 * - 0b1 - Enable asynchronous DMA request for channel 11.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_11 field. */
#define DMA_RD_EARS_EDREQ_11(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_11_MASK) >> DMA_EARS_EDREQ_11_SHIFT)
#define DMA_BRD_EARS_EDREQ_11(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_11_SHIFT))

/*! @brief Set the EDREQ_11 field to a new value. */
#define DMA_WR_EARS_EDREQ_11(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_11_MASK, DMA_EARS_EDREQ_11(value)))
#define DMA_BWR_EARS_EDREQ_11(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_12[12] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 12.
 * - 0b1 - Enable asynchronous DMA request for channel 12.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_12 field. */
#define DMA_RD_EARS_EDREQ_12(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_12_MASK) >> DMA_EARS_EDREQ_12_SHIFT)
#define DMA_BRD_EARS_EDREQ_12(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_12_SHIFT))

/*! @brief Set the EDREQ_12 field to a new value. */
#define DMA_WR_EARS_EDREQ_12(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_12_MASK, DMA_EARS_EDREQ_12(value)))
#define DMA_BWR_EARS_EDREQ_12(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_13[13] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 13.
 * - 0b1 - Enable asynchronous DMA request for channel 13.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_13 field. */
#define DMA_RD_EARS_EDREQ_13(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_13_MASK) >> DMA_EARS_EDREQ_13_SHIFT)
#define DMA_BRD_EARS_EDREQ_13(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_13_SHIFT))

/*! @brief Set the EDREQ_13 field to a new value. */
#define DMA_WR_EARS_EDREQ_13(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_13_MASK, DMA_EARS_EDREQ_13(value)))
#define DMA_BWR_EARS_EDREQ_13(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_14[14] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 14.
 * - 0b1 - Enable asynchronous DMA request for channel 14.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_14 field. */
#define DMA_RD_EARS_EDREQ_14(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_14_MASK) >> DMA_EARS_EDREQ_14_SHIFT)
#define DMA_BRD_EARS_EDREQ_14(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_14_SHIFT))

/*! @brief Set the EDREQ_14 field to a new value. */
#define DMA_WR_EARS_EDREQ_14(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_14_MASK, DMA_EARS_EDREQ_14(value)))
#define DMA_BWR_EARS_EDREQ_14(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_15[15] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 15.
 * - 0b1 - Enable asynchronous DMA request for channel 15.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_15 field. */
#define DMA_RD_EARS_EDREQ_15(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_15_MASK) >> DMA_EARS_EDREQ_15_SHIFT)
#define DMA_BRD_EARS_EDREQ_15(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_15_SHIFT))

/*! @brief Set the EDREQ_15 field to a new value. */
#define DMA_WR_EARS_EDREQ_15(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_15_MASK, DMA_EARS_EDREQ_15(value)))
#define DMA_BWR_EARS_EDREQ_15(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI register
 */
/*@{*/
#define DMA_RD_DCHPRI(base, index) (DMA_DCHPRI_REG(base, index))
#define DMA_WR_DCHPRI(base, index, value) (DMA_DCHPRI_REG(base, index) = (value))
#define DMA_RMW_DCHPRI(base, index, mask, value) (DMA_WR_DCHPRI(base, index, (DMA_RD_DCHPRI(base, index) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI(base, index, value) (DMA_WR_DCHPRI(base, index, DMA_RD_DCHPRI(base, index) |  (value)))
#define DMA_CLR_DCHPRI(base, index, value) (DMA_WR_DCHPRI(base, index, DMA_RD_DCHPRI(base, index) & ~(value)))
#define DMA_TOG_DCHPRI(base, index, value) (DMA_WR_DCHPRI(base, index, DMA_RD_DCHPRI(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI bitfields
 */

/*!
 * @name Register DMA_DCHPRI, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI_CHPRI field. */
#define DMA_RD_DCHPRI_CHPRI(base, index) ((DMA_DCHPRI_REG(base, index) & DMA_DCHPRI_CHPRI_MASK) >> DMA_DCHPRI_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI_CHPRI(base, index) (DMA_RD_DCHPRI_CHPRI(base, index))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI_CHPRI(base, index, value) (DMA_RMW_DCHPRI(base, index, DMA_DCHPRI_CHPRI_MASK, DMA_DCHPRI_CHPRI(value)))
#define DMA_BWR_DCHPRI_CHPRI(base, index, value) (DMA_WR_DCHPRI_CHPRI(base, index, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI_DPA field. */
#define DMA_RD_DCHPRI_DPA(base, index) ((DMA_DCHPRI_REG(base, index) & DMA_DCHPRI_DPA_MASK) >> DMA_DCHPRI_DPA_SHIFT)
#define DMA_BRD_DCHPRI_DPA(base, index) (BITBAND_ACCESS8(&DMA_DCHPRI_REG(base, index), DMA_DCHPRI_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI_DPA(base, index, value) (DMA_RMW_DCHPRI(base, index, DMA_DCHPRI_DPA_MASK, DMA_DCHPRI_DPA(value)))
#define DMA_BWR_DCHPRI_DPA(base, index, value) (BITBAND_ACCESS8(&DMA_DCHPRI_REG(base, index), DMA_DCHPRI_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI_ECP field. */
#define DMA_RD_DCHPRI_ECP(base, index) ((DMA_DCHPRI_REG(base, index) & DMA_DCHPRI_ECP_MASK) >> DMA_DCHPRI_ECP_SHIFT)
#define DMA_BRD_DCHPRI_ECP(base, index) (BITBAND_ACCESS8(&DMA_DCHPRI_REG(base, index), DMA_DCHPRI_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI_ECP(base, index, value) (DMA_RMW_DCHPRI(base, index, DMA_DCHPRI_ECP_MASK, DMA_DCHPRI_ECP(value)))
#define DMA_BWR_DCHPRI_ECP(base, index, value) (BITBAND_ACCESS8(&DMA_DCHPRI_REG(base, index), DMA_DCHPRI_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_SADDR register
 */
/*@{*/
#define DMA_RD_TCD0_SADDR(base)  (DMA_TCD0_SADDR_REG(base))
#define DMA_WR_TCD0_SADDR(base, value) (DMA_TCD0_SADDR_REG(base) = (value))
#define DMA_RMW_TCD0_SADDR(base, mask, value) (DMA_WR_TCD0_SADDR(base, (DMA_RD_TCD0_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_SADDR(base, value) (DMA_WR_TCD0_SADDR(base, DMA_RD_TCD0_SADDR(base) |  (value)))
#define DMA_CLR_TCD0_SADDR(base, value) (DMA_WR_TCD0_SADDR(base, DMA_RD_TCD0_SADDR(base) & ~(value)))
#define DMA_TOG_TCD0_SADDR(base, value) (DMA_WR_TCD0_SADDR(base, DMA_RD_TCD0_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_SOFF register
 */
/*@{*/
#define DMA_RD_TCD0_SOFF(base)   (DMA_TCD0_SOFF_REG(base))
#define DMA_WR_TCD0_SOFF(base, value) (DMA_TCD0_SOFF_REG(base) = (value))
#define DMA_RMW_TCD0_SOFF(base, mask, value) (DMA_WR_TCD0_SOFF(base, (DMA_RD_TCD0_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_SOFF(base, value) (DMA_WR_TCD0_SOFF(base, DMA_RD_TCD0_SOFF(base) |  (value)))
#define DMA_CLR_TCD0_SOFF(base, value) (DMA_WR_TCD0_SOFF(base, DMA_RD_TCD0_SOFF(base) & ~(value)))
#define DMA_TOG_TCD0_SOFF(base, value) (DMA_WR_TCD0_SOFF(base, DMA_RD_TCD0_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_ATTR register
 */
/*@{*/
#define DMA_RD_TCD0_ATTR(base)   (DMA_TCD0_ATTR_REG(base))
#define DMA_WR_TCD0_ATTR(base, value) (DMA_TCD0_ATTR_REG(base) = (value))
#define DMA_RMW_TCD0_ATTR(base, mask, value) (DMA_WR_TCD0_ATTR(base, (DMA_RD_TCD0_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_ATTR(base, value) (DMA_WR_TCD0_ATTR(base, DMA_RD_TCD0_ATTR(base) |  (value)))
#define DMA_CLR_TCD0_ATTR(base, value) (DMA_WR_TCD0_ATTR(base, DMA_RD_TCD0_ATTR(base) & ~(value)))
#define DMA_TOG_TCD0_ATTR(base, value) (DMA_WR_TCD0_ATTR(base, DMA_RD_TCD0_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD0_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_ATTR_DSIZE field. */
#define DMA_RD_TCD0_ATTR_DSIZE(base) ((DMA_TCD0_ATTR_REG(base) & DMA_TCD0_ATTR_DSIZE_MASK) >> DMA_TCD0_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD0_ATTR_DSIZE(base) (DMA_RD_TCD0_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD0_ATTR_DSIZE(base, value) (DMA_RMW_TCD0_ATTR(base, DMA_TCD0_ATTR_DSIZE_MASK, DMA_TCD0_ATTR_DSIZE(value)))
#define DMA_BWR_TCD0_ATTR_DSIZE(base, value) (DMA_WR_TCD0_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_ATTR_DMOD field. */
#define DMA_RD_TCD0_ATTR_DMOD(base) ((DMA_TCD0_ATTR_REG(base) & DMA_TCD0_ATTR_DMOD_MASK) >> DMA_TCD0_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD0_ATTR_DMOD(base) (DMA_RD_TCD0_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD0_ATTR_DMOD(base, value) (DMA_RMW_TCD0_ATTR(base, DMA_TCD0_ATTR_DMOD_MASK, DMA_TCD0_ATTR_DMOD(value)))
#define DMA_BWR_TCD0_ATTR_DMOD(base, value) (DMA_WR_TCD0_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_ATTR_SSIZE field. */
#define DMA_RD_TCD0_ATTR_SSIZE(base) ((DMA_TCD0_ATTR_REG(base) & DMA_TCD0_ATTR_SSIZE_MASK) >> DMA_TCD0_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD0_ATTR_SSIZE(base) (DMA_RD_TCD0_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD0_ATTR_SSIZE(base, value) (DMA_RMW_TCD0_ATTR(base, DMA_TCD0_ATTR_SSIZE_MASK, DMA_TCD0_ATTR_SSIZE(value)))
#define DMA_BWR_TCD0_ATTR_SSIZE(base, value) (DMA_WR_TCD0_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_ATTR_SMOD field. */
#define DMA_RD_TCD0_ATTR_SMOD(base) ((DMA_TCD0_ATTR_REG(base) & DMA_TCD0_ATTR_SMOD_MASK) >> DMA_TCD0_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD0_ATTR_SMOD(base) (DMA_RD_TCD0_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD0_ATTR_SMOD(base, value) (DMA_RMW_TCD0_ATTR(base, DMA_TCD0_ATTR_SMOD_MASK, DMA_TCD0_ATTR_SMOD(value)))
#define DMA_BWR_TCD0_ATTR_SMOD(base, value) (DMA_WR_TCD0_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD0_NBYTES_MLOFFYES(base) (DMA_TCD0_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD0_NBYTES_MLOFFYES(base, value) (DMA_TCD0_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD0_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD0_NBYTES_MLOFFYES(base, (DMA_RD_TCD0_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD0_NBYTES_MLOFFYES(base, DMA_RD_TCD0_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD0_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD0_NBYTES_MLOFFYES(base, DMA_RD_TCD0_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD0_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD0_NBYTES_MLOFFYES(base, DMA_RD_TCD0_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD0_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD0_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD0_NBYTES_MLOFFYES_REG(base) & DMA_TCD0_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD0_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD0_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD0_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD0_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD0_NBYTES_MLOFFYES(base, DMA_TCD0_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD0_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD0_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD0_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD0_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD0_NBYTES_MLOFFYES_REG(base) & DMA_TCD0_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD0_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD0_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD0_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD0_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD0_NBYTES_MLOFFYES(base, DMA_TCD0_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD0_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD0_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD0_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD0_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD0_NBYTES_MLOFFYES_REG(base) & DMA_TCD0_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD0_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD0_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFYES_REG(base), DMA_TCD0_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD0_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD0_NBYTES_MLOFFYES(base, DMA_TCD0_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD0_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD0_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFYES_REG(base), DMA_TCD0_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD0_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD0_NBYTES_MLOFFYES_REG(base) & DMA_TCD0_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD0_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD0_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFYES_REG(base), DMA_TCD0_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD0_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD0_NBYTES_MLOFFYES(base, DMA_TCD0_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD0_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD0_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFYES_REG(base), DMA_TCD0_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD0_NBYTES_MLOFFNO(base) (DMA_TCD0_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD0_NBYTES_MLOFFNO(base, value) (DMA_TCD0_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD0_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD0_NBYTES_MLOFFNO(base, (DMA_RD_TCD0_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD0_NBYTES_MLOFFNO(base, DMA_RD_TCD0_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD0_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD0_NBYTES_MLOFFNO(base, DMA_RD_TCD0_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD0_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD0_NBYTES_MLOFFNO(base, DMA_RD_TCD0_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD0_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD0_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD0_NBYTES_MLOFFNO_REG(base) & DMA_TCD0_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD0_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD0_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD0_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD0_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD0_NBYTES_MLOFFNO(base, DMA_TCD0_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD0_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD0_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD0_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD0_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD0_NBYTES_MLOFFNO_REG(base) & DMA_TCD0_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD0_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD0_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFNO_REG(base), DMA_TCD0_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD0_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD0_NBYTES_MLOFFNO(base, DMA_TCD0_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD0_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD0_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFNO_REG(base), DMA_TCD0_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD0_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD0_NBYTES_MLOFFNO_REG(base) & DMA_TCD0_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD0_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD0_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFNO_REG(base), DMA_TCD0_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD0_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD0_NBYTES_MLOFFNO(base, DMA_TCD0_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD0_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD0_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD0_NBYTES_MLOFFNO_REG(base), DMA_TCD0_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD0_NBYTES_MLNO(base) (DMA_TCD0_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD0_NBYTES_MLNO(base, value) (DMA_TCD0_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD0_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD0_NBYTES_MLNO(base, (DMA_RD_TCD0_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_NBYTES_MLNO(base, value) (DMA_WR_TCD0_NBYTES_MLNO(base, DMA_RD_TCD0_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD0_NBYTES_MLNO(base, value) (DMA_WR_TCD0_NBYTES_MLNO(base, DMA_RD_TCD0_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD0_NBYTES_MLNO(base, value) (DMA_WR_TCD0_NBYTES_MLNO(base, DMA_RD_TCD0_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_SLAST register
 */
/*@{*/
#define DMA_RD_TCD0_SLAST(base)  (DMA_TCD0_SLAST_REG(base))
#define DMA_WR_TCD0_SLAST(base, value) (DMA_TCD0_SLAST_REG(base) = (value))
#define DMA_RMW_TCD0_SLAST(base, mask, value) (DMA_WR_TCD0_SLAST(base, (DMA_RD_TCD0_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_SLAST(base, value) (DMA_WR_TCD0_SLAST(base, DMA_RD_TCD0_SLAST(base) |  (value)))
#define DMA_CLR_TCD0_SLAST(base, value) (DMA_WR_TCD0_SLAST(base, DMA_RD_TCD0_SLAST(base) & ~(value)))
#define DMA_TOG_TCD0_SLAST(base, value) (DMA_WR_TCD0_SLAST(base, DMA_RD_TCD0_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_DADDR register
 */
/*@{*/
#define DMA_RD_TCD0_DADDR(base)  (DMA_TCD0_DADDR_REG(base))
#define DMA_WR_TCD0_DADDR(base, value) (DMA_TCD0_DADDR_REG(base) = (value))
#define DMA_RMW_TCD0_DADDR(base, mask, value) (DMA_WR_TCD0_DADDR(base, (DMA_RD_TCD0_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_DADDR(base, value) (DMA_WR_TCD0_DADDR(base, DMA_RD_TCD0_DADDR(base) |  (value)))
#define DMA_CLR_TCD0_DADDR(base, value) (DMA_WR_TCD0_DADDR(base, DMA_RD_TCD0_DADDR(base) & ~(value)))
#define DMA_TOG_TCD0_DADDR(base, value) (DMA_WR_TCD0_DADDR(base, DMA_RD_TCD0_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_DOFF register
 */
/*@{*/
#define DMA_RD_TCD0_DOFF(base)   (DMA_TCD0_DOFF_REG(base))
#define DMA_WR_TCD0_DOFF(base, value) (DMA_TCD0_DOFF_REG(base) = (value))
#define DMA_RMW_TCD0_DOFF(base, mask, value) (DMA_WR_TCD0_DOFF(base, (DMA_RD_TCD0_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_DOFF(base, value) (DMA_WR_TCD0_DOFF(base, DMA_RD_TCD0_DOFF(base) |  (value)))
#define DMA_CLR_TCD0_DOFF(base, value) (DMA_WR_TCD0_DOFF(base, DMA_RD_TCD0_DOFF(base) & ~(value)))
#define DMA_TOG_TCD0_DOFF(base, value) (DMA_WR_TCD0_DOFF(base, DMA_RD_TCD0_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD0_CITER_ELINKNO(base) (DMA_TCD0_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD0_CITER_ELINKNO(base, value) (DMA_TCD0_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD0_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD0_CITER_ELINKNO(base, (DMA_RD_TCD0_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_CITER_ELINKNO(base, value) (DMA_WR_TCD0_CITER_ELINKNO(base, DMA_RD_TCD0_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD0_CITER_ELINKNO(base, value) (DMA_WR_TCD0_CITER_ELINKNO(base, DMA_RD_TCD0_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD0_CITER_ELINKNO(base, value) (DMA_WR_TCD0_CITER_ELINKNO(base, DMA_RD_TCD0_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD0_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD0_CITER_ELINKNO_CITER(base) ((DMA_TCD0_CITER_ELINKNO_REG(base) & DMA_TCD0_CITER_ELINKNO_CITER_MASK) >> DMA_TCD0_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD0_CITER_ELINKNO_CITER(base) (DMA_RD_TCD0_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD0_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD0_CITER_ELINKNO(base, DMA_TCD0_CITER_ELINKNO_CITER_MASK, DMA_TCD0_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD0_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD0_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD0_CITER_ELINKNO_ELINK(base) ((DMA_TCD0_CITER_ELINKNO_REG(base) & DMA_TCD0_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD0_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD0_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD0_CITER_ELINKNO_REG(base), DMA_TCD0_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD0_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD0_CITER_ELINKNO(base, DMA_TCD0_CITER_ELINKNO_ELINK_MASK, DMA_TCD0_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD0_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CITER_ELINKNO_REG(base), DMA_TCD0_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD0_CITER_ELINKYES(base) (DMA_TCD0_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD0_CITER_ELINKYES(base, value) (DMA_TCD0_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD0_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD0_CITER_ELINKYES(base, (DMA_RD_TCD0_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_CITER_ELINKYES(base, value) (DMA_WR_TCD0_CITER_ELINKYES(base, DMA_RD_TCD0_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD0_CITER_ELINKYES(base, value) (DMA_WR_TCD0_CITER_ELINKYES(base, DMA_RD_TCD0_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD0_CITER_ELINKYES(base, value) (DMA_WR_TCD0_CITER_ELINKYES(base, DMA_RD_TCD0_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD0_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD0_CITER_ELINKYES_CITER(base) ((DMA_TCD0_CITER_ELINKYES_REG(base) & DMA_TCD0_CITER_ELINKYES_CITER_MASK) >> DMA_TCD0_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD0_CITER_ELINKYES_CITER(base) (DMA_RD_TCD0_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD0_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD0_CITER_ELINKYES(base, DMA_TCD0_CITER_ELINKYES_CITER_MASK, DMA_TCD0_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD0_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD0_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD0_CITER_ELINKYES_LINKCH(base) ((DMA_TCD0_CITER_ELINKYES_REG(base) & DMA_TCD0_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD0_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD0_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD0_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD0_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD0_CITER_ELINKYES(base, DMA_TCD0_CITER_ELINKYES_LINKCH_MASK, DMA_TCD0_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD0_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD0_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD0_CITER_ELINKYES_ELINK(base) ((DMA_TCD0_CITER_ELINKYES_REG(base) & DMA_TCD0_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD0_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD0_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD0_CITER_ELINKYES_REG(base), DMA_TCD0_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD0_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD0_CITER_ELINKYES(base, DMA_TCD0_CITER_ELINKYES_ELINK_MASK, DMA_TCD0_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD0_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CITER_ELINKYES_REG(base), DMA_TCD0_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD0_DLASTSGA(base) (DMA_TCD0_DLASTSGA_REG(base))
#define DMA_WR_TCD0_DLASTSGA(base, value) (DMA_TCD0_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD0_DLASTSGA(base, mask, value) (DMA_WR_TCD0_DLASTSGA(base, (DMA_RD_TCD0_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_DLASTSGA(base, value) (DMA_WR_TCD0_DLASTSGA(base, DMA_RD_TCD0_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD0_DLASTSGA(base, value) (DMA_WR_TCD0_DLASTSGA(base, DMA_RD_TCD0_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD0_DLASTSGA(base, value) (DMA_WR_TCD0_DLASTSGA(base, DMA_RD_TCD0_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_CSR register
 */
/*@{*/
#define DMA_RD_TCD0_CSR(base)    (DMA_TCD0_CSR_REG(base))
#define DMA_WR_TCD0_CSR(base, value) (DMA_TCD0_CSR_REG(base) = (value))
#define DMA_RMW_TCD0_CSR(base, mask, value) (DMA_WR_TCD0_CSR(base, (DMA_RD_TCD0_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_CSR(base, value) (DMA_WR_TCD0_CSR(base, DMA_RD_TCD0_CSR(base) |  (value)))
#define DMA_CLR_TCD0_CSR(base, value) (DMA_WR_TCD0_CSR(base, DMA_RD_TCD0_CSR(base) & ~(value)))
#define DMA_TOG_TCD0_CSR(base, value) (DMA_WR_TCD0_CSR(base, DMA_RD_TCD0_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_CSR bitfields
 */

/*!
 * @name Register DMA_TCD0_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_START field. */
#define DMA_RD_TCD0_CSR_START(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_START_MASK) >> DMA_TCD0_CSR_START_SHIFT)
#define DMA_BRD_TCD0_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD0_CSR_START(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_START_MASK, DMA_TCD0_CSR_START(value)))
#define DMA_BWR_TCD0_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_INTMAJOR field. */
#define DMA_RD_TCD0_CSR_INTMAJOR(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_INTMAJOR_MASK) >> DMA_TCD0_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD0_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD0_CSR_INTMAJOR(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_INTMAJOR_MASK, DMA_TCD0_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD0_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_INTHALF field. */
#define DMA_RD_TCD0_CSR_INTHALF(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_INTHALF_MASK) >> DMA_TCD0_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD0_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD0_CSR_INTHALF(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_INTHALF_MASK, DMA_TCD0_CSR_INTHALF(value)))
#define DMA_BWR_TCD0_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_DREQ field. */
#define DMA_RD_TCD0_CSR_DREQ(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_DREQ_MASK) >> DMA_TCD0_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD0_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD0_CSR_DREQ(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_DREQ_MASK, DMA_TCD0_CSR_DREQ(value)))
#define DMA_BWR_TCD0_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_ESG field. */
#define DMA_RD_TCD0_CSR_ESG(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_ESG_MASK) >> DMA_TCD0_CSR_ESG_SHIFT)
#define DMA_BRD_TCD0_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD0_CSR_ESG(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_ESG_MASK, DMA_TCD0_CSR_ESG(value)))
#define DMA_BWR_TCD0_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_MAJORELINK field. */
#define DMA_RD_TCD0_CSR_MAJORELINK(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_MAJORELINK_MASK) >> DMA_TCD0_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD0_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD0_CSR_MAJORELINK(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_MAJORELINK_MASK, DMA_TCD0_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD0_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_ACTIVE field. */
#define DMA_RD_TCD0_CSR_ACTIVE(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_ACTIVE_MASK) >> DMA_TCD0_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD0_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD0_CSR_ACTIVE(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_ACTIVE_MASK, DMA_TCD0_CSR_ACTIVE(value)))
#define DMA_BWR_TCD0_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_DONE field. */
#define DMA_RD_TCD0_CSR_DONE(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_DONE_MASK) >> DMA_TCD0_CSR_DONE_SHIFT)
#define DMA_BRD_TCD0_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD0_CSR_DONE(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_DONE_MASK, DMA_TCD0_CSR_DONE(value)))
#define DMA_BWR_TCD0_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD0_CSR_REG(base), DMA_TCD0_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD0_CSR_MAJORLINKCH(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_MAJORLINKCH_MASK) >> DMA_TCD0_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD0_CSR_MAJORLINKCH(base) (DMA_RD_TCD0_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD0_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_MAJORLINKCH_MASK, DMA_TCD0_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD0_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD0_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_CSR_BWC field. */
#define DMA_RD_TCD0_CSR_BWC(base) ((DMA_TCD0_CSR_REG(base) & DMA_TCD0_CSR_BWC_MASK) >> DMA_TCD0_CSR_BWC_SHIFT)
#define DMA_BRD_TCD0_CSR_BWC(base) (DMA_RD_TCD0_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD0_CSR_BWC(base, value) (DMA_RMW_TCD0_CSR(base, DMA_TCD0_CSR_BWC_MASK, DMA_TCD0_CSR_BWC(value)))
#define DMA_BWR_TCD0_CSR_BWC(base, value) (DMA_WR_TCD0_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD0_BITER_ELINKNO(base) (DMA_TCD0_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD0_BITER_ELINKNO(base, value) (DMA_TCD0_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD0_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD0_BITER_ELINKNO(base, (DMA_RD_TCD0_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_BITER_ELINKNO(base, value) (DMA_WR_TCD0_BITER_ELINKNO(base, DMA_RD_TCD0_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD0_BITER_ELINKNO(base, value) (DMA_WR_TCD0_BITER_ELINKNO(base, DMA_RD_TCD0_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD0_BITER_ELINKNO(base, value) (DMA_WR_TCD0_BITER_ELINKNO(base, DMA_RD_TCD0_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD0_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD0_BITER_ELINKNO_BITER(base) ((DMA_TCD0_BITER_ELINKNO_REG(base) & DMA_TCD0_BITER_ELINKNO_BITER_MASK) >> DMA_TCD0_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD0_BITER_ELINKNO_BITER(base) (DMA_RD_TCD0_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD0_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD0_BITER_ELINKNO(base, DMA_TCD0_BITER_ELINKNO_BITER_MASK, DMA_TCD0_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD0_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD0_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD0_BITER_ELINKNO_ELINK(base) ((DMA_TCD0_BITER_ELINKNO_REG(base) & DMA_TCD0_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD0_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD0_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD0_BITER_ELINKNO_REG(base), DMA_TCD0_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD0_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD0_BITER_ELINKNO(base, DMA_TCD0_BITER_ELINKNO_ELINK_MASK, DMA_TCD0_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD0_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD0_BITER_ELINKNO_REG(base), DMA_TCD0_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD0_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD0_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD0_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD0_BITER_ELINKYES(base) (DMA_TCD0_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD0_BITER_ELINKYES(base, value) (DMA_TCD0_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD0_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD0_BITER_ELINKYES(base, (DMA_RD_TCD0_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD0_BITER_ELINKYES(base, value) (DMA_WR_TCD0_BITER_ELINKYES(base, DMA_RD_TCD0_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD0_BITER_ELINKYES(base, value) (DMA_WR_TCD0_BITER_ELINKYES(base, DMA_RD_TCD0_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD0_BITER_ELINKYES(base, value) (DMA_WR_TCD0_BITER_ELINKYES(base, DMA_RD_TCD0_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD0_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD0_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD0_BITER_ELINKYES_BITER(base) ((DMA_TCD0_BITER_ELINKYES_REG(base) & DMA_TCD0_BITER_ELINKYES_BITER_MASK) >> DMA_TCD0_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD0_BITER_ELINKYES_BITER(base) (DMA_RD_TCD0_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD0_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD0_BITER_ELINKYES(base, DMA_TCD0_BITER_ELINKYES_BITER_MASK, DMA_TCD0_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD0_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD0_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD0_BITER_ELINKYES_LINKCH(base) ((DMA_TCD0_BITER_ELINKYES_REG(base) & DMA_TCD0_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD0_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD0_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD0_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD0_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD0_BITER_ELINKYES(base, DMA_TCD0_BITER_ELINKYES_LINKCH_MASK, DMA_TCD0_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD0_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD0_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD0_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD0_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD0_BITER_ELINKYES_ELINK(base) ((DMA_TCD0_BITER_ELINKYES_REG(base) & DMA_TCD0_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD0_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD0_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD0_BITER_ELINKYES_REG(base), DMA_TCD0_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD0_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD0_BITER_ELINKYES(base, DMA_TCD0_BITER_ELINKYES_ELINK_MASK, DMA_TCD0_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD0_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD0_BITER_ELINKYES_REG(base), DMA_TCD0_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_SADDR register
 */
/*@{*/
#define DMA_RD_TCD1_SADDR(base)  (DMA_TCD1_SADDR_REG(base))
#define DMA_WR_TCD1_SADDR(base, value) (DMA_TCD1_SADDR_REG(base) = (value))
#define DMA_RMW_TCD1_SADDR(base, mask, value) (DMA_WR_TCD1_SADDR(base, (DMA_RD_TCD1_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_SADDR(base, value) (DMA_WR_TCD1_SADDR(base, DMA_RD_TCD1_SADDR(base) |  (value)))
#define DMA_CLR_TCD1_SADDR(base, value) (DMA_WR_TCD1_SADDR(base, DMA_RD_TCD1_SADDR(base) & ~(value)))
#define DMA_TOG_TCD1_SADDR(base, value) (DMA_WR_TCD1_SADDR(base, DMA_RD_TCD1_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_SOFF register
 */
/*@{*/
#define DMA_RD_TCD1_SOFF(base)   (DMA_TCD1_SOFF_REG(base))
#define DMA_WR_TCD1_SOFF(base, value) (DMA_TCD1_SOFF_REG(base) = (value))
#define DMA_RMW_TCD1_SOFF(base, mask, value) (DMA_WR_TCD1_SOFF(base, (DMA_RD_TCD1_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_SOFF(base, value) (DMA_WR_TCD1_SOFF(base, DMA_RD_TCD1_SOFF(base) |  (value)))
#define DMA_CLR_TCD1_SOFF(base, value) (DMA_WR_TCD1_SOFF(base, DMA_RD_TCD1_SOFF(base) & ~(value)))
#define DMA_TOG_TCD1_SOFF(base, value) (DMA_WR_TCD1_SOFF(base, DMA_RD_TCD1_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_ATTR register
 */
/*@{*/
#define DMA_RD_TCD1_ATTR(base)   (DMA_TCD1_ATTR_REG(base))
#define DMA_WR_TCD1_ATTR(base, value) (DMA_TCD1_ATTR_REG(base) = (value))
#define DMA_RMW_TCD1_ATTR(base, mask, value) (DMA_WR_TCD1_ATTR(base, (DMA_RD_TCD1_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_ATTR(base, value) (DMA_WR_TCD1_ATTR(base, DMA_RD_TCD1_ATTR(base) |  (value)))
#define DMA_CLR_TCD1_ATTR(base, value) (DMA_WR_TCD1_ATTR(base, DMA_RD_TCD1_ATTR(base) & ~(value)))
#define DMA_TOG_TCD1_ATTR(base, value) (DMA_WR_TCD1_ATTR(base, DMA_RD_TCD1_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD1_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_ATTR_DSIZE field. */
#define DMA_RD_TCD1_ATTR_DSIZE(base) ((DMA_TCD1_ATTR_REG(base) & DMA_TCD1_ATTR_DSIZE_MASK) >> DMA_TCD1_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD1_ATTR_DSIZE(base) (DMA_RD_TCD1_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD1_ATTR_DSIZE(base, value) (DMA_RMW_TCD1_ATTR(base, DMA_TCD1_ATTR_DSIZE_MASK, DMA_TCD1_ATTR_DSIZE(value)))
#define DMA_BWR_TCD1_ATTR_DSIZE(base, value) (DMA_WR_TCD1_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_ATTR_DMOD field. */
#define DMA_RD_TCD1_ATTR_DMOD(base) ((DMA_TCD1_ATTR_REG(base) & DMA_TCD1_ATTR_DMOD_MASK) >> DMA_TCD1_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD1_ATTR_DMOD(base) (DMA_RD_TCD1_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD1_ATTR_DMOD(base, value) (DMA_RMW_TCD1_ATTR(base, DMA_TCD1_ATTR_DMOD_MASK, DMA_TCD1_ATTR_DMOD(value)))
#define DMA_BWR_TCD1_ATTR_DMOD(base, value) (DMA_WR_TCD1_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_ATTR_SSIZE field. */
#define DMA_RD_TCD1_ATTR_SSIZE(base) ((DMA_TCD1_ATTR_REG(base) & DMA_TCD1_ATTR_SSIZE_MASK) >> DMA_TCD1_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD1_ATTR_SSIZE(base) (DMA_RD_TCD1_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD1_ATTR_SSIZE(base, value) (DMA_RMW_TCD1_ATTR(base, DMA_TCD1_ATTR_SSIZE_MASK, DMA_TCD1_ATTR_SSIZE(value)))
#define DMA_BWR_TCD1_ATTR_SSIZE(base, value) (DMA_WR_TCD1_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_ATTR_SMOD field. */
#define DMA_RD_TCD1_ATTR_SMOD(base) ((DMA_TCD1_ATTR_REG(base) & DMA_TCD1_ATTR_SMOD_MASK) >> DMA_TCD1_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD1_ATTR_SMOD(base) (DMA_RD_TCD1_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD1_ATTR_SMOD(base, value) (DMA_RMW_TCD1_ATTR(base, DMA_TCD1_ATTR_SMOD_MASK, DMA_TCD1_ATTR_SMOD(value)))
#define DMA_BWR_TCD1_ATTR_SMOD(base, value) (DMA_WR_TCD1_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD1_NBYTES_MLOFFYES(base) (DMA_TCD1_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD1_NBYTES_MLOFFYES(base, value) (DMA_TCD1_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD1_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD1_NBYTES_MLOFFYES(base, (DMA_RD_TCD1_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD1_NBYTES_MLOFFYES(base, DMA_RD_TCD1_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD1_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD1_NBYTES_MLOFFYES(base, DMA_RD_TCD1_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD1_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD1_NBYTES_MLOFFYES(base, DMA_RD_TCD1_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD1_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD1_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD1_NBYTES_MLOFFYES_REG(base) & DMA_TCD1_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD1_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD1_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD1_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD1_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD1_NBYTES_MLOFFYES(base, DMA_TCD1_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD1_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD1_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD1_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD1_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD1_NBYTES_MLOFFYES_REG(base) & DMA_TCD1_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD1_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD1_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD1_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD1_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD1_NBYTES_MLOFFYES(base, DMA_TCD1_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD1_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD1_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD1_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD1_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD1_NBYTES_MLOFFYES_REG(base) & DMA_TCD1_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD1_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD1_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFYES_REG(base), DMA_TCD1_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD1_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD1_NBYTES_MLOFFYES(base, DMA_TCD1_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD1_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD1_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFYES_REG(base), DMA_TCD1_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD1_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD1_NBYTES_MLOFFYES_REG(base) & DMA_TCD1_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD1_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD1_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFYES_REG(base), DMA_TCD1_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD1_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD1_NBYTES_MLOFFYES(base, DMA_TCD1_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD1_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD1_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFYES_REG(base), DMA_TCD1_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD1_NBYTES_MLNO(base) (DMA_TCD1_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD1_NBYTES_MLNO(base, value) (DMA_TCD1_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD1_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD1_NBYTES_MLNO(base, (DMA_RD_TCD1_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_NBYTES_MLNO(base, value) (DMA_WR_TCD1_NBYTES_MLNO(base, DMA_RD_TCD1_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD1_NBYTES_MLNO(base, value) (DMA_WR_TCD1_NBYTES_MLNO(base, DMA_RD_TCD1_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD1_NBYTES_MLNO(base, value) (DMA_WR_TCD1_NBYTES_MLNO(base, DMA_RD_TCD1_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD1_NBYTES_MLOFFNO(base) (DMA_TCD1_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD1_NBYTES_MLOFFNO(base, value) (DMA_TCD1_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD1_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD1_NBYTES_MLOFFNO(base, (DMA_RD_TCD1_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD1_NBYTES_MLOFFNO(base, DMA_RD_TCD1_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD1_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD1_NBYTES_MLOFFNO(base, DMA_RD_TCD1_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD1_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD1_NBYTES_MLOFFNO(base, DMA_RD_TCD1_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD1_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD1_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD1_NBYTES_MLOFFNO_REG(base) & DMA_TCD1_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD1_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD1_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD1_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD1_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD1_NBYTES_MLOFFNO(base, DMA_TCD1_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD1_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD1_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD1_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD1_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD1_NBYTES_MLOFFNO_REG(base) & DMA_TCD1_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD1_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD1_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFNO_REG(base), DMA_TCD1_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD1_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD1_NBYTES_MLOFFNO(base, DMA_TCD1_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD1_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD1_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFNO_REG(base), DMA_TCD1_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD1_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD1_NBYTES_MLOFFNO_REG(base) & DMA_TCD1_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD1_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD1_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFNO_REG(base), DMA_TCD1_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD1_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD1_NBYTES_MLOFFNO(base, DMA_TCD1_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD1_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD1_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD1_NBYTES_MLOFFNO_REG(base), DMA_TCD1_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_SLAST register
 */
/*@{*/
#define DMA_RD_TCD1_SLAST(base)  (DMA_TCD1_SLAST_REG(base))
#define DMA_WR_TCD1_SLAST(base, value) (DMA_TCD1_SLAST_REG(base) = (value))
#define DMA_RMW_TCD1_SLAST(base, mask, value) (DMA_WR_TCD1_SLAST(base, (DMA_RD_TCD1_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_SLAST(base, value) (DMA_WR_TCD1_SLAST(base, DMA_RD_TCD1_SLAST(base) |  (value)))
#define DMA_CLR_TCD1_SLAST(base, value) (DMA_WR_TCD1_SLAST(base, DMA_RD_TCD1_SLAST(base) & ~(value)))
#define DMA_TOG_TCD1_SLAST(base, value) (DMA_WR_TCD1_SLAST(base, DMA_RD_TCD1_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_DADDR register
 */
/*@{*/
#define DMA_RD_TCD1_DADDR(base)  (DMA_TCD1_DADDR_REG(base))
#define DMA_WR_TCD1_DADDR(base, value) (DMA_TCD1_DADDR_REG(base) = (value))
#define DMA_RMW_TCD1_DADDR(base, mask, value) (DMA_WR_TCD1_DADDR(base, (DMA_RD_TCD1_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_DADDR(base, value) (DMA_WR_TCD1_DADDR(base, DMA_RD_TCD1_DADDR(base) |  (value)))
#define DMA_CLR_TCD1_DADDR(base, value) (DMA_WR_TCD1_DADDR(base, DMA_RD_TCD1_DADDR(base) & ~(value)))
#define DMA_TOG_TCD1_DADDR(base, value) (DMA_WR_TCD1_DADDR(base, DMA_RD_TCD1_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_DOFF register
 */
/*@{*/
#define DMA_RD_TCD1_DOFF(base)   (DMA_TCD1_DOFF_REG(base))
#define DMA_WR_TCD1_DOFF(base, value) (DMA_TCD1_DOFF_REG(base) = (value))
#define DMA_RMW_TCD1_DOFF(base, mask, value) (DMA_WR_TCD1_DOFF(base, (DMA_RD_TCD1_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_DOFF(base, value) (DMA_WR_TCD1_DOFF(base, DMA_RD_TCD1_DOFF(base) |  (value)))
#define DMA_CLR_TCD1_DOFF(base, value) (DMA_WR_TCD1_DOFF(base, DMA_RD_TCD1_DOFF(base) & ~(value)))
#define DMA_TOG_TCD1_DOFF(base, value) (DMA_WR_TCD1_DOFF(base, DMA_RD_TCD1_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD1_CITER_ELINKYES(base) (DMA_TCD1_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD1_CITER_ELINKYES(base, value) (DMA_TCD1_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD1_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD1_CITER_ELINKYES(base, (DMA_RD_TCD1_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_CITER_ELINKYES(base, value) (DMA_WR_TCD1_CITER_ELINKYES(base, DMA_RD_TCD1_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD1_CITER_ELINKYES(base, value) (DMA_WR_TCD1_CITER_ELINKYES(base, DMA_RD_TCD1_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD1_CITER_ELINKYES(base, value) (DMA_WR_TCD1_CITER_ELINKYES(base, DMA_RD_TCD1_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD1_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD1_CITER_ELINKYES_CITER(base) ((DMA_TCD1_CITER_ELINKYES_REG(base) & DMA_TCD1_CITER_ELINKYES_CITER_MASK) >> DMA_TCD1_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD1_CITER_ELINKYES_CITER(base) (DMA_RD_TCD1_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD1_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD1_CITER_ELINKYES(base, DMA_TCD1_CITER_ELINKYES_CITER_MASK, DMA_TCD1_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD1_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD1_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD1_CITER_ELINKYES_LINKCH(base) ((DMA_TCD1_CITER_ELINKYES_REG(base) & DMA_TCD1_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD1_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD1_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD1_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD1_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD1_CITER_ELINKYES(base, DMA_TCD1_CITER_ELINKYES_LINKCH_MASK, DMA_TCD1_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD1_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD1_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD1_CITER_ELINKYES_ELINK(base) ((DMA_TCD1_CITER_ELINKYES_REG(base) & DMA_TCD1_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD1_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD1_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD1_CITER_ELINKYES_REG(base), DMA_TCD1_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD1_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD1_CITER_ELINKYES(base, DMA_TCD1_CITER_ELINKYES_ELINK_MASK, DMA_TCD1_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD1_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CITER_ELINKYES_REG(base), DMA_TCD1_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD1_CITER_ELINKNO(base) (DMA_TCD1_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD1_CITER_ELINKNO(base, value) (DMA_TCD1_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD1_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD1_CITER_ELINKNO(base, (DMA_RD_TCD1_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_CITER_ELINKNO(base, value) (DMA_WR_TCD1_CITER_ELINKNO(base, DMA_RD_TCD1_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD1_CITER_ELINKNO(base, value) (DMA_WR_TCD1_CITER_ELINKNO(base, DMA_RD_TCD1_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD1_CITER_ELINKNO(base, value) (DMA_WR_TCD1_CITER_ELINKNO(base, DMA_RD_TCD1_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD1_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD1_CITER_ELINKNO_CITER(base) ((DMA_TCD1_CITER_ELINKNO_REG(base) & DMA_TCD1_CITER_ELINKNO_CITER_MASK) >> DMA_TCD1_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD1_CITER_ELINKNO_CITER(base) (DMA_RD_TCD1_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD1_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD1_CITER_ELINKNO(base, DMA_TCD1_CITER_ELINKNO_CITER_MASK, DMA_TCD1_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD1_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD1_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD1_CITER_ELINKNO_ELINK(base) ((DMA_TCD1_CITER_ELINKNO_REG(base) & DMA_TCD1_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD1_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD1_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD1_CITER_ELINKNO_REG(base), DMA_TCD1_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD1_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD1_CITER_ELINKNO(base, DMA_TCD1_CITER_ELINKNO_ELINK_MASK, DMA_TCD1_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD1_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CITER_ELINKNO_REG(base), DMA_TCD1_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD1_DLASTSGA(base) (DMA_TCD1_DLASTSGA_REG(base))
#define DMA_WR_TCD1_DLASTSGA(base, value) (DMA_TCD1_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD1_DLASTSGA(base, mask, value) (DMA_WR_TCD1_DLASTSGA(base, (DMA_RD_TCD1_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_DLASTSGA(base, value) (DMA_WR_TCD1_DLASTSGA(base, DMA_RD_TCD1_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD1_DLASTSGA(base, value) (DMA_WR_TCD1_DLASTSGA(base, DMA_RD_TCD1_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD1_DLASTSGA(base, value) (DMA_WR_TCD1_DLASTSGA(base, DMA_RD_TCD1_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_CSR register
 */
/*@{*/
#define DMA_RD_TCD1_CSR(base)    (DMA_TCD1_CSR_REG(base))
#define DMA_WR_TCD1_CSR(base, value) (DMA_TCD1_CSR_REG(base) = (value))
#define DMA_RMW_TCD1_CSR(base, mask, value) (DMA_WR_TCD1_CSR(base, (DMA_RD_TCD1_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_CSR(base, value) (DMA_WR_TCD1_CSR(base, DMA_RD_TCD1_CSR(base) |  (value)))
#define DMA_CLR_TCD1_CSR(base, value) (DMA_WR_TCD1_CSR(base, DMA_RD_TCD1_CSR(base) & ~(value)))
#define DMA_TOG_TCD1_CSR(base, value) (DMA_WR_TCD1_CSR(base, DMA_RD_TCD1_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_CSR bitfields
 */

/*!
 * @name Register DMA_TCD1_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_START field. */
#define DMA_RD_TCD1_CSR_START(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_START_MASK) >> DMA_TCD1_CSR_START_SHIFT)
#define DMA_BRD_TCD1_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD1_CSR_START(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_START_MASK, DMA_TCD1_CSR_START(value)))
#define DMA_BWR_TCD1_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_INTMAJOR field. */
#define DMA_RD_TCD1_CSR_INTMAJOR(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_INTMAJOR_MASK) >> DMA_TCD1_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD1_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD1_CSR_INTMAJOR(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_INTMAJOR_MASK, DMA_TCD1_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD1_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_INTHALF field. */
#define DMA_RD_TCD1_CSR_INTHALF(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_INTHALF_MASK) >> DMA_TCD1_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD1_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD1_CSR_INTHALF(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_INTHALF_MASK, DMA_TCD1_CSR_INTHALF(value)))
#define DMA_BWR_TCD1_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_DREQ field. */
#define DMA_RD_TCD1_CSR_DREQ(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_DREQ_MASK) >> DMA_TCD1_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD1_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD1_CSR_DREQ(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_DREQ_MASK, DMA_TCD1_CSR_DREQ(value)))
#define DMA_BWR_TCD1_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_ESG field. */
#define DMA_RD_TCD1_CSR_ESG(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_ESG_MASK) >> DMA_TCD1_CSR_ESG_SHIFT)
#define DMA_BRD_TCD1_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD1_CSR_ESG(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_ESG_MASK, DMA_TCD1_CSR_ESG(value)))
#define DMA_BWR_TCD1_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_MAJORELINK field. */
#define DMA_RD_TCD1_CSR_MAJORELINK(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_MAJORELINK_MASK) >> DMA_TCD1_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD1_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD1_CSR_MAJORELINK(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_MAJORELINK_MASK, DMA_TCD1_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD1_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_ACTIVE field. */
#define DMA_RD_TCD1_CSR_ACTIVE(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_ACTIVE_MASK) >> DMA_TCD1_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD1_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD1_CSR_ACTIVE(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_ACTIVE_MASK, DMA_TCD1_CSR_ACTIVE(value)))
#define DMA_BWR_TCD1_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_DONE field. */
#define DMA_RD_TCD1_CSR_DONE(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_DONE_MASK) >> DMA_TCD1_CSR_DONE_SHIFT)
#define DMA_BRD_TCD1_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD1_CSR_DONE(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_DONE_MASK, DMA_TCD1_CSR_DONE(value)))
#define DMA_BWR_TCD1_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD1_CSR_REG(base), DMA_TCD1_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD1_CSR_MAJORLINKCH(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_MAJORLINKCH_MASK) >> DMA_TCD1_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD1_CSR_MAJORLINKCH(base) (DMA_RD_TCD1_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD1_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_MAJORLINKCH_MASK, DMA_TCD1_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD1_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD1_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_CSR_BWC field. */
#define DMA_RD_TCD1_CSR_BWC(base) ((DMA_TCD1_CSR_REG(base) & DMA_TCD1_CSR_BWC_MASK) >> DMA_TCD1_CSR_BWC_SHIFT)
#define DMA_BRD_TCD1_CSR_BWC(base) (DMA_RD_TCD1_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD1_CSR_BWC(base, value) (DMA_RMW_TCD1_CSR(base, DMA_TCD1_CSR_BWC_MASK, DMA_TCD1_CSR_BWC(value)))
#define DMA_BWR_TCD1_CSR_BWC(base, value) (DMA_WR_TCD1_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD1_BITER_ELINKYES(base) (DMA_TCD1_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD1_BITER_ELINKYES(base, value) (DMA_TCD1_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD1_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD1_BITER_ELINKYES(base, (DMA_RD_TCD1_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_BITER_ELINKYES(base, value) (DMA_WR_TCD1_BITER_ELINKYES(base, DMA_RD_TCD1_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD1_BITER_ELINKYES(base, value) (DMA_WR_TCD1_BITER_ELINKYES(base, DMA_RD_TCD1_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD1_BITER_ELINKYES(base, value) (DMA_WR_TCD1_BITER_ELINKYES(base, DMA_RD_TCD1_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD1_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD1_BITER_ELINKYES_BITER(base) ((DMA_TCD1_BITER_ELINKYES_REG(base) & DMA_TCD1_BITER_ELINKYES_BITER_MASK) >> DMA_TCD1_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD1_BITER_ELINKYES_BITER(base) (DMA_RD_TCD1_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD1_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD1_BITER_ELINKYES(base, DMA_TCD1_BITER_ELINKYES_BITER_MASK, DMA_TCD1_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD1_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD1_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD1_BITER_ELINKYES_LINKCH(base) ((DMA_TCD1_BITER_ELINKYES_REG(base) & DMA_TCD1_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD1_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD1_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD1_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD1_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD1_BITER_ELINKYES(base, DMA_TCD1_BITER_ELINKYES_LINKCH_MASK, DMA_TCD1_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD1_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD1_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD1_BITER_ELINKYES_ELINK(base) ((DMA_TCD1_BITER_ELINKYES_REG(base) & DMA_TCD1_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD1_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD1_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD1_BITER_ELINKYES_REG(base), DMA_TCD1_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD1_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD1_BITER_ELINKYES(base, DMA_TCD1_BITER_ELINKYES_ELINK_MASK, DMA_TCD1_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD1_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD1_BITER_ELINKYES_REG(base), DMA_TCD1_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD1_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD1_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD1_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD1_BITER_ELINKNO(base) (DMA_TCD1_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD1_BITER_ELINKNO(base, value) (DMA_TCD1_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD1_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD1_BITER_ELINKNO(base, (DMA_RD_TCD1_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD1_BITER_ELINKNO(base, value) (DMA_WR_TCD1_BITER_ELINKNO(base, DMA_RD_TCD1_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD1_BITER_ELINKNO(base, value) (DMA_WR_TCD1_BITER_ELINKNO(base, DMA_RD_TCD1_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD1_BITER_ELINKNO(base, value) (DMA_WR_TCD1_BITER_ELINKNO(base, DMA_RD_TCD1_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD1_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD1_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD1_BITER_ELINKNO_BITER(base) ((DMA_TCD1_BITER_ELINKNO_REG(base) & DMA_TCD1_BITER_ELINKNO_BITER_MASK) >> DMA_TCD1_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD1_BITER_ELINKNO_BITER(base) (DMA_RD_TCD1_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD1_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD1_BITER_ELINKNO(base, DMA_TCD1_BITER_ELINKNO_BITER_MASK, DMA_TCD1_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD1_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD1_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD1_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD1_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD1_BITER_ELINKNO_ELINK(base) ((DMA_TCD1_BITER_ELINKNO_REG(base) & DMA_TCD1_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD1_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD1_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD1_BITER_ELINKNO_REG(base), DMA_TCD1_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD1_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD1_BITER_ELINKNO(base, DMA_TCD1_BITER_ELINKNO_ELINK_MASK, DMA_TCD1_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD1_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD1_BITER_ELINKNO_REG(base), DMA_TCD1_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_SADDR register
 */
/*@{*/
#define DMA_RD_TCD2_SADDR(base)  (DMA_TCD2_SADDR_REG(base))
#define DMA_WR_TCD2_SADDR(base, value) (DMA_TCD2_SADDR_REG(base) = (value))
#define DMA_RMW_TCD2_SADDR(base, mask, value) (DMA_WR_TCD2_SADDR(base, (DMA_RD_TCD2_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_SADDR(base, value) (DMA_WR_TCD2_SADDR(base, DMA_RD_TCD2_SADDR(base) |  (value)))
#define DMA_CLR_TCD2_SADDR(base, value) (DMA_WR_TCD2_SADDR(base, DMA_RD_TCD2_SADDR(base) & ~(value)))
#define DMA_TOG_TCD2_SADDR(base, value) (DMA_WR_TCD2_SADDR(base, DMA_RD_TCD2_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_SOFF register
 */
/*@{*/
#define DMA_RD_TCD2_SOFF(base)   (DMA_TCD2_SOFF_REG(base))
#define DMA_WR_TCD2_SOFF(base, value) (DMA_TCD2_SOFF_REG(base) = (value))
#define DMA_RMW_TCD2_SOFF(base, mask, value) (DMA_WR_TCD2_SOFF(base, (DMA_RD_TCD2_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_SOFF(base, value) (DMA_WR_TCD2_SOFF(base, DMA_RD_TCD2_SOFF(base) |  (value)))
#define DMA_CLR_TCD2_SOFF(base, value) (DMA_WR_TCD2_SOFF(base, DMA_RD_TCD2_SOFF(base) & ~(value)))
#define DMA_TOG_TCD2_SOFF(base, value) (DMA_WR_TCD2_SOFF(base, DMA_RD_TCD2_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_ATTR register
 */
/*@{*/
#define DMA_RD_TCD2_ATTR(base)   (DMA_TCD2_ATTR_REG(base))
#define DMA_WR_TCD2_ATTR(base, value) (DMA_TCD2_ATTR_REG(base) = (value))
#define DMA_RMW_TCD2_ATTR(base, mask, value) (DMA_WR_TCD2_ATTR(base, (DMA_RD_TCD2_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_ATTR(base, value) (DMA_WR_TCD2_ATTR(base, DMA_RD_TCD2_ATTR(base) |  (value)))
#define DMA_CLR_TCD2_ATTR(base, value) (DMA_WR_TCD2_ATTR(base, DMA_RD_TCD2_ATTR(base) & ~(value)))
#define DMA_TOG_TCD2_ATTR(base, value) (DMA_WR_TCD2_ATTR(base, DMA_RD_TCD2_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD2_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_ATTR_DSIZE field. */
#define DMA_RD_TCD2_ATTR_DSIZE(base) ((DMA_TCD2_ATTR_REG(base) & DMA_TCD2_ATTR_DSIZE_MASK) >> DMA_TCD2_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD2_ATTR_DSIZE(base) (DMA_RD_TCD2_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD2_ATTR_DSIZE(base, value) (DMA_RMW_TCD2_ATTR(base, DMA_TCD2_ATTR_DSIZE_MASK, DMA_TCD2_ATTR_DSIZE(value)))
#define DMA_BWR_TCD2_ATTR_DSIZE(base, value) (DMA_WR_TCD2_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_ATTR_DMOD field. */
#define DMA_RD_TCD2_ATTR_DMOD(base) ((DMA_TCD2_ATTR_REG(base) & DMA_TCD2_ATTR_DMOD_MASK) >> DMA_TCD2_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD2_ATTR_DMOD(base) (DMA_RD_TCD2_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD2_ATTR_DMOD(base, value) (DMA_RMW_TCD2_ATTR(base, DMA_TCD2_ATTR_DMOD_MASK, DMA_TCD2_ATTR_DMOD(value)))
#define DMA_BWR_TCD2_ATTR_DMOD(base, value) (DMA_WR_TCD2_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_ATTR_SSIZE field. */
#define DMA_RD_TCD2_ATTR_SSIZE(base) ((DMA_TCD2_ATTR_REG(base) & DMA_TCD2_ATTR_SSIZE_MASK) >> DMA_TCD2_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD2_ATTR_SSIZE(base) (DMA_RD_TCD2_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD2_ATTR_SSIZE(base, value) (DMA_RMW_TCD2_ATTR(base, DMA_TCD2_ATTR_SSIZE_MASK, DMA_TCD2_ATTR_SSIZE(value)))
#define DMA_BWR_TCD2_ATTR_SSIZE(base, value) (DMA_WR_TCD2_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_ATTR_SMOD field. */
#define DMA_RD_TCD2_ATTR_SMOD(base) ((DMA_TCD2_ATTR_REG(base) & DMA_TCD2_ATTR_SMOD_MASK) >> DMA_TCD2_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD2_ATTR_SMOD(base) (DMA_RD_TCD2_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD2_ATTR_SMOD(base, value) (DMA_RMW_TCD2_ATTR(base, DMA_TCD2_ATTR_SMOD_MASK, DMA_TCD2_ATTR_SMOD(value)))
#define DMA_BWR_TCD2_ATTR_SMOD(base, value) (DMA_WR_TCD2_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD2_NBYTES_MLOFFNO(base) (DMA_TCD2_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD2_NBYTES_MLOFFNO(base, value) (DMA_TCD2_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD2_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD2_NBYTES_MLOFFNO(base, (DMA_RD_TCD2_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD2_NBYTES_MLOFFNO(base, DMA_RD_TCD2_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD2_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD2_NBYTES_MLOFFNO(base, DMA_RD_TCD2_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD2_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD2_NBYTES_MLOFFNO(base, DMA_RD_TCD2_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD2_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD2_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD2_NBYTES_MLOFFNO_REG(base) & DMA_TCD2_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD2_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD2_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD2_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD2_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD2_NBYTES_MLOFFNO(base, DMA_TCD2_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD2_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD2_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD2_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD2_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD2_NBYTES_MLOFFNO_REG(base) & DMA_TCD2_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD2_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD2_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFNO_REG(base), DMA_TCD2_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD2_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD2_NBYTES_MLOFFNO(base, DMA_TCD2_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD2_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD2_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFNO_REG(base), DMA_TCD2_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD2_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD2_NBYTES_MLOFFNO_REG(base) & DMA_TCD2_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD2_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD2_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFNO_REG(base), DMA_TCD2_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD2_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD2_NBYTES_MLOFFNO(base, DMA_TCD2_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD2_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD2_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFNO_REG(base), DMA_TCD2_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD2_NBYTES_MLOFFYES(base) (DMA_TCD2_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD2_NBYTES_MLOFFYES(base, value) (DMA_TCD2_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD2_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD2_NBYTES_MLOFFYES(base, (DMA_RD_TCD2_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD2_NBYTES_MLOFFYES(base, DMA_RD_TCD2_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD2_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD2_NBYTES_MLOFFYES(base, DMA_RD_TCD2_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD2_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD2_NBYTES_MLOFFYES(base, DMA_RD_TCD2_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD2_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD2_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD2_NBYTES_MLOFFYES_REG(base) & DMA_TCD2_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD2_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD2_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD2_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD2_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD2_NBYTES_MLOFFYES(base, DMA_TCD2_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD2_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD2_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD2_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD2_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD2_NBYTES_MLOFFYES_REG(base) & DMA_TCD2_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD2_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD2_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD2_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD2_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD2_NBYTES_MLOFFYES(base, DMA_TCD2_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD2_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD2_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD2_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD2_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD2_NBYTES_MLOFFYES_REG(base) & DMA_TCD2_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD2_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD2_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFYES_REG(base), DMA_TCD2_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD2_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD2_NBYTES_MLOFFYES(base, DMA_TCD2_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD2_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD2_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFYES_REG(base), DMA_TCD2_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD2_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD2_NBYTES_MLOFFYES_REG(base) & DMA_TCD2_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD2_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD2_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFYES_REG(base), DMA_TCD2_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD2_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD2_NBYTES_MLOFFYES(base, DMA_TCD2_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD2_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD2_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD2_NBYTES_MLOFFYES_REG(base), DMA_TCD2_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD2_NBYTES_MLNO(base) (DMA_TCD2_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD2_NBYTES_MLNO(base, value) (DMA_TCD2_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD2_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD2_NBYTES_MLNO(base, (DMA_RD_TCD2_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_NBYTES_MLNO(base, value) (DMA_WR_TCD2_NBYTES_MLNO(base, DMA_RD_TCD2_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD2_NBYTES_MLNO(base, value) (DMA_WR_TCD2_NBYTES_MLNO(base, DMA_RD_TCD2_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD2_NBYTES_MLNO(base, value) (DMA_WR_TCD2_NBYTES_MLNO(base, DMA_RD_TCD2_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_SLAST register
 */
/*@{*/
#define DMA_RD_TCD2_SLAST(base)  (DMA_TCD2_SLAST_REG(base))
#define DMA_WR_TCD2_SLAST(base, value) (DMA_TCD2_SLAST_REG(base) = (value))
#define DMA_RMW_TCD2_SLAST(base, mask, value) (DMA_WR_TCD2_SLAST(base, (DMA_RD_TCD2_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_SLAST(base, value) (DMA_WR_TCD2_SLAST(base, DMA_RD_TCD2_SLAST(base) |  (value)))
#define DMA_CLR_TCD2_SLAST(base, value) (DMA_WR_TCD2_SLAST(base, DMA_RD_TCD2_SLAST(base) & ~(value)))
#define DMA_TOG_TCD2_SLAST(base, value) (DMA_WR_TCD2_SLAST(base, DMA_RD_TCD2_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_DADDR register
 */
/*@{*/
#define DMA_RD_TCD2_DADDR(base)  (DMA_TCD2_DADDR_REG(base))
#define DMA_WR_TCD2_DADDR(base, value) (DMA_TCD2_DADDR_REG(base) = (value))
#define DMA_RMW_TCD2_DADDR(base, mask, value) (DMA_WR_TCD2_DADDR(base, (DMA_RD_TCD2_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_DADDR(base, value) (DMA_WR_TCD2_DADDR(base, DMA_RD_TCD2_DADDR(base) |  (value)))
#define DMA_CLR_TCD2_DADDR(base, value) (DMA_WR_TCD2_DADDR(base, DMA_RD_TCD2_DADDR(base) & ~(value)))
#define DMA_TOG_TCD2_DADDR(base, value) (DMA_WR_TCD2_DADDR(base, DMA_RD_TCD2_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_DOFF register
 */
/*@{*/
#define DMA_RD_TCD2_DOFF(base)   (DMA_TCD2_DOFF_REG(base))
#define DMA_WR_TCD2_DOFF(base, value) (DMA_TCD2_DOFF_REG(base) = (value))
#define DMA_RMW_TCD2_DOFF(base, mask, value) (DMA_WR_TCD2_DOFF(base, (DMA_RD_TCD2_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_DOFF(base, value) (DMA_WR_TCD2_DOFF(base, DMA_RD_TCD2_DOFF(base) |  (value)))
#define DMA_CLR_TCD2_DOFF(base, value) (DMA_WR_TCD2_DOFF(base, DMA_RD_TCD2_DOFF(base) & ~(value)))
#define DMA_TOG_TCD2_DOFF(base, value) (DMA_WR_TCD2_DOFF(base, DMA_RD_TCD2_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD2_CITER_ELINKYES(base) (DMA_TCD2_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD2_CITER_ELINKYES(base, value) (DMA_TCD2_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD2_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD2_CITER_ELINKYES(base, (DMA_RD_TCD2_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_CITER_ELINKYES(base, value) (DMA_WR_TCD2_CITER_ELINKYES(base, DMA_RD_TCD2_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD2_CITER_ELINKYES(base, value) (DMA_WR_TCD2_CITER_ELINKYES(base, DMA_RD_TCD2_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD2_CITER_ELINKYES(base, value) (DMA_WR_TCD2_CITER_ELINKYES(base, DMA_RD_TCD2_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD2_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD2_CITER_ELINKYES_CITER(base) ((DMA_TCD2_CITER_ELINKYES_REG(base) & DMA_TCD2_CITER_ELINKYES_CITER_MASK) >> DMA_TCD2_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD2_CITER_ELINKYES_CITER(base) (DMA_RD_TCD2_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD2_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD2_CITER_ELINKYES(base, DMA_TCD2_CITER_ELINKYES_CITER_MASK, DMA_TCD2_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD2_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD2_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD2_CITER_ELINKYES_LINKCH(base) ((DMA_TCD2_CITER_ELINKYES_REG(base) & DMA_TCD2_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD2_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD2_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD2_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD2_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD2_CITER_ELINKYES(base, DMA_TCD2_CITER_ELINKYES_LINKCH_MASK, DMA_TCD2_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD2_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD2_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD2_CITER_ELINKYES_ELINK(base) ((DMA_TCD2_CITER_ELINKYES_REG(base) & DMA_TCD2_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD2_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD2_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD2_CITER_ELINKYES_REG(base), DMA_TCD2_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD2_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD2_CITER_ELINKYES(base, DMA_TCD2_CITER_ELINKYES_ELINK_MASK, DMA_TCD2_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD2_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CITER_ELINKYES_REG(base), DMA_TCD2_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD2_CITER_ELINKNO(base) (DMA_TCD2_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD2_CITER_ELINKNO(base, value) (DMA_TCD2_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD2_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD2_CITER_ELINKNO(base, (DMA_RD_TCD2_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_CITER_ELINKNO(base, value) (DMA_WR_TCD2_CITER_ELINKNO(base, DMA_RD_TCD2_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD2_CITER_ELINKNO(base, value) (DMA_WR_TCD2_CITER_ELINKNO(base, DMA_RD_TCD2_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD2_CITER_ELINKNO(base, value) (DMA_WR_TCD2_CITER_ELINKNO(base, DMA_RD_TCD2_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD2_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD2_CITER_ELINKNO_CITER(base) ((DMA_TCD2_CITER_ELINKNO_REG(base) & DMA_TCD2_CITER_ELINKNO_CITER_MASK) >> DMA_TCD2_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD2_CITER_ELINKNO_CITER(base) (DMA_RD_TCD2_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD2_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD2_CITER_ELINKNO(base, DMA_TCD2_CITER_ELINKNO_CITER_MASK, DMA_TCD2_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD2_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD2_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD2_CITER_ELINKNO_ELINK(base) ((DMA_TCD2_CITER_ELINKNO_REG(base) & DMA_TCD2_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD2_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD2_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD2_CITER_ELINKNO_REG(base), DMA_TCD2_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD2_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD2_CITER_ELINKNO(base, DMA_TCD2_CITER_ELINKNO_ELINK_MASK, DMA_TCD2_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD2_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CITER_ELINKNO_REG(base), DMA_TCD2_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD2_DLASTSGA(base) (DMA_TCD2_DLASTSGA_REG(base))
#define DMA_WR_TCD2_DLASTSGA(base, value) (DMA_TCD2_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD2_DLASTSGA(base, mask, value) (DMA_WR_TCD2_DLASTSGA(base, (DMA_RD_TCD2_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_DLASTSGA(base, value) (DMA_WR_TCD2_DLASTSGA(base, DMA_RD_TCD2_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD2_DLASTSGA(base, value) (DMA_WR_TCD2_DLASTSGA(base, DMA_RD_TCD2_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD2_DLASTSGA(base, value) (DMA_WR_TCD2_DLASTSGA(base, DMA_RD_TCD2_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_CSR register
 */
/*@{*/
#define DMA_RD_TCD2_CSR(base)    (DMA_TCD2_CSR_REG(base))
#define DMA_WR_TCD2_CSR(base, value) (DMA_TCD2_CSR_REG(base) = (value))
#define DMA_RMW_TCD2_CSR(base, mask, value) (DMA_WR_TCD2_CSR(base, (DMA_RD_TCD2_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_CSR(base, value) (DMA_WR_TCD2_CSR(base, DMA_RD_TCD2_CSR(base) |  (value)))
#define DMA_CLR_TCD2_CSR(base, value) (DMA_WR_TCD2_CSR(base, DMA_RD_TCD2_CSR(base) & ~(value)))
#define DMA_TOG_TCD2_CSR(base, value) (DMA_WR_TCD2_CSR(base, DMA_RD_TCD2_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_CSR bitfields
 */

/*!
 * @name Register DMA_TCD2_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_START field. */
#define DMA_RD_TCD2_CSR_START(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_START_MASK) >> DMA_TCD2_CSR_START_SHIFT)
#define DMA_BRD_TCD2_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD2_CSR_START(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_START_MASK, DMA_TCD2_CSR_START(value)))
#define DMA_BWR_TCD2_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_INTMAJOR field. */
#define DMA_RD_TCD2_CSR_INTMAJOR(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_INTMAJOR_MASK) >> DMA_TCD2_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD2_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD2_CSR_INTMAJOR(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_INTMAJOR_MASK, DMA_TCD2_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD2_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_INTHALF field. */
#define DMA_RD_TCD2_CSR_INTHALF(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_INTHALF_MASK) >> DMA_TCD2_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD2_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD2_CSR_INTHALF(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_INTHALF_MASK, DMA_TCD2_CSR_INTHALF(value)))
#define DMA_BWR_TCD2_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_DREQ field. */
#define DMA_RD_TCD2_CSR_DREQ(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_DREQ_MASK) >> DMA_TCD2_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD2_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD2_CSR_DREQ(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_DREQ_MASK, DMA_TCD2_CSR_DREQ(value)))
#define DMA_BWR_TCD2_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_ESG field. */
#define DMA_RD_TCD2_CSR_ESG(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_ESG_MASK) >> DMA_TCD2_CSR_ESG_SHIFT)
#define DMA_BRD_TCD2_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD2_CSR_ESG(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_ESG_MASK, DMA_TCD2_CSR_ESG(value)))
#define DMA_BWR_TCD2_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_MAJORELINK field. */
#define DMA_RD_TCD2_CSR_MAJORELINK(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_MAJORELINK_MASK) >> DMA_TCD2_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD2_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD2_CSR_MAJORELINK(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_MAJORELINK_MASK, DMA_TCD2_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD2_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_ACTIVE field. */
#define DMA_RD_TCD2_CSR_ACTIVE(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_ACTIVE_MASK) >> DMA_TCD2_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD2_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD2_CSR_ACTIVE(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_ACTIVE_MASK, DMA_TCD2_CSR_ACTIVE(value)))
#define DMA_BWR_TCD2_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_DONE field. */
#define DMA_RD_TCD2_CSR_DONE(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_DONE_MASK) >> DMA_TCD2_CSR_DONE_SHIFT)
#define DMA_BRD_TCD2_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD2_CSR_DONE(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_DONE_MASK, DMA_TCD2_CSR_DONE(value)))
#define DMA_BWR_TCD2_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD2_CSR_REG(base), DMA_TCD2_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD2_CSR_MAJORLINKCH(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_MAJORLINKCH_MASK) >> DMA_TCD2_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD2_CSR_MAJORLINKCH(base) (DMA_RD_TCD2_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD2_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_MAJORLINKCH_MASK, DMA_TCD2_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD2_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD2_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_CSR_BWC field. */
#define DMA_RD_TCD2_CSR_BWC(base) ((DMA_TCD2_CSR_REG(base) & DMA_TCD2_CSR_BWC_MASK) >> DMA_TCD2_CSR_BWC_SHIFT)
#define DMA_BRD_TCD2_CSR_BWC(base) (DMA_RD_TCD2_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD2_CSR_BWC(base, value) (DMA_RMW_TCD2_CSR(base, DMA_TCD2_CSR_BWC_MASK, DMA_TCD2_CSR_BWC(value)))
#define DMA_BWR_TCD2_CSR_BWC(base, value) (DMA_WR_TCD2_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD2_BITER_ELINKNO(base) (DMA_TCD2_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD2_BITER_ELINKNO(base, value) (DMA_TCD2_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD2_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD2_BITER_ELINKNO(base, (DMA_RD_TCD2_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_BITER_ELINKNO(base, value) (DMA_WR_TCD2_BITER_ELINKNO(base, DMA_RD_TCD2_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD2_BITER_ELINKNO(base, value) (DMA_WR_TCD2_BITER_ELINKNO(base, DMA_RD_TCD2_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD2_BITER_ELINKNO(base, value) (DMA_WR_TCD2_BITER_ELINKNO(base, DMA_RD_TCD2_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD2_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD2_BITER_ELINKNO_BITER(base) ((DMA_TCD2_BITER_ELINKNO_REG(base) & DMA_TCD2_BITER_ELINKNO_BITER_MASK) >> DMA_TCD2_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD2_BITER_ELINKNO_BITER(base) (DMA_RD_TCD2_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD2_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD2_BITER_ELINKNO(base, DMA_TCD2_BITER_ELINKNO_BITER_MASK, DMA_TCD2_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD2_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD2_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD2_BITER_ELINKNO_ELINK(base) ((DMA_TCD2_BITER_ELINKNO_REG(base) & DMA_TCD2_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD2_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD2_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD2_BITER_ELINKNO_REG(base), DMA_TCD2_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD2_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD2_BITER_ELINKNO(base, DMA_TCD2_BITER_ELINKNO_ELINK_MASK, DMA_TCD2_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD2_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD2_BITER_ELINKNO_REG(base), DMA_TCD2_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD2_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD2_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD2_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD2_BITER_ELINKYES(base) (DMA_TCD2_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD2_BITER_ELINKYES(base, value) (DMA_TCD2_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD2_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD2_BITER_ELINKYES(base, (DMA_RD_TCD2_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD2_BITER_ELINKYES(base, value) (DMA_WR_TCD2_BITER_ELINKYES(base, DMA_RD_TCD2_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD2_BITER_ELINKYES(base, value) (DMA_WR_TCD2_BITER_ELINKYES(base, DMA_RD_TCD2_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD2_BITER_ELINKYES(base, value) (DMA_WR_TCD2_BITER_ELINKYES(base, DMA_RD_TCD2_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD2_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD2_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD2_BITER_ELINKYES_BITER(base) ((DMA_TCD2_BITER_ELINKYES_REG(base) & DMA_TCD2_BITER_ELINKYES_BITER_MASK) >> DMA_TCD2_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD2_BITER_ELINKYES_BITER(base) (DMA_RD_TCD2_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD2_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD2_BITER_ELINKYES(base, DMA_TCD2_BITER_ELINKYES_BITER_MASK, DMA_TCD2_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD2_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD2_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD2_BITER_ELINKYES_LINKCH(base) ((DMA_TCD2_BITER_ELINKYES_REG(base) & DMA_TCD2_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD2_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD2_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD2_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD2_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD2_BITER_ELINKYES(base, DMA_TCD2_BITER_ELINKYES_LINKCH_MASK, DMA_TCD2_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD2_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD2_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD2_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD2_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD2_BITER_ELINKYES_ELINK(base) ((DMA_TCD2_BITER_ELINKYES_REG(base) & DMA_TCD2_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD2_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD2_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD2_BITER_ELINKYES_REG(base), DMA_TCD2_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD2_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD2_BITER_ELINKYES(base, DMA_TCD2_BITER_ELINKYES_ELINK_MASK, DMA_TCD2_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD2_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD2_BITER_ELINKYES_REG(base), DMA_TCD2_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_SADDR register
 */
/*@{*/
#define DMA_RD_TCD3_SADDR(base)  (DMA_TCD3_SADDR_REG(base))
#define DMA_WR_TCD3_SADDR(base, value) (DMA_TCD3_SADDR_REG(base) = (value))
#define DMA_RMW_TCD3_SADDR(base, mask, value) (DMA_WR_TCD3_SADDR(base, (DMA_RD_TCD3_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_SADDR(base, value) (DMA_WR_TCD3_SADDR(base, DMA_RD_TCD3_SADDR(base) |  (value)))
#define DMA_CLR_TCD3_SADDR(base, value) (DMA_WR_TCD3_SADDR(base, DMA_RD_TCD3_SADDR(base) & ~(value)))
#define DMA_TOG_TCD3_SADDR(base, value) (DMA_WR_TCD3_SADDR(base, DMA_RD_TCD3_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_SOFF register
 */
/*@{*/
#define DMA_RD_TCD3_SOFF(base)   (DMA_TCD3_SOFF_REG(base))
#define DMA_WR_TCD3_SOFF(base, value) (DMA_TCD3_SOFF_REG(base) = (value))
#define DMA_RMW_TCD3_SOFF(base, mask, value) (DMA_WR_TCD3_SOFF(base, (DMA_RD_TCD3_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_SOFF(base, value) (DMA_WR_TCD3_SOFF(base, DMA_RD_TCD3_SOFF(base) |  (value)))
#define DMA_CLR_TCD3_SOFF(base, value) (DMA_WR_TCD3_SOFF(base, DMA_RD_TCD3_SOFF(base) & ~(value)))
#define DMA_TOG_TCD3_SOFF(base, value) (DMA_WR_TCD3_SOFF(base, DMA_RD_TCD3_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_ATTR register
 */
/*@{*/
#define DMA_RD_TCD3_ATTR(base)   (DMA_TCD3_ATTR_REG(base))
#define DMA_WR_TCD3_ATTR(base, value) (DMA_TCD3_ATTR_REG(base) = (value))
#define DMA_RMW_TCD3_ATTR(base, mask, value) (DMA_WR_TCD3_ATTR(base, (DMA_RD_TCD3_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_ATTR(base, value) (DMA_WR_TCD3_ATTR(base, DMA_RD_TCD3_ATTR(base) |  (value)))
#define DMA_CLR_TCD3_ATTR(base, value) (DMA_WR_TCD3_ATTR(base, DMA_RD_TCD3_ATTR(base) & ~(value)))
#define DMA_TOG_TCD3_ATTR(base, value) (DMA_WR_TCD3_ATTR(base, DMA_RD_TCD3_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD3_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_ATTR_DSIZE field. */
#define DMA_RD_TCD3_ATTR_DSIZE(base) ((DMA_TCD3_ATTR_REG(base) & DMA_TCD3_ATTR_DSIZE_MASK) >> DMA_TCD3_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD3_ATTR_DSIZE(base) (DMA_RD_TCD3_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD3_ATTR_DSIZE(base, value) (DMA_RMW_TCD3_ATTR(base, DMA_TCD3_ATTR_DSIZE_MASK, DMA_TCD3_ATTR_DSIZE(value)))
#define DMA_BWR_TCD3_ATTR_DSIZE(base, value) (DMA_WR_TCD3_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_ATTR_DMOD field. */
#define DMA_RD_TCD3_ATTR_DMOD(base) ((DMA_TCD3_ATTR_REG(base) & DMA_TCD3_ATTR_DMOD_MASK) >> DMA_TCD3_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD3_ATTR_DMOD(base) (DMA_RD_TCD3_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD3_ATTR_DMOD(base, value) (DMA_RMW_TCD3_ATTR(base, DMA_TCD3_ATTR_DMOD_MASK, DMA_TCD3_ATTR_DMOD(value)))
#define DMA_BWR_TCD3_ATTR_DMOD(base, value) (DMA_WR_TCD3_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_ATTR_SSIZE field. */
#define DMA_RD_TCD3_ATTR_SSIZE(base) ((DMA_TCD3_ATTR_REG(base) & DMA_TCD3_ATTR_SSIZE_MASK) >> DMA_TCD3_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD3_ATTR_SSIZE(base) (DMA_RD_TCD3_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD3_ATTR_SSIZE(base, value) (DMA_RMW_TCD3_ATTR(base, DMA_TCD3_ATTR_SSIZE_MASK, DMA_TCD3_ATTR_SSIZE(value)))
#define DMA_BWR_TCD3_ATTR_SSIZE(base, value) (DMA_WR_TCD3_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_ATTR_SMOD field. */
#define DMA_RD_TCD3_ATTR_SMOD(base) ((DMA_TCD3_ATTR_REG(base) & DMA_TCD3_ATTR_SMOD_MASK) >> DMA_TCD3_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD3_ATTR_SMOD(base) (DMA_RD_TCD3_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD3_ATTR_SMOD(base, value) (DMA_RMW_TCD3_ATTR(base, DMA_TCD3_ATTR_SMOD_MASK, DMA_TCD3_ATTR_SMOD(value)))
#define DMA_BWR_TCD3_ATTR_SMOD(base, value) (DMA_WR_TCD3_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD3_NBYTES_MLNO(base) (DMA_TCD3_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD3_NBYTES_MLNO(base, value) (DMA_TCD3_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD3_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD3_NBYTES_MLNO(base, (DMA_RD_TCD3_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_NBYTES_MLNO(base, value) (DMA_WR_TCD3_NBYTES_MLNO(base, DMA_RD_TCD3_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD3_NBYTES_MLNO(base, value) (DMA_WR_TCD3_NBYTES_MLNO(base, DMA_RD_TCD3_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD3_NBYTES_MLNO(base, value) (DMA_WR_TCD3_NBYTES_MLNO(base, DMA_RD_TCD3_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD3_NBYTES_MLOFFNO(base) (DMA_TCD3_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD3_NBYTES_MLOFFNO(base, value) (DMA_TCD3_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD3_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD3_NBYTES_MLOFFNO(base, (DMA_RD_TCD3_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD3_NBYTES_MLOFFNO(base, DMA_RD_TCD3_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD3_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD3_NBYTES_MLOFFNO(base, DMA_RD_TCD3_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD3_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD3_NBYTES_MLOFFNO(base, DMA_RD_TCD3_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD3_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD3_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD3_NBYTES_MLOFFNO_REG(base) & DMA_TCD3_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD3_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD3_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD3_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD3_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD3_NBYTES_MLOFFNO(base, DMA_TCD3_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD3_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD3_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD3_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD3_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD3_NBYTES_MLOFFNO_REG(base) & DMA_TCD3_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD3_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD3_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFNO_REG(base), DMA_TCD3_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD3_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD3_NBYTES_MLOFFNO(base, DMA_TCD3_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD3_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD3_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFNO_REG(base), DMA_TCD3_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD3_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD3_NBYTES_MLOFFNO_REG(base) & DMA_TCD3_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD3_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD3_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFNO_REG(base), DMA_TCD3_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD3_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD3_NBYTES_MLOFFNO(base, DMA_TCD3_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD3_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD3_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFNO_REG(base), DMA_TCD3_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD3_NBYTES_MLOFFYES(base) (DMA_TCD3_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD3_NBYTES_MLOFFYES(base, value) (DMA_TCD3_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD3_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD3_NBYTES_MLOFFYES(base, (DMA_RD_TCD3_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD3_NBYTES_MLOFFYES(base, DMA_RD_TCD3_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD3_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD3_NBYTES_MLOFFYES(base, DMA_RD_TCD3_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD3_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD3_NBYTES_MLOFFYES(base, DMA_RD_TCD3_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD3_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD3_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD3_NBYTES_MLOFFYES_REG(base) & DMA_TCD3_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD3_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD3_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD3_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD3_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD3_NBYTES_MLOFFYES(base, DMA_TCD3_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD3_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD3_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD3_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD3_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD3_NBYTES_MLOFFYES_REG(base) & DMA_TCD3_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD3_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD3_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD3_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD3_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD3_NBYTES_MLOFFYES(base, DMA_TCD3_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD3_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD3_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD3_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD3_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD3_NBYTES_MLOFFYES_REG(base) & DMA_TCD3_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD3_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD3_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFYES_REG(base), DMA_TCD3_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD3_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD3_NBYTES_MLOFFYES(base, DMA_TCD3_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD3_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD3_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFYES_REG(base), DMA_TCD3_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD3_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD3_NBYTES_MLOFFYES_REG(base) & DMA_TCD3_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD3_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD3_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFYES_REG(base), DMA_TCD3_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD3_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD3_NBYTES_MLOFFYES(base, DMA_TCD3_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD3_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD3_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD3_NBYTES_MLOFFYES_REG(base), DMA_TCD3_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_SLAST register
 */
/*@{*/
#define DMA_RD_TCD3_SLAST(base)  (DMA_TCD3_SLAST_REG(base))
#define DMA_WR_TCD3_SLAST(base, value) (DMA_TCD3_SLAST_REG(base) = (value))
#define DMA_RMW_TCD3_SLAST(base, mask, value) (DMA_WR_TCD3_SLAST(base, (DMA_RD_TCD3_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_SLAST(base, value) (DMA_WR_TCD3_SLAST(base, DMA_RD_TCD3_SLAST(base) |  (value)))
#define DMA_CLR_TCD3_SLAST(base, value) (DMA_WR_TCD3_SLAST(base, DMA_RD_TCD3_SLAST(base) & ~(value)))
#define DMA_TOG_TCD3_SLAST(base, value) (DMA_WR_TCD3_SLAST(base, DMA_RD_TCD3_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_DADDR register
 */
/*@{*/
#define DMA_RD_TCD3_DADDR(base)  (DMA_TCD3_DADDR_REG(base))
#define DMA_WR_TCD3_DADDR(base, value) (DMA_TCD3_DADDR_REG(base) = (value))
#define DMA_RMW_TCD3_DADDR(base, mask, value) (DMA_WR_TCD3_DADDR(base, (DMA_RD_TCD3_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_DADDR(base, value) (DMA_WR_TCD3_DADDR(base, DMA_RD_TCD3_DADDR(base) |  (value)))
#define DMA_CLR_TCD3_DADDR(base, value) (DMA_WR_TCD3_DADDR(base, DMA_RD_TCD3_DADDR(base) & ~(value)))
#define DMA_TOG_TCD3_DADDR(base, value) (DMA_WR_TCD3_DADDR(base, DMA_RD_TCD3_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_DOFF register
 */
/*@{*/
#define DMA_RD_TCD3_DOFF(base)   (DMA_TCD3_DOFF_REG(base))
#define DMA_WR_TCD3_DOFF(base, value) (DMA_TCD3_DOFF_REG(base) = (value))
#define DMA_RMW_TCD3_DOFF(base, mask, value) (DMA_WR_TCD3_DOFF(base, (DMA_RD_TCD3_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_DOFF(base, value) (DMA_WR_TCD3_DOFF(base, DMA_RD_TCD3_DOFF(base) |  (value)))
#define DMA_CLR_TCD3_DOFF(base, value) (DMA_WR_TCD3_DOFF(base, DMA_RD_TCD3_DOFF(base) & ~(value)))
#define DMA_TOG_TCD3_DOFF(base, value) (DMA_WR_TCD3_DOFF(base, DMA_RD_TCD3_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD3_CITER_ELINKNO(base) (DMA_TCD3_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD3_CITER_ELINKNO(base, value) (DMA_TCD3_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD3_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD3_CITER_ELINKNO(base, (DMA_RD_TCD3_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_CITER_ELINKNO(base, value) (DMA_WR_TCD3_CITER_ELINKNO(base, DMA_RD_TCD3_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD3_CITER_ELINKNO(base, value) (DMA_WR_TCD3_CITER_ELINKNO(base, DMA_RD_TCD3_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD3_CITER_ELINKNO(base, value) (DMA_WR_TCD3_CITER_ELINKNO(base, DMA_RD_TCD3_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD3_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD3_CITER_ELINKNO_CITER(base) ((DMA_TCD3_CITER_ELINKNO_REG(base) & DMA_TCD3_CITER_ELINKNO_CITER_MASK) >> DMA_TCD3_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD3_CITER_ELINKNO_CITER(base) (DMA_RD_TCD3_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD3_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD3_CITER_ELINKNO(base, DMA_TCD3_CITER_ELINKNO_CITER_MASK, DMA_TCD3_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD3_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD3_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD3_CITER_ELINKNO_ELINK(base) ((DMA_TCD3_CITER_ELINKNO_REG(base) & DMA_TCD3_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD3_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD3_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD3_CITER_ELINKNO_REG(base), DMA_TCD3_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD3_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD3_CITER_ELINKNO(base, DMA_TCD3_CITER_ELINKNO_ELINK_MASK, DMA_TCD3_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD3_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CITER_ELINKNO_REG(base), DMA_TCD3_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD3_CITER_ELINKYES(base) (DMA_TCD3_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD3_CITER_ELINKYES(base, value) (DMA_TCD3_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD3_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD3_CITER_ELINKYES(base, (DMA_RD_TCD3_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_CITER_ELINKYES(base, value) (DMA_WR_TCD3_CITER_ELINKYES(base, DMA_RD_TCD3_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD3_CITER_ELINKYES(base, value) (DMA_WR_TCD3_CITER_ELINKYES(base, DMA_RD_TCD3_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD3_CITER_ELINKYES(base, value) (DMA_WR_TCD3_CITER_ELINKYES(base, DMA_RD_TCD3_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD3_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD3_CITER_ELINKYES_CITER(base) ((DMA_TCD3_CITER_ELINKYES_REG(base) & DMA_TCD3_CITER_ELINKYES_CITER_MASK) >> DMA_TCD3_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD3_CITER_ELINKYES_CITER(base) (DMA_RD_TCD3_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD3_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD3_CITER_ELINKYES(base, DMA_TCD3_CITER_ELINKYES_CITER_MASK, DMA_TCD3_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD3_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD3_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD3_CITER_ELINKYES_LINKCH(base) ((DMA_TCD3_CITER_ELINKYES_REG(base) & DMA_TCD3_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD3_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD3_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD3_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD3_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD3_CITER_ELINKYES(base, DMA_TCD3_CITER_ELINKYES_LINKCH_MASK, DMA_TCD3_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD3_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD3_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD3_CITER_ELINKYES_ELINK(base) ((DMA_TCD3_CITER_ELINKYES_REG(base) & DMA_TCD3_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD3_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD3_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD3_CITER_ELINKYES_REG(base), DMA_TCD3_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD3_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD3_CITER_ELINKYES(base, DMA_TCD3_CITER_ELINKYES_ELINK_MASK, DMA_TCD3_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD3_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CITER_ELINKYES_REG(base), DMA_TCD3_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD3_DLASTSGA(base) (DMA_TCD3_DLASTSGA_REG(base))
#define DMA_WR_TCD3_DLASTSGA(base, value) (DMA_TCD3_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD3_DLASTSGA(base, mask, value) (DMA_WR_TCD3_DLASTSGA(base, (DMA_RD_TCD3_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_DLASTSGA(base, value) (DMA_WR_TCD3_DLASTSGA(base, DMA_RD_TCD3_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD3_DLASTSGA(base, value) (DMA_WR_TCD3_DLASTSGA(base, DMA_RD_TCD3_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD3_DLASTSGA(base, value) (DMA_WR_TCD3_DLASTSGA(base, DMA_RD_TCD3_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_CSR register
 */
/*@{*/
#define DMA_RD_TCD3_CSR(base)    (DMA_TCD3_CSR_REG(base))
#define DMA_WR_TCD3_CSR(base, value) (DMA_TCD3_CSR_REG(base) = (value))
#define DMA_RMW_TCD3_CSR(base, mask, value) (DMA_WR_TCD3_CSR(base, (DMA_RD_TCD3_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_CSR(base, value) (DMA_WR_TCD3_CSR(base, DMA_RD_TCD3_CSR(base) |  (value)))
#define DMA_CLR_TCD3_CSR(base, value) (DMA_WR_TCD3_CSR(base, DMA_RD_TCD3_CSR(base) & ~(value)))
#define DMA_TOG_TCD3_CSR(base, value) (DMA_WR_TCD3_CSR(base, DMA_RD_TCD3_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_CSR bitfields
 */

/*!
 * @name Register DMA_TCD3_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_START field. */
#define DMA_RD_TCD3_CSR_START(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_START_MASK) >> DMA_TCD3_CSR_START_SHIFT)
#define DMA_BRD_TCD3_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD3_CSR_START(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_START_MASK, DMA_TCD3_CSR_START(value)))
#define DMA_BWR_TCD3_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_INTMAJOR field. */
#define DMA_RD_TCD3_CSR_INTMAJOR(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_INTMAJOR_MASK) >> DMA_TCD3_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD3_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD3_CSR_INTMAJOR(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_INTMAJOR_MASK, DMA_TCD3_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD3_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_INTHALF field. */
#define DMA_RD_TCD3_CSR_INTHALF(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_INTHALF_MASK) >> DMA_TCD3_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD3_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD3_CSR_INTHALF(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_INTHALF_MASK, DMA_TCD3_CSR_INTHALF(value)))
#define DMA_BWR_TCD3_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_DREQ field. */
#define DMA_RD_TCD3_CSR_DREQ(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_DREQ_MASK) >> DMA_TCD3_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD3_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD3_CSR_DREQ(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_DREQ_MASK, DMA_TCD3_CSR_DREQ(value)))
#define DMA_BWR_TCD3_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_ESG field. */
#define DMA_RD_TCD3_CSR_ESG(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_ESG_MASK) >> DMA_TCD3_CSR_ESG_SHIFT)
#define DMA_BRD_TCD3_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD3_CSR_ESG(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_ESG_MASK, DMA_TCD3_CSR_ESG(value)))
#define DMA_BWR_TCD3_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_MAJORELINK field. */
#define DMA_RD_TCD3_CSR_MAJORELINK(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_MAJORELINK_MASK) >> DMA_TCD3_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD3_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD3_CSR_MAJORELINK(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_MAJORELINK_MASK, DMA_TCD3_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD3_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_ACTIVE field. */
#define DMA_RD_TCD3_CSR_ACTIVE(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_ACTIVE_MASK) >> DMA_TCD3_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD3_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD3_CSR_ACTIVE(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_ACTIVE_MASK, DMA_TCD3_CSR_ACTIVE(value)))
#define DMA_BWR_TCD3_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_DONE field. */
#define DMA_RD_TCD3_CSR_DONE(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_DONE_MASK) >> DMA_TCD3_CSR_DONE_SHIFT)
#define DMA_BRD_TCD3_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD3_CSR_DONE(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_DONE_MASK, DMA_TCD3_CSR_DONE(value)))
#define DMA_BWR_TCD3_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD3_CSR_REG(base), DMA_TCD3_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD3_CSR_MAJORLINKCH(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_MAJORLINKCH_MASK) >> DMA_TCD3_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD3_CSR_MAJORLINKCH(base) (DMA_RD_TCD3_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD3_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_MAJORLINKCH_MASK, DMA_TCD3_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD3_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD3_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_CSR_BWC field. */
#define DMA_RD_TCD3_CSR_BWC(base) ((DMA_TCD3_CSR_REG(base) & DMA_TCD3_CSR_BWC_MASK) >> DMA_TCD3_CSR_BWC_SHIFT)
#define DMA_BRD_TCD3_CSR_BWC(base) (DMA_RD_TCD3_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD3_CSR_BWC(base, value) (DMA_RMW_TCD3_CSR(base, DMA_TCD3_CSR_BWC_MASK, DMA_TCD3_CSR_BWC(value)))
#define DMA_BWR_TCD3_CSR_BWC(base, value) (DMA_WR_TCD3_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD3_BITER_ELINKNO(base) (DMA_TCD3_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD3_BITER_ELINKNO(base, value) (DMA_TCD3_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD3_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD3_BITER_ELINKNO(base, (DMA_RD_TCD3_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_BITER_ELINKNO(base, value) (DMA_WR_TCD3_BITER_ELINKNO(base, DMA_RD_TCD3_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD3_BITER_ELINKNO(base, value) (DMA_WR_TCD3_BITER_ELINKNO(base, DMA_RD_TCD3_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD3_BITER_ELINKNO(base, value) (DMA_WR_TCD3_BITER_ELINKNO(base, DMA_RD_TCD3_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD3_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD3_BITER_ELINKNO_BITER(base) ((DMA_TCD3_BITER_ELINKNO_REG(base) & DMA_TCD3_BITER_ELINKNO_BITER_MASK) >> DMA_TCD3_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD3_BITER_ELINKNO_BITER(base) (DMA_RD_TCD3_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD3_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD3_BITER_ELINKNO(base, DMA_TCD3_BITER_ELINKNO_BITER_MASK, DMA_TCD3_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD3_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD3_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD3_BITER_ELINKNO_ELINK(base) ((DMA_TCD3_BITER_ELINKNO_REG(base) & DMA_TCD3_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD3_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD3_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD3_BITER_ELINKNO_REG(base), DMA_TCD3_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD3_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD3_BITER_ELINKNO(base, DMA_TCD3_BITER_ELINKNO_ELINK_MASK, DMA_TCD3_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD3_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD3_BITER_ELINKNO_REG(base), DMA_TCD3_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD3_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD3_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD3_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD3_BITER_ELINKYES(base) (DMA_TCD3_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD3_BITER_ELINKYES(base, value) (DMA_TCD3_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD3_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD3_BITER_ELINKYES(base, (DMA_RD_TCD3_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD3_BITER_ELINKYES(base, value) (DMA_WR_TCD3_BITER_ELINKYES(base, DMA_RD_TCD3_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD3_BITER_ELINKYES(base, value) (DMA_WR_TCD3_BITER_ELINKYES(base, DMA_RD_TCD3_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD3_BITER_ELINKYES(base, value) (DMA_WR_TCD3_BITER_ELINKYES(base, DMA_RD_TCD3_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD3_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD3_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD3_BITER_ELINKYES_BITER(base) ((DMA_TCD3_BITER_ELINKYES_REG(base) & DMA_TCD3_BITER_ELINKYES_BITER_MASK) >> DMA_TCD3_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD3_BITER_ELINKYES_BITER(base) (DMA_RD_TCD3_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD3_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD3_BITER_ELINKYES(base, DMA_TCD3_BITER_ELINKYES_BITER_MASK, DMA_TCD3_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD3_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD3_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD3_BITER_ELINKYES_LINKCH(base) ((DMA_TCD3_BITER_ELINKYES_REG(base) & DMA_TCD3_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD3_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD3_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD3_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD3_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD3_BITER_ELINKYES(base, DMA_TCD3_BITER_ELINKYES_LINKCH_MASK, DMA_TCD3_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD3_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD3_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD3_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD3_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD3_BITER_ELINKYES_ELINK(base) ((DMA_TCD3_BITER_ELINKYES_REG(base) & DMA_TCD3_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD3_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD3_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD3_BITER_ELINKYES_REG(base), DMA_TCD3_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD3_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD3_BITER_ELINKYES(base, DMA_TCD3_BITER_ELINKYES_ELINK_MASK, DMA_TCD3_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD3_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD3_BITER_ELINKYES_REG(base), DMA_TCD3_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_SADDR register
 */
/*@{*/
#define DMA_RD_TCD4_SADDR(base)  (DMA_TCD4_SADDR_REG(base))
#define DMA_WR_TCD4_SADDR(base, value) (DMA_TCD4_SADDR_REG(base) = (value))
#define DMA_RMW_TCD4_SADDR(base, mask, value) (DMA_WR_TCD4_SADDR(base, (DMA_RD_TCD4_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_SADDR(base, value) (DMA_WR_TCD4_SADDR(base, DMA_RD_TCD4_SADDR(base) |  (value)))
#define DMA_CLR_TCD4_SADDR(base, value) (DMA_WR_TCD4_SADDR(base, DMA_RD_TCD4_SADDR(base) & ~(value)))
#define DMA_TOG_TCD4_SADDR(base, value) (DMA_WR_TCD4_SADDR(base, DMA_RD_TCD4_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_SOFF register
 */
/*@{*/
#define DMA_RD_TCD4_SOFF(base)   (DMA_TCD4_SOFF_REG(base))
#define DMA_WR_TCD4_SOFF(base, value) (DMA_TCD4_SOFF_REG(base) = (value))
#define DMA_RMW_TCD4_SOFF(base, mask, value) (DMA_WR_TCD4_SOFF(base, (DMA_RD_TCD4_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_SOFF(base, value) (DMA_WR_TCD4_SOFF(base, DMA_RD_TCD4_SOFF(base) |  (value)))
#define DMA_CLR_TCD4_SOFF(base, value) (DMA_WR_TCD4_SOFF(base, DMA_RD_TCD4_SOFF(base) & ~(value)))
#define DMA_TOG_TCD4_SOFF(base, value) (DMA_WR_TCD4_SOFF(base, DMA_RD_TCD4_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_ATTR register
 */
/*@{*/
#define DMA_RD_TCD4_ATTR(base)   (DMA_TCD4_ATTR_REG(base))
#define DMA_WR_TCD4_ATTR(base, value) (DMA_TCD4_ATTR_REG(base) = (value))
#define DMA_RMW_TCD4_ATTR(base, mask, value) (DMA_WR_TCD4_ATTR(base, (DMA_RD_TCD4_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_ATTR(base, value) (DMA_WR_TCD4_ATTR(base, DMA_RD_TCD4_ATTR(base) |  (value)))
#define DMA_CLR_TCD4_ATTR(base, value) (DMA_WR_TCD4_ATTR(base, DMA_RD_TCD4_ATTR(base) & ~(value)))
#define DMA_TOG_TCD4_ATTR(base, value) (DMA_WR_TCD4_ATTR(base, DMA_RD_TCD4_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD4_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_ATTR_DSIZE field. */
#define DMA_RD_TCD4_ATTR_DSIZE(base) ((DMA_TCD4_ATTR_REG(base) & DMA_TCD4_ATTR_DSIZE_MASK) >> DMA_TCD4_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD4_ATTR_DSIZE(base) (DMA_RD_TCD4_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD4_ATTR_DSIZE(base, value) (DMA_RMW_TCD4_ATTR(base, DMA_TCD4_ATTR_DSIZE_MASK, DMA_TCD4_ATTR_DSIZE(value)))
#define DMA_BWR_TCD4_ATTR_DSIZE(base, value) (DMA_WR_TCD4_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_ATTR_DMOD field. */
#define DMA_RD_TCD4_ATTR_DMOD(base) ((DMA_TCD4_ATTR_REG(base) & DMA_TCD4_ATTR_DMOD_MASK) >> DMA_TCD4_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD4_ATTR_DMOD(base) (DMA_RD_TCD4_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD4_ATTR_DMOD(base, value) (DMA_RMW_TCD4_ATTR(base, DMA_TCD4_ATTR_DMOD_MASK, DMA_TCD4_ATTR_DMOD(value)))
#define DMA_BWR_TCD4_ATTR_DMOD(base, value) (DMA_WR_TCD4_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_ATTR_SSIZE field. */
#define DMA_RD_TCD4_ATTR_SSIZE(base) ((DMA_TCD4_ATTR_REG(base) & DMA_TCD4_ATTR_SSIZE_MASK) >> DMA_TCD4_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD4_ATTR_SSIZE(base) (DMA_RD_TCD4_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD4_ATTR_SSIZE(base, value) (DMA_RMW_TCD4_ATTR(base, DMA_TCD4_ATTR_SSIZE_MASK, DMA_TCD4_ATTR_SSIZE(value)))
#define DMA_BWR_TCD4_ATTR_SSIZE(base, value) (DMA_WR_TCD4_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_ATTR_SMOD field. */
#define DMA_RD_TCD4_ATTR_SMOD(base) ((DMA_TCD4_ATTR_REG(base) & DMA_TCD4_ATTR_SMOD_MASK) >> DMA_TCD4_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD4_ATTR_SMOD(base) (DMA_RD_TCD4_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD4_ATTR_SMOD(base, value) (DMA_RMW_TCD4_ATTR(base, DMA_TCD4_ATTR_SMOD_MASK, DMA_TCD4_ATTR_SMOD(value)))
#define DMA_BWR_TCD4_ATTR_SMOD(base, value) (DMA_WR_TCD4_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD4_NBYTES_MLOFFYES(base) (DMA_TCD4_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD4_NBYTES_MLOFFYES(base, value) (DMA_TCD4_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD4_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD4_NBYTES_MLOFFYES(base, (DMA_RD_TCD4_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD4_NBYTES_MLOFFYES(base, DMA_RD_TCD4_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD4_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD4_NBYTES_MLOFFYES(base, DMA_RD_TCD4_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD4_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD4_NBYTES_MLOFFYES(base, DMA_RD_TCD4_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD4_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD4_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD4_NBYTES_MLOFFYES_REG(base) & DMA_TCD4_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD4_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD4_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD4_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD4_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD4_NBYTES_MLOFFYES(base, DMA_TCD4_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD4_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD4_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD4_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD4_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD4_NBYTES_MLOFFYES_REG(base) & DMA_TCD4_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD4_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD4_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD4_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD4_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD4_NBYTES_MLOFFYES(base, DMA_TCD4_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD4_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD4_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD4_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD4_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD4_NBYTES_MLOFFYES_REG(base) & DMA_TCD4_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD4_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD4_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFYES_REG(base), DMA_TCD4_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD4_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD4_NBYTES_MLOFFYES(base, DMA_TCD4_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD4_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD4_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFYES_REG(base), DMA_TCD4_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD4_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD4_NBYTES_MLOFFYES_REG(base) & DMA_TCD4_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD4_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD4_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFYES_REG(base), DMA_TCD4_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD4_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD4_NBYTES_MLOFFYES(base, DMA_TCD4_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD4_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD4_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFYES_REG(base), DMA_TCD4_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD4_NBYTES_MLOFFNO(base) (DMA_TCD4_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD4_NBYTES_MLOFFNO(base, value) (DMA_TCD4_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD4_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD4_NBYTES_MLOFFNO(base, (DMA_RD_TCD4_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD4_NBYTES_MLOFFNO(base, DMA_RD_TCD4_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD4_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD4_NBYTES_MLOFFNO(base, DMA_RD_TCD4_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD4_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD4_NBYTES_MLOFFNO(base, DMA_RD_TCD4_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD4_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD4_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD4_NBYTES_MLOFFNO_REG(base) & DMA_TCD4_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD4_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD4_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD4_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD4_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD4_NBYTES_MLOFFNO(base, DMA_TCD4_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD4_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD4_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD4_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD4_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD4_NBYTES_MLOFFNO_REG(base) & DMA_TCD4_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD4_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD4_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFNO_REG(base), DMA_TCD4_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD4_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD4_NBYTES_MLOFFNO(base, DMA_TCD4_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD4_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD4_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFNO_REG(base), DMA_TCD4_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD4_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD4_NBYTES_MLOFFNO_REG(base) & DMA_TCD4_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD4_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD4_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFNO_REG(base), DMA_TCD4_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD4_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD4_NBYTES_MLOFFNO(base, DMA_TCD4_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD4_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD4_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD4_NBYTES_MLOFFNO_REG(base), DMA_TCD4_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD4_NBYTES_MLNO(base) (DMA_TCD4_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD4_NBYTES_MLNO(base, value) (DMA_TCD4_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD4_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD4_NBYTES_MLNO(base, (DMA_RD_TCD4_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_NBYTES_MLNO(base, value) (DMA_WR_TCD4_NBYTES_MLNO(base, DMA_RD_TCD4_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD4_NBYTES_MLNO(base, value) (DMA_WR_TCD4_NBYTES_MLNO(base, DMA_RD_TCD4_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD4_NBYTES_MLNO(base, value) (DMA_WR_TCD4_NBYTES_MLNO(base, DMA_RD_TCD4_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_SLAST register
 */
/*@{*/
#define DMA_RD_TCD4_SLAST(base)  (DMA_TCD4_SLAST_REG(base))
#define DMA_WR_TCD4_SLAST(base, value) (DMA_TCD4_SLAST_REG(base) = (value))
#define DMA_RMW_TCD4_SLAST(base, mask, value) (DMA_WR_TCD4_SLAST(base, (DMA_RD_TCD4_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_SLAST(base, value) (DMA_WR_TCD4_SLAST(base, DMA_RD_TCD4_SLAST(base) |  (value)))
#define DMA_CLR_TCD4_SLAST(base, value) (DMA_WR_TCD4_SLAST(base, DMA_RD_TCD4_SLAST(base) & ~(value)))
#define DMA_TOG_TCD4_SLAST(base, value) (DMA_WR_TCD4_SLAST(base, DMA_RD_TCD4_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_DADDR register
 */
/*@{*/
#define DMA_RD_TCD4_DADDR(base)  (DMA_TCD4_DADDR_REG(base))
#define DMA_WR_TCD4_DADDR(base, value) (DMA_TCD4_DADDR_REG(base) = (value))
#define DMA_RMW_TCD4_DADDR(base, mask, value) (DMA_WR_TCD4_DADDR(base, (DMA_RD_TCD4_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_DADDR(base, value) (DMA_WR_TCD4_DADDR(base, DMA_RD_TCD4_DADDR(base) |  (value)))
#define DMA_CLR_TCD4_DADDR(base, value) (DMA_WR_TCD4_DADDR(base, DMA_RD_TCD4_DADDR(base) & ~(value)))
#define DMA_TOG_TCD4_DADDR(base, value) (DMA_WR_TCD4_DADDR(base, DMA_RD_TCD4_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_DOFF register
 */
/*@{*/
#define DMA_RD_TCD4_DOFF(base)   (DMA_TCD4_DOFF_REG(base))
#define DMA_WR_TCD4_DOFF(base, value) (DMA_TCD4_DOFF_REG(base) = (value))
#define DMA_RMW_TCD4_DOFF(base, mask, value) (DMA_WR_TCD4_DOFF(base, (DMA_RD_TCD4_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_DOFF(base, value) (DMA_WR_TCD4_DOFF(base, DMA_RD_TCD4_DOFF(base) |  (value)))
#define DMA_CLR_TCD4_DOFF(base, value) (DMA_WR_TCD4_DOFF(base, DMA_RD_TCD4_DOFF(base) & ~(value)))
#define DMA_TOG_TCD4_DOFF(base, value) (DMA_WR_TCD4_DOFF(base, DMA_RD_TCD4_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD4_CITER_ELINKYES(base) (DMA_TCD4_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD4_CITER_ELINKYES(base, value) (DMA_TCD4_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD4_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD4_CITER_ELINKYES(base, (DMA_RD_TCD4_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_CITER_ELINKYES(base, value) (DMA_WR_TCD4_CITER_ELINKYES(base, DMA_RD_TCD4_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD4_CITER_ELINKYES(base, value) (DMA_WR_TCD4_CITER_ELINKYES(base, DMA_RD_TCD4_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD4_CITER_ELINKYES(base, value) (DMA_WR_TCD4_CITER_ELINKYES(base, DMA_RD_TCD4_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD4_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD4_CITER_ELINKYES_CITER(base) ((DMA_TCD4_CITER_ELINKYES_REG(base) & DMA_TCD4_CITER_ELINKYES_CITER_MASK) >> DMA_TCD4_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD4_CITER_ELINKYES_CITER(base) (DMA_RD_TCD4_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD4_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD4_CITER_ELINKYES(base, DMA_TCD4_CITER_ELINKYES_CITER_MASK, DMA_TCD4_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD4_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD4_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD4_CITER_ELINKYES_LINKCH(base) ((DMA_TCD4_CITER_ELINKYES_REG(base) & DMA_TCD4_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD4_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD4_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD4_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD4_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD4_CITER_ELINKYES(base, DMA_TCD4_CITER_ELINKYES_LINKCH_MASK, DMA_TCD4_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD4_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD4_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD4_CITER_ELINKYES_ELINK(base) ((DMA_TCD4_CITER_ELINKYES_REG(base) & DMA_TCD4_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD4_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD4_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD4_CITER_ELINKYES_REG(base), DMA_TCD4_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD4_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD4_CITER_ELINKYES(base, DMA_TCD4_CITER_ELINKYES_ELINK_MASK, DMA_TCD4_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD4_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CITER_ELINKYES_REG(base), DMA_TCD4_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD4_CITER_ELINKNO(base) (DMA_TCD4_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD4_CITER_ELINKNO(base, value) (DMA_TCD4_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD4_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD4_CITER_ELINKNO(base, (DMA_RD_TCD4_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_CITER_ELINKNO(base, value) (DMA_WR_TCD4_CITER_ELINKNO(base, DMA_RD_TCD4_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD4_CITER_ELINKNO(base, value) (DMA_WR_TCD4_CITER_ELINKNO(base, DMA_RD_TCD4_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD4_CITER_ELINKNO(base, value) (DMA_WR_TCD4_CITER_ELINKNO(base, DMA_RD_TCD4_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD4_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD4_CITER_ELINKNO_CITER(base) ((DMA_TCD4_CITER_ELINKNO_REG(base) & DMA_TCD4_CITER_ELINKNO_CITER_MASK) >> DMA_TCD4_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD4_CITER_ELINKNO_CITER(base) (DMA_RD_TCD4_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD4_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD4_CITER_ELINKNO(base, DMA_TCD4_CITER_ELINKNO_CITER_MASK, DMA_TCD4_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD4_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD4_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD4_CITER_ELINKNO_ELINK(base) ((DMA_TCD4_CITER_ELINKNO_REG(base) & DMA_TCD4_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD4_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD4_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD4_CITER_ELINKNO_REG(base), DMA_TCD4_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD4_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD4_CITER_ELINKNO(base, DMA_TCD4_CITER_ELINKNO_ELINK_MASK, DMA_TCD4_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD4_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CITER_ELINKNO_REG(base), DMA_TCD4_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD4_DLASTSGA(base) (DMA_TCD4_DLASTSGA_REG(base))
#define DMA_WR_TCD4_DLASTSGA(base, value) (DMA_TCD4_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD4_DLASTSGA(base, mask, value) (DMA_WR_TCD4_DLASTSGA(base, (DMA_RD_TCD4_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_DLASTSGA(base, value) (DMA_WR_TCD4_DLASTSGA(base, DMA_RD_TCD4_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD4_DLASTSGA(base, value) (DMA_WR_TCD4_DLASTSGA(base, DMA_RD_TCD4_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD4_DLASTSGA(base, value) (DMA_WR_TCD4_DLASTSGA(base, DMA_RD_TCD4_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_CSR register
 */
/*@{*/
#define DMA_RD_TCD4_CSR(base)    (DMA_TCD4_CSR_REG(base))
#define DMA_WR_TCD4_CSR(base, value) (DMA_TCD4_CSR_REG(base) = (value))
#define DMA_RMW_TCD4_CSR(base, mask, value) (DMA_WR_TCD4_CSR(base, (DMA_RD_TCD4_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_CSR(base, value) (DMA_WR_TCD4_CSR(base, DMA_RD_TCD4_CSR(base) |  (value)))
#define DMA_CLR_TCD4_CSR(base, value) (DMA_WR_TCD4_CSR(base, DMA_RD_TCD4_CSR(base) & ~(value)))
#define DMA_TOG_TCD4_CSR(base, value) (DMA_WR_TCD4_CSR(base, DMA_RD_TCD4_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_CSR bitfields
 */

/*!
 * @name Register DMA_TCD4_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_START field. */
#define DMA_RD_TCD4_CSR_START(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_START_MASK) >> DMA_TCD4_CSR_START_SHIFT)
#define DMA_BRD_TCD4_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD4_CSR_START(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_START_MASK, DMA_TCD4_CSR_START(value)))
#define DMA_BWR_TCD4_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_INTMAJOR field. */
#define DMA_RD_TCD4_CSR_INTMAJOR(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_INTMAJOR_MASK) >> DMA_TCD4_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD4_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD4_CSR_INTMAJOR(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_INTMAJOR_MASK, DMA_TCD4_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD4_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_INTHALF field. */
#define DMA_RD_TCD4_CSR_INTHALF(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_INTHALF_MASK) >> DMA_TCD4_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD4_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD4_CSR_INTHALF(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_INTHALF_MASK, DMA_TCD4_CSR_INTHALF(value)))
#define DMA_BWR_TCD4_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_DREQ field. */
#define DMA_RD_TCD4_CSR_DREQ(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_DREQ_MASK) >> DMA_TCD4_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD4_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD4_CSR_DREQ(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_DREQ_MASK, DMA_TCD4_CSR_DREQ(value)))
#define DMA_BWR_TCD4_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_ESG field. */
#define DMA_RD_TCD4_CSR_ESG(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_ESG_MASK) >> DMA_TCD4_CSR_ESG_SHIFT)
#define DMA_BRD_TCD4_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD4_CSR_ESG(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_ESG_MASK, DMA_TCD4_CSR_ESG(value)))
#define DMA_BWR_TCD4_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_MAJORELINK field. */
#define DMA_RD_TCD4_CSR_MAJORELINK(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_MAJORELINK_MASK) >> DMA_TCD4_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD4_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD4_CSR_MAJORELINK(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_MAJORELINK_MASK, DMA_TCD4_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD4_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_ACTIVE field. */
#define DMA_RD_TCD4_CSR_ACTIVE(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_ACTIVE_MASK) >> DMA_TCD4_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD4_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD4_CSR_ACTIVE(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_ACTIVE_MASK, DMA_TCD4_CSR_ACTIVE(value)))
#define DMA_BWR_TCD4_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_DONE field. */
#define DMA_RD_TCD4_CSR_DONE(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_DONE_MASK) >> DMA_TCD4_CSR_DONE_SHIFT)
#define DMA_BRD_TCD4_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD4_CSR_DONE(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_DONE_MASK, DMA_TCD4_CSR_DONE(value)))
#define DMA_BWR_TCD4_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD4_CSR_REG(base), DMA_TCD4_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD4_CSR_MAJORLINKCH(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_MAJORLINKCH_MASK) >> DMA_TCD4_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD4_CSR_MAJORLINKCH(base) (DMA_RD_TCD4_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD4_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_MAJORLINKCH_MASK, DMA_TCD4_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD4_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD4_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_CSR_BWC field. */
#define DMA_RD_TCD4_CSR_BWC(base) ((DMA_TCD4_CSR_REG(base) & DMA_TCD4_CSR_BWC_MASK) >> DMA_TCD4_CSR_BWC_SHIFT)
#define DMA_BRD_TCD4_CSR_BWC(base) (DMA_RD_TCD4_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD4_CSR_BWC(base, value) (DMA_RMW_TCD4_CSR(base, DMA_TCD4_CSR_BWC_MASK, DMA_TCD4_CSR_BWC(value)))
#define DMA_BWR_TCD4_CSR_BWC(base, value) (DMA_WR_TCD4_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD4_BITER_ELINKNO(base) (DMA_TCD4_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD4_BITER_ELINKNO(base, value) (DMA_TCD4_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD4_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD4_BITER_ELINKNO(base, (DMA_RD_TCD4_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_BITER_ELINKNO(base, value) (DMA_WR_TCD4_BITER_ELINKNO(base, DMA_RD_TCD4_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD4_BITER_ELINKNO(base, value) (DMA_WR_TCD4_BITER_ELINKNO(base, DMA_RD_TCD4_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD4_BITER_ELINKNO(base, value) (DMA_WR_TCD4_BITER_ELINKNO(base, DMA_RD_TCD4_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD4_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD4_BITER_ELINKNO_BITER(base) ((DMA_TCD4_BITER_ELINKNO_REG(base) & DMA_TCD4_BITER_ELINKNO_BITER_MASK) >> DMA_TCD4_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD4_BITER_ELINKNO_BITER(base) (DMA_RD_TCD4_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD4_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD4_BITER_ELINKNO(base, DMA_TCD4_BITER_ELINKNO_BITER_MASK, DMA_TCD4_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD4_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD4_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD4_BITER_ELINKNO_ELINK(base) ((DMA_TCD4_BITER_ELINKNO_REG(base) & DMA_TCD4_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD4_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD4_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD4_BITER_ELINKNO_REG(base), DMA_TCD4_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD4_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD4_BITER_ELINKNO(base, DMA_TCD4_BITER_ELINKNO_ELINK_MASK, DMA_TCD4_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD4_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD4_BITER_ELINKNO_REG(base), DMA_TCD4_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD4_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD4_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD4_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD4_BITER_ELINKYES(base) (DMA_TCD4_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD4_BITER_ELINKYES(base, value) (DMA_TCD4_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD4_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD4_BITER_ELINKYES(base, (DMA_RD_TCD4_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD4_BITER_ELINKYES(base, value) (DMA_WR_TCD4_BITER_ELINKYES(base, DMA_RD_TCD4_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD4_BITER_ELINKYES(base, value) (DMA_WR_TCD4_BITER_ELINKYES(base, DMA_RD_TCD4_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD4_BITER_ELINKYES(base, value) (DMA_WR_TCD4_BITER_ELINKYES(base, DMA_RD_TCD4_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD4_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD4_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD4_BITER_ELINKYES_BITER(base) ((DMA_TCD4_BITER_ELINKYES_REG(base) & DMA_TCD4_BITER_ELINKYES_BITER_MASK) >> DMA_TCD4_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD4_BITER_ELINKYES_BITER(base) (DMA_RD_TCD4_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD4_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD4_BITER_ELINKYES(base, DMA_TCD4_BITER_ELINKYES_BITER_MASK, DMA_TCD4_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD4_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD4_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD4_BITER_ELINKYES_LINKCH(base) ((DMA_TCD4_BITER_ELINKYES_REG(base) & DMA_TCD4_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD4_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD4_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD4_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD4_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD4_BITER_ELINKYES(base, DMA_TCD4_BITER_ELINKYES_LINKCH_MASK, DMA_TCD4_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD4_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD4_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD4_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD4_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD4_BITER_ELINKYES_ELINK(base) ((DMA_TCD4_BITER_ELINKYES_REG(base) & DMA_TCD4_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD4_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD4_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD4_BITER_ELINKYES_REG(base), DMA_TCD4_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD4_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD4_BITER_ELINKYES(base, DMA_TCD4_BITER_ELINKYES_ELINK_MASK, DMA_TCD4_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD4_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD4_BITER_ELINKYES_REG(base), DMA_TCD4_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_SADDR register
 */
/*@{*/
#define DMA_RD_TCD5_SADDR(base)  (DMA_TCD5_SADDR_REG(base))
#define DMA_WR_TCD5_SADDR(base, value) (DMA_TCD5_SADDR_REG(base) = (value))
#define DMA_RMW_TCD5_SADDR(base, mask, value) (DMA_WR_TCD5_SADDR(base, (DMA_RD_TCD5_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_SADDR(base, value) (DMA_WR_TCD5_SADDR(base, DMA_RD_TCD5_SADDR(base) |  (value)))
#define DMA_CLR_TCD5_SADDR(base, value) (DMA_WR_TCD5_SADDR(base, DMA_RD_TCD5_SADDR(base) & ~(value)))
#define DMA_TOG_TCD5_SADDR(base, value) (DMA_WR_TCD5_SADDR(base, DMA_RD_TCD5_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_SOFF register
 */
/*@{*/
#define DMA_RD_TCD5_SOFF(base)   (DMA_TCD5_SOFF_REG(base))
#define DMA_WR_TCD5_SOFF(base, value) (DMA_TCD5_SOFF_REG(base) = (value))
#define DMA_RMW_TCD5_SOFF(base, mask, value) (DMA_WR_TCD5_SOFF(base, (DMA_RD_TCD5_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_SOFF(base, value) (DMA_WR_TCD5_SOFF(base, DMA_RD_TCD5_SOFF(base) |  (value)))
#define DMA_CLR_TCD5_SOFF(base, value) (DMA_WR_TCD5_SOFF(base, DMA_RD_TCD5_SOFF(base) & ~(value)))
#define DMA_TOG_TCD5_SOFF(base, value) (DMA_WR_TCD5_SOFF(base, DMA_RD_TCD5_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_ATTR register
 */
/*@{*/
#define DMA_RD_TCD5_ATTR(base)   (DMA_TCD5_ATTR_REG(base))
#define DMA_WR_TCD5_ATTR(base, value) (DMA_TCD5_ATTR_REG(base) = (value))
#define DMA_RMW_TCD5_ATTR(base, mask, value) (DMA_WR_TCD5_ATTR(base, (DMA_RD_TCD5_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_ATTR(base, value) (DMA_WR_TCD5_ATTR(base, DMA_RD_TCD5_ATTR(base) |  (value)))
#define DMA_CLR_TCD5_ATTR(base, value) (DMA_WR_TCD5_ATTR(base, DMA_RD_TCD5_ATTR(base) & ~(value)))
#define DMA_TOG_TCD5_ATTR(base, value) (DMA_WR_TCD5_ATTR(base, DMA_RD_TCD5_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD5_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_ATTR_DSIZE field. */
#define DMA_RD_TCD5_ATTR_DSIZE(base) ((DMA_TCD5_ATTR_REG(base) & DMA_TCD5_ATTR_DSIZE_MASK) >> DMA_TCD5_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD5_ATTR_DSIZE(base) (DMA_RD_TCD5_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD5_ATTR_DSIZE(base, value) (DMA_RMW_TCD5_ATTR(base, DMA_TCD5_ATTR_DSIZE_MASK, DMA_TCD5_ATTR_DSIZE(value)))
#define DMA_BWR_TCD5_ATTR_DSIZE(base, value) (DMA_WR_TCD5_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_ATTR_DMOD field. */
#define DMA_RD_TCD5_ATTR_DMOD(base) ((DMA_TCD5_ATTR_REG(base) & DMA_TCD5_ATTR_DMOD_MASK) >> DMA_TCD5_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD5_ATTR_DMOD(base) (DMA_RD_TCD5_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD5_ATTR_DMOD(base, value) (DMA_RMW_TCD5_ATTR(base, DMA_TCD5_ATTR_DMOD_MASK, DMA_TCD5_ATTR_DMOD(value)))
#define DMA_BWR_TCD5_ATTR_DMOD(base, value) (DMA_WR_TCD5_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_ATTR_SSIZE field. */
#define DMA_RD_TCD5_ATTR_SSIZE(base) ((DMA_TCD5_ATTR_REG(base) & DMA_TCD5_ATTR_SSIZE_MASK) >> DMA_TCD5_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD5_ATTR_SSIZE(base) (DMA_RD_TCD5_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD5_ATTR_SSIZE(base, value) (DMA_RMW_TCD5_ATTR(base, DMA_TCD5_ATTR_SSIZE_MASK, DMA_TCD5_ATTR_SSIZE(value)))
#define DMA_BWR_TCD5_ATTR_SSIZE(base, value) (DMA_WR_TCD5_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_ATTR_SMOD field. */
#define DMA_RD_TCD5_ATTR_SMOD(base) ((DMA_TCD5_ATTR_REG(base) & DMA_TCD5_ATTR_SMOD_MASK) >> DMA_TCD5_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD5_ATTR_SMOD(base) (DMA_RD_TCD5_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD5_ATTR_SMOD(base, value) (DMA_RMW_TCD5_ATTR(base, DMA_TCD5_ATTR_SMOD_MASK, DMA_TCD5_ATTR_SMOD(value)))
#define DMA_BWR_TCD5_ATTR_SMOD(base, value) (DMA_WR_TCD5_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD5_NBYTES_MLOFFYES(base) (DMA_TCD5_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD5_NBYTES_MLOFFYES(base, value) (DMA_TCD5_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD5_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD5_NBYTES_MLOFFYES(base, (DMA_RD_TCD5_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD5_NBYTES_MLOFFYES(base, DMA_RD_TCD5_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD5_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD5_NBYTES_MLOFFYES(base, DMA_RD_TCD5_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD5_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD5_NBYTES_MLOFFYES(base, DMA_RD_TCD5_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD5_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD5_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD5_NBYTES_MLOFFYES_REG(base) & DMA_TCD5_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD5_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD5_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD5_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD5_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD5_NBYTES_MLOFFYES(base, DMA_TCD5_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD5_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD5_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD5_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD5_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD5_NBYTES_MLOFFYES_REG(base) & DMA_TCD5_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD5_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD5_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD5_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD5_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD5_NBYTES_MLOFFYES(base, DMA_TCD5_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD5_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD5_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD5_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD5_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD5_NBYTES_MLOFFYES_REG(base) & DMA_TCD5_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD5_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD5_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFYES_REG(base), DMA_TCD5_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD5_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD5_NBYTES_MLOFFYES(base, DMA_TCD5_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD5_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD5_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFYES_REG(base), DMA_TCD5_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD5_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD5_NBYTES_MLOFFYES_REG(base) & DMA_TCD5_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD5_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD5_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFYES_REG(base), DMA_TCD5_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD5_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD5_NBYTES_MLOFFYES(base, DMA_TCD5_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD5_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD5_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFYES_REG(base), DMA_TCD5_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD5_NBYTES_MLNO(base) (DMA_TCD5_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD5_NBYTES_MLNO(base, value) (DMA_TCD5_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD5_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD5_NBYTES_MLNO(base, (DMA_RD_TCD5_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_NBYTES_MLNO(base, value) (DMA_WR_TCD5_NBYTES_MLNO(base, DMA_RD_TCD5_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD5_NBYTES_MLNO(base, value) (DMA_WR_TCD5_NBYTES_MLNO(base, DMA_RD_TCD5_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD5_NBYTES_MLNO(base, value) (DMA_WR_TCD5_NBYTES_MLNO(base, DMA_RD_TCD5_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD5_NBYTES_MLOFFNO(base) (DMA_TCD5_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD5_NBYTES_MLOFFNO(base, value) (DMA_TCD5_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD5_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD5_NBYTES_MLOFFNO(base, (DMA_RD_TCD5_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD5_NBYTES_MLOFFNO(base, DMA_RD_TCD5_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD5_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD5_NBYTES_MLOFFNO(base, DMA_RD_TCD5_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD5_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD5_NBYTES_MLOFFNO(base, DMA_RD_TCD5_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD5_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD5_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD5_NBYTES_MLOFFNO_REG(base) & DMA_TCD5_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD5_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD5_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD5_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD5_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD5_NBYTES_MLOFFNO(base, DMA_TCD5_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD5_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD5_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD5_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD5_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD5_NBYTES_MLOFFNO_REG(base) & DMA_TCD5_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD5_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD5_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFNO_REG(base), DMA_TCD5_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD5_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD5_NBYTES_MLOFFNO(base, DMA_TCD5_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD5_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD5_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFNO_REG(base), DMA_TCD5_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD5_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD5_NBYTES_MLOFFNO_REG(base) & DMA_TCD5_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD5_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD5_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFNO_REG(base), DMA_TCD5_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD5_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD5_NBYTES_MLOFFNO(base, DMA_TCD5_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD5_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD5_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD5_NBYTES_MLOFFNO_REG(base), DMA_TCD5_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_SLAST register
 */
/*@{*/
#define DMA_RD_TCD5_SLAST(base)  (DMA_TCD5_SLAST_REG(base))
#define DMA_WR_TCD5_SLAST(base, value) (DMA_TCD5_SLAST_REG(base) = (value))
#define DMA_RMW_TCD5_SLAST(base, mask, value) (DMA_WR_TCD5_SLAST(base, (DMA_RD_TCD5_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_SLAST(base, value) (DMA_WR_TCD5_SLAST(base, DMA_RD_TCD5_SLAST(base) |  (value)))
#define DMA_CLR_TCD5_SLAST(base, value) (DMA_WR_TCD5_SLAST(base, DMA_RD_TCD5_SLAST(base) & ~(value)))
#define DMA_TOG_TCD5_SLAST(base, value) (DMA_WR_TCD5_SLAST(base, DMA_RD_TCD5_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_DADDR register
 */
/*@{*/
#define DMA_RD_TCD5_DADDR(base)  (DMA_TCD5_DADDR_REG(base))
#define DMA_WR_TCD5_DADDR(base, value) (DMA_TCD5_DADDR_REG(base) = (value))
#define DMA_RMW_TCD5_DADDR(base, mask, value) (DMA_WR_TCD5_DADDR(base, (DMA_RD_TCD5_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_DADDR(base, value) (DMA_WR_TCD5_DADDR(base, DMA_RD_TCD5_DADDR(base) |  (value)))
#define DMA_CLR_TCD5_DADDR(base, value) (DMA_WR_TCD5_DADDR(base, DMA_RD_TCD5_DADDR(base) & ~(value)))
#define DMA_TOG_TCD5_DADDR(base, value) (DMA_WR_TCD5_DADDR(base, DMA_RD_TCD5_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_DOFF register
 */
/*@{*/
#define DMA_RD_TCD5_DOFF(base)   (DMA_TCD5_DOFF_REG(base))
#define DMA_WR_TCD5_DOFF(base, value) (DMA_TCD5_DOFF_REG(base) = (value))
#define DMA_RMW_TCD5_DOFF(base, mask, value) (DMA_WR_TCD5_DOFF(base, (DMA_RD_TCD5_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_DOFF(base, value) (DMA_WR_TCD5_DOFF(base, DMA_RD_TCD5_DOFF(base) |  (value)))
#define DMA_CLR_TCD5_DOFF(base, value) (DMA_WR_TCD5_DOFF(base, DMA_RD_TCD5_DOFF(base) & ~(value)))
#define DMA_TOG_TCD5_DOFF(base, value) (DMA_WR_TCD5_DOFF(base, DMA_RD_TCD5_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD5_CITER_ELINKYES(base) (DMA_TCD5_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD5_CITER_ELINKYES(base, value) (DMA_TCD5_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD5_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD5_CITER_ELINKYES(base, (DMA_RD_TCD5_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_CITER_ELINKYES(base, value) (DMA_WR_TCD5_CITER_ELINKYES(base, DMA_RD_TCD5_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD5_CITER_ELINKYES(base, value) (DMA_WR_TCD5_CITER_ELINKYES(base, DMA_RD_TCD5_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD5_CITER_ELINKYES(base, value) (DMA_WR_TCD5_CITER_ELINKYES(base, DMA_RD_TCD5_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD5_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD5_CITER_ELINKYES_CITER(base) ((DMA_TCD5_CITER_ELINKYES_REG(base) & DMA_TCD5_CITER_ELINKYES_CITER_MASK) >> DMA_TCD5_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD5_CITER_ELINKYES_CITER(base) (DMA_RD_TCD5_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD5_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD5_CITER_ELINKYES(base, DMA_TCD5_CITER_ELINKYES_CITER_MASK, DMA_TCD5_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD5_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD5_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD5_CITER_ELINKYES_LINKCH(base) ((DMA_TCD5_CITER_ELINKYES_REG(base) & DMA_TCD5_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD5_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD5_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD5_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD5_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD5_CITER_ELINKYES(base, DMA_TCD5_CITER_ELINKYES_LINKCH_MASK, DMA_TCD5_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD5_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD5_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD5_CITER_ELINKYES_ELINK(base) ((DMA_TCD5_CITER_ELINKYES_REG(base) & DMA_TCD5_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD5_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD5_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD5_CITER_ELINKYES_REG(base), DMA_TCD5_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD5_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD5_CITER_ELINKYES(base, DMA_TCD5_CITER_ELINKYES_ELINK_MASK, DMA_TCD5_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD5_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CITER_ELINKYES_REG(base), DMA_TCD5_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD5_CITER_ELINKNO(base) (DMA_TCD5_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD5_CITER_ELINKNO(base, value) (DMA_TCD5_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD5_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD5_CITER_ELINKNO(base, (DMA_RD_TCD5_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_CITER_ELINKNO(base, value) (DMA_WR_TCD5_CITER_ELINKNO(base, DMA_RD_TCD5_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD5_CITER_ELINKNO(base, value) (DMA_WR_TCD5_CITER_ELINKNO(base, DMA_RD_TCD5_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD5_CITER_ELINKNO(base, value) (DMA_WR_TCD5_CITER_ELINKNO(base, DMA_RD_TCD5_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD5_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD5_CITER_ELINKNO_CITER(base) ((DMA_TCD5_CITER_ELINKNO_REG(base) & DMA_TCD5_CITER_ELINKNO_CITER_MASK) >> DMA_TCD5_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD5_CITER_ELINKNO_CITER(base) (DMA_RD_TCD5_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD5_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD5_CITER_ELINKNO(base, DMA_TCD5_CITER_ELINKNO_CITER_MASK, DMA_TCD5_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD5_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD5_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD5_CITER_ELINKNO_ELINK(base) ((DMA_TCD5_CITER_ELINKNO_REG(base) & DMA_TCD5_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD5_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD5_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD5_CITER_ELINKNO_REG(base), DMA_TCD5_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD5_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD5_CITER_ELINKNO(base, DMA_TCD5_CITER_ELINKNO_ELINK_MASK, DMA_TCD5_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD5_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CITER_ELINKNO_REG(base), DMA_TCD5_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD5_DLASTSGA(base) (DMA_TCD5_DLASTSGA_REG(base))
#define DMA_WR_TCD5_DLASTSGA(base, value) (DMA_TCD5_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD5_DLASTSGA(base, mask, value) (DMA_WR_TCD5_DLASTSGA(base, (DMA_RD_TCD5_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_DLASTSGA(base, value) (DMA_WR_TCD5_DLASTSGA(base, DMA_RD_TCD5_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD5_DLASTSGA(base, value) (DMA_WR_TCD5_DLASTSGA(base, DMA_RD_TCD5_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD5_DLASTSGA(base, value) (DMA_WR_TCD5_DLASTSGA(base, DMA_RD_TCD5_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_CSR register
 */
/*@{*/
#define DMA_RD_TCD5_CSR(base)    (DMA_TCD5_CSR_REG(base))
#define DMA_WR_TCD5_CSR(base, value) (DMA_TCD5_CSR_REG(base) = (value))
#define DMA_RMW_TCD5_CSR(base, mask, value) (DMA_WR_TCD5_CSR(base, (DMA_RD_TCD5_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_CSR(base, value) (DMA_WR_TCD5_CSR(base, DMA_RD_TCD5_CSR(base) |  (value)))
#define DMA_CLR_TCD5_CSR(base, value) (DMA_WR_TCD5_CSR(base, DMA_RD_TCD5_CSR(base) & ~(value)))
#define DMA_TOG_TCD5_CSR(base, value) (DMA_WR_TCD5_CSR(base, DMA_RD_TCD5_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_CSR bitfields
 */

/*!
 * @name Register DMA_TCD5_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_START field. */
#define DMA_RD_TCD5_CSR_START(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_START_MASK) >> DMA_TCD5_CSR_START_SHIFT)
#define DMA_BRD_TCD5_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD5_CSR_START(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_START_MASK, DMA_TCD5_CSR_START(value)))
#define DMA_BWR_TCD5_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_INTMAJOR field. */
#define DMA_RD_TCD5_CSR_INTMAJOR(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_INTMAJOR_MASK) >> DMA_TCD5_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD5_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD5_CSR_INTMAJOR(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_INTMAJOR_MASK, DMA_TCD5_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD5_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_INTHALF field. */
#define DMA_RD_TCD5_CSR_INTHALF(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_INTHALF_MASK) >> DMA_TCD5_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD5_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD5_CSR_INTHALF(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_INTHALF_MASK, DMA_TCD5_CSR_INTHALF(value)))
#define DMA_BWR_TCD5_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_DREQ field. */
#define DMA_RD_TCD5_CSR_DREQ(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_DREQ_MASK) >> DMA_TCD5_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD5_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD5_CSR_DREQ(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_DREQ_MASK, DMA_TCD5_CSR_DREQ(value)))
#define DMA_BWR_TCD5_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_ESG field. */
#define DMA_RD_TCD5_CSR_ESG(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_ESG_MASK) >> DMA_TCD5_CSR_ESG_SHIFT)
#define DMA_BRD_TCD5_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD5_CSR_ESG(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_ESG_MASK, DMA_TCD5_CSR_ESG(value)))
#define DMA_BWR_TCD5_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_MAJORELINK field. */
#define DMA_RD_TCD5_CSR_MAJORELINK(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_MAJORELINK_MASK) >> DMA_TCD5_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD5_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD5_CSR_MAJORELINK(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_MAJORELINK_MASK, DMA_TCD5_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD5_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_ACTIVE field. */
#define DMA_RD_TCD5_CSR_ACTIVE(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_ACTIVE_MASK) >> DMA_TCD5_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD5_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD5_CSR_ACTIVE(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_ACTIVE_MASK, DMA_TCD5_CSR_ACTIVE(value)))
#define DMA_BWR_TCD5_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_DONE field. */
#define DMA_RD_TCD5_CSR_DONE(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_DONE_MASK) >> DMA_TCD5_CSR_DONE_SHIFT)
#define DMA_BRD_TCD5_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD5_CSR_DONE(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_DONE_MASK, DMA_TCD5_CSR_DONE(value)))
#define DMA_BWR_TCD5_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD5_CSR_REG(base), DMA_TCD5_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD5_CSR_MAJORLINKCH(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_MAJORLINKCH_MASK) >> DMA_TCD5_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD5_CSR_MAJORLINKCH(base) (DMA_RD_TCD5_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD5_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_MAJORLINKCH_MASK, DMA_TCD5_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD5_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD5_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_CSR_BWC field. */
#define DMA_RD_TCD5_CSR_BWC(base) ((DMA_TCD5_CSR_REG(base) & DMA_TCD5_CSR_BWC_MASK) >> DMA_TCD5_CSR_BWC_SHIFT)
#define DMA_BRD_TCD5_CSR_BWC(base) (DMA_RD_TCD5_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD5_CSR_BWC(base, value) (DMA_RMW_TCD5_CSR(base, DMA_TCD5_CSR_BWC_MASK, DMA_TCD5_CSR_BWC(value)))
#define DMA_BWR_TCD5_CSR_BWC(base, value) (DMA_WR_TCD5_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD5_BITER_ELINKYES(base) (DMA_TCD5_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD5_BITER_ELINKYES(base, value) (DMA_TCD5_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD5_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD5_BITER_ELINKYES(base, (DMA_RD_TCD5_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_BITER_ELINKYES(base, value) (DMA_WR_TCD5_BITER_ELINKYES(base, DMA_RD_TCD5_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD5_BITER_ELINKYES(base, value) (DMA_WR_TCD5_BITER_ELINKYES(base, DMA_RD_TCD5_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD5_BITER_ELINKYES(base, value) (DMA_WR_TCD5_BITER_ELINKYES(base, DMA_RD_TCD5_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD5_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD5_BITER_ELINKYES_BITER(base) ((DMA_TCD5_BITER_ELINKYES_REG(base) & DMA_TCD5_BITER_ELINKYES_BITER_MASK) >> DMA_TCD5_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD5_BITER_ELINKYES_BITER(base) (DMA_RD_TCD5_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD5_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD5_BITER_ELINKYES(base, DMA_TCD5_BITER_ELINKYES_BITER_MASK, DMA_TCD5_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD5_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD5_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD5_BITER_ELINKYES_LINKCH(base) ((DMA_TCD5_BITER_ELINKYES_REG(base) & DMA_TCD5_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD5_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD5_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD5_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD5_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD5_BITER_ELINKYES(base, DMA_TCD5_BITER_ELINKYES_LINKCH_MASK, DMA_TCD5_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD5_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD5_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD5_BITER_ELINKYES_ELINK(base) ((DMA_TCD5_BITER_ELINKYES_REG(base) & DMA_TCD5_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD5_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD5_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD5_BITER_ELINKYES_REG(base), DMA_TCD5_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD5_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD5_BITER_ELINKYES(base, DMA_TCD5_BITER_ELINKYES_ELINK_MASK, DMA_TCD5_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD5_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD5_BITER_ELINKYES_REG(base), DMA_TCD5_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD5_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD5_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD5_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD5_BITER_ELINKNO(base) (DMA_TCD5_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD5_BITER_ELINKNO(base, value) (DMA_TCD5_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD5_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD5_BITER_ELINKNO(base, (DMA_RD_TCD5_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD5_BITER_ELINKNO(base, value) (DMA_WR_TCD5_BITER_ELINKNO(base, DMA_RD_TCD5_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD5_BITER_ELINKNO(base, value) (DMA_WR_TCD5_BITER_ELINKNO(base, DMA_RD_TCD5_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD5_BITER_ELINKNO(base, value) (DMA_WR_TCD5_BITER_ELINKNO(base, DMA_RD_TCD5_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD5_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD5_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD5_BITER_ELINKNO_BITER(base) ((DMA_TCD5_BITER_ELINKNO_REG(base) & DMA_TCD5_BITER_ELINKNO_BITER_MASK) >> DMA_TCD5_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD5_BITER_ELINKNO_BITER(base) (DMA_RD_TCD5_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD5_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD5_BITER_ELINKNO(base, DMA_TCD5_BITER_ELINKNO_BITER_MASK, DMA_TCD5_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD5_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD5_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD5_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD5_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD5_BITER_ELINKNO_ELINK(base) ((DMA_TCD5_BITER_ELINKNO_REG(base) & DMA_TCD5_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD5_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD5_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD5_BITER_ELINKNO_REG(base), DMA_TCD5_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD5_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD5_BITER_ELINKNO(base, DMA_TCD5_BITER_ELINKNO_ELINK_MASK, DMA_TCD5_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD5_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD5_BITER_ELINKNO_REG(base), DMA_TCD5_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_SADDR register
 */
/*@{*/
#define DMA_RD_TCD6_SADDR(base)  (DMA_TCD6_SADDR_REG(base))
#define DMA_WR_TCD6_SADDR(base, value) (DMA_TCD6_SADDR_REG(base) = (value))
#define DMA_RMW_TCD6_SADDR(base, mask, value) (DMA_WR_TCD6_SADDR(base, (DMA_RD_TCD6_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_SADDR(base, value) (DMA_WR_TCD6_SADDR(base, DMA_RD_TCD6_SADDR(base) |  (value)))
#define DMA_CLR_TCD6_SADDR(base, value) (DMA_WR_TCD6_SADDR(base, DMA_RD_TCD6_SADDR(base) & ~(value)))
#define DMA_TOG_TCD6_SADDR(base, value) (DMA_WR_TCD6_SADDR(base, DMA_RD_TCD6_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_SOFF register
 */
/*@{*/
#define DMA_RD_TCD6_SOFF(base)   (DMA_TCD6_SOFF_REG(base))
#define DMA_WR_TCD6_SOFF(base, value) (DMA_TCD6_SOFF_REG(base) = (value))
#define DMA_RMW_TCD6_SOFF(base, mask, value) (DMA_WR_TCD6_SOFF(base, (DMA_RD_TCD6_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_SOFF(base, value) (DMA_WR_TCD6_SOFF(base, DMA_RD_TCD6_SOFF(base) |  (value)))
#define DMA_CLR_TCD6_SOFF(base, value) (DMA_WR_TCD6_SOFF(base, DMA_RD_TCD6_SOFF(base) & ~(value)))
#define DMA_TOG_TCD6_SOFF(base, value) (DMA_WR_TCD6_SOFF(base, DMA_RD_TCD6_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_ATTR register
 */
/*@{*/
#define DMA_RD_TCD6_ATTR(base)   (DMA_TCD6_ATTR_REG(base))
#define DMA_WR_TCD6_ATTR(base, value) (DMA_TCD6_ATTR_REG(base) = (value))
#define DMA_RMW_TCD6_ATTR(base, mask, value) (DMA_WR_TCD6_ATTR(base, (DMA_RD_TCD6_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_ATTR(base, value) (DMA_WR_TCD6_ATTR(base, DMA_RD_TCD6_ATTR(base) |  (value)))
#define DMA_CLR_TCD6_ATTR(base, value) (DMA_WR_TCD6_ATTR(base, DMA_RD_TCD6_ATTR(base) & ~(value)))
#define DMA_TOG_TCD6_ATTR(base, value) (DMA_WR_TCD6_ATTR(base, DMA_RD_TCD6_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD6_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_ATTR_DSIZE field. */
#define DMA_RD_TCD6_ATTR_DSIZE(base) ((DMA_TCD6_ATTR_REG(base) & DMA_TCD6_ATTR_DSIZE_MASK) >> DMA_TCD6_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD6_ATTR_DSIZE(base) (DMA_RD_TCD6_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD6_ATTR_DSIZE(base, value) (DMA_RMW_TCD6_ATTR(base, DMA_TCD6_ATTR_DSIZE_MASK, DMA_TCD6_ATTR_DSIZE(value)))
#define DMA_BWR_TCD6_ATTR_DSIZE(base, value) (DMA_WR_TCD6_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_ATTR_DMOD field. */
#define DMA_RD_TCD6_ATTR_DMOD(base) ((DMA_TCD6_ATTR_REG(base) & DMA_TCD6_ATTR_DMOD_MASK) >> DMA_TCD6_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD6_ATTR_DMOD(base) (DMA_RD_TCD6_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD6_ATTR_DMOD(base, value) (DMA_RMW_TCD6_ATTR(base, DMA_TCD6_ATTR_DMOD_MASK, DMA_TCD6_ATTR_DMOD(value)))
#define DMA_BWR_TCD6_ATTR_DMOD(base, value) (DMA_WR_TCD6_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_ATTR_SSIZE field. */
#define DMA_RD_TCD6_ATTR_SSIZE(base) ((DMA_TCD6_ATTR_REG(base) & DMA_TCD6_ATTR_SSIZE_MASK) >> DMA_TCD6_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD6_ATTR_SSIZE(base) (DMA_RD_TCD6_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD6_ATTR_SSIZE(base, value) (DMA_RMW_TCD6_ATTR(base, DMA_TCD6_ATTR_SSIZE_MASK, DMA_TCD6_ATTR_SSIZE(value)))
#define DMA_BWR_TCD6_ATTR_SSIZE(base, value) (DMA_WR_TCD6_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_ATTR_SMOD field. */
#define DMA_RD_TCD6_ATTR_SMOD(base) ((DMA_TCD6_ATTR_REG(base) & DMA_TCD6_ATTR_SMOD_MASK) >> DMA_TCD6_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD6_ATTR_SMOD(base) (DMA_RD_TCD6_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD6_ATTR_SMOD(base, value) (DMA_RMW_TCD6_ATTR(base, DMA_TCD6_ATTR_SMOD_MASK, DMA_TCD6_ATTR_SMOD(value)))
#define DMA_BWR_TCD6_ATTR_SMOD(base, value) (DMA_WR_TCD6_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD6_NBYTES_MLOFFYES(base) (DMA_TCD6_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD6_NBYTES_MLOFFYES(base, value) (DMA_TCD6_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD6_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD6_NBYTES_MLOFFYES(base, (DMA_RD_TCD6_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD6_NBYTES_MLOFFYES(base, DMA_RD_TCD6_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD6_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD6_NBYTES_MLOFFYES(base, DMA_RD_TCD6_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD6_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD6_NBYTES_MLOFFYES(base, DMA_RD_TCD6_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD6_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD6_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD6_NBYTES_MLOFFYES_REG(base) & DMA_TCD6_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD6_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD6_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD6_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD6_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD6_NBYTES_MLOFFYES(base, DMA_TCD6_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD6_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD6_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD6_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD6_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD6_NBYTES_MLOFFYES_REG(base) & DMA_TCD6_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD6_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD6_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD6_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD6_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD6_NBYTES_MLOFFYES(base, DMA_TCD6_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD6_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD6_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD6_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD6_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD6_NBYTES_MLOFFYES_REG(base) & DMA_TCD6_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD6_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD6_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFYES_REG(base), DMA_TCD6_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD6_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD6_NBYTES_MLOFFYES(base, DMA_TCD6_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD6_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD6_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFYES_REG(base), DMA_TCD6_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD6_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD6_NBYTES_MLOFFYES_REG(base) & DMA_TCD6_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD6_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD6_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFYES_REG(base), DMA_TCD6_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD6_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD6_NBYTES_MLOFFYES(base, DMA_TCD6_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD6_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD6_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFYES_REG(base), DMA_TCD6_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD6_NBYTES_MLOFFNO(base) (DMA_TCD6_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD6_NBYTES_MLOFFNO(base, value) (DMA_TCD6_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD6_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD6_NBYTES_MLOFFNO(base, (DMA_RD_TCD6_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD6_NBYTES_MLOFFNO(base, DMA_RD_TCD6_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD6_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD6_NBYTES_MLOFFNO(base, DMA_RD_TCD6_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD6_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD6_NBYTES_MLOFFNO(base, DMA_RD_TCD6_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD6_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD6_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD6_NBYTES_MLOFFNO_REG(base) & DMA_TCD6_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD6_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD6_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD6_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD6_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD6_NBYTES_MLOFFNO(base, DMA_TCD6_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD6_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD6_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD6_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD6_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD6_NBYTES_MLOFFNO_REG(base) & DMA_TCD6_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD6_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD6_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFNO_REG(base), DMA_TCD6_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD6_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD6_NBYTES_MLOFFNO(base, DMA_TCD6_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD6_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD6_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFNO_REG(base), DMA_TCD6_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD6_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD6_NBYTES_MLOFFNO_REG(base) & DMA_TCD6_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD6_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD6_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFNO_REG(base), DMA_TCD6_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD6_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD6_NBYTES_MLOFFNO(base, DMA_TCD6_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD6_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD6_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD6_NBYTES_MLOFFNO_REG(base), DMA_TCD6_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD6_NBYTES_MLNO(base) (DMA_TCD6_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD6_NBYTES_MLNO(base, value) (DMA_TCD6_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD6_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD6_NBYTES_MLNO(base, (DMA_RD_TCD6_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_NBYTES_MLNO(base, value) (DMA_WR_TCD6_NBYTES_MLNO(base, DMA_RD_TCD6_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD6_NBYTES_MLNO(base, value) (DMA_WR_TCD6_NBYTES_MLNO(base, DMA_RD_TCD6_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD6_NBYTES_MLNO(base, value) (DMA_WR_TCD6_NBYTES_MLNO(base, DMA_RD_TCD6_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_SLAST register
 */
/*@{*/
#define DMA_RD_TCD6_SLAST(base)  (DMA_TCD6_SLAST_REG(base))
#define DMA_WR_TCD6_SLAST(base, value) (DMA_TCD6_SLAST_REG(base) = (value))
#define DMA_RMW_TCD6_SLAST(base, mask, value) (DMA_WR_TCD6_SLAST(base, (DMA_RD_TCD6_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_SLAST(base, value) (DMA_WR_TCD6_SLAST(base, DMA_RD_TCD6_SLAST(base) |  (value)))
#define DMA_CLR_TCD6_SLAST(base, value) (DMA_WR_TCD6_SLAST(base, DMA_RD_TCD6_SLAST(base) & ~(value)))
#define DMA_TOG_TCD6_SLAST(base, value) (DMA_WR_TCD6_SLAST(base, DMA_RD_TCD6_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_DADDR register
 */
/*@{*/
#define DMA_RD_TCD6_DADDR(base)  (DMA_TCD6_DADDR_REG(base))
#define DMA_WR_TCD6_DADDR(base, value) (DMA_TCD6_DADDR_REG(base) = (value))
#define DMA_RMW_TCD6_DADDR(base, mask, value) (DMA_WR_TCD6_DADDR(base, (DMA_RD_TCD6_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_DADDR(base, value) (DMA_WR_TCD6_DADDR(base, DMA_RD_TCD6_DADDR(base) |  (value)))
#define DMA_CLR_TCD6_DADDR(base, value) (DMA_WR_TCD6_DADDR(base, DMA_RD_TCD6_DADDR(base) & ~(value)))
#define DMA_TOG_TCD6_DADDR(base, value) (DMA_WR_TCD6_DADDR(base, DMA_RD_TCD6_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_DOFF register
 */
/*@{*/
#define DMA_RD_TCD6_DOFF(base)   (DMA_TCD6_DOFF_REG(base))
#define DMA_WR_TCD6_DOFF(base, value) (DMA_TCD6_DOFF_REG(base) = (value))
#define DMA_RMW_TCD6_DOFF(base, mask, value) (DMA_WR_TCD6_DOFF(base, (DMA_RD_TCD6_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_DOFF(base, value) (DMA_WR_TCD6_DOFF(base, DMA_RD_TCD6_DOFF(base) |  (value)))
#define DMA_CLR_TCD6_DOFF(base, value) (DMA_WR_TCD6_DOFF(base, DMA_RD_TCD6_DOFF(base) & ~(value)))
#define DMA_TOG_TCD6_DOFF(base, value) (DMA_WR_TCD6_DOFF(base, DMA_RD_TCD6_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD6_CITER_ELINKNO(base) (DMA_TCD6_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD6_CITER_ELINKNO(base, value) (DMA_TCD6_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD6_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD6_CITER_ELINKNO(base, (DMA_RD_TCD6_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_CITER_ELINKNO(base, value) (DMA_WR_TCD6_CITER_ELINKNO(base, DMA_RD_TCD6_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD6_CITER_ELINKNO(base, value) (DMA_WR_TCD6_CITER_ELINKNO(base, DMA_RD_TCD6_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD6_CITER_ELINKNO(base, value) (DMA_WR_TCD6_CITER_ELINKNO(base, DMA_RD_TCD6_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD6_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD6_CITER_ELINKNO_CITER(base) ((DMA_TCD6_CITER_ELINKNO_REG(base) & DMA_TCD6_CITER_ELINKNO_CITER_MASK) >> DMA_TCD6_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD6_CITER_ELINKNO_CITER(base) (DMA_RD_TCD6_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD6_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD6_CITER_ELINKNO(base, DMA_TCD6_CITER_ELINKNO_CITER_MASK, DMA_TCD6_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD6_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD6_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD6_CITER_ELINKNO_ELINK(base) ((DMA_TCD6_CITER_ELINKNO_REG(base) & DMA_TCD6_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD6_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD6_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD6_CITER_ELINKNO_REG(base), DMA_TCD6_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD6_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD6_CITER_ELINKNO(base, DMA_TCD6_CITER_ELINKNO_ELINK_MASK, DMA_TCD6_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD6_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CITER_ELINKNO_REG(base), DMA_TCD6_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD6_CITER_ELINKYES(base) (DMA_TCD6_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD6_CITER_ELINKYES(base, value) (DMA_TCD6_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD6_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD6_CITER_ELINKYES(base, (DMA_RD_TCD6_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_CITER_ELINKYES(base, value) (DMA_WR_TCD6_CITER_ELINKYES(base, DMA_RD_TCD6_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD6_CITER_ELINKYES(base, value) (DMA_WR_TCD6_CITER_ELINKYES(base, DMA_RD_TCD6_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD6_CITER_ELINKYES(base, value) (DMA_WR_TCD6_CITER_ELINKYES(base, DMA_RD_TCD6_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD6_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD6_CITER_ELINKYES_CITER(base) ((DMA_TCD6_CITER_ELINKYES_REG(base) & DMA_TCD6_CITER_ELINKYES_CITER_MASK) >> DMA_TCD6_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD6_CITER_ELINKYES_CITER(base) (DMA_RD_TCD6_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD6_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD6_CITER_ELINKYES(base, DMA_TCD6_CITER_ELINKYES_CITER_MASK, DMA_TCD6_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD6_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD6_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD6_CITER_ELINKYES_LINKCH(base) ((DMA_TCD6_CITER_ELINKYES_REG(base) & DMA_TCD6_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD6_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD6_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD6_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD6_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD6_CITER_ELINKYES(base, DMA_TCD6_CITER_ELINKYES_LINKCH_MASK, DMA_TCD6_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD6_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD6_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD6_CITER_ELINKYES_ELINK(base) ((DMA_TCD6_CITER_ELINKYES_REG(base) & DMA_TCD6_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD6_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD6_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD6_CITER_ELINKYES_REG(base), DMA_TCD6_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD6_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD6_CITER_ELINKYES(base, DMA_TCD6_CITER_ELINKYES_ELINK_MASK, DMA_TCD6_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD6_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CITER_ELINKYES_REG(base), DMA_TCD6_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD6_DLASTSGA(base) (DMA_TCD6_DLASTSGA_REG(base))
#define DMA_WR_TCD6_DLASTSGA(base, value) (DMA_TCD6_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD6_DLASTSGA(base, mask, value) (DMA_WR_TCD6_DLASTSGA(base, (DMA_RD_TCD6_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_DLASTSGA(base, value) (DMA_WR_TCD6_DLASTSGA(base, DMA_RD_TCD6_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD6_DLASTSGA(base, value) (DMA_WR_TCD6_DLASTSGA(base, DMA_RD_TCD6_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD6_DLASTSGA(base, value) (DMA_WR_TCD6_DLASTSGA(base, DMA_RD_TCD6_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_CSR register
 */
/*@{*/
#define DMA_RD_TCD6_CSR(base)    (DMA_TCD6_CSR_REG(base))
#define DMA_WR_TCD6_CSR(base, value) (DMA_TCD6_CSR_REG(base) = (value))
#define DMA_RMW_TCD6_CSR(base, mask, value) (DMA_WR_TCD6_CSR(base, (DMA_RD_TCD6_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_CSR(base, value) (DMA_WR_TCD6_CSR(base, DMA_RD_TCD6_CSR(base) |  (value)))
#define DMA_CLR_TCD6_CSR(base, value) (DMA_WR_TCD6_CSR(base, DMA_RD_TCD6_CSR(base) & ~(value)))
#define DMA_TOG_TCD6_CSR(base, value) (DMA_WR_TCD6_CSR(base, DMA_RD_TCD6_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_CSR bitfields
 */

/*!
 * @name Register DMA_TCD6_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_START field. */
#define DMA_RD_TCD6_CSR_START(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_START_MASK) >> DMA_TCD6_CSR_START_SHIFT)
#define DMA_BRD_TCD6_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD6_CSR_START(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_START_MASK, DMA_TCD6_CSR_START(value)))
#define DMA_BWR_TCD6_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_INTMAJOR field. */
#define DMA_RD_TCD6_CSR_INTMAJOR(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_INTMAJOR_MASK) >> DMA_TCD6_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD6_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD6_CSR_INTMAJOR(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_INTMAJOR_MASK, DMA_TCD6_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD6_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_INTHALF field. */
#define DMA_RD_TCD6_CSR_INTHALF(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_INTHALF_MASK) >> DMA_TCD6_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD6_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD6_CSR_INTHALF(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_INTHALF_MASK, DMA_TCD6_CSR_INTHALF(value)))
#define DMA_BWR_TCD6_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_DREQ field. */
#define DMA_RD_TCD6_CSR_DREQ(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_DREQ_MASK) >> DMA_TCD6_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD6_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD6_CSR_DREQ(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_DREQ_MASK, DMA_TCD6_CSR_DREQ(value)))
#define DMA_BWR_TCD6_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_ESG field. */
#define DMA_RD_TCD6_CSR_ESG(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_ESG_MASK) >> DMA_TCD6_CSR_ESG_SHIFT)
#define DMA_BRD_TCD6_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD6_CSR_ESG(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_ESG_MASK, DMA_TCD6_CSR_ESG(value)))
#define DMA_BWR_TCD6_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_MAJORELINK field. */
#define DMA_RD_TCD6_CSR_MAJORELINK(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_MAJORELINK_MASK) >> DMA_TCD6_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD6_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD6_CSR_MAJORELINK(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_MAJORELINK_MASK, DMA_TCD6_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD6_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_ACTIVE field. */
#define DMA_RD_TCD6_CSR_ACTIVE(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_ACTIVE_MASK) >> DMA_TCD6_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD6_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD6_CSR_ACTIVE(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_ACTIVE_MASK, DMA_TCD6_CSR_ACTIVE(value)))
#define DMA_BWR_TCD6_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_DONE field. */
#define DMA_RD_TCD6_CSR_DONE(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_DONE_MASK) >> DMA_TCD6_CSR_DONE_SHIFT)
#define DMA_BRD_TCD6_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD6_CSR_DONE(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_DONE_MASK, DMA_TCD6_CSR_DONE(value)))
#define DMA_BWR_TCD6_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD6_CSR_REG(base), DMA_TCD6_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD6_CSR_MAJORLINKCH(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_MAJORLINKCH_MASK) >> DMA_TCD6_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD6_CSR_MAJORLINKCH(base) (DMA_RD_TCD6_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD6_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_MAJORLINKCH_MASK, DMA_TCD6_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD6_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD6_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_CSR_BWC field. */
#define DMA_RD_TCD6_CSR_BWC(base) ((DMA_TCD6_CSR_REG(base) & DMA_TCD6_CSR_BWC_MASK) >> DMA_TCD6_CSR_BWC_SHIFT)
#define DMA_BRD_TCD6_CSR_BWC(base) (DMA_RD_TCD6_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD6_CSR_BWC(base, value) (DMA_RMW_TCD6_CSR(base, DMA_TCD6_CSR_BWC_MASK, DMA_TCD6_CSR_BWC(value)))
#define DMA_BWR_TCD6_CSR_BWC(base, value) (DMA_WR_TCD6_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD6_BITER_ELINKNO(base) (DMA_TCD6_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD6_BITER_ELINKNO(base, value) (DMA_TCD6_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD6_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD6_BITER_ELINKNO(base, (DMA_RD_TCD6_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_BITER_ELINKNO(base, value) (DMA_WR_TCD6_BITER_ELINKNO(base, DMA_RD_TCD6_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD6_BITER_ELINKNO(base, value) (DMA_WR_TCD6_BITER_ELINKNO(base, DMA_RD_TCD6_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD6_BITER_ELINKNO(base, value) (DMA_WR_TCD6_BITER_ELINKNO(base, DMA_RD_TCD6_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD6_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD6_BITER_ELINKNO_BITER(base) ((DMA_TCD6_BITER_ELINKNO_REG(base) & DMA_TCD6_BITER_ELINKNO_BITER_MASK) >> DMA_TCD6_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD6_BITER_ELINKNO_BITER(base) (DMA_RD_TCD6_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD6_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD6_BITER_ELINKNO(base, DMA_TCD6_BITER_ELINKNO_BITER_MASK, DMA_TCD6_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD6_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD6_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD6_BITER_ELINKNO_ELINK(base) ((DMA_TCD6_BITER_ELINKNO_REG(base) & DMA_TCD6_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD6_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD6_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD6_BITER_ELINKNO_REG(base), DMA_TCD6_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD6_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD6_BITER_ELINKNO(base, DMA_TCD6_BITER_ELINKNO_ELINK_MASK, DMA_TCD6_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD6_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD6_BITER_ELINKNO_REG(base), DMA_TCD6_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD6_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD6_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD6_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD6_BITER_ELINKYES(base) (DMA_TCD6_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD6_BITER_ELINKYES(base, value) (DMA_TCD6_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD6_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD6_BITER_ELINKYES(base, (DMA_RD_TCD6_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD6_BITER_ELINKYES(base, value) (DMA_WR_TCD6_BITER_ELINKYES(base, DMA_RD_TCD6_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD6_BITER_ELINKYES(base, value) (DMA_WR_TCD6_BITER_ELINKYES(base, DMA_RD_TCD6_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD6_BITER_ELINKYES(base, value) (DMA_WR_TCD6_BITER_ELINKYES(base, DMA_RD_TCD6_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD6_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD6_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD6_BITER_ELINKYES_BITER(base) ((DMA_TCD6_BITER_ELINKYES_REG(base) & DMA_TCD6_BITER_ELINKYES_BITER_MASK) >> DMA_TCD6_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD6_BITER_ELINKYES_BITER(base) (DMA_RD_TCD6_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD6_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD6_BITER_ELINKYES(base, DMA_TCD6_BITER_ELINKYES_BITER_MASK, DMA_TCD6_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD6_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD6_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD6_BITER_ELINKYES_LINKCH(base) ((DMA_TCD6_BITER_ELINKYES_REG(base) & DMA_TCD6_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD6_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD6_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD6_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD6_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD6_BITER_ELINKYES(base, DMA_TCD6_BITER_ELINKYES_LINKCH_MASK, DMA_TCD6_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD6_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD6_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD6_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD6_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD6_BITER_ELINKYES_ELINK(base) ((DMA_TCD6_BITER_ELINKYES_REG(base) & DMA_TCD6_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD6_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD6_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD6_BITER_ELINKYES_REG(base), DMA_TCD6_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD6_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD6_BITER_ELINKYES(base, DMA_TCD6_BITER_ELINKYES_ELINK_MASK, DMA_TCD6_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD6_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD6_BITER_ELINKYES_REG(base), DMA_TCD6_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_SADDR register
 */
/*@{*/
#define DMA_RD_TCD7_SADDR(base)  (DMA_TCD7_SADDR_REG(base))
#define DMA_WR_TCD7_SADDR(base, value) (DMA_TCD7_SADDR_REG(base) = (value))
#define DMA_RMW_TCD7_SADDR(base, mask, value) (DMA_WR_TCD7_SADDR(base, (DMA_RD_TCD7_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_SADDR(base, value) (DMA_WR_TCD7_SADDR(base, DMA_RD_TCD7_SADDR(base) |  (value)))
#define DMA_CLR_TCD7_SADDR(base, value) (DMA_WR_TCD7_SADDR(base, DMA_RD_TCD7_SADDR(base) & ~(value)))
#define DMA_TOG_TCD7_SADDR(base, value) (DMA_WR_TCD7_SADDR(base, DMA_RD_TCD7_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_SOFF register
 */
/*@{*/
#define DMA_RD_TCD7_SOFF(base)   (DMA_TCD7_SOFF_REG(base))
#define DMA_WR_TCD7_SOFF(base, value) (DMA_TCD7_SOFF_REG(base) = (value))
#define DMA_RMW_TCD7_SOFF(base, mask, value) (DMA_WR_TCD7_SOFF(base, (DMA_RD_TCD7_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_SOFF(base, value) (DMA_WR_TCD7_SOFF(base, DMA_RD_TCD7_SOFF(base) |  (value)))
#define DMA_CLR_TCD7_SOFF(base, value) (DMA_WR_TCD7_SOFF(base, DMA_RD_TCD7_SOFF(base) & ~(value)))
#define DMA_TOG_TCD7_SOFF(base, value) (DMA_WR_TCD7_SOFF(base, DMA_RD_TCD7_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_ATTR register
 */
/*@{*/
#define DMA_RD_TCD7_ATTR(base)   (DMA_TCD7_ATTR_REG(base))
#define DMA_WR_TCD7_ATTR(base, value) (DMA_TCD7_ATTR_REG(base) = (value))
#define DMA_RMW_TCD7_ATTR(base, mask, value) (DMA_WR_TCD7_ATTR(base, (DMA_RD_TCD7_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_ATTR(base, value) (DMA_WR_TCD7_ATTR(base, DMA_RD_TCD7_ATTR(base) |  (value)))
#define DMA_CLR_TCD7_ATTR(base, value) (DMA_WR_TCD7_ATTR(base, DMA_RD_TCD7_ATTR(base) & ~(value)))
#define DMA_TOG_TCD7_ATTR(base, value) (DMA_WR_TCD7_ATTR(base, DMA_RD_TCD7_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD7_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_ATTR_DSIZE field. */
#define DMA_RD_TCD7_ATTR_DSIZE(base) ((DMA_TCD7_ATTR_REG(base) & DMA_TCD7_ATTR_DSIZE_MASK) >> DMA_TCD7_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD7_ATTR_DSIZE(base) (DMA_RD_TCD7_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD7_ATTR_DSIZE(base, value) (DMA_RMW_TCD7_ATTR(base, DMA_TCD7_ATTR_DSIZE_MASK, DMA_TCD7_ATTR_DSIZE(value)))
#define DMA_BWR_TCD7_ATTR_DSIZE(base, value) (DMA_WR_TCD7_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_ATTR_DMOD field. */
#define DMA_RD_TCD7_ATTR_DMOD(base) ((DMA_TCD7_ATTR_REG(base) & DMA_TCD7_ATTR_DMOD_MASK) >> DMA_TCD7_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD7_ATTR_DMOD(base) (DMA_RD_TCD7_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD7_ATTR_DMOD(base, value) (DMA_RMW_TCD7_ATTR(base, DMA_TCD7_ATTR_DMOD_MASK, DMA_TCD7_ATTR_DMOD(value)))
#define DMA_BWR_TCD7_ATTR_DMOD(base, value) (DMA_WR_TCD7_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_ATTR_SSIZE field. */
#define DMA_RD_TCD7_ATTR_SSIZE(base) ((DMA_TCD7_ATTR_REG(base) & DMA_TCD7_ATTR_SSIZE_MASK) >> DMA_TCD7_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD7_ATTR_SSIZE(base) (DMA_RD_TCD7_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD7_ATTR_SSIZE(base, value) (DMA_RMW_TCD7_ATTR(base, DMA_TCD7_ATTR_SSIZE_MASK, DMA_TCD7_ATTR_SSIZE(value)))
#define DMA_BWR_TCD7_ATTR_SSIZE(base, value) (DMA_WR_TCD7_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_ATTR_SMOD field. */
#define DMA_RD_TCD7_ATTR_SMOD(base) ((DMA_TCD7_ATTR_REG(base) & DMA_TCD7_ATTR_SMOD_MASK) >> DMA_TCD7_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD7_ATTR_SMOD(base) (DMA_RD_TCD7_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD7_ATTR_SMOD(base, value) (DMA_RMW_TCD7_ATTR(base, DMA_TCD7_ATTR_SMOD_MASK, DMA_TCD7_ATTR_SMOD(value)))
#define DMA_BWR_TCD7_ATTR_SMOD(base, value) (DMA_WR_TCD7_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD7_NBYTES_MLOFFYES(base) (DMA_TCD7_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD7_NBYTES_MLOFFYES(base, value) (DMA_TCD7_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD7_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD7_NBYTES_MLOFFYES(base, (DMA_RD_TCD7_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD7_NBYTES_MLOFFYES(base, DMA_RD_TCD7_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD7_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD7_NBYTES_MLOFFYES(base, DMA_RD_TCD7_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD7_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD7_NBYTES_MLOFFYES(base, DMA_RD_TCD7_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD7_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD7_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD7_NBYTES_MLOFFYES_REG(base) & DMA_TCD7_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD7_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD7_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD7_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD7_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD7_NBYTES_MLOFFYES(base, DMA_TCD7_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD7_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD7_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD7_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD7_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD7_NBYTES_MLOFFYES_REG(base) & DMA_TCD7_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD7_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD7_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD7_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD7_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD7_NBYTES_MLOFFYES(base, DMA_TCD7_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD7_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD7_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD7_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD7_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD7_NBYTES_MLOFFYES_REG(base) & DMA_TCD7_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD7_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD7_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFYES_REG(base), DMA_TCD7_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD7_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD7_NBYTES_MLOFFYES(base, DMA_TCD7_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD7_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD7_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFYES_REG(base), DMA_TCD7_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD7_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD7_NBYTES_MLOFFYES_REG(base) & DMA_TCD7_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD7_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD7_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFYES_REG(base), DMA_TCD7_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD7_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD7_NBYTES_MLOFFYES(base, DMA_TCD7_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD7_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD7_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFYES_REG(base), DMA_TCD7_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD7_NBYTES_MLOFFNO(base) (DMA_TCD7_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD7_NBYTES_MLOFFNO(base, value) (DMA_TCD7_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD7_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD7_NBYTES_MLOFFNO(base, (DMA_RD_TCD7_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD7_NBYTES_MLOFFNO(base, DMA_RD_TCD7_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD7_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD7_NBYTES_MLOFFNO(base, DMA_RD_TCD7_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD7_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD7_NBYTES_MLOFFNO(base, DMA_RD_TCD7_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD7_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD7_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD7_NBYTES_MLOFFNO_REG(base) & DMA_TCD7_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD7_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD7_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD7_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD7_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD7_NBYTES_MLOFFNO(base, DMA_TCD7_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD7_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD7_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD7_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD7_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD7_NBYTES_MLOFFNO_REG(base) & DMA_TCD7_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD7_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD7_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFNO_REG(base), DMA_TCD7_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD7_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD7_NBYTES_MLOFFNO(base, DMA_TCD7_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD7_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD7_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFNO_REG(base), DMA_TCD7_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD7_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD7_NBYTES_MLOFFNO_REG(base) & DMA_TCD7_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD7_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD7_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFNO_REG(base), DMA_TCD7_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD7_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD7_NBYTES_MLOFFNO(base, DMA_TCD7_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD7_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD7_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD7_NBYTES_MLOFFNO_REG(base), DMA_TCD7_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD7_NBYTES_MLNO(base) (DMA_TCD7_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD7_NBYTES_MLNO(base, value) (DMA_TCD7_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD7_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD7_NBYTES_MLNO(base, (DMA_RD_TCD7_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_NBYTES_MLNO(base, value) (DMA_WR_TCD7_NBYTES_MLNO(base, DMA_RD_TCD7_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD7_NBYTES_MLNO(base, value) (DMA_WR_TCD7_NBYTES_MLNO(base, DMA_RD_TCD7_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD7_NBYTES_MLNO(base, value) (DMA_WR_TCD7_NBYTES_MLNO(base, DMA_RD_TCD7_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_SLAST register
 */
/*@{*/
#define DMA_RD_TCD7_SLAST(base)  (DMA_TCD7_SLAST_REG(base))
#define DMA_WR_TCD7_SLAST(base, value) (DMA_TCD7_SLAST_REG(base) = (value))
#define DMA_RMW_TCD7_SLAST(base, mask, value) (DMA_WR_TCD7_SLAST(base, (DMA_RD_TCD7_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_SLAST(base, value) (DMA_WR_TCD7_SLAST(base, DMA_RD_TCD7_SLAST(base) |  (value)))
#define DMA_CLR_TCD7_SLAST(base, value) (DMA_WR_TCD7_SLAST(base, DMA_RD_TCD7_SLAST(base) & ~(value)))
#define DMA_TOG_TCD7_SLAST(base, value) (DMA_WR_TCD7_SLAST(base, DMA_RD_TCD7_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_DADDR register
 */
/*@{*/
#define DMA_RD_TCD7_DADDR(base)  (DMA_TCD7_DADDR_REG(base))
#define DMA_WR_TCD7_DADDR(base, value) (DMA_TCD7_DADDR_REG(base) = (value))
#define DMA_RMW_TCD7_DADDR(base, mask, value) (DMA_WR_TCD7_DADDR(base, (DMA_RD_TCD7_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_DADDR(base, value) (DMA_WR_TCD7_DADDR(base, DMA_RD_TCD7_DADDR(base) |  (value)))
#define DMA_CLR_TCD7_DADDR(base, value) (DMA_WR_TCD7_DADDR(base, DMA_RD_TCD7_DADDR(base) & ~(value)))
#define DMA_TOG_TCD7_DADDR(base, value) (DMA_WR_TCD7_DADDR(base, DMA_RD_TCD7_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_DOFF register
 */
/*@{*/
#define DMA_RD_TCD7_DOFF(base)   (DMA_TCD7_DOFF_REG(base))
#define DMA_WR_TCD7_DOFF(base, value) (DMA_TCD7_DOFF_REG(base) = (value))
#define DMA_RMW_TCD7_DOFF(base, mask, value) (DMA_WR_TCD7_DOFF(base, (DMA_RD_TCD7_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_DOFF(base, value) (DMA_WR_TCD7_DOFF(base, DMA_RD_TCD7_DOFF(base) |  (value)))
#define DMA_CLR_TCD7_DOFF(base, value) (DMA_WR_TCD7_DOFF(base, DMA_RD_TCD7_DOFF(base) & ~(value)))
#define DMA_TOG_TCD7_DOFF(base, value) (DMA_WR_TCD7_DOFF(base, DMA_RD_TCD7_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD7_CITER_ELINKYES(base) (DMA_TCD7_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD7_CITER_ELINKYES(base, value) (DMA_TCD7_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD7_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD7_CITER_ELINKYES(base, (DMA_RD_TCD7_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_CITER_ELINKYES(base, value) (DMA_WR_TCD7_CITER_ELINKYES(base, DMA_RD_TCD7_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD7_CITER_ELINKYES(base, value) (DMA_WR_TCD7_CITER_ELINKYES(base, DMA_RD_TCD7_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD7_CITER_ELINKYES(base, value) (DMA_WR_TCD7_CITER_ELINKYES(base, DMA_RD_TCD7_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD7_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD7_CITER_ELINKYES_CITER(base) ((DMA_TCD7_CITER_ELINKYES_REG(base) & DMA_TCD7_CITER_ELINKYES_CITER_MASK) >> DMA_TCD7_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD7_CITER_ELINKYES_CITER(base) (DMA_RD_TCD7_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD7_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD7_CITER_ELINKYES(base, DMA_TCD7_CITER_ELINKYES_CITER_MASK, DMA_TCD7_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD7_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD7_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD7_CITER_ELINKYES_LINKCH(base) ((DMA_TCD7_CITER_ELINKYES_REG(base) & DMA_TCD7_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD7_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD7_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD7_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD7_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD7_CITER_ELINKYES(base, DMA_TCD7_CITER_ELINKYES_LINKCH_MASK, DMA_TCD7_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD7_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD7_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD7_CITER_ELINKYES_ELINK(base) ((DMA_TCD7_CITER_ELINKYES_REG(base) & DMA_TCD7_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD7_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD7_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD7_CITER_ELINKYES_REG(base), DMA_TCD7_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD7_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD7_CITER_ELINKYES(base, DMA_TCD7_CITER_ELINKYES_ELINK_MASK, DMA_TCD7_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD7_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CITER_ELINKYES_REG(base), DMA_TCD7_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD7_CITER_ELINKNO(base) (DMA_TCD7_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD7_CITER_ELINKNO(base, value) (DMA_TCD7_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD7_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD7_CITER_ELINKNO(base, (DMA_RD_TCD7_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_CITER_ELINKNO(base, value) (DMA_WR_TCD7_CITER_ELINKNO(base, DMA_RD_TCD7_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD7_CITER_ELINKNO(base, value) (DMA_WR_TCD7_CITER_ELINKNO(base, DMA_RD_TCD7_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD7_CITER_ELINKNO(base, value) (DMA_WR_TCD7_CITER_ELINKNO(base, DMA_RD_TCD7_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD7_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD7_CITER_ELINKNO_CITER(base) ((DMA_TCD7_CITER_ELINKNO_REG(base) & DMA_TCD7_CITER_ELINKNO_CITER_MASK) >> DMA_TCD7_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD7_CITER_ELINKNO_CITER(base) (DMA_RD_TCD7_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD7_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD7_CITER_ELINKNO(base, DMA_TCD7_CITER_ELINKNO_CITER_MASK, DMA_TCD7_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD7_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD7_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD7_CITER_ELINKNO_ELINK(base) ((DMA_TCD7_CITER_ELINKNO_REG(base) & DMA_TCD7_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD7_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD7_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD7_CITER_ELINKNO_REG(base), DMA_TCD7_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD7_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD7_CITER_ELINKNO(base, DMA_TCD7_CITER_ELINKNO_ELINK_MASK, DMA_TCD7_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD7_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CITER_ELINKNO_REG(base), DMA_TCD7_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD7_DLASTSGA(base) (DMA_TCD7_DLASTSGA_REG(base))
#define DMA_WR_TCD7_DLASTSGA(base, value) (DMA_TCD7_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD7_DLASTSGA(base, mask, value) (DMA_WR_TCD7_DLASTSGA(base, (DMA_RD_TCD7_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_DLASTSGA(base, value) (DMA_WR_TCD7_DLASTSGA(base, DMA_RD_TCD7_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD7_DLASTSGA(base, value) (DMA_WR_TCD7_DLASTSGA(base, DMA_RD_TCD7_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD7_DLASTSGA(base, value) (DMA_WR_TCD7_DLASTSGA(base, DMA_RD_TCD7_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_CSR register
 */
/*@{*/
#define DMA_RD_TCD7_CSR(base)    (DMA_TCD7_CSR_REG(base))
#define DMA_WR_TCD7_CSR(base, value) (DMA_TCD7_CSR_REG(base) = (value))
#define DMA_RMW_TCD7_CSR(base, mask, value) (DMA_WR_TCD7_CSR(base, (DMA_RD_TCD7_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_CSR(base, value) (DMA_WR_TCD7_CSR(base, DMA_RD_TCD7_CSR(base) |  (value)))
#define DMA_CLR_TCD7_CSR(base, value) (DMA_WR_TCD7_CSR(base, DMA_RD_TCD7_CSR(base) & ~(value)))
#define DMA_TOG_TCD7_CSR(base, value) (DMA_WR_TCD7_CSR(base, DMA_RD_TCD7_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_CSR bitfields
 */

/*!
 * @name Register DMA_TCD7_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_START field. */
#define DMA_RD_TCD7_CSR_START(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_START_MASK) >> DMA_TCD7_CSR_START_SHIFT)
#define DMA_BRD_TCD7_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD7_CSR_START(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_START_MASK, DMA_TCD7_CSR_START(value)))
#define DMA_BWR_TCD7_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_INTMAJOR field. */
#define DMA_RD_TCD7_CSR_INTMAJOR(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_INTMAJOR_MASK) >> DMA_TCD7_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD7_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD7_CSR_INTMAJOR(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_INTMAJOR_MASK, DMA_TCD7_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD7_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_INTHALF field. */
#define DMA_RD_TCD7_CSR_INTHALF(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_INTHALF_MASK) >> DMA_TCD7_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD7_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD7_CSR_INTHALF(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_INTHALF_MASK, DMA_TCD7_CSR_INTHALF(value)))
#define DMA_BWR_TCD7_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_DREQ field. */
#define DMA_RD_TCD7_CSR_DREQ(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_DREQ_MASK) >> DMA_TCD7_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD7_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD7_CSR_DREQ(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_DREQ_MASK, DMA_TCD7_CSR_DREQ(value)))
#define DMA_BWR_TCD7_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_ESG field. */
#define DMA_RD_TCD7_CSR_ESG(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_ESG_MASK) >> DMA_TCD7_CSR_ESG_SHIFT)
#define DMA_BRD_TCD7_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD7_CSR_ESG(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_ESG_MASK, DMA_TCD7_CSR_ESG(value)))
#define DMA_BWR_TCD7_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_MAJORELINK field. */
#define DMA_RD_TCD7_CSR_MAJORELINK(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_MAJORELINK_MASK) >> DMA_TCD7_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD7_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD7_CSR_MAJORELINK(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_MAJORELINK_MASK, DMA_TCD7_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD7_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_ACTIVE field. */
#define DMA_RD_TCD7_CSR_ACTIVE(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_ACTIVE_MASK) >> DMA_TCD7_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD7_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD7_CSR_ACTIVE(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_ACTIVE_MASK, DMA_TCD7_CSR_ACTIVE(value)))
#define DMA_BWR_TCD7_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_DONE field. */
#define DMA_RD_TCD7_CSR_DONE(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_DONE_MASK) >> DMA_TCD7_CSR_DONE_SHIFT)
#define DMA_BRD_TCD7_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD7_CSR_DONE(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_DONE_MASK, DMA_TCD7_CSR_DONE(value)))
#define DMA_BWR_TCD7_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD7_CSR_REG(base), DMA_TCD7_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD7_CSR_MAJORLINKCH(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_MAJORLINKCH_MASK) >> DMA_TCD7_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD7_CSR_MAJORLINKCH(base) (DMA_RD_TCD7_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD7_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_MAJORLINKCH_MASK, DMA_TCD7_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD7_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD7_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_CSR_BWC field. */
#define DMA_RD_TCD7_CSR_BWC(base) ((DMA_TCD7_CSR_REG(base) & DMA_TCD7_CSR_BWC_MASK) >> DMA_TCD7_CSR_BWC_SHIFT)
#define DMA_BRD_TCD7_CSR_BWC(base) (DMA_RD_TCD7_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD7_CSR_BWC(base, value) (DMA_RMW_TCD7_CSR(base, DMA_TCD7_CSR_BWC_MASK, DMA_TCD7_CSR_BWC(value)))
#define DMA_BWR_TCD7_CSR_BWC(base, value) (DMA_WR_TCD7_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD7_BITER_ELINKNO(base) (DMA_TCD7_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD7_BITER_ELINKNO(base, value) (DMA_TCD7_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD7_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD7_BITER_ELINKNO(base, (DMA_RD_TCD7_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_BITER_ELINKNO(base, value) (DMA_WR_TCD7_BITER_ELINKNO(base, DMA_RD_TCD7_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD7_BITER_ELINKNO(base, value) (DMA_WR_TCD7_BITER_ELINKNO(base, DMA_RD_TCD7_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD7_BITER_ELINKNO(base, value) (DMA_WR_TCD7_BITER_ELINKNO(base, DMA_RD_TCD7_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD7_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD7_BITER_ELINKNO_BITER(base) ((DMA_TCD7_BITER_ELINKNO_REG(base) & DMA_TCD7_BITER_ELINKNO_BITER_MASK) >> DMA_TCD7_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD7_BITER_ELINKNO_BITER(base) (DMA_RD_TCD7_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD7_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD7_BITER_ELINKNO(base, DMA_TCD7_BITER_ELINKNO_BITER_MASK, DMA_TCD7_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD7_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD7_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD7_BITER_ELINKNO_ELINK(base) ((DMA_TCD7_BITER_ELINKNO_REG(base) & DMA_TCD7_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD7_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD7_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD7_BITER_ELINKNO_REG(base), DMA_TCD7_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD7_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD7_BITER_ELINKNO(base, DMA_TCD7_BITER_ELINKNO_ELINK_MASK, DMA_TCD7_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD7_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD7_BITER_ELINKNO_REG(base), DMA_TCD7_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD7_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD7_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD7_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD7_BITER_ELINKYES(base) (DMA_TCD7_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD7_BITER_ELINKYES(base, value) (DMA_TCD7_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD7_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD7_BITER_ELINKYES(base, (DMA_RD_TCD7_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD7_BITER_ELINKYES(base, value) (DMA_WR_TCD7_BITER_ELINKYES(base, DMA_RD_TCD7_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD7_BITER_ELINKYES(base, value) (DMA_WR_TCD7_BITER_ELINKYES(base, DMA_RD_TCD7_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD7_BITER_ELINKYES(base, value) (DMA_WR_TCD7_BITER_ELINKYES(base, DMA_RD_TCD7_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD7_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD7_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD7_BITER_ELINKYES_BITER(base) ((DMA_TCD7_BITER_ELINKYES_REG(base) & DMA_TCD7_BITER_ELINKYES_BITER_MASK) >> DMA_TCD7_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD7_BITER_ELINKYES_BITER(base) (DMA_RD_TCD7_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD7_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD7_BITER_ELINKYES(base, DMA_TCD7_BITER_ELINKYES_BITER_MASK, DMA_TCD7_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD7_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD7_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD7_BITER_ELINKYES_LINKCH(base) ((DMA_TCD7_BITER_ELINKYES_REG(base) & DMA_TCD7_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD7_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD7_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD7_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD7_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD7_BITER_ELINKYES(base, DMA_TCD7_BITER_ELINKYES_LINKCH_MASK, DMA_TCD7_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD7_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD7_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD7_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD7_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD7_BITER_ELINKYES_ELINK(base) ((DMA_TCD7_BITER_ELINKYES_REG(base) & DMA_TCD7_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD7_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD7_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD7_BITER_ELINKYES_REG(base), DMA_TCD7_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD7_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD7_BITER_ELINKYES(base, DMA_TCD7_BITER_ELINKYES_ELINK_MASK, DMA_TCD7_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD7_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD7_BITER_ELINKYES_REG(base), DMA_TCD7_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_SADDR register
 */
/*@{*/
#define DMA_RD_TCD8_SADDR(base)  (DMA_TCD8_SADDR_REG(base))
#define DMA_WR_TCD8_SADDR(base, value) (DMA_TCD8_SADDR_REG(base) = (value))
#define DMA_RMW_TCD8_SADDR(base, mask, value) (DMA_WR_TCD8_SADDR(base, (DMA_RD_TCD8_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_SADDR(base, value) (DMA_WR_TCD8_SADDR(base, DMA_RD_TCD8_SADDR(base) |  (value)))
#define DMA_CLR_TCD8_SADDR(base, value) (DMA_WR_TCD8_SADDR(base, DMA_RD_TCD8_SADDR(base) & ~(value)))
#define DMA_TOG_TCD8_SADDR(base, value) (DMA_WR_TCD8_SADDR(base, DMA_RD_TCD8_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_SOFF register
 */
/*@{*/
#define DMA_RD_TCD8_SOFF(base)   (DMA_TCD8_SOFF_REG(base))
#define DMA_WR_TCD8_SOFF(base, value) (DMA_TCD8_SOFF_REG(base) = (value))
#define DMA_RMW_TCD8_SOFF(base, mask, value) (DMA_WR_TCD8_SOFF(base, (DMA_RD_TCD8_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_SOFF(base, value) (DMA_WR_TCD8_SOFF(base, DMA_RD_TCD8_SOFF(base) |  (value)))
#define DMA_CLR_TCD8_SOFF(base, value) (DMA_WR_TCD8_SOFF(base, DMA_RD_TCD8_SOFF(base) & ~(value)))
#define DMA_TOG_TCD8_SOFF(base, value) (DMA_WR_TCD8_SOFF(base, DMA_RD_TCD8_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_ATTR register
 */
/*@{*/
#define DMA_RD_TCD8_ATTR(base)   (DMA_TCD8_ATTR_REG(base))
#define DMA_WR_TCD8_ATTR(base, value) (DMA_TCD8_ATTR_REG(base) = (value))
#define DMA_RMW_TCD8_ATTR(base, mask, value) (DMA_WR_TCD8_ATTR(base, (DMA_RD_TCD8_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_ATTR(base, value) (DMA_WR_TCD8_ATTR(base, DMA_RD_TCD8_ATTR(base) |  (value)))
#define DMA_CLR_TCD8_ATTR(base, value) (DMA_WR_TCD8_ATTR(base, DMA_RD_TCD8_ATTR(base) & ~(value)))
#define DMA_TOG_TCD8_ATTR(base, value) (DMA_WR_TCD8_ATTR(base, DMA_RD_TCD8_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD8_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_ATTR_DSIZE field. */
#define DMA_RD_TCD8_ATTR_DSIZE(base) ((DMA_TCD8_ATTR_REG(base) & DMA_TCD8_ATTR_DSIZE_MASK) >> DMA_TCD8_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD8_ATTR_DSIZE(base) (DMA_RD_TCD8_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD8_ATTR_DSIZE(base, value) (DMA_RMW_TCD8_ATTR(base, DMA_TCD8_ATTR_DSIZE_MASK, DMA_TCD8_ATTR_DSIZE(value)))
#define DMA_BWR_TCD8_ATTR_DSIZE(base, value) (DMA_WR_TCD8_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_ATTR_DMOD field. */
#define DMA_RD_TCD8_ATTR_DMOD(base) ((DMA_TCD8_ATTR_REG(base) & DMA_TCD8_ATTR_DMOD_MASK) >> DMA_TCD8_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD8_ATTR_DMOD(base) (DMA_RD_TCD8_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD8_ATTR_DMOD(base, value) (DMA_RMW_TCD8_ATTR(base, DMA_TCD8_ATTR_DMOD_MASK, DMA_TCD8_ATTR_DMOD(value)))
#define DMA_BWR_TCD8_ATTR_DMOD(base, value) (DMA_WR_TCD8_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_ATTR_SSIZE field. */
#define DMA_RD_TCD8_ATTR_SSIZE(base) ((DMA_TCD8_ATTR_REG(base) & DMA_TCD8_ATTR_SSIZE_MASK) >> DMA_TCD8_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD8_ATTR_SSIZE(base) (DMA_RD_TCD8_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD8_ATTR_SSIZE(base, value) (DMA_RMW_TCD8_ATTR(base, DMA_TCD8_ATTR_SSIZE_MASK, DMA_TCD8_ATTR_SSIZE(value)))
#define DMA_BWR_TCD8_ATTR_SSIZE(base, value) (DMA_WR_TCD8_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_ATTR_SMOD field. */
#define DMA_RD_TCD8_ATTR_SMOD(base) ((DMA_TCD8_ATTR_REG(base) & DMA_TCD8_ATTR_SMOD_MASK) >> DMA_TCD8_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD8_ATTR_SMOD(base) (DMA_RD_TCD8_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD8_ATTR_SMOD(base, value) (DMA_RMW_TCD8_ATTR(base, DMA_TCD8_ATTR_SMOD_MASK, DMA_TCD8_ATTR_SMOD(value)))
#define DMA_BWR_TCD8_ATTR_SMOD(base, value) (DMA_WR_TCD8_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD8_NBYTES_MLOFFYES(base) (DMA_TCD8_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD8_NBYTES_MLOFFYES(base, value) (DMA_TCD8_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD8_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD8_NBYTES_MLOFFYES(base, (DMA_RD_TCD8_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD8_NBYTES_MLOFFYES(base, DMA_RD_TCD8_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD8_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD8_NBYTES_MLOFFYES(base, DMA_RD_TCD8_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD8_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD8_NBYTES_MLOFFYES(base, DMA_RD_TCD8_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD8_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD8_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD8_NBYTES_MLOFFYES_REG(base) & DMA_TCD8_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD8_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD8_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD8_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD8_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD8_NBYTES_MLOFFYES(base, DMA_TCD8_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD8_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD8_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD8_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD8_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD8_NBYTES_MLOFFYES_REG(base) & DMA_TCD8_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD8_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD8_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD8_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD8_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD8_NBYTES_MLOFFYES(base, DMA_TCD8_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD8_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD8_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD8_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD8_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD8_NBYTES_MLOFFYES_REG(base) & DMA_TCD8_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD8_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD8_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFYES_REG(base), DMA_TCD8_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD8_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD8_NBYTES_MLOFFYES(base, DMA_TCD8_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD8_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD8_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFYES_REG(base), DMA_TCD8_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD8_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD8_NBYTES_MLOFFYES_REG(base) & DMA_TCD8_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD8_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD8_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFYES_REG(base), DMA_TCD8_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD8_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD8_NBYTES_MLOFFYES(base, DMA_TCD8_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD8_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD8_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFYES_REG(base), DMA_TCD8_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD8_NBYTES_MLNO(base) (DMA_TCD8_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD8_NBYTES_MLNO(base, value) (DMA_TCD8_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD8_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD8_NBYTES_MLNO(base, (DMA_RD_TCD8_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_NBYTES_MLNO(base, value) (DMA_WR_TCD8_NBYTES_MLNO(base, DMA_RD_TCD8_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD8_NBYTES_MLNO(base, value) (DMA_WR_TCD8_NBYTES_MLNO(base, DMA_RD_TCD8_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD8_NBYTES_MLNO(base, value) (DMA_WR_TCD8_NBYTES_MLNO(base, DMA_RD_TCD8_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD8_NBYTES_MLOFFNO(base) (DMA_TCD8_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD8_NBYTES_MLOFFNO(base, value) (DMA_TCD8_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD8_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD8_NBYTES_MLOFFNO(base, (DMA_RD_TCD8_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD8_NBYTES_MLOFFNO(base, DMA_RD_TCD8_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD8_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD8_NBYTES_MLOFFNO(base, DMA_RD_TCD8_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD8_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD8_NBYTES_MLOFFNO(base, DMA_RD_TCD8_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD8_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD8_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD8_NBYTES_MLOFFNO_REG(base) & DMA_TCD8_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD8_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD8_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD8_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD8_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD8_NBYTES_MLOFFNO(base, DMA_TCD8_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD8_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD8_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD8_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD8_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD8_NBYTES_MLOFFNO_REG(base) & DMA_TCD8_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD8_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD8_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFNO_REG(base), DMA_TCD8_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD8_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD8_NBYTES_MLOFFNO(base, DMA_TCD8_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD8_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD8_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFNO_REG(base), DMA_TCD8_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD8_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD8_NBYTES_MLOFFNO_REG(base) & DMA_TCD8_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD8_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD8_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFNO_REG(base), DMA_TCD8_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD8_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD8_NBYTES_MLOFFNO(base, DMA_TCD8_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD8_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD8_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD8_NBYTES_MLOFFNO_REG(base), DMA_TCD8_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_SLAST register
 */
/*@{*/
#define DMA_RD_TCD8_SLAST(base)  (DMA_TCD8_SLAST_REG(base))
#define DMA_WR_TCD8_SLAST(base, value) (DMA_TCD8_SLAST_REG(base) = (value))
#define DMA_RMW_TCD8_SLAST(base, mask, value) (DMA_WR_TCD8_SLAST(base, (DMA_RD_TCD8_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_SLAST(base, value) (DMA_WR_TCD8_SLAST(base, DMA_RD_TCD8_SLAST(base) |  (value)))
#define DMA_CLR_TCD8_SLAST(base, value) (DMA_WR_TCD8_SLAST(base, DMA_RD_TCD8_SLAST(base) & ~(value)))
#define DMA_TOG_TCD8_SLAST(base, value) (DMA_WR_TCD8_SLAST(base, DMA_RD_TCD8_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_DADDR register
 */
/*@{*/
#define DMA_RD_TCD8_DADDR(base)  (DMA_TCD8_DADDR_REG(base))
#define DMA_WR_TCD8_DADDR(base, value) (DMA_TCD8_DADDR_REG(base) = (value))
#define DMA_RMW_TCD8_DADDR(base, mask, value) (DMA_WR_TCD8_DADDR(base, (DMA_RD_TCD8_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_DADDR(base, value) (DMA_WR_TCD8_DADDR(base, DMA_RD_TCD8_DADDR(base) |  (value)))
#define DMA_CLR_TCD8_DADDR(base, value) (DMA_WR_TCD8_DADDR(base, DMA_RD_TCD8_DADDR(base) & ~(value)))
#define DMA_TOG_TCD8_DADDR(base, value) (DMA_WR_TCD8_DADDR(base, DMA_RD_TCD8_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_DOFF register
 */
/*@{*/
#define DMA_RD_TCD8_DOFF(base)   (DMA_TCD8_DOFF_REG(base))
#define DMA_WR_TCD8_DOFF(base, value) (DMA_TCD8_DOFF_REG(base) = (value))
#define DMA_RMW_TCD8_DOFF(base, mask, value) (DMA_WR_TCD8_DOFF(base, (DMA_RD_TCD8_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_DOFF(base, value) (DMA_WR_TCD8_DOFF(base, DMA_RD_TCD8_DOFF(base) |  (value)))
#define DMA_CLR_TCD8_DOFF(base, value) (DMA_WR_TCD8_DOFF(base, DMA_RD_TCD8_DOFF(base) & ~(value)))
#define DMA_TOG_TCD8_DOFF(base, value) (DMA_WR_TCD8_DOFF(base, DMA_RD_TCD8_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD8_CITER_ELINKYES(base) (DMA_TCD8_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD8_CITER_ELINKYES(base, value) (DMA_TCD8_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD8_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD8_CITER_ELINKYES(base, (DMA_RD_TCD8_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_CITER_ELINKYES(base, value) (DMA_WR_TCD8_CITER_ELINKYES(base, DMA_RD_TCD8_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD8_CITER_ELINKYES(base, value) (DMA_WR_TCD8_CITER_ELINKYES(base, DMA_RD_TCD8_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD8_CITER_ELINKYES(base, value) (DMA_WR_TCD8_CITER_ELINKYES(base, DMA_RD_TCD8_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD8_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD8_CITER_ELINKYES_CITER(base) ((DMA_TCD8_CITER_ELINKYES_REG(base) & DMA_TCD8_CITER_ELINKYES_CITER_MASK) >> DMA_TCD8_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD8_CITER_ELINKYES_CITER(base) (DMA_RD_TCD8_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD8_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD8_CITER_ELINKYES(base, DMA_TCD8_CITER_ELINKYES_CITER_MASK, DMA_TCD8_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD8_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD8_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD8_CITER_ELINKYES_LINKCH(base) ((DMA_TCD8_CITER_ELINKYES_REG(base) & DMA_TCD8_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD8_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD8_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD8_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD8_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD8_CITER_ELINKYES(base, DMA_TCD8_CITER_ELINKYES_LINKCH_MASK, DMA_TCD8_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD8_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD8_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD8_CITER_ELINKYES_ELINK(base) ((DMA_TCD8_CITER_ELINKYES_REG(base) & DMA_TCD8_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD8_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD8_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD8_CITER_ELINKYES_REG(base), DMA_TCD8_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD8_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD8_CITER_ELINKYES(base, DMA_TCD8_CITER_ELINKYES_ELINK_MASK, DMA_TCD8_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD8_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CITER_ELINKYES_REG(base), DMA_TCD8_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD8_CITER_ELINKNO(base) (DMA_TCD8_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD8_CITER_ELINKNO(base, value) (DMA_TCD8_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD8_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD8_CITER_ELINKNO(base, (DMA_RD_TCD8_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_CITER_ELINKNO(base, value) (DMA_WR_TCD8_CITER_ELINKNO(base, DMA_RD_TCD8_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD8_CITER_ELINKNO(base, value) (DMA_WR_TCD8_CITER_ELINKNO(base, DMA_RD_TCD8_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD8_CITER_ELINKNO(base, value) (DMA_WR_TCD8_CITER_ELINKNO(base, DMA_RD_TCD8_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD8_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD8_CITER_ELINKNO_CITER(base) ((DMA_TCD8_CITER_ELINKNO_REG(base) & DMA_TCD8_CITER_ELINKNO_CITER_MASK) >> DMA_TCD8_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD8_CITER_ELINKNO_CITER(base) (DMA_RD_TCD8_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD8_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD8_CITER_ELINKNO(base, DMA_TCD8_CITER_ELINKNO_CITER_MASK, DMA_TCD8_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD8_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD8_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD8_CITER_ELINKNO_ELINK(base) ((DMA_TCD8_CITER_ELINKNO_REG(base) & DMA_TCD8_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD8_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD8_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD8_CITER_ELINKNO_REG(base), DMA_TCD8_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD8_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD8_CITER_ELINKNO(base, DMA_TCD8_CITER_ELINKNO_ELINK_MASK, DMA_TCD8_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD8_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CITER_ELINKNO_REG(base), DMA_TCD8_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD8_DLASTSGA(base) (DMA_TCD8_DLASTSGA_REG(base))
#define DMA_WR_TCD8_DLASTSGA(base, value) (DMA_TCD8_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD8_DLASTSGA(base, mask, value) (DMA_WR_TCD8_DLASTSGA(base, (DMA_RD_TCD8_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_DLASTSGA(base, value) (DMA_WR_TCD8_DLASTSGA(base, DMA_RD_TCD8_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD8_DLASTSGA(base, value) (DMA_WR_TCD8_DLASTSGA(base, DMA_RD_TCD8_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD8_DLASTSGA(base, value) (DMA_WR_TCD8_DLASTSGA(base, DMA_RD_TCD8_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_CSR register
 */
/*@{*/
#define DMA_RD_TCD8_CSR(base)    (DMA_TCD8_CSR_REG(base))
#define DMA_WR_TCD8_CSR(base, value) (DMA_TCD8_CSR_REG(base) = (value))
#define DMA_RMW_TCD8_CSR(base, mask, value) (DMA_WR_TCD8_CSR(base, (DMA_RD_TCD8_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_CSR(base, value) (DMA_WR_TCD8_CSR(base, DMA_RD_TCD8_CSR(base) |  (value)))
#define DMA_CLR_TCD8_CSR(base, value) (DMA_WR_TCD8_CSR(base, DMA_RD_TCD8_CSR(base) & ~(value)))
#define DMA_TOG_TCD8_CSR(base, value) (DMA_WR_TCD8_CSR(base, DMA_RD_TCD8_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_CSR bitfields
 */

/*!
 * @name Register DMA_TCD8_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_START field. */
#define DMA_RD_TCD8_CSR_START(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_START_MASK) >> DMA_TCD8_CSR_START_SHIFT)
#define DMA_BRD_TCD8_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD8_CSR_START(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_START_MASK, DMA_TCD8_CSR_START(value)))
#define DMA_BWR_TCD8_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_INTMAJOR field. */
#define DMA_RD_TCD8_CSR_INTMAJOR(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_INTMAJOR_MASK) >> DMA_TCD8_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD8_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD8_CSR_INTMAJOR(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_INTMAJOR_MASK, DMA_TCD8_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD8_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_INTHALF field. */
#define DMA_RD_TCD8_CSR_INTHALF(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_INTHALF_MASK) >> DMA_TCD8_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD8_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD8_CSR_INTHALF(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_INTHALF_MASK, DMA_TCD8_CSR_INTHALF(value)))
#define DMA_BWR_TCD8_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_DREQ field. */
#define DMA_RD_TCD8_CSR_DREQ(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_DREQ_MASK) >> DMA_TCD8_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD8_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD8_CSR_DREQ(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_DREQ_MASK, DMA_TCD8_CSR_DREQ(value)))
#define DMA_BWR_TCD8_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_ESG field. */
#define DMA_RD_TCD8_CSR_ESG(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_ESG_MASK) >> DMA_TCD8_CSR_ESG_SHIFT)
#define DMA_BRD_TCD8_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD8_CSR_ESG(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_ESG_MASK, DMA_TCD8_CSR_ESG(value)))
#define DMA_BWR_TCD8_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_MAJORELINK field. */
#define DMA_RD_TCD8_CSR_MAJORELINK(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_MAJORELINK_MASK) >> DMA_TCD8_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD8_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD8_CSR_MAJORELINK(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_MAJORELINK_MASK, DMA_TCD8_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD8_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_ACTIVE field. */
#define DMA_RD_TCD8_CSR_ACTIVE(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_ACTIVE_MASK) >> DMA_TCD8_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD8_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD8_CSR_ACTIVE(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_ACTIVE_MASK, DMA_TCD8_CSR_ACTIVE(value)))
#define DMA_BWR_TCD8_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_DONE field. */
#define DMA_RD_TCD8_CSR_DONE(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_DONE_MASK) >> DMA_TCD8_CSR_DONE_SHIFT)
#define DMA_BRD_TCD8_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD8_CSR_DONE(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_DONE_MASK, DMA_TCD8_CSR_DONE(value)))
#define DMA_BWR_TCD8_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD8_CSR_REG(base), DMA_TCD8_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD8_CSR_MAJORLINKCH(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_MAJORLINKCH_MASK) >> DMA_TCD8_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD8_CSR_MAJORLINKCH(base) (DMA_RD_TCD8_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD8_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_MAJORLINKCH_MASK, DMA_TCD8_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD8_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD8_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_CSR_BWC field. */
#define DMA_RD_TCD8_CSR_BWC(base) ((DMA_TCD8_CSR_REG(base) & DMA_TCD8_CSR_BWC_MASK) >> DMA_TCD8_CSR_BWC_SHIFT)
#define DMA_BRD_TCD8_CSR_BWC(base) (DMA_RD_TCD8_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD8_CSR_BWC(base, value) (DMA_RMW_TCD8_CSR(base, DMA_TCD8_CSR_BWC_MASK, DMA_TCD8_CSR_BWC(value)))
#define DMA_BWR_TCD8_CSR_BWC(base, value) (DMA_WR_TCD8_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD8_BITER_ELINKYES(base) (DMA_TCD8_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD8_BITER_ELINKYES(base, value) (DMA_TCD8_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD8_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD8_BITER_ELINKYES(base, (DMA_RD_TCD8_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_BITER_ELINKYES(base, value) (DMA_WR_TCD8_BITER_ELINKYES(base, DMA_RD_TCD8_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD8_BITER_ELINKYES(base, value) (DMA_WR_TCD8_BITER_ELINKYES(base, DMA_RD_TCD8_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD8_BITER_ELINKYES(base, value) (DMA_WR_TCD8_BITER_ELINKYES(base, DMA_RD_TCD8_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD8_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD8_BITER_ELINKYES_BITER(base) ((DMA_TCD8_BITER_ELINKYES_REG(base) & DMA_TCD8_BITER_ELINKYES_BITER_MASK) >> DMA_TCD8_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD8_BITER_ELINKYES_BITER(base) (DMA_RD_TCD8_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD8_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD8_BITER_ELINKYES(base, DMA_TCD8_BITER_ELINKYES_BITER_MASK, DMA_TCD8_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD8_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD8_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD8_BITER_ELINKYES_LINKCH(base) ((DMA_TCD8_BITER_ELINKYES_REG(base) & DMA_TCD8_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD8_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD8_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD8_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD8_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD8_BITER_ELINKYES(base, DMA_TCD8_BITER_ELINKYES_LINKCH_MASK, DMA_TCD8_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD8_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD8_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD8_BITER_ELINKYES_ELINK(base) ((DMA_TCD8_BITER_ELINKYES_REG(base) & DMA_TCD8_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD8_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD8_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD8_BITER_ELINKYES_REG(base), DMA_TCD8_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD8_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD8_BITER_ELINKYES(base, DMA_TCD8_BITER_ELINKYES_ELINK_MASK, DMA_TCD8_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD8_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD8_BITER_ELINKYES_REG(base), DMA_TCD8_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD8_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD8_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD8_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD8_BITER_ELINKNO(base) (DMA_TCD8_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD8_BITER_ELINKNO(base, value) (DMA_TCD8_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD8_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD8_BITER_ELINKNO(base, (DMA_RD_TCD8_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD8_BITER_ELINKNO(base, value) (DMA_WR_TCD8_BITER_ELINKNO(base, DMA_RD_TCD8_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD8_BITER_ELINKNO(base, value) (DMA_WR_TCD8_BITER_ELINKNO(base, DMA_RD_TCD8_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD8_BITER_ELINKNO(base, value) (DMA_WR_TCD8_BITER_ELINKNO(base, DMA_RD_TCD8_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD8_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD8_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD8_BITER_ELINKNO_BITER(base) ((DMA_TCD8_BITER_ELINKNO_REG(base) & DMA_TCD8_BITER_ELINKNO_BITER_MASK) >> DMA_TCD8_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD8_BITER_ELINKNO_BITER(base) (DMA_RD_TCD8_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD8_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD8_BITER_ELINKNO(base, DMA_TCD8_BITER_ELINKNO_BITER_MASK, DMA_TCD8_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD8_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD8_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD8_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD8_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD8_BITER_ELINKNO_ELINK(base) ((DMA_TCD8_BITER_ELINKNO_REG(base) & DMA_TCD8_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD8_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD8_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD8_BITER_ELINKNO_REG(base), DMA_TCD8_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD8_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD8_BITER_ELINKNO(base, DMA_TCD8_BITER_ELINKNO_ELINK_MASK, DMA_TCD8_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD8_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD8_BITER_ELINKNO_REG(base), DMA_TCD8_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_SADDR register
 */
/*@{*/
#define DMA_RD_TCD9_SADDR(base)  (DMA_TCD9_SADDR_REG(base))
#define DMA_WR_TCD9_SADDR(base, value) (DMA_TCD9_SADDR_REG(base) = (value))
#define DMA_RMW_TCD9_SADDR(base, mask, value) (DMA_WR_TCD9_SADDR(base, (DMA_RD_TCD9_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_SADDR(base, value) (DMA_WR_TCD9_SADDR(base, DMA_RD_TCD9_SADDR(base) |  (value)))
#define DMA_CLR_TCD9_SADDR(base, value) (DMA_WR_TCD9_SADDR(base, DMA_RD_TCD9_SADDR(base) & ~(value)))
#define DMA_TOG_TCD9_SADDR(base, value) (DMA_WR_TCD9_SADDR(base, DMA_RD_TCD9_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_SOFF register
 */
/*@{*/
#define DMA_RD_TCD9_SOFF(base)   (DMA_TCD9_SOFF_REG(base))
#define DMA_WR_TCD9_SOFF(base, value) (DMA_TCD9_SOFF_REG(base) = (value))
#define DMA_RMW_TCD9_SOFF(base, mask, value) (DMA_WR_TCD9_SOFF(base, (DMA_RD_TCD9_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_SOFF(base, value) (DMA_WR_TCD9_SOFF(base, DMA_RD_TCD9_SOFF(base) |  (value)))
#define DMA_CLR_TCD9_SOFF(base, value) (DMA_WR_TCD9_SOFF(base, DMA_RD_TCD9_SOFF(base) & ~(value)))
#define DMA_TOG_TCD9_SOFF(base, value) (DMA_WR_TCD9_SOFF(base, DMA_RD_TCD9_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_ATTR register
 */
/*@{*/
#define DMA_RD_TCD9_ATTR(base)   (DMA_TCD9_ATTR_REG(base))
#define DMA_WR_TCD9_ATTR(base, value) (DMA_TCD9_ATTR_REG(base) = (value))
#define DMA_RMW_TCD9_ATTR(base, mask, value) (DMA_WR_TCD9_ATTR(base, (DMA_RD_TCD9_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_ATTR(base, value) (DMA_WR_TCD9_ATTR(base, DMA_RD_TCD9_ATTR(base) |  (value)))
#define DMA_CLR_TCD9_ATTR(base, value) (DMA_WR_TCD9_ATTR(base, DMA_RD_TCD9_ATTR(base) & ~(value)))
#define DMA_TOG_TCD9_ATTR(base, value) (DMA_WR_TCD9_ATTR(base, DMA_RD_TCD9_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD9_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_ATTR_DSIZE field. */
#define DMA_RD_TCD9_ATTR_DSIZE(base) ((DMA_TCD9_ATTR_REG(base) & DMA_TCD9_ATTR_DSIZE_MASK) >> DMA_TCD9_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD9_ATTR_DSIZE(base) (DMA_RD_TCD9_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD9_ATTR_DSIZE(base, value) (DMA_RMW_TCD9_ATTR(base, DMA_TCD9_ATTR_DSIZE_MASK, DMA_TCD9_ATTR_DSIZE(value)))
#define DMA_BWR_TCD9_ATTR_DSIZE(base, value) (DMA_WR_TCD9_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_ATTR_DMOD field. */
#define DMA_RD_TCD9_ATTR_DMOD(base) ((DMA_TCD9_ATTR_REG(base) & DMA_TCD9_ATTR_DMOD_MASK) >> DMA_TCD9_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD9_ATTR_DMOD(base) (DMA_RD_TCD9_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD9_ATTR_DMOD(base, value) (DMA_RMW_TCD9_ATTR(base, DMA_TCD9_ATTR_DMOD_MASK, DMA_TCD9_ATTR_DMOD(value)))
#define DMA_BWR_TCD9_ATTR_DMOD(base, value) (DMA_WR_TCD9_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_ATTR_SSIZE field. */
#define DMA_RD_TCD9_ATTR_SSIZE(base) ((DMA_TCD9_ATTR_REG(base) & DMA_TCD9_ATTR_SSIZE_MASK) >> DMA_TCD9_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD9_ATTR_SSIZE(base) (DMA_RD_TCD9_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD9_ATTR_SSIZE(base, value) (DMA_RMW_TCD9_ATTR(base, DMA_TCD9_ATTR_SSIZE_MASK, DMA_TCD9_ATTR_SSIZE(value)))
#define DMA_BWR_TCD9_ATTR_SSIZE(base, value) (DMA_WR_TCD9_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_ATTR_SMOD field. */
#define DMA_RD_TCD9_ATTR_SMOD(base) ((DMA_TCD9_ATTR_REG(base) & DMA_TCD9_ATTR_SMOD_MASK) >> DMA_TCD9_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD9_ATTR_SMOD(base) (DMA_RD_TCD9_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD9_ATTR_SMOD(base, value) (DMA_RMW_TCD9_ATTR(base, DMA_TCD9_ATTR_SMOD_MASK, DMA_TCD9_ATTR_SMOD(value)))
#define DMA_BWR_TCD9_ATTR_SMOD(base, value) (DMA_WR_TCD9_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD9_NBYTES_MLNO(base) (DMA_TCD9_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD9_NBYTES_MLNO(base, value) (DMA_TCD9_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD9_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD9_NBYTES_MLNO(base, (DMA_RD_TCD9_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_NBYTES_MLNO(base, value) (DMA_WR_TCD9_NBYTES_MLNO(base, DMA_RD_TCD9_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD9_NBYTES_MLNO(base, value) (DMA_WR_TCD9_NBYTES_MLNO(base, DMA_RD_TCD9_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD9_NBYTES_MLNO(base, value) (DMA_WR_TCD9_NBYTES_MLNO(base, DMA_RD_TCD9_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD9_NBYTES_MLOFFNO(base) (DMA_TCD9_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD9_NBYTES_MLOFFNO(base, value) (DMA_TCD9_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD9_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD9_NBYTES_MLOFFNO(base, (DMA_RD_TCD9_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD9_NBYTES_MLOFFNO(base, DMA_RD_TCD9_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD9_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD9_NBYTES_MLOFFNO(base, DMA_RD_TCD9_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD9_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD9_NBYTES_MLOFFNO(base, DMA_RD_TCD9_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD9_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD9_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD9_NBYTES_MLOFFNO_REG(base) & DMA_TCD9_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD9_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD9_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD9_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD9_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD9_NBYTES_MLOFFNO(base, DMA_TCD9_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD9_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD9_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD9_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD9_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD9_NBYTES_MLOFFNO_REG(base) & DMA_TCD9_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD9_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD9_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFNO_REG(base), DMA_TCD9_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD9_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD9_NBYTES_MLOFFNO(base, DMA_TCD9_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD9_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD9_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFNO_REG(base), DMA_TCD9_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD9_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD9_NBYTES_MLOFFNO_REG(base) & DMA_TCD9_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD9_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD9_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFNO_REG(base), DMA_TCD9_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD9_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD9_NBYTES_MLOFFNO(base, DMA_TCD9_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD9_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD9_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFNO_REG(base), DMA_TCD9_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD9_NBYTES_MLOFFYES(base) (DMA_TCD9_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD9_NBYTES_MLOFFYES(base, value) (DMA_TCD9_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD9_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD9_NBYTES_MLOFFYES(base, (DMA_RD_TCD9_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD9_NBYTES_MLOFFYES(base, DMA_RD_TCD9_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD9_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD9_NBYTES_MLOFFYES(base, DMA_RD_TCD9_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD9_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD9_NBYTES_MLOFFYES(base, DMA_RD_TCD9_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD9_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD9_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD9_NBYTES_MLOFFYES_REG(base) & DMA_TCD9_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD9_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD9_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD9_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD9_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD9_NBYTES_MLOFFYES(base, DMA_TCD9_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD9_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD9_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD9_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD9_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD9_NBYTES_MLOFFYES_REG(base) & DMA_TCD9_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD9_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD9_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD9_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD9_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD9_NBYTES_MLOFFYES(base, DMA_TCD9_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD9_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD9_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD9_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD9_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD9_NBYTES_MLOFFYES_REG(base) & DMA_TCD9_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD9_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD9_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFYES_REG(base), DMA_TCD9_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD9_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD9_NBYTES_MLOFFYES(base, DMA_TCD9_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD9_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD9_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFYES_REG(base), DMA_TCD9_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD9_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD9_NBYTES_MLOFFYES_REG(base) & DMA_TCD9_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD9_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD9_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFYES_REG(base), DMA_TCD9_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD9_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD9_NBYTES_MLOFFYES(base, DMA_TCD9_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD9_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD9_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD9_NBYTES_MLOFFYES_REG(base), DMA_TCD9_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_SLAST register
 */
/*@{*/
#define DMA_RD_TCD9_SLAST(base)  (DMA_TCD9_SLAST_REG(base))
#define DMA_WR_TCD9_SLAST(base, value) (DMA_TCD9_SLAST_REG(base) = (value))
#define DMA_RMW_TCD9_SLAST(base, mask, value) (DMA_WR_TCD9_SLAST(base, (DMA_RD_TCD9_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_SLAST(base, value) (DMA_WR_TCD9_SLAST(base, DMA_RD_TCD9_SLAST(base) |  (value)))
#define DMA_CLR_TCD9_SLAST(base, value) (DMA_WR_TCD9_SLAST(base, DMA_RD_TCD9_SLAST(base) & ~(value)))
#define DMA_TOG_TCD9_SLAST(base, value) (DMA_WR_TCD9_SLAST(base, DMA_RD_TCD9_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_DADDR register
 */
/*@{*/
#define DMA_RD_TCD9_DADDR(base)  (DMA_TCD9_DADDR_REG(base))
#define DMA_WR_TCD9_DADDR(base, value) (DMA_TCD9_DADDR_REG(base) = (value))
#define DMA_RMW_TCD9_DADDR(base, mask, value) (DMA_WR_TCD9_DADDR(base, (DMA_RD_TCD9_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_DADDR(base, value) (DMA_WR_TCD9_DADDR(base, DMA_RD_TCD9_DADDR(base) |  (value)))
#define DMA_CLR_TCD9_DADDR(base, value) (DMA_WR_TCD9_DADDR(base, DMA_RD_TCD9_DADDR(base) & ~(value)))
#define DMA_TOG_TCD9_DADDR(base, value) (DMA_WR_TCD9_DADDR(base, DMA_RD_TCD9_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_DOFF register
 */
/*@{*/
#define DMA_RD_TCD9_DOFF(base)   (DMA_TCD9_DOFF_REG(base))
#define DMA_WR_TCD9_DOFF(base, value) (DMA_TCD9_DOFF_REG(base) = (value))
#define DMA_RMW_TCD9_DOFF(base, mask, value) (DMA_WR_TCD9_DOFF(base, (DMA_RD_TCD9_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_DOFF(base, value) (DMA_WR_TCD9_DOFF(base, DMA_RD_TCD9_DOFF(base) |  (value)))
#define DMA_CLR_TCD9_DOFF(base, value) (DMA_WR_TCD9_DOFF(base, DMA_RD_TCD9_DOFF(base) & ~(value)))
#define DMA_TOG_TCD9_DOFF(base, value) (DMA_WR_TCD9_DOFF(base, DMA_RD_TCD9_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD9_CITER_ELINKYES(base) (DMA_TCD9_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD9_CITER_ELINKYES(base, value) (DMA_TCD9_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD9_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD9_CITER_ELINKYES(base, (DMA_RD_TCD9_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_CITER_ELINKYES(base, value) (DMA_WR_TCD9_CITER_ELINKYES(base, DMA_RD_TCD9_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD9_CITER_ELINKYES(base, value) (DMA_WR_TCD9_CITER_ELINKYES(base, DMA_RD_TCD9_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD9_CITER_ELINKYES(base, value) (DMA_WR_TCD9_CITER_ELINKYES(base, DMA_RD_TCD9_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD9_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD9_CITER_ELINKYES_CITER(base) ((DMA_TCD9_CITER_ELINKYES_REG(base) & DMA_TCD9_CITER_ELINKYES_CITER_MASK) >> DMA_TCD9_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD9_CITER_ELINKYES_CITER(base) (DMA_RD_TCD9_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD9_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD9_CITER_ELINKYES(base, DMA_TCD9_CITER_ELINKYES_CITER_MASK, DMA_TCD9_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD9_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD9_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD9_CITER_ELINKYES_LINKCH(base) ((DMA_TCD9_CITER_ELINKYES_REG(base) & DMA_TCD9_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD9_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD9_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD9_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD9_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD9_CITER_ELINKYES(base, DMA_TCD9_CITER_ELINKYES_LINKCH_MASK, DMA_TCD9_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD9_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD9_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD9_CITER_ELINKYES_ELINK(base) ((DMA_TCD9_CITER_ELINKYES_REG(base) & DMA_TCD9_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD9_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD9_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD9_CITER_ELINKYES_REG(base), DMA_TCD9_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD9_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD9_CITER_ELINKYES(base, DMA_TCD9_CITER_ELINKYES_ELINK_MASK, DMA_TCD9_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD9_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CITER_ELINKYES_REG(base), DMA_TCD9_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD9_CITER_ELINKNO(base) (DMA_TCD9_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD9_CITER_ELINKNO(base, value) (DMA_TCD9_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD9_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD9_CITER_ELINKNO(base, (DMA_RD_TCD9_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_CITER_ELINKNO(base, value) (DMA_WR_TCD9_CITER_ELINKNO(base, DMA_RD_TCD9_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD9_CITER_ELINKNO(base, value) (DMA_WR_TCD9_CITER_ELINKNO(base, DMA_RD_TCD9_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD9_CITER_ELINKNO(base, value) (DMA_WR_TCD9_CITER_ELINKNO(base, DMA_RD_TCD9_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD9_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD9_CITER_ELINKNO_CITER(base) ((DMA_TCD9_CITER_ELINKNO_REG(base) & DMA_TCD9_CITER_ELINKNO_CITER_MASK) >> DMA_TCD9_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD9_CITER_ELINKNO_CITER(base) (DMA_RD_TCD9_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD9_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD9_CITER_ELINKNO(base, DMA_TCD9_CITER_ELINKNO_CITER_MASK, DMA_TCD9_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD9_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD9_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD9_CITER_ELINKNO_ELINK(base) ((DMA_TCD9_CITER_ELINKNO_REG(base) & DMA_TCD9_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD9_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD9_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD9_CITER_ELINKNO_REG(base), DMA_TCD9_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD9_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD9_CITER_ELINKNO(base, DMA_TCD9_CITER_ELINKNO_ELINK_MASK, DMA_TCD9_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD9_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CITER_ELINKNO_REG(base), DMA_TCD9_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD9_DLASTSGA(base) (DMA_TCD9_DLASTSGA_REG(base))
#define DMA_WR_TCD9_DLASTSGA(base, value) (DMA_TCD9_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD9_DLASTSGA(base, mask, value) (DMA_WR_TCD9_DLASTSGA(base, (DMA_RD_TCD9_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_DLASTSGA(base, value) (DMA_WR_TCD9_DLASTSGA(base, DMA_RD_TCD9_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD9_DLASTSGA(base, value) (DMA_WR_TCD9_DLASTSGA(base, DMA_RD_TCD9_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD9_DLASTSGA(base, value) (DMA_WR_TCD9_DLASTSGA(base, DMA_RD_TCD9_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_CSR register
 */
/*@{*/
#define DMA_RD_TCD9_CSR(base)    (DMA_TCD9_CSR_REG(base))
#define DMA_WR_TCD9_CSR(base, value) (DMA_TCD9_CSR_REG(base) = (value))
#define DMA_RMW_TCD9_CSR(base, mask, value) (DMA_WR_TCD9_CSR(base, (DMA_RD_TCD9_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_CSR(base, value) (DMA_WR_TCD9_CSR(base, DMA_RD_TCD9_CSR(base) |  (value)))
#define DMA_CLR_TCD9_CSR(base, value) (DMA_WR_TCD9_CSR(base, DMA_RD_TCD9_CSR(base) & ~(value)))
#define DMA_TOG_TCD9_CSR(base, value) (DMA_WR_TCD9_CSR(base, DMA_RD_TCD9_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_CSR bitfields
 */

/*!
 * @name Register DMA_TCD9_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_START field. */
#define DMA_RD_TCD9_CSR_START(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_START_MASK) >> DMA_TCD9_CSR_START_SHIFT)
#define DMA_BRD_TCD9_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD9_CSR_START(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_START_MASK, DMA_TCD9_CSR_START(value)))
#define DMA_BWR_TCD9_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_INTMAJOR field. */
#define DMA_RD_TCD9_CSR_INTMAJOR(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_INTMAJOR_MASK) >> DMA_TCD9_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD9_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD9_CSR_INTMAJOR(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_INTMAJOR_MASK, DMA_TCD9_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD9_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_INTHALF field. */
#define DMA_RD_TCD9_CSR_INTHALF(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_INTHALF_MASK) >> DMA_TCD9_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD9_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD9_CSR_INTHALF(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_INTHALF_MASK, DMA_TCD9_CSR_INTHALF(value)))
#define DMA_BWR_TCD9_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_DREQ field. */
#define DMA_RD_TCD9_CSR_DREQ(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_DREQ_MASK) >> DMA_TCD9_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD9_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD9_CSR_DREQ(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_DREQ_MASK, DMA_TCD9_CSR_DREQ(value)))
#define DMA_BWR_TCD9_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_ESG field. */
#define DMA_RD_TCD9_CSR_ESG(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_ESG_MASK) >> DMA_TCD9_CSR_ESG_SHIFT)
#define DMA_BRD_TCD9_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD9_CSR_ESG(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_ESG_MASK, DMA_TCD9_CSR_ESG(value)))
#define DMA_BWR_TCD9_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_MAJORELINK field. */
#define DMA_RD_TCD9_CSR_MAJORELINK(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_MAJORELINK_MASK) >> DMA_TCD9_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD9_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD9_CSR_MAJORELINK(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_MAJORELINK_MASK, DMA_TCD9_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD9_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_ACTIVE field. */
#define DMA_RD_TCD9_CSR_ACTIVE(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_ACTIVE_MASK) >> DMA_TCD9_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD9_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD9_CSR_ACTIVE(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_ACTIVE_MASK, DMA_TCD9_CSR_ACTIVE(value)))
#define DMA_BWR_TCD9_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_DONE field. */
#define DMA_RD_TCD9_CSR_DONE(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_DONE_MASK) >> DMA_TCD9_CSR_DONE_SHIFT)
#define DMA_BRD_TCD9_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD9_CSR_DONE(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_DONE_MASK, DMA_TCD9_CSR_DONE(value)))
#define DMA_BWR_TCD9_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD9_CSR_REG(base), DMA_TCD9_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD9_CSR_MAJORLINKCH(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_MAJORLINKCH_MASK) >> DMA_TCD9_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD9_CSR_MAJORLINKCH(base) (DMA_RD_TCD9_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD9_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_MAJORLINKCH_MASK, DMA_TCD9_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD9_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD9_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_CSR_BWC field. */
#define DMA_RD_TCD9_CSR_BWC(base) ((DMA_TCD9_CSR_REG(base) & DMA_TCD9_CSR_BWC_MASK) >> DMA_TCD9_CSR_BWC_SHIFT)
#define DMA_BRD_TCD9_CSR_BWC(base) (DMA_RD_TCD9_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD9_CSR_BWC(base, value) (DMA_RMW_TCD9_CSR(base, DMA_TCD9_CSR_BWC_MASK, DMA_TCD9_CSR_BWC(value)))
#define DMA_BWR_TCD9_CSR_BWC(base, value) (DMA_WR_TCD9_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD9_BITER_ELINKYES(base) (DMA_TCD9_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD9_BITER_ELINKYES(base, value) (DMA_TCD9_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD9_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD9_BITER_ELINKYES(base, (DMA_RD_TCD9_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_BITER_ELINKYES(base, value) (DMA_WR_TCD9_BITER_ELINKYES(base, DMA_RD_TCD9_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD9_BITER_ELINKYES(base, value) (DMA_WR_TCD9_BITER_ELINKYES(base, DMA_RD_TCD9_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD9_BITER_ELINKYES(base, value) (DMA_WR_TCD9_BITER_ELINKYES(base, DMA_RD_TCD9_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD9_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD9_BITER_ELINKYES_BITER(base) ((DMA_TCD9_BITER_ELINKYES_REG(base) & DMA_TCD9_BITER_ELINKYES_BITER_MASK) >> DMA_TCD9_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD9_BITER_ELINKYES_BITER(base) (DMA_RD_TCD9_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD9_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD9_BITER_ELINKYES(base, DMA_TCD9_BITER_ELINKYES_BITER_MASK, DMA_TCD9_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD9_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD9_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD9_BITER_ELINKYES_LINKCH(base) ((DMA_TCD9_BITER_ELINKYES_REG(base) & DMA_TCD9_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD9_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD9_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD9_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD9_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD9_BITER_ELINKYES(base, DMA_TCD9_BITER_ELINKYES_LINKCH_MASK, DMA_TCD9_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD9_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD9_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD9_BITER_ELINKYES_ELINK(base) ((DMA_TCD9_BITER_ELINKYES_REG(base) & DMA_TCD9_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD9_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD9_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD9_BITER_ELINKYES_REG(base), DMA_TCD9_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD9_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD9_BITER_ELINKYES(base, DMA_TCD9_BITER_ELINKYES_ELINK_MASK, DMA_TCD9_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD9_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD9_BITER_ELINKYES_REG(base), DMA_TCD9_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD9_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD9_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD9_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD9_BITER_ELINKNO(base) (DMA_TCD9_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD9_BITER_ELINKNO(base, value) (DMA_TCD9_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD9_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD9_BITER_ELINKNO(base, (DMA_RD_TCD9_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD9_BITER_ELINKNO(base, value) (DMA_WR_TCD9_BITER_ELINKNO(base, DMA_RD_TCD9_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD9_BITER_ELINKNO(base, value) (DMA_WR_TCD9_BITER_ELINKNO(base, DMA_RD_TCD9_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD9_BITER_ELINKNO(base, value) (DMA_WR_TCD9_BITER_ELINKNO(base, DMA_RD_TCD9_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD9_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD9_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD9_BITER_ELINKNO_BITER(base) ((DMA_TCD9_BITER_ELINKNO_REG(base) & DMA_TCD9_BITER_ELINKNO_BITER_MASK) >> DMA_TCD9_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD9_BITER_ELINKNO_BITER(base) (DMA_RD_TCD9_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD9_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD9_BITER_ELINKNO(base, DMA_TCD9_BITER_ELINKNO_BITER_MASK, DMA_TCD9_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD9_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD9_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD9_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD9_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD9_BITER_ELINKNO_ELINK(base) ((DMA_TCD9_BITER_ELINKNO_REG(base) & DMA_TCD9_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD9_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD9_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD9_BITER_ELINKNO_REG(base), DMA_TCD9_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD9_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD9_BITER_ELINKNO(base, DMA_TCD9_BITER_ELINKNO_ELINK_MASK, DMA_TCD9_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD9_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD9_BITER_ELINKNO_REG(base), DMA_TCD9_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_SADDR register
 */
/*@{*/
#define DMA_RD_TCD10_SADDR(base) (DMA_TCD10_SADDR_REG(base))
#define DMA_WR_TCD10_SADDR(base, value) (DMA_TCD10_SADDR_REG(base) = (value))
#define DMA_RMW_TCD10_SADDR(base, mask, value) (DMA_WR_TCD10_SADDR(base, (DMA_RD_TCD10_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_SADDR(base, value) (DMA_WR_TCD10_SADDR(base, DMA_RD_TCD10_SADDR(base) |  (value)))
#define DMA_CLR_TCD10_SADDR(base, value) (DMA_WR_TCD10_SADDR(base, DMA_RD_TCD10_SADDR(base) & ~(value)))
#define DMA_TOG_TCD10_SADDR(base, value) (DMA_WR_TCD10_SADDR(base, DMA_RD_TCD10_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_SOFF register
 */
/*@{*/
#define DMA_RD_TCD10_SOFF(base)  (DMA_TCD10_SOFF_REG(base))
#define DMA_WR_TCD10_SOFF(base, value) (DMA_TCD10_SOFF_REG(base) = (value))
#define DMA_RMW_TCD10_SOFF(base, mask, value) (DMA_WR_TCD10_SOFF(base, (DMA_RD_TCD10_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_SOFF(base, value) (DMA_WR_TCD10_SOFF(base, DMA_RD_TCD10_SOFF(base) |  (value)))
#define DMA_CLR_TCD10_SOFF(base, value) (DMA_WR_TCD10_SOFF(base, DMA_RD_TCD10_SOFF(base) & ~(value)))
#define DMA_TOG_TCD10_SOFF(base, value) (DMA_WR_TCD10_SOFF(base, DMA_RD_TCD10_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_ATTR register
 */
/*@{*/
#define DMA_RD_TCD10_ATTR(base)  (DMA_TCD10_ATTR_REG(base))
#define DMA_WR_TCD10_ATTR(base, value) (DMA_TCD10_ATTR_REG(base) = (value))
#define DMA_RMW_TCD10_ATTR(base, mask, value) (DMA_WR_TCD10_ATTR(base, (DMA_RD_TCD10_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_ATTR(base, value) (DMA_WR_TCD10_ATTR(base, DMA_RD_TCD10_ATTR(base) |  (value)))
#define DMA_CLR_TCD10_ATTR(base, value) (DMA_WR_TCD10_ATTR(base, DMA_RD_TCD10_ATTR(base) & ~(value)))
#define DMA_TOG_TCD10_ATTR(base, value) (DMA_WR_TCD10_ATTR(base, DMA_RD_TCD10_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD10_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_ATTR_DSIZE field. */
#define DMA_RD_TCD10_ATTR_DSIZE(base) ((DMA_TCD10_ATTR_REG(base) & DMA_TCD10_ATTR_DSIZE_MASK) >> DMA_TCD10_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD10_ATTR_DSIZE(base) (DMA_RD_TCD10_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD10_ATTR_DSIZE(base, value) (DMA_RMW_TCD10_ATTR(base, DMA_TCD10_ATTR_DSIZE_MASK, DMA_TCD10_ATTR_DSIZE(value)))
#define DMA_BWR_TCD10_ATTR_DSIZE(base, value) (DMA_WR_TCD10_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_ATTR_DMOD field. */
#define DMA_RD_TCD10_ATTR_DMOD(base) ((DMA_TCD10_ATTR_REG(base) & DMA_TCD10_ATTR_DMOD_MASK) >> DMA_TCD10_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD10_ATTR_DMOD(base) (DMA_RD_TCD10_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD10_ATTR_DMOD(base, value) (DMA_RMW_TCD10_ATTR(base, DMA_TCD10_ATTR_DMOD_MASK, DMA_TCD10_ATTR_DMOD(value)))
#define DMA_BWR_TCD10_ATTR_DMOD(base, value) (DMA_WR_TCD10_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_ATTR_SSIZE field. */
#define DMA_RD_TCD10_ATTR_SSIZE(base) ((DMA_TCD10_ATTR_REG(base) & DMA_TCD10_ATTR_SSIZE_MASK) >> DMA_TCD10_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD10_ATTR_SSIZE(base) (DMA_RD_TCD10_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD10_ATTR_SSIZE(base, value) (DMA_RMW_TCD10_ATTR(base, DMA_TCD10_ATTR_SSIZE_MASK, DMA_TCD10_ATTR_SSIZE(value)))
#define DMA_BWR_TCD10_ATTR_SSIZE(base, value) (DMA_WR_TCD10_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_ATTR_SMOD field. */
#define DMA_RD_TCD10_ATTR_SMOD(base) ((DMA_TCD10_ATTR_REG(base) & DMA_TCD10_ATTR_SMOD_MASK) >> DMA_TCD10_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD10_ATTR_SMOD(base) (DMA_RD_TCD10_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD10_ATTR_SMOD(base, value) (DMA_RMW_TCD10_ATTR(base, DMA_TCD10_ATTR_SMOD_MASK, DMA_TCD10_ATTR_SMOD(value)))
#define DMA_BWR_TCD10_ATTR_SMOD(base, value) (DMA_WR_TCD10_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD10_NBYTES_MLOFFYES(base) (DMA_TCD10_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD10_NBYTES_MLOFFYES(base, value) (DMA_TCD10_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD10_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD10_NBYTES_MLOFFYES(base, (DMA_RD_TCD10_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD10_NBYTES_MLOFFYES(base, DMA_RD_TCD10_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD10_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD10_NBYTES_MLOFFYES(base, DMA_RD_TCD10_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD10_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD10_NBYTES_MLOFFYES(base, DMA_RD_TCD10_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD10_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD10_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD10_NBYTES_MLOFFYES_REG(base) & DMA_TCD10_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD10_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD10_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD10_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD10_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD10_NBYTES_MLOFFYES(base, DMA_TCD10_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD10_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD10_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD10_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD10_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD10_NBYTES_MLOFFYES_REG(base) & DMA_TCD10_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD10_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD10_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD10_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD10_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD10_NBYTES_MLOFFYES(base, DMA_TCD10_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD10_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD10_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD10_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD10_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD10_NBYTES_MLOFFYES_REG(base) & DMA_TCD10_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD10_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD10_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFYES_REG(base), DMA_TCD10_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD10_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD10_NBYTES_MLOFFYES(base, DMA_TCD10_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD10_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD10_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFYES_REG(base), DMA_TCD10_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD10_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD10_NBYTES_MLOFFYES_REG(base) & DMA_TCD10_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD10_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD10_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFYES_REG(base), DMA_TCD10_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD10_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD10_NBYTES_MLOFFYES(base, DMA_TCD10_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD10_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD10_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFYES_REG(base), DMA_TCD10_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD10_NBYTES_MLOFFNO(base) (DMA_TCD10_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD10_NBYTES_MLOFFNO(base, value) (DMA_TCD10_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD10_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD10_NBYTES_MLOFFNO(base, (DMA_RD_TCD10_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD10_NBYTES_MLOFFNO(base, DMA_RD_TCD10_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD10_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD10_NBYTES_MLOFFNO(base, DMA_RD_TCD10_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD10_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD10_NBYTES_MLOFFNO(base, DMA_RD_TCD10_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD10_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD10_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD10_NBYTES_MLOFFNO_REG(base) & DMA_TCD10_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD10_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD10_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD10_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD10_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD10_NBYTES_MLOFFNO(base, DMA_TCD10_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD10_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD10_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD10_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD10_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD10_NBYTES_MLOFFNO_REG(base) & DMA_TCD10_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD10_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD10_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFNO_REG(base), DMA_TCD10_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD10_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD10_NBYTES_MLOFFNO(base, DMA_TCD10_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD10_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD10_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFNO_REG(base), DMA_TCD10_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD10_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD10_NBYTES_MLOFFNO_REG(base) & DMA_TCD10_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD10_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD10_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFNO_REG(base), DMA_TCD10_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD10_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD10_NBYTES_MLOFFNO(base, DMA_TCD10_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD10_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD10_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD10_NBYTES_MLOFFNO_REG(base), DMA_TCD10_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD10_NBYTES_MLNO(base) (DMA_TCD10_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD10_NBYTES_MLNO(base, value) (DMA_TCD10_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD10_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD10_NBYTES_MLNO(base, (DMA_RD_TCD10_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_NBYTES_MLNO(base, value) (DMA_WR_TCD10_NBYTES_MLNO(base, DMA_RD_TCD10_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD10_NBYTES_MLNO(base, value) (DMA_WR_TCD10_NBYTES_MLNO(base, DMA_RD_TCD10_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD10_NBYTES_MLNO(base, value) (DMA_WR_TCD10_NBYTES_MLNO(base, DMA_RD_TCD10_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_SLAST register
 */
/*@{*/
#define DMA_RD_TCD10_SLAST(base) (DMA_TCD10_SLAST_REG(base))
#define DMA_WR_TCD10_SLAST(base, value) (DMA_TCD10_SLAST_REG(base) = (value))
#define DMA_RMW_TCD10_SLAST(base, mask, value) (DMA_WR_TCD10_SLAST(base, (DMA_RD_TCD10_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_SLAST(base, value) (DMA_WR_TCD10_SLAST(base, DMA_RD_TCD10_SLAST(base) |  (value)))
#define DMA_CLR_TCD10_SLAST(base, value) (DMA_WR_TCD10_SLAST(base, DMA_RD_TCD10_SLAST(base) & ~(value)))
#define DMA_TOG_TCD10_SLAST(base, value) (DMA_WR_TCD10_SLAST(base, DMA_RD_TCD10_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_DADDR register
 */
/*@{*/
#define DMA_RD_TCD10_DADDR(base) (DMA_TCD10_DADDR_REG(base))
#define DMA_WR_TCD10_DADDR(base, value) (DMA_TCD10_DADDR_REG(base) = (value))
#define DMA_RMW_TCD10_DADDR(base, mask, value) (DMA_WR_TCD10_DADDR(base, (DMA_RD_TCD10_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_DADDR(base, value) (DMA_WR_TCD10_DADDR(base, DMA_RD_TCD10_DADDR(base) |  (value)))
#define DMA_CLR_TCD10_DADDR(base, value) (DMA_WR_TCD10_DADDR(base, DMA_RD_TCD10_DADDR(base) & ~(value)))
#define DMA_TOG_TCD10_DADDR(base, value) (DMA_WR_TCD10_DADDR(base, DMA_RD_TCD10_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_DOFF register
 */
/*@{*/
#define DMA_RD_TCD10_DOFF(base)  (DMA_TCD10_DOFF_REG(base))
#define DMA_WR_TCD10_DOFF(base, value) (DMA_TCD10_DOFF_REG(base) = (value))
#define DMA_RMW_TCD10_DOFF(base, mask, value) (DMA_WR_TCD10_DOFF(base, (DMA_RD_TCD10_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_DOFF(base, value) (DMA_WR_TCD10_DOFF(base, DMA_RD_TCD10_DOFF(base) |  (value)))
#define DMA_CLR_TCD10_DOFF(base, value) (DMA_WR_TCD10_DOFF(base, DMA_RD_TCD10_DOFF(base) & ~(value)))
#define DMA_TOG_TCD10_DOFF(base, value) (DMA_WR_TCD10_DOFF(base, DMA_RD_TCD10_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD10_CITER_ELINKNO(base) (DMA_TCD10_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD10_CITER_ELINKNO(base, value) (DMA_TCD10_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD10_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD10_CITER_ELINKNO(base, (DMA_RD_TCD10_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_CITER_ELINKNO(base, value) (DMA_WR_TCD10_CITER_ELINKNO(base, DMA_RD_TCD10_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD10_CITER_ELINKNO(base, value) (DMA_WR_TCD10_CITER_ELINKNO(base, DMA_RD_TCD10_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD10_CITER_ELINKNO(base, value) (DMA_WR_TCD10_CITER_ELINKNO(base, DMA_RD_TCD10_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD10_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD10_CITER_ELINKNO_CITER(base) ((DMA_TCD10_CITER_ELINKNO_REG(base) & DMA_TCD10_CITER_ELINKNO_CITER_MASK) >> DMA_TCD10_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD10_CITER_ELINKNO_CITER(base) (DMA_RD_TCD10_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD10_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD10_CITER_ELINKNO(base, DMA_TCD10_CITER_ELINKNO_CITER_MASK, DMA_TCD10_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD10_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD10_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD10_CITER_ELINKNO_ELINK(base) ((DMA_TCD10_CITER_ELINKNO_REG(base) & DMA_TCD10_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD10_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD10_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD10_CITER_ELINKNO_REG(base), DMA_TCD10_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD10_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD10_CITER_ELINKNO(base, DMA_TCD10_CITER_ELINKNO_ELINK_MASK, DMA_TCD10_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD10_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CITER_ELINKNO_REG(base), DMA_TCD10_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD10_CITER_ELINKYES(base) (DMA_TCD10_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD10_CITER_ELINKYES(base, value) (DMA_TCD10_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD10_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD10_CITER_ELINKYES(base, (DMA_RD_TCD10_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_CITER_ELINKYES(base, value) (DMA_WR_TCD10_CITER_ELINKYES(base, DMA_RD_TCD10_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD10_CITER_ELINKYES(base, value) (DMA_WR_TCD10_CITER_ELINKYES(base, DMA_RD_TCD10_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD10_CITER_ELINKYES(base, value) (DMA_WR_TCD10_CITER_ELINKYES(base, DMA_RD_TCD10_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD10_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD10_CITER_ELINKYES_CITER(base) ((DMA_TCD10_CITER_ELINKYES_REG(base) & DMA_TCD10_CITER_ELINKYES_CITER_MASK) >> DMA_TCD10_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD10_CITER_ELINKYES_CITER(base) (DMA_RD_TCD10_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD10_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD10_CITER_ELINKYES(base, DMA_TCD10_CITER_ELINKYES_CITER_MASK, DMA_TCD10_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD10_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD10_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD10_CITER_ELINKYES_LINKCH(base) ((DMA_TCD10_CITER_ELINKYES_REG(base) & DMA_TCD10_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD10_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD10_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD10_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD10_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD10_CITER_ELINKYES(base, DMA_TCD10_CITER_ELINKYES_LINKCH_MASK, DMA_TCD10_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD10_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD10_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD10_CITER_ELINKYES_ELINK(base) ((DMA_TCD10_CITER_ELINKYES_REG(base) & DMA_TCD10_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD10_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD10_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD10_CITER_ELINKYES_REG(base), DMA_TCD10_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD10_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD10_CITER_ELINKYES(base, DMA_TCD10_CITER_ELINKYES_ELINK_MASK, DMA_TCD10_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD10_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CITER_ELINKYES_REG(base), DMA_TCD10_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD10_DLASTSGA(base) (DMA_TCD10_DLASTSGA_REG(base))
#define DMA_WR_TCD10_DLASTSGA(base, value) (DMA_TCD10_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD10_DLASTSGA(base, mask, value) (DMA_WR_TCD10_DLASTSGA(base, (DMA_RD_TCD10_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_DLASTSGA(base, value) (DMA_WR_TCD10_DLASTSGA(base, DMA_RD_TCD10_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD10_DLASTSGA(base, value) (DMA_WR_TCD10_DLASTSGA(base, DMA_RD_TCD10_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD10_DLASTSGA(base, value) (DMA_WR_TCD10_DLASTSGA(base, DMA_RD_TCD10_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_CSR register
 */
/*@{*/
#define DMA_RD_TCD10_CSR(base)   (DMA_TCD10_CSR_REG(base))
#define DMA_WR_TCD10_CSR(base, value) (DMA_TCD10_CSR_REG(base) = (value))
#define DMA_RMW_TCD10_CSR(base, mask, value) (DMA_WR_TCD10_CSR(base, (DMA_RD_TCD10_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_CSR(base, value) (DMA_WR_TCD10_CSR(base, DMA_RD_TCD10_CSR(base) |  (value)))
#define DMA_CLR_TCD10_CSR(base, value) (DMA_WR_TCD10_CSR(base, DMA_RD_TCD10_CSR(base) & ~(value)))
#define DMA_TOG_TCD10_CSR(base, value) (DMA_WR_TCD10_CSR(base, DMA_RD_TCD10_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_CSR bitfields
 */

/*!
 * @name Register DMA_TCD10_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_START field. */
#define DMA_RD_TCD10_CSR_START(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_START_MASK) >> DMA_TCD10_CSR_START_SHIFT)
#define DMA_BRD_TCD10_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD10_CSR_START(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_START_MASK, DMA_TCD10_CSR_START(value)))
#define DMA_BWR_TCD10_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_INTMAJOR field. */
#define DMA_RD_TCD10_CSR_INTMAJOR(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_INTMAJOR_MASK) >> DMA_TCD10_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD10_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD10_CSR_INTMAJOR(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_INTMAJOR_MASK, DMA_TCD10_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD10_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_INTHALF field. */
#define DMA_RD_TCD10_CSR_INTHALF(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_INTHALF_MASK) >> DMA_TCD10_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD10_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD10_CSR_INTHALF(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_INTHALF_MASK, DMA_TCD10_CSR_INTHALF(value)))
#define DMA_BWR_TCD10_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_DREQ field. */
#define DMA_RD_TCD10_CSR_DREQ(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_DREQ_MASK) >> DMA_TCD10_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD10_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD10_CSR_DREQ(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_DREQ_MASK, DMA_TCD10_CSR_DREQ(value)))
#define DMA_BWR_TCD10_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_ESG field. */
#define DMA_RD_TCD10_CSR_ESG(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_ESG_MASK) >> DMA_TCD10_CSR_ESG_SHIFT)
#define DMA_BRD_TCD10_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD10_CSR_ESG(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_ESG_MASK, DMA_TCD10_CSR_ESG(value)))
#define DMA_BWR_TCD10_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_MAJORELINK field. */
#define DMA_RD_TCD10_CSR_MAJORELINK(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_MAJORELINK_MASK) >> DMA_TCD10_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD10_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD10_CSR_MAJORELINK(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_MAJORELINK_MASK, DMA_TCD10_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD10_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_ACTIVE field. */
#define DMA_RD_TCD10_CSR_ACTIVE(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_ACTIVE_MASK) >> DMA_TCD10_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD10_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD10_CSR_ACTIVE(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_ACTIVE_MASK, DMA_TCD10_CSR_ACTIVE(value)))
#define DMA_BWR_TCD10_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_DONE field. */
#define DMA_RD_TCD10_CSR_DONE(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_DONE_MASK) >> DMA_TCD10_CSR_DONE_SHIFT)
#define DMA_BRD_TCD10_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD10_CSR_DONE(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_DONE_MASK, DMA_TCD10_CSR_DONE(value)))
#define DMA_BWR_TCD10_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD10_CSR_REG(base), DMA_TCD10_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD10_CSR_MAJORLINKCH(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_MAJORLINKCH_MASK) >> DMA_TCD10_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD10_CSR_MAJORLINKCH(base) (DMA_RD_TCD10_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD10_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_MAJORLINKCH_MASK, DMA_TCD10_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD10_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD10_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_CSR_BWC field. */
#define DMA_RD_TCD10_CSR_BWC(base) ((DMA_TCD10_CSR_REG(base) & DMA_TCD10_CSR_BWC_MASK) >> DMA_TCD10_CSR_BWC_SHIFT)
#define DMA_BRD_TCD10_CSR_BWC(base) (DMA_RD_TCD10_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD10_CSR_BWC(base, value) (DMA_RMW_TCD10_CSR(base, DMA_TCD10_CSR_BWC_MASK, DMA_TCD10_CSR_BWC(value)))
#define DMA_BWR_TCD10_CSR_BWC(base, value) (DMA_WR_TCD10_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD10_BITER_ELINKYES(base) (DMA_TCD10_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD10_BITER_ELINKYES(base, value) (DMA_TCD10_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD10_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD10_BITER_ELINKYES(base, (DMA_RD_TCD10_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_BITER_ELINKYES(base, value) (DMA_WR_TCD10_BITER_ELINKYES(base, DMA_RD_TCD10_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD10_BITER_ELINKYES(base, value) (DMA_WR_TCD10_BITER_ELINKYES(base, DMA_RD_TCD10_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD10_BITER_ELINKYES(base, value) (DMA_WR_TCD10_BITER_ELINKYES(base, DMA_RD_TCD10_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD10_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD10_BITER_ELINKYES_BITER(base) ((DMA_TCD10_BITER_ELINKYES_REG(base) & DMA_TCD10_BITER_ELINKYES_BITER_MASK) >> DMA_TCD10_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD10_BITER_ELINKYES_BITER(base) (DMA_RD_TCD10_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD10_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD10_BITER_ELINKYES(base, DMA_TCD10_BITER_ELINKYES_BITER_MASK, DMA_TCD10_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD10_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD10_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD10_BITER_ELINKYES_LINKCH(base) ((DMA_TCD10_BITER_ELINKYES_REG(base) & DMA_TCD10_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD10_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD10_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD10_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD10_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD10_BITER_ELINKYES(base, DMA_TCD10_BITER_ELINKYES_LINKCH_MASK, DMA_TCD10_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD10_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD10_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD10_BITER_ELINKYES_ELINK(base) ((DMA_TCD10_BITER_ELINKYES_REG(base) & DMA_TCD10_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD10_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD10_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD10_BITER_ELINKYES_REG(base), DMA_TCD10_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD10_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD10_BITER_ELINKYES(base, DMA_TCD10_BITER_ELINKYES_ELINK_MASK, DMA_TCD10_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD10_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD10_BITER_ELINKYES_REG(base), DMA_TCD10_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD10_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD10_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD10_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD10_BITER_ELINKNO(base) (DMA_TCD10_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD10_BITER_ELINKNO(base, value) (DMA_TCD10_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD10_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD10_BITER_ELINKNO(base, (DMA_RD_TCD10_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD10_BITER_ELINKNO(base, value) (DMA_WR_TCD10_BITER_ELINKNO(base, DMA_RD_TCD10_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD10_BITER_ELINKNO(base, value) (DMA_WR_TCD10_BITER_ELINKNO(base, DMA_RD_TCD10_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD10_BITER_ELINKNO(base, value) (DMA_WR_TCD10_BITER_ELINKNO(base, DMA_RD_TCD10_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD10_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD10_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD10_BITER_ELINKNO_BITER(base) ((DMA_TCD10_BITER_ELINKNO_REG(base) & DMA_TCD10_BITER_ELINKNO_BITER_MASK) >> DMA_TCD10_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD10_BITER_ELINKNO_BITER(base) (DMA_RD_TCD10_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD10_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD10_BITER_ELINKNO(base, DMA_TCD10_BITER_ELINKNO_BITER_MASK, DMA_TCD10_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD10_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD10_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD10_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD10_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD10_BITER_ELINKNO_ELINK(base) ((DMA_TCD10_BITER_ELINKNO_REG(base) & DMA_TCD10_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD10_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD10_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD10_BITER_ELINKNO_REG(base), DMA_TCD10_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD10_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD10_BITER_ELINKNO(base, DMA_TCD10_BITER_ELINKNO_ELINK_MASK, DMA_TCD10_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD10_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD10_BITER_ELINKNO_REG(base), DMA_TCD10_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_SADDR register
 */
/*@{*/
#define DMA_RD_TCD11_SADDR(base) (DMA_TCD11_SADDR_REG(base))
#define DMA_WR_TCD11_SADDR(base, value) (DMA_TCD11_SADDR_REG(base) = (value))
#define DMA_RMW_TCD11_SADDR(base, mask, value) (DMA_WR_TCD11_SADDR(base, (DMA_RD_TCD11_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_SADDR(base, value) (DMA_WR_TCD11_SADDR(base, DMA_RD_TCD11_SADDR(base) |  (value)))
#define DMA_CLR_TCD11_SADDR(base, value) (DMA_WR_TCD11_SADDR(base, DMA_RD_TCD11_SADDR(base) & ~(value)))
#define DMA_TOG_TCD11_SADDR(base, value) (DMA_WR_TCD11_SADDR(base, DMA_RD_TCD11_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_SOFF register
 */
/*@{*/
#define DMA_RD_TCD11_SOFF(base)  (DMA_TCD11_SOFF_REG(base))
#define DMA_WR_TCD11_SOFF(base, value) (DMA_TCD11_SOFF_REG(base) = (value))
#define DMA_RMW_TCD11_SOFF(base, mask, value) (DMA_WR_TCD11_SOFF(base, (DMA_RD_TCD11_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_SOFF(base, value) (DMA_WR_TCD11_SOFF(base, DMA_RD_TCD11_SOFF(base) |  (value)))
#define DMA_CLR_TCD11_SOFF(base, value) (DMA_WR_TCD11_SOFF(base, DMA_RD_TCD11_SOFF(base) & ~(value)))
#define DMA_TOG_TCD11_SOFF(base, value) (DMA_WR_TCD11_SOFF(base, DMA_RD_TCD11_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_ATTR register
 */
/*@{*/
#define DMA_RD_TCD11_ATTR(base)  (DMA_TCD11_ATTR_REG(base))
#define DMA_WR_TCD11_ATTR(base, value) (DMA_TCD11_ATTR_REG(base) = (value))
#define DMA_RMW_TCD11_ATTR(base, mask, value) (DMA_WR_TCD11_ATTR(base, (DMA_RD_TCD11_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_ATTR(base, value) (DMA_WR_TCD11_ATTR(base, DMA_RD_TCD11_ATTR(base) |  (value)))
#define DMA_CLR_TCD11_ATTR(base, value) (DMA_WR_TCD11_ATTR(base, DMA_RD_TCD11_ATTR(base) & ~(value)))
#define DMA_TOG_TCD11_ATTR(base, value) (DMA_WR_TCD11_ATTR(base, DMA_RD_TCD11_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD11_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_ATTR_DSIZE field. */
#define DMA_RD_TCD11_ATTR_DSIZE(base) ((DMA_TCD11_ATTR_REG(base) & DMA_TCD11_ATTR_DSIZE_MASK) >> DMA_TCD11_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD11_ATTR_DSIZE(base) (DMA_RD_TCD11_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD11_ATTR_DSIZE(base, value) (DMA_RMW_TCD11_ATTR(base, DMA_TCD11_ATTR_DSIZE_MASK, DMA_TCD11_ATTR_DSIZE(value)))
#define DMA_BWR_TCD11_ATTR_DSIZE(base, value) (DMA_WR_TCD11_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_ATTR_DMOD field. */
#define DMA_RD_TCD11_ATTR_DMOD(base) ((DMA_TCD11_ATTR_REG(base) & DMA_TCD11_ATTR_DMOD_MASK) >> DMA_TCD11_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD11_ATTR_DMOD(base) (DMA_RD_TCD11_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD11_ATTR_DMOD(base, value) (DMA_RMW_TCD11_ATTR(base, DMA_TCD11_ATTR_DMOD_MASK, DMA_TCD11_ATTR_DMOD(value)))
#define DMA_BWR_TCD11_ATTR_DMOD(base, value) (DMA_WR_TCD11_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_ATTR_SSIZE field. */
#define DMA_RD_TCD11_ATTR_SSIZE(base) ((DMA_TCD11_ATTR_REG(base) & DMA_TCD11_ATTR_SSIZE_MASK) >> DMA_TCD11_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD11_ATTR_SSIZE(base) (DMA_RD_TCD11_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD11_ATTR_SSIZE(base, value) (DMA_RMW_TCD11_ATTR(base, DMA_TCD11_ATTR_SSIZE_MASK, DMA_TCD11_ATTR_SSIZE(value)))
#define DMA_BWR_TCD11_ATTR_SSIZE(base, value) (DMA_WR_TCD11_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_ATTR_SMOD field. */
#define DMA_RD_TCD11_ATTR_SMOD(base) ((DMA_TCD11_ATTR_REG(base) & DMA_TCD11_ATTR_SMOD_MASK) >> DMA_TCD11_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD11_ATTR_SMOD(base) (DMA_RD_TCD11_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD11_ATTR_SMOD(base, value) (DMA_RMW_TCD11_ATTR(base, DMA_TCD11_ATTR_SMOD_MASK, DMA_TCD11_ATTR_SMOD(value)))
#define DMA_BWR_TCD11_ATTR_SMOD(base, value) (DMA_WR_TCD11_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD11_NBYTES_MLOFFYES(base) (DMA_TCD11_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD11_NBYTES_MLOFFYES(base, value) (DMA_TCD11_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD11_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD11_NBYTES_MLOFFYES(base, (DMA_RD_TCD11_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD11_NBYTES_MLOFFYES(base, DMA_RD_TCD11_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD11_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD11_NBYTES_MLOFFYES(base, DMA_RD_TCD11_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD11_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD11_NBYTES_MLOFFYES(base, DMA_RD_TCD11_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD11_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD11_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD11_NBYTES_MLOFFYES_REG(base) & DMA_TCD11_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD11_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD11_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD11_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD11_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD11_NBYTES_MLOFFYES(base, DMA_TCD11_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD11_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD11_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD11_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD11_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD11_NBYTES_MLOFFYES_REG(base) & DMA_TCD11_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD11_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD11_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD11_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD11_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD11_NBYTES_MLOFFYES(base, DMA_TCD11_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD11_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD11_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD11_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD11_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD11_NBYTES_MLOFFYES_REG(base) & DMA_TCD11_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD11_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD11_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFYES_REG(base), DMA_TCD11_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD11_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD11_NBYTES_MLOFFYES(base, DMA_TCD11_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD11_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD11_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFYES_REG(base), DMA_TCD11_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD11_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD11_NBYTES_MLOFFYES_REG(base) & DMA_TCD11_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD11_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD11_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFYES_REG(base), DMA_TCD11_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD11_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD11_NBYTES_MLOFFYES(base, DMA_TCD11_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD11_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD11_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFYES_REG(base), DMA_TCD11_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD11_NBYTES_MLNO(base) (DMA_TCD11_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD11_NBYTES_MLNO(base, value) (DMA_TCD11_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD11_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD11_NBYTES_MLNO(base, (DMA_RD_TCD11_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_NBYTES_MLNO(base, value) (DMA_WR_TCD11_NBYTES_MLNO(base, DMA_RD_TCD11_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD11_NBYTES_MLNO(base, value) (DMA_WR_TCD11_NBYTES_MLNO(base, DMA_RD_TCD11_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD11_NBYTES_MLNO(base, value) (DMA_WR_TCD11_NBYTES_MLNO(base, DMA_RD_TCD11_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD11_NBYTES_MLOFFNO(base) (DMA_TCD11_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD11_NBYTES_MLOFFNO(base, value) (DMA_TCD11_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD11_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD11_NBYTES_MLOFFNO(base, (DMA_RD_TCD11_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD11_NBYTES_MLOFFNO(base, DMA_RD_TCD11_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD11_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD11_NBYTES_MLOFFNO(base, DMA_RD_TCD11_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD11_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD11_NBYTES_MLOFFNO(base, DMA_RD_TCD11_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD11_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD11_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD11_NBYTES_MLOFFNO_REG(base) & DMA_TCD11_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD11_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD11_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD11_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD11_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD11_NBYTES_MLOFFNO(base, DMA_TCD11_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD11_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD11_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD11_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD11_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD11_NBYTES_MLOFFNO_REG(base) & DMA_TCD11_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD11_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD11_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFNO_REG(base), DMA_TCD11_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD11_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD11_NBYTES_MLOFFNO(base, DMA_TCD11_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD11_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD11_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFNO_REG(base), DMA_TCD11_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD11_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD11_NBYTES_MLOFFNO_REG(base) & DMA_TCD11_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD11_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD11_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFNO_REG(base), DMA_TCD11_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD11_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD11_NBYTES_MLOFFNO(base, DMA_TCD11_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD11_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD11_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD11_NBYTES_MLOFFNO_REG(base), DMA_TCD11_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_SLAST register
 */
/*@{*/
#define DMA_RD_TCD11_SLAST(base) (DMA_TCD11_SLAST_REG(base))
#define DMA_WR_TCD11_SLAST(base, value) (DMA_TCD11_SLAST_REG(base) = (value))
#define DMA_RMW_TCD11_SLAST(base, mask, value) (DMA_WR_TCD11_SLAST(base, (DMA_RD_TCD11_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_SLAST(base, value) (DMA_WR_TCD11_SLAST(base, DMA_RD_TCD11_SLAST(base) |  (value)))
#define DMA_CLR_TCD11_SLAST(base, value) (DMA_WR_TCD11_SLAST(base, DMA_RD_TCD11_SLAST(base) & ~(value)))
#define DMA_TOG_TCD11_SLAST(base, value) (DMA_WR_TCD11_SLAST(base, DMA_RD_TCD11_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_DADDR register
 */
/*@{*/
#define DMA_RD_TCD11_DADDR(base) (DMA_TCD11_DADDR_REG(base))
#define DMA_WR_TCD11_DADDR(base, value) (DMA_TCD11_DADDR_REG(base) = (value))
#define DMA_RMW_TCD11_DADDR(base, mask, value) (DMA_WR_TCD11_DADDR(base, (DMA_RD_TCD11_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_DADDR(base, value) (DMA_WR_TCD11_DADDR(base, DMA_RD_TCD11_DADDR(base) |  (value)))
#define DMA_CLR_TCD11_DADDR(base, value) (DMA_WR_TCD11_DADDR(base, DMA_RD_TCD11_DADDR(base) & ~(value)))
#define DMA_TOG_TCD11_DADDR(base, value) (DMA_WR_TCD11_DADDR(base, DMA_RD_TCD11_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_DOFF register
 */
/*@{*/
#define DMA_RD_TCD11_DOFF(base)  (DMA_TCD11_DOFF_REG(base))
#define DMA_WR_TCD11_DOFF(base, value) (DMA_TCD11_DOFF_REG(base) = (value))
#define DMA_RMW_TCD11_DOFF(base, mask, value) (DMA_WR_TCD11_DOFF(base, (DMA_RD_TCD11_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_DOFF(base, value) (DMA_WR_TCD11_DOFF(base, DMA_RD_TCD11_DOFF(base) |  (value)))
#define DMA_CLR_TCD11_DOFF(base, value) (DMA_WR_TCD11_DOFF(base, DMA_RD_TCD11_DOFF(base) & ~(value)))
#define DMA_TOG_TCD11_DOFF(base, value) (DMA_WR_TCD11_DOFF(base, DMA_RD_TCD11_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD11_CITER_ELINKNO(base) (DMA_TCD11_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD11_CITER_ELINKNO(base, value) (DMA_TCD11_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD11_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD11_CITER_ELINKNO(base, (DMA_RD_TCD11_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_CITER_ELINKNO(base, value) (DMA_WR_TCD11_CITER_ELINKNO(base, DMA_RD_TCD11_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD11_CITER_ELINKNO(base, value) (DMA_WR_TCD11_CITER_ELINKNO(base, DMA_RD_TCD11_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD11_CITER_ELINKNO(base, value) (DMA_WR_TCD11_CITER_ELINKNO(base, DMA_RD_TCD11_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD11_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD11_CITER_ELINKNO_CITER(base) ((DMA_TCD11_CITER_ELINKNO_REG(base) & DMA_TCD11_CITER_ELINKNO_CITER_MASK) >> DMA_TCD11_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD11_CITER_ELINKNO_CITER(base) (DMA_RD_TCD11_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD11_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD11_CITER_ELINKNO(base, DMA_TCD11_CITER_ELINKNO_CITER_MASK, DMA_TCD11_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD11_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD11_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD11_CITER_ELINKNO_ELINK(base) ((DMA_TCD11_CITER_ELINKNO_REG(base) & DMA_TCD11_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD11_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD11_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD11_CITER_ELINKNO_REG(base), DMA_TCD11_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD11_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD11_CITER_ELINKNO(base, DMA_TCD11_CITER_ELINKNO_ELINK_MASK, DMA_TCD11_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD11_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CITER_ELINKNO_REG(base), DMA_TCD11_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD11_CITER_ELINKYES(base) (DMA_TCD11_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD11_CITER_ELINKYES(base, value) (DMA_TCD11_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD11_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD11_CITER_ELINKYES(base, (DMA_RD_TCD11_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_CITER_ELINKYES(base, value) (DMA_WR_TCD11_CITER_ELINKYES(base, DMA_RD_TCD11_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD11_CITER_ELINKYES(base, value) (DMA_WR_TCD11_CITER_ELINKYES(base, DMA_RD_TCD11_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD11_CITER_ELINKYES(base, value) (DMA_WR_TCD11_CITER_ELINKYES(base, DMA_RD_TCD11_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD11_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD11_CITER_ELINKYES_CITER(base) ((DMA_TCD11_CITER_ELINKYES_REG(base) & DMA_TCD11_CITER_ELINKYES_CITER_MASK) >> DMA_TCD11_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD11_CITER_ELINKYES_CITER(base) (DMA_RD_TCD11_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD11_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD11_CITER_ELINKYES(base, DMA_TCD11_CITER_ELINKYES_CITER_MASK, DMA_TCD11_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD11_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD11_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD11_CITER_ELINKYES_LINKCH(base) ((DMA_TCD11_CITER_ELINKYES_REG(base) & DMA_TCD11_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD11_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD11_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD11_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD11_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD11_CITER_ELINKYES(base, DMA_TCD11_CITER_ELINKYES_LINKCH_MASK, DMA_TCD11_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD11_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD11_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD11_CITER_ELINKYES_ELINK(base) ((DMA_TCD11_CITER_ELINKYES_REG(base) & DMA_TCD11_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD11_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD11_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD11_CITER_ELINKYES_REG(base), DMA_TCD11_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD11_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD11_CITER_ELINKYES(base, DMA_TCD11_CITER_ELINKYES_ELINK_MASK, DMA_TCD11_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD11_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CITER_ELINKYES_REG(base), DMA_TCD11_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD11_DLASTSGA(base) (DMA_TCD11_DLASTSGA_REG(base))
#define DMA_WR_TCD11_DLASTSGA(base, value) (DMA_TCD11_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD11_DLASTSGA(base, mask, value) (DMA_WR_TCD11_DLASTSGA(base, (DMA_RD_TCD11_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_DLASTSGA(base, value) (DMA_WR_TCD11_DLASTSGA(base, DMA_RD_TCD11_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD11_DLASTSGA(base, value) (DMA_WR_TCD11_DLASTSGA(base, DMA_RD_TCD11_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD11_DLASTSGA(base, value) (DMA_WR_TCD11_DLASTSGA(base, DMA_RD_TCD11_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_CSR register
 */
/*@{*/
#define DMA_RD_TCD11_CSR(base)   (DMA_TCD11_CSR_REG(base))
#define DMA_WR_TCD11_CSR(base, value) (DMA_TCD11_CSR_REG(base) = (value))
#define DMA_RMW_TCD11_CSR(base, mask, value) (DMA_WR_TCD11_CSR(base, (DMA_RD_TCD11_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_CSR(base, value) (DMA_WR_TCD11_CSR(base, DMA_RD_TCD11_CSR(base) |  (value)))
#define DMA_CLR_TCD11_CSR(base, value) (DMA_WR_TCD11_CSR(base, DMA_RD_TCD11_CSR(base) & ~(value)))
#define DMA_TOG_TCD11_CSR(base, value) (DMA_WR_TCD11_CSR(base, DMA_RD_TCD11_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_CSR bitfields
 */

/*!
 * @name Register DMA_TCD11_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_START field. */
#define DMA_RD_TCD11_CSR_START(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_START_MASK) >> DMA_TCD11_CSR_START_SHIFT)
#define DMA_BRD_TCD11_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD11_CSR_START(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_START_MASK, DMA_TCD11_CSR_START(value)))
#define DMA_BWR_TCD11_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_INTMAJOR field. */
#define DMA_RD_TCD11_CSR_INTMAJOR(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_INTMAJOR_MASK) >> DMA_TCD11_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD11_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD11_CSR_INTMAJOR(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_INTMAJOR_MASK, DMA_TCD11_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD11_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_INTHALF field. */
#define DMA_RD_TCD11_CSR_INTHALF(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_INTHALF_MASK) >> DMA_TCD11_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD11_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD11_CSR_INTHALF(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_INTHALF_MASK, DMA_TCD11_CSR_INTHALF(value)))
#define DMA_BWR_TCD11_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_DREQ field. */
#define DMA_RD_TCD11_CSR_DREQ(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_DREQ_MASK) >> DMA_TCD11_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD11_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD11_CSR_DREQ(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_DREQ_MASK, DMA_TCD11_CSR_DREQ(value)))
#define DMA_BWR_TCD11_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_ESG field. */
#define DMA_RD_TCD11_CSR_ESG(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_ESG_MASK) >> DMA_TCD11_CSR_ESG_SHIFT)
#define DMA_BRD_TCD11_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD11_CSR_ESG(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_ESG_MASK, DMA_TCD11_CSR_ESG(value)))
#define DMA_BWR_TCD11_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_MAJORELINK field. */
#define DMA_RD_TCD11_CSR_MAJORELINK(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_MAJORELINK_MASK) >> DMA_TCD11_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD11_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD11_CSR_MAJORELINK(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_MAJORELINK_MASK, DMA_TCD11_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD11_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_ACTIVE field. */
#define DMA_RD_TCD11_CSR_ACTIVE(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_ACTIVE_MASK) >> DMA_TCD11_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD11_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD11_CSR_ACTIVE(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_ACTIVE_MASK, DMA_TCD11_CSR_ACTIVE(value)))
#define DMA_BWR_TCD11_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_DONE field. */
#define DMA_RD_TCD11_CSR_DONE(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_DONE_MASK) >> DMA_TCD11_CSR_DONE_SHIFT)
#define DMA_BRD_TCD11_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD11_CSR_DONE(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_DONE_MASK, DMA_TCD11_CSR_DONE(value)))
#define DMA_BWR_TCD11_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD11_CSR_REG(base), DMA_TCD11_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD11_CSR_MAJORLINKCH(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_MAJORLINKCH_MASK) >> DMA_TCD11_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD11_CSR_MAJORLINKCH(base) (DMA_RD_TCD11_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD11_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_MAJORLINKCH_MASK, DMA_TCD11_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD11_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD11_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_CSR_BWC field. */
#define DMA_RD_TCD11_CSR_BWC(base) ((DMA_TCD11_CSR_REG(base) & DMA_TCD11_CSR_BWC_MASK) >> DMA_TCD11_CSR_BWC_SHIFT)
#define DMA_BRD_TCD11_CSR_BWC(base) (DMA_RD_TCD11_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD11_CSR_BWC(base, value) (DMA_RMW_TCD11_CSR(base, DMA_TCD11_CSR_BWC_MASK, DMA_TCD11_CSR_BWC(value)))
#define DMA_BWR_TCD11_CSR_BWC(base, value) (DMA_WR_TCD11_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD11_BITER_ELINKYES(base) (DMA_TCD11_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD11_BITER_ELINKYES(base, value) (DMA_TCD11_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD11_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD11_BITER_ELINKYES(base, (DMA_RD_TCD11_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_BITER_ELINKYES(base, value) (DMA_WR_TCD11_BITER_ELINKYES(base, DMA_RD_TCD11_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD11_BITER_ELINKYES(base, value) (DMA_WR_TCD11_BITER_ELINKYES(base, DMA_RD_TCD11_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD11_BITER_ELINKYES(base, value) (DMA_WR_TCD11_BITER_ELINKYES(base, DMA_RD_TCD11_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD11_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD11_BITER_ELINKYES_BITER(base) ((DMA_TCD11_BITER_ELINKYES_REG(base) & DMA_TCD11_BITER_ELINKYES_BITER_MASK) >> DMA_TCD11_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD11_BITER_ELINKYES_BITER(base) (DMA_RD_TCD11_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD11_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD11_BITER_ELINKYES(base, DMA_TCD11_BITER_ELINKYES_BITER_MASK, DMA_TCD11_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD11_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD11_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD11_BITER_ELINKYES_LINKCH(base) ((DMA_TCD11_BITER_ELINKYES_REG(base) & DMA_TCD11_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD11_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD11_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD11_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD11_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD11_BITER_ELINKYES(base, DMA_TCD11_BITER_ELINKYES_LINKCH_MASK, DMA_TCD11_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD11_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD11_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD11_BITER_ELINKYES_ELINK(base) ((DMA_TCD11_BITER_ELINKYES_REG(base) & DMA_TCD11_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD11_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD11_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD11_BITER_ELINKYES_REG(base), DMA_TCD11_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD11_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD11_BITER_ELINKYES(base, DMA_TCD11_BITER_ELINKYES_ELINK_MASK, DMA_TCD11_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD11_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD11_BITER_ELINKYES_REG(base), DMA_TCD11_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD11_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD11_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD11_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD11_BITER_ELINKNO(base) (DMA_TCD11_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD11_BITER_ELINKNO(base, value) (DMA_TCD11_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD11_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD11_BITER_ELINKNO(base, (DMA_RD_TCD11_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD11_BITER_ELINKNO(base, value) (DMA_WR_TCD11_BITER_ELINKNO(base, DMA_RD_TCD11_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD11_BITER_ELINKNO(base, value) (DMA_WR_TCD11_BITER_ELINKNO(base, DMA_RD_TCD11_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD11_BITER_ELINKNO(base, value) (DMA_WR_TCD11_BITER_ELINKNO(base, DMA_RD_TCD11_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD11_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD11_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD11_BITER_ELINKNO_BITER(base) ((DMA_TCD11_BITER_ELINKNO_REG(base) & DMA_TCD11_BITER_ELINKNO_BITER_MASK) >> DMA_TCD11_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD11_BITER_ELINKNO_BITER(base) (DMA_RD_TCD11_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD11_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD11_BITER_ELINKNO(base, DMA_TCD11_BITER_ELINKNO_BITER_MASK, DMA_TCD11_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD11_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD11_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD11_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD11_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD11_BITER_ELINKNO_ELINK(base) ((DMA_TCD11_BITER_ELINKNO_REG(base) & DMA_TCD11_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD11_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD11_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD11_BITER_ELINKNO_REG(base), DMA_TCD11_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD11_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD11_BITER_ELINKNO(base, DMA_TCD11_BITER_ELINKNO_ELINK_MASK, DMA_TCD11_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD11_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD11_BITER_ELINKNO_REG(base), DMA_TCD11_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_SADDR register
 */
/*@{*/
#define DMA_RD_TCD12_SADDR(base) (DMA_TCD12_SADDR_REG(base))
#define DMA_WR_TCD12_SADDR(base, value) (DMA_TCD12_SADDR_REG(base) = (value))
#define DMA_RMW_TCD12_SADDR(base, mask, value) (DMA_WR_TCD12_SADDR(base, (DMA_RD_TCD12_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_SADDR(base, value) (DMA_WR_TCD12_SADDR(base, DMA_RD_TCD12_SADDR(base) |  (value)))
#define DMA_CLR_TCD12_SADDR(base, value) (DMA_WR_TCD12_SADDR(base, DMA_RD_TCD12_SADDR(base) & ~(value)))
#define DMA_TOG_TCD12_SADDR(base, value) (DMA_WR_TCD12_SADDR(base, DMA_RD_TCD12_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_SOFF register
 */
/*@{*/
#define DMA_RD_TCD12_SOFF(base)  (DMA_TCD12_SOFF_REG(base))
#define DMA_WR_TCD12_SOFF(base, value) (DMA_TCD12_SOFF_REG(base) = (value))
#define DMA_RMW_TCD12_SOFF(base, mask, value) (DMA_WR_TCD12_SOFF(base, (DMA_RD_TCD12_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_SOFF(base, value) (DMA_WR_TCD12_SOFF(base, DMA_RD_TCD12_SOFF(base) |  (value)))
#define DMA_CLR_TCD12_SOFF(base, value) (DMA_WR_TCD12_SOFF(base, DMA_RD_TCD12_SOFF(base) & ~(value)))
#define DMA_TOG_TCD12_SOFF(base, value) (DMA_WR_TCD12_SOFF(base, DMA_RD_TCD12_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_ATTR register
 */
/*@{*/
#define DMA_RD_TCD12_ATTR(base)  (DMA_TCD12_ATTR_REG(base))
#define DMA_WR_TCD12_ATTR(base, value) (DMA_TCD12_ATTR_REG(base) = (value))
#define DMA_RMW_TCD12_ATTR(base, mask, value) (DMA_WR_TCD12_ATTR(base, (DMA_RD_TCD12_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_ATTR(base, value) (DMA_WR_TCD12_ATTR(base, DMA_RD_TCD12_ATTR(base) |  (value)))
#define DMA_CLR_TCD12_ATTR(base, value) (DMA_WR_TCD12_ATTR(base, DMA_RD_TCD12_ATTR(base) & ~(value)))
#define DMA_TOG_TCD12_ATTR(base, value) (DMA_WR_TCD12_ATTR(base, DMA_RD_TCD12_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD12_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_ATTR_DSIZE field. */
#define DMA_RD_TCD12_ATTR_DSIZE(base) ((DMA_TCD12_ATTR_REG(base) & DMA_TCD12_ATTR_DSIZE_MASK) >> DMA_TCD12_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD12_ATTR_DSIZE(base) (DMA_RD_TCD12_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD12_ATTR_DSIZE(base, value) (DMA_RMW_TCD12_ATTR(base, DMA_TCD12_ATTR_DSIZE_MASK, DMA_TCD12_ATTR_DSIZE(value)))
#define DMA_BWR_TCD12_ATTR_DSIZE(base, value) (DMA_WR_TCD12_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_ATTR_DMOD field. */
#define DMA_RD_TCD12_ATTR_DMOD(base) ((DMA_TCD12_ATTR_REG(base) & DMA_TCD12_ATTR_DMOD_MASK) >> DMA_TCD12_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD12_ATTR_DMOD(base) (DMA_RD_TCD12_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD12_ATTR_DMOD(base, value) (DMA_RMW_TCD12_ATTR(base, DMA_TCD12_ATTR_DMOD_MASK, DMA_TCD12_ATTR_DMOD(value)))
#define DMA_BWR_TCD12_ATTR_DMOD(base, value) (DMA_WR_TCD12_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_ATTR_SSIZE field. */
#define DMA_RD_TCD12_ATTR_SSIZE(base) ((DMA_TCD12_ATTR_REG(base) & DMA_TCD12_ATTR_SSIZE_MASK) >> DMA_TCD12_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD12_ATTR_SSIZE(base) (DMA_RD_TCD12_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD12_ATTR_SSIZE(base, value) (DMA_RMW_TCD12_ATTR(base, DMA_TCD12_ATTR_SSIZE_MASK, DMA_TCD12_ATTR_SSIZE(value)))
#define DMA_BWR_TCD12_ATTR_SSIZE(base, value) (DMA_WR_TCD12_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_ATTR_SMOD field. */
#define DMA_RD_TCD12_ATTR_SMOD(base) ((DMA_TCD12_ATTR_REG(base) & DMA_TCD12_ATTR_SMOD_MASK) >> DMA_TCD12_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD12_ATTR_SMOD(base) (DMA_RD_TCD12_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD12_ATTR_SMOD(base, value) (DMA_RMW_TCD12_ATTR(base, DMA_TCD12_ATTR_SMOD_MASK, DMA_TCD12_ATTR_SMOD(value)))
#define DMA_BWR_TCD12_ATTR_SMOD(base, value) (DMA_WR_TCD12_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD12_NBYTES_MLOFFYES(base) (DMA_TCD12_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD12_NBYTES_MLOFFYES(base, value) (DMA_TCD12_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD12_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD12_NBYTES_MLOFFYES(base, (DMA_RD_TCD12_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD12_NBYTES_MLOFFYES(base, DMA_RD_TCD12_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD12_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD12_NBYTES_MLOFFYES(base, DMA_RD_TCD12_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD12_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD12_NBYTES_MLOFFYES(base, DMA_RD_TCD12_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD12_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD12_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD12_NBYTES_MLOFFYES_REG(base) & DMA_TCD12_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD12_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD12_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD12_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD12_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD12_NBYTES_MLOFFYES(base, DMA_TCD12_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD12_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD12_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD12_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD12_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD12_NBYTES_MLOFFYES_REG(base) & DMA_TCD12_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD12_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD12_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD12_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD12_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD12_NBYTES_MLOFFYES(base, DMA_TCD12_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD12_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD12_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD12_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD12_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD12_NBYTES_MLOFFYES_REG(base) & DMA_TCD12_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD12_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD12_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFYES_REG(base), DMA_TCD12_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD12_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD12_NBYTES_MLOFFYES(base, DMA_TCD12_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD12_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD12_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFYES_REG(base), DMA_TCD12_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD12_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD12_NBYTES_MLOFFYES_REG(base) & DMA_TCD12_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD12_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD12_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFYES_REG(base), DMA_TCD12_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD12_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD12_NBYTES_MLOFFYES(base, DMA_TCD12_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD12_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD12_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFYES_REG(base), DMA_TCD12_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD12_NBYTES_MLNO(base) (DMA_TCD12_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD12_NBYTES_MLNO(base, value) (DMA_TCD12_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD12_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD12_NBYTES_MLNO(base, (DMA_RD_TCD12_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_NBYTES_MLNO(base, value) (DMA_WR_TCD12_NBYTES_MLNO(base, DMA_RD_TCD12_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD12_NBYTES_MLNO(base, value) (DMA_WR_TCD12_NBYTES_MLNO(base, DMA_RD_TCD12_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD12_NBYTES_MLNO(base, value) (DMA_WR_TCD12_NBYTES_MLNO(base, DMA_RD_TCD12_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD12_NBYTES_MLOFFNO(base) (DMA_TCD12_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD12_NBYTES_MLOFFNO(base, value) (DMA_TCD12_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD12_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD12_NBYTES_MLOFFNO(base, (DMA_RD_TCD12_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD12_NBYTES_MLOFFNO(base, DMA_RD_TCD12_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD12_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD12_NBYTES_MLOFFNO(base, DMA_RD_TCD12_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD12_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD12_NBYTES_MLOFFNO(base, DMA_RD_TCD12_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD12_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD12_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD12_NBYTES_MLOFFNO_REG(base) & DMA_TCD12_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD12_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD12_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD12_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD12_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD12_NBYTES_MLOFFNO(base, DMA_TCD12_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD12_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD12_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD12_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD12_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD12_NBYTES_MLOFFNO_REG(base) & DMA_TCD12_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD12_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD12_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFNO_REG(base), DMA_TCD12_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD12_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD12_NBYTES_MLOFFNO(base, DMA_TCD12_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD12_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD12_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFNO_REG(base), DMA_TCD12_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD12_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD12_NBYTES_MLOFFNO_REG(base) & DMA_TCD12_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD12_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD12_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFNO_REG(base), DMA_TCD12_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD12_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD12_NBYTES_MLOFFNO(base, DMA_TCD12_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD12_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD12_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD12_NBYTES_MLOFFNO_REG(base), DMA_TCD12_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_SLAST register
 */
/*@{*/
#define DMA_RD_TCD12_SLAST(base) (DMA_TCD12_SLAST_REG(base))
#define DMA_WR_TCD12_SLAST(base, value) (DMA_TCD12_SLAST_REG(base) = (value))
#define DMA_RMW_TCD12_SLAST(base, mask, value) (DMA_WR_TCD12_SLAST(base, (DMA_RD_TCD12_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_SLAST(base, value) (DMA_WR_TCD12_SLAST(base, DMA_RD_TCD12_SLAST(base) |  (value)))
#define DMA_CLR_TCD12_SLAST(base, value) (DMA_WR_TCD12_SLAST(base, DMA_RD_TCD12_SLAST(base) & ~(value)))
#define DMA_TOG_TCD12_SLAST(base, value) (DMA_WR_TCD12_SLAST(base, DMA_RD_TCD12_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_DADDR register
 */
/*@{*/
#define DMA_RD_TCD12_DADDR(base) (DMA_TCD12_DADDR_REG(base))
#define DMA_WR_TCD12_DADDR(base, value) (DMA_TCD12_DADDR_REG(base) = (value))
#define DMA_RMW_TCD12_DADDR(base, mask, value) (DMA_WR_TCD12_DADDR(base, (DMA_RD_TCD12_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_DADDR(base, value) (DMA_WR_TCD12_DADDR(base, DMA_RD_TCD12_DADDR(base) |  (value)))
#define DMA_CLR_TCD12_DADDR(base, value) (DMA_WR_TCD12_DADDR(base, DMA_RD_TCD12_DADDR(base) & ~(value)))
#define DMA_TOG_TCD12_DADDR(base, value) (DMA_WR_TCD12_DADDR(base, DMA_RD_TCD12_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_DOFF register
 */
/*@{*/
#define DMA_RD_TCD12_DOFF(base)  (DMA_TCD12_DOFF_REG(base))
#define DMA_WR_TCD12_DOFF(base, value) (DMA_TCD12_DOFF_REG(base) = (value))
#define DMA_RMW_TCD12_DOFF(base, mask, value) (DMA_WR_TCD12_DOFF(base, (DMA_RD_TCD12_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_DOFF(base, value) (DMA_WR_TCD12_DOFF(base, DMA_RD_TCD12_DOFF(base) |  (value)))
#define DMA_CLR_TCD12_DOFF(base, value) (DMA_WR_TCD12_DOFF(base, DMA_RD_TCD12_DOFF(base) & ~(value)))
#define DMA_TOG_TCD12_DOFF(base, value) (DMA_WR_TCD12_DOFF(base, DMA_RD_TCD12_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD12_CITER_ELINKYES(base) (DMA_TCD12_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD12_CITER_ELINKYES(base, value) (DMA_TCD12_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD12_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD12_CITER_ELINKYES(base, (DMA_RD_TCD12_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_CITER_ELINKYES(base, value) (DMA_WR_TCD12_CITER_ELINKYES(base, DMA_RD_TCD12_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD12_CITER_ELINKYES(base, value) (DMA_WR_TCD12_CITER_ELINKYES(base, DMA_RD_TCD12_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD12_CITER_ELINKYES(base, value) (DMA_WR_TCD12_CITER_ELINKYES(base, DMA_RD_TCD12_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD12_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD12_CITER_ELINKYES_CITER(base) ((DMA_TCD12_CITER_ELINKYES_REG(base) & DMA_TCD12_CITER_ELINKYES_CITER_MASK) >> DMA_TCD12_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD12_CITER_ELINKYES_CITER(base) (DMA_RD_TCD12_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD12_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD12_CITER_ELINKYES(base, DMA_TCD12_CITER_ELINKYES_CITER_MASK, DMA_TCD12_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD12_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD12_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD12_CITER_ELINKYES_LINKCH(base) ((DMA_TCD12_CITER_ELINKYES_REG(base) & DMA_TCD12_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD12_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD12_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD12_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD12_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD12_CITER_ELINKYES(base, DMA_TCD12_CITER_ELINKYES_LINKCH_MASK, DMA_TCD12_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD12_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD12_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD12_CITER_ELINKYES_ELINK(base) ((DMA_TCD12_CITER_ELINKYES_REG(base) & DMA_TCD12_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD12_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD12_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD12_CITER_ELINKYES_REG(base), DMA_TCD12_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD12_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD12_CITER_ELINKYES(base, DMA_TCD12_CITER_ELINKYES_ELINK_MASK, DMA_TCD12_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD12_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CITER_ELINKYES_REG(base), DMA_TCD12_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD12_CITER_ELINKNO(base) (DMA_TCD12_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD12_CITER_ELINKNO(base, value) (DMA_TCD12_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD12_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD12_CITER_ELINKNO(base, (DMA_RD_TCD12_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_CITER_ELINKNO(base, value) (DMA_WR_TCD12_CITER_ELINKNO(base, DMA_RD_TCD12_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD12_CITER_ELINKNO(base, value) (DMA_WR_TCD12_CITER_ELINKNO(base, DMA_RD_TCD12_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD12_CITER_ELINKNO(base, value) (DMA_WR_TCD12_CITER_ELINKNO(base, DMA_RD_TCD12_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD12_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD12_CITER_ELINKNO_CITER(base) ((DMA_TCD12_CITER_ELINKNO_REG(base) & DMA_TCD12_CITER_ELINKNO_CITER_MASK) >> DMA_TCD12_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD12_CITER_ELINKNO_CITER(base) (DMA_RD_TCD12_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD12_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD12_CITER_ELINKNO(base, DMA_TCD12_CITER_ELINKNO_CITER_MASK, DMA_TCD12_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD12_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD12_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD12_CITER_ELINKNO_ELINK(base) ((DMA_TCD12_CITER_ELINKNO_REG(base) & DMA_TCD12_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD12_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD12_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD12_CITER_ELINKNO_REG(base), DMA_TCD12_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD12_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD12_CITER_ELINKNO(base, DMA_TCD12_CITER_ELINKNO_ELINK_MASK, DMA_TCD12_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD12_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CITER_ELINKNO_REG(base), DMA_TCD12_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD12_DLASTSGA(base) (DMA_TCD12_DLASTSGA_REG(base))
#define DMA_WR_TCD12_DLASTSGA(base, value) (DMA_TCD12_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD12_DLASTSGA(base, mask, value) (DMA_WR_TCD12_DLASTSGA(base, (DMA_RD_TCD12_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_DLASTSGA(base, value) (DMA_WR_TCD12_DLASTSGA(base, DMA_RD_TCD12_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD12_DLASTSGA(base, value) (DMA_WR_TCD12_DLASTSGA(base, DMA_RD_TCD12_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD12_DLASTSGA(base, value) (DMA_WR_TCD12_DLASTSGA(base, DMA_RD_TCD12_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_CSR register
 */
/*@{*/
#define DMA_RD_TCD12_CSR(base)   (DMA_TCD12_CSR_REG(base))
#define DMA_WR_TCD12_CSR(base, value) (DMA_TCD12_CSR_REG(base) = (value))
#define DMA_RMW_TCD12_CSR(base, mask, value) (DMA_WR_TCD12_CSR(base, (DMA_RD_TCD12_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_CSR(base, value) (DMA_WR_TCD12_CSR(base, DMA_RD_TCD12_CSR(base) |  (value)))
#define DMA_CLR_TCD12_CSR(base, value) (DMA_WR_TCD12_CSR(base, DMA_RD_TCD12_CSR(base) & ~(value)))
#define DMA_TOG_TCD12_CSR(base, value) (DMA_WR_TCD12_CSR(base, DMA_RD_TCD12_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_CSR bitfields
 */

/*!
 * @name Register DMA_TCD12_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_START field. */
#define DMA_RD_TCD12_CSR_START(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_START_MASK) >> DMA_TCD12_CSR_START_SHIFT)
#define DMA_BRD_TCD12_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD12_CSR_START(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_START_MASK, DMA_TCD12_CSR_START(value)))
#define DMA_BWR_TCD12_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_INTMAJOR field. */
#define DMA_RD_TCD12_CSR_INTMAJOR(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_INTMAJOR_MASK) >> DMA_TCD12_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD12_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD12_CSR_INTMAJOR(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_INTMAJOR_MASK, DMA_TCD12_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD12_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_INTHALF field. */
#define DMA_RD_TCD12_CSR_INTHALF(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_INTHALF_MASK) >> DMA_TCD12_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD12_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD12_CSR_INTHALF(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_INTHALF_MASK, DMA_TCD12_CSR_INTHALF(value)))
#define DMA_BWR_TCD12_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_DREQ field. */
#define DMA_RD_TCD12_CSR_DREQ(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_DREQ_MASK) >> DMA_TCD12_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD12_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD12_CSR_DREQ(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_DREQ_MASK, DMA_TCD12_CSR_DREQ(value)))
#define DMA_BWR_TCD12_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_ESG field. */
#define DMA_RD_TCD12_CSR_ESG(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_ESG_MASK) >> DMA_TCD12_CSR_ESG_SHIFT)
#define DMA_BRD_TCD12_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD12_CSR_ESG(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_ESG_MASK, DMA_TCD12_CSR_ESG(value)))
#define DMA_BWR_TCD12_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_MAJORELINK field. */
#define DMA_RD_TCD12_CSR_MAJORELINK(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_MAJORELINK_MASK) >> DMA_TCD12_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD12_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD12_CSR_MAJORELINK(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_MAJORELINK_MASK, DMA_TCD12_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD12_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_ACTIVE field. */
#define DMA_RD_TCD12_CSR_ACTIVE(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_ACTIVE_MASK) >> DMA_TCD12_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD12_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD12_CSR_ACTIVE(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_ACTIVE_MASK, DMA_TCD12_CSR_ACTIVE(value)))
#define DMA_BWR_TCD12_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_DONE field. */
#define DMA_RD_TCD12_CSR_DONE(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_DONE_MASK) >> DMA_TCD12_CSR_DONE_SHIFT)
#define DMA_BRD_TCD12_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD12_CSR_DONE(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_DONE_MASK, DMA_TCD12_CSR_DONE(value)))
#define DMA_BWR_TCD12_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD12_CSR_REG(base), DMA_TCD12_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD12_CSR_MAJORLINKCH(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_MAJORLINKCH_MASK) >> DMA_TCD12_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD12_CSR_MAJORLINKCH(base) (DMA_RD_TCD12_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD12_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_MAJORLINKCH_MASK, DMA_TCD12_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD12_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD12_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_CSR_BWC field. */
#define DMA_RD_TCD12_CSR_BWC(base) ((DMA_TCD12_CSR_REG(base) & DMA_TCD12_CSR_BWC_MASK) >> DMA_TCD12_CSR_BWC_SHIFT)
#define DMA_BRD_TCD12_CSR_BWC(base) (DMA_RD_TCD12_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD12_CSR_BWC(base, value) (DMA_RMW_TCD12_CSR(base, DMA_TCD12_CSR_BWC_MASK, DMA_TCD12_CSR_BWC(value)))
#define DMA_BWR_TCD12_CSR_BWC(base, value) (DMA_WR_TCD12_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD12_BITER_ELINKNO(base) (DMA_TCD12_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD12_BITER_ELINKNO(base, value) (DMA_TCD12_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD12_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD12_BITER_ELINKNO(base, (DMA_RD_TCD12_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_BITER_ELINKNO(base, value) (DMA_WR_TCD12_BITER_ELINKNO(base, DMA_RD_TCD12_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD12_BITER_ELINKNO(base, value) (DMA_WR_TCD12_BITER_ELINKNO(base, DMA_RD_TCD12_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD12_BITER_ELINKNO(base, value) (DMA_WR_TCD12_BITER_ELINKNO(base, DMA_RD_TCD12_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD12_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD12_BITER_ELINKNO_BITER(base) ((DMA_TCD12_BITER_ELINKNO_REG(base) & DMA_TCD12_BITER_ELINKNO_BITER_MASK) >> DMA_TCD12_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD12_BITER_ELINKNO_BITER(base) (DMA_RD_TCD12_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD12_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD12_BITER_ELINKNO(base, DMA_TCD12_BITER_ELINKNO_BITER_MASK, DMA_TCD12_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD12_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD12_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD12_BITER_ELINKNO_ELINK(base) ((DMA_TCD12_BITER_ELINKNO_REG(base) & DMA_TCD12_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD12_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD12_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD12_BITER_ELINKNO_REG(base), DMA_TCD12_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD12_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD12_BITER_ELINKNO(base, DMA_TCD12_BITER_ELINKNO_ELINK_MASK, DMA_TCD12_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD12_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD12_BITER_ELINKNO_REG(base), DMA_TCD12_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD12_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD12_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD12_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD12_BITER_ELINKYES(base) (DMA_TCD12_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD12_BITER_ELINKYES(base, value) (DMA_TCD12_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD12_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD12_BITER_ELINKYES(base, (DMA_RD_TCD12_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD12_BITER_ELINKYES(base, value) (DMA_WR_TCD12_BITER_ELINKYES(base, DMA_RD_TCD12_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD12_BITER_ELINKYES(base, value) (DMA_WR_TCD12_BITER_ELINKYES(base, DMA_RD_TCD12_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD12_BITER_ELINKYES(base, value) (DMA_WR_TCD12_BITER_ELINKYES(base, DMA_RD_TCD12_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD12_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD12_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD12_BITER_ELINKYES_BITER(base) ((DMA_TCD12_BITER_ELINKYES_REG(base) & DMA_TCD12_BITER_ELINKYES_BITER_MASK) >> DMA_TCD12_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD12_BITER_ELINKYES_BITER(base) (DMA_RD_TCD12_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD12_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD12_BITER_ELINKYES(base, DMA_TCD12_BITER_ELINKYES_BITER_MASK, DMA_TCD12_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD12_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD12_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD12_BITER_ELINKYES_LINKCH(base) ((DMA_TCD12_BITER_ELINKYES_REG(base) & DMA_TCD12_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD12_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD12_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD12_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD12_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD12_BITER_ELINKYES(base, DMA_TCD12_BITER_ELINKYES_LINKCH_MASK, DMA_TCD12_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD12_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD12_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD12_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD12_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD12_BITER_ELINKYES_ELINK(base) ((DMA_TCD12_BITER_ELINKYES_REG(base) & DMA_TCD12_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD12_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD12_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD12_BITER_ELINKYES_REG(base), DMA_TCD12_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD12_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD12_BITER_ELINKYES(base, DMA_TCD12_BITER_ELINKYES_ELINK_MASK, DMA_TCD12_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD12_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD12_BITER_ELINKYES_REG(base), DMA_TCD12_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_SADDR register
 */
/*@{*/
#define DMA_RD_TCD13_SADDR(base) (DMA_TCD13_SADDR_REG(base))
#define DMA_WR_TCD13_SADDR(base, value) (DMA_TCD13_SADDR_REG(base) = (value))
#define DMA_RMW_TCD13_SADDR(base, mask, value) (DMA_WR_TCD13_SADDR(base, (DMA_RD_TCD13_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_SADDR(base, value) (DMA_WR_TCD13_SADDR(base, DMA_RD_TCD13_SADDR(base) |  (value)))
#define DMA_CLR_TCD13_SADDR(base, value) (DMA_WR_TCD13_SADDR(base, DMA_RD_TCD13_SADDR(base) & ~(value)))
#define DMA_TOG_TCD13_SADDR(base, value) (DMA_WR_TCD13_SADDR(base, DMA_RD_TCD13_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_SOFF register
 */
/*@{*/
#define DMA_RD_TCD13_SOFF(base)  (DMA_TCD13_SOFF_REG(base))
#define DMA_WR_TCD13_SOFF(base, value) (DMA_TCD13_SOFF_REG(base) = (value))
#define DMA_RMW_TCD13_SOFF(base, mask, value) (DMA_WR_TCD13_SOFF(base, (DMA_RD_TCD13_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_SOFF(base, value) (DMA_WR_TCD13_SOFF(base, DMA_RD_TCD13_SOFF(base) |  (value)))
#define DMA_CLR_TCD13_SOFF(base, value) (DMA_WR_TCD13_SOFF(base, DMA_RD_TCD13_SOFF(base) & ~(value)))
#define DMA_TOG_TCD13_SOFF(base, value) (DMA_WR_TCD13_SOFF(base, DMA_RD_TCD13_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_ATTR register
 */
/*@{*/
#define DMA_RD_TCD13_ATTR(base)  (DMA_TCD13_ATTR_REG(base))
#define DMA_WR_TCD13_ATTR(base, value) (DMA_TCD13_ATTR_REG(base) = (value))
#define DMA_RMW_TCD13_ATTR(base, mask, value) (DMA_WR_TCD13_ATTR(base, (DMA_RD_TCD13_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_ATTR(base, value) (DMA_WR_TCD13_ATTR(base, DMA_RD_TCD13_ATTR(base) |  (value)))
#define DMA_CLR_TCD13_ATTR(base, value) (DMA_WR_TCD13_ATTR(base, DMA_RD_TCD13_ATTR(base) & ~(value)))
#define DMA_TOG_TCD13_ATTR(base, value) (DMA_WR_TCD13_ATTR(base, DMA_RD_TCD13_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD13_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_ATTR_DSIZE field. */
#define DMA_RD_TCD13_ATTR_DSIZE(base) ((DMA_TCD13_ATTR_REG(base) & DMA_TCD13_ATTR_DSIZE_MASK) >> DMA_TCD13_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD13_ATTR_DSIZE(base) (DMA_RD_TCD13_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD13_ATTR_DSIZE(base, value) (DMA_RMW_TCD13_ATTR(base, DMA_TCD13_ATTR_DSIZE_MASK, DMA_TCD13_ATTR_DSIZE(value)))
#define DMA_BWR_TCD13_ATTR_DSIZE(base, value) (DMA_WR_TCD13_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_ATTR_DMOD field. */
#define DMA_RD_TCD13_ATTR_DMOD(base) ((DMA_TCD13_ATTR_REG(base) & DMA_TCD13_ATTR_DMOD_MASK) >> DMA_TCD13_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD13_ATTR_DMOD(base) (DMA_RD_TCD13_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD13_ATTR_DMOD(base, value) (DMA_RMW_TCD13_ATTR(base, DMA_TCD13_ATTR_DMOD_MASK, DMA_TCD13_ATTR_DMOD(value)))
#define DMA_BWR_TCD13_ATTR_DMOD(base, value) (DMA_WR_TCD13_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_ATTR_SSIZE field. */
#define DMA_RD_TCD13_ATTR_SSIZE(base) ((DMA_TCD13_ATTR_REG(base) & DMA_TCD13_ATTR_SSIZE_MASK) >> DMA_TCD13_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD13_ATTR_SSIZE(base) (DMA_RD_TCD13_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD13_ATTR_SSIZE(base, value) (DMA_RMW_TCD13_ATTR(base, DMA_TCD13_ATTR_SSIZE_MASK, DMA_TCD13_ATTR_SSIZE(value)))
#define DMA_BWR_TCD13_ATTR_SSIZE(base, value) (DMA_WR_TCD13_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_ATTR_SMOD field. */
#define DMA_RD_TCD13_ATTR_SMOD(base) ((DMA_TCD13_ATTR_REG(base) & DMA_TCD13_ATTR_SMOD_MASK) >> DMA_TCD13_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD13_ATTR_SMOD(base) (DMA_RD_TCD13_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD13_ATTR_SMOD(base, value) (DMA_RMW_TCD13_ATTR(base, DMA_TCD13_ATTR_SMOD_MASK, DMA_TCD13_ATTR_SMOD(value)))
#define DMA_BWR_TCD13_ATTR_SMOD(base, value) (DMA_WR_TCD13_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD13_NBYTES_MLOFFNO(base) (DMA_TCD13_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD13_NBYTES_MLOFFNO(base, value) (DMA_TCD13_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD13_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD13_NBYTES_MLOFFNO(base, (DMA_RD_TCD13_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD13_NBYTES_MLOFFNO(base, DMA_RD_TCD13_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD13_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD13_NBYTES_MLOFFNO(base, DMA_RD_TCD13_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD13_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD13_NBYTES_MLOFFNO(base, DMA_RD_TCD13_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD13_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD13_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD13_NBYTES_MLOFFNO_REG(base) & DMA_TCD13_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD13_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD13_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD13_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD13_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD13_NBYTES_MLOFFNO(base, DMA_TCD13_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD13_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD13_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD13_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD13_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD13_NBYTES_MLOFFNO_REG(base) & DMA_TCD13_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD13_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD13_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFNO_REG(base), DMA_TCD13_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD13_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD13_NBYTES_MLOFFNO(base, DMA_TCD13_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD13_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD13_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFNO_REG(base), DMA_TCD13_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD13_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD13_NBYTES_MLOFFNO_REG(base) & DMA_TCD13_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD13_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD13_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFNO_REG(base), DMA_TCD13_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD13_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD13_NBYTES_MLOFFNO(base, DMA_TCD13_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD13_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD13_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFNO_REG(base), DMA_TCD13_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD13_NBYTES_MLNO(base) (DMA_TCD13_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD13_NBYTES_MLNO(base, value) (DMA_TCD13_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD13_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD13_NBYTES_MLNO(base, (DMA_RD_TCD13_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_NBYTES_MLNO(base, value) (DMA_WR_TCD13_NBYTES_MLNO(base, DMA_RD_TCD13_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD13_NBYTES_MLNO(base, value) (DMA_WR_TCD13_NBYTES_MLNO(base, DMA_RD_TCD13_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD13_NBYTES_MLNO(base, value) (DMA_WR_TCD13_NBYTES_MLNO(base, DMA_RD_TCD13_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD13_NBYTES_MLOFFYES(base) (DMA_TCD13_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD13_NBYTES_MLOFFYES(base, value) (DMA_TCD13_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD13_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD13_NBYTES_MLOFFYES(base, (DMA_RD_TCD13_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD13_NBYTES_MLOFFYES(base, DMA_RD_TCD13_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD13_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD13_NBYTES_MLOFFYES(base, DMA_RD_TCD13_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD13_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD13_NBYTES_MLOFFYES(base, DMA_RD_TCD13_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD13_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD13_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD13_NBYTES_MLOFFYES_REG(base) & DMA_TCD13_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD13_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD13_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD13_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD13_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD13_NBYTES_MLOFFYES(base, DMA_TCD13_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD13_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD13_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD13_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD13_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD13_NBYTES_MLOFFYES_REG(base) & DMA_TCD13_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD13_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD13_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD13_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD13_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD13_NBYTES_MLOFFYES(base, DMA_TCD13_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD13_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD13_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD13_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD13_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD13_NBYTES_MLOFFYES_REG(base) & DMA_TCD13_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD13_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD13_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFYES_REG(base), DMA_TCD13_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD13_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD13_NBYTES_MLOFFYES(base, DMA_TCD13_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD13_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD13_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFYES_REG(base), DMA_TCD13_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD13_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD13_NBYTES_MLOFFYES_REG(base) & DMA_TCD13_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD13_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD13_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFYES_REG(base), DMA_TCD13_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD13_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD13_NBYTES_MLOFFYES(base, DMA_TCD13_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD13_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD13_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD13_NBYTES_MLOFFYES_REG(base), DMA_TCD13_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_SLAST register
 */
/*@{*/
#define DMA_RD_TCD13_SLAST(base) (DMA_TCD13_SLAST_REG(base))
#define DMA_WR_TCD13_SLAST(base, value) (DMA_TCD13_SLAST_REG(base) = (value))
#define DMA_RMW_TCD13_SLAST(base, mask, value) (DMA_WR_TCD13_SLAST(base, (DMA_RD_TCD13_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_SLAST(base, value) (DMA_WR_TCD13_SLAST(base, DMA_RD_TCD13_SLAST(base) |  (value)))
#define DMA_CLR_TCD13_SLAST(base, value) (DMA_WR_TCD13_SLAST(base, DMA_RD_TCD13_SLAST(base) & ~(value)))
#define DMA_TOG_TCD13_SLAST(base, value) (DMA_WR_TCD13_SLAST(base, DMA_RD_TCD13_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_DADDR register
 */
/*@{*/
#define DMA_RD_TCD13_DADDR(base) (DMA_TCD13_DADDR_REG(base))
#define DMA_WR_TCD13_DADDR(base, value) (DMA_TCD13_DADDR_REG(base) = (value))
#define DMA_RMW_TCD13_DADDR(base, mask, value) (DMA_WR_TCD13_DADDR(base, (DMA_RD_TCD13_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_DADDR(base, value) (DMA_WR_TCD13_DADDR(base, DMA_RD_TCD13_DADDR(base) |  (value)))
#define DMA_CLR_TCD13_DADDR(base, value) (DMA_WR_TCD13_DADDR(base, DMA_RD_TCD13_DADDR(base) & ~(value)))
#define DMA_TOG_TCD13_DADDR(base, value) (DMA_WR_TCD13_DADDR(base, DMA_RD_TCD13_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_DOFF register
 */
/*@{*/
#define DMA_RD_TCD13_DOFF(base)  (DMA_TCD13_DOFF_REG(base))
#define DMA_WR_TCD13_DOFF(base, value) (DMA_TCD13_DOFF_REG(base) = (value))
#define DMA_RMW_TCD13_DOFF(base, mask, value) (DMA_WR_TCD13_DOFF(base, (DMA_RD_TCD13_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_DOFF(base, value) (DMA_WR_TCD13_DOFF(base, DMA_RD_TCD13_DOFF(base) |  (value)))
#define DMA_CLR_TCD13_DOFF(base, value) (DMA_WR_TCD13_DOFF(base, DMA_RD_TCD13_DOFF(base) & ~(value)))
#define DMA_TOG_TCD13_DOFF(base, value) (DMA_WR_TCD13_DOFF(base, DMA_RD_TCD13_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD13_CITER_ELINKYES(base) (DMA_TCD13_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD13_CITER_ELINKYES(base, value) (DMA_TCD13_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD13_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD13_CITER_ELINKYES(base, (DMA_RD_TCD13_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_CITER_ELINKYES(base, value) (DMA_WR_TCD13_CITER_ELINKYES(base, DMA_RD_TCD13_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD13_CITER_ELINKYES(base, value) (DMA_WR_TCD13_CITER_ELINKYES(base, DMA_RD_TCD13_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD13_CITER_ELINKYES(base, value) (DMA_WR_TCD13_CITER_ELINKYES(base, DMA_RD_TCD13_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD13_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD13_CITER_ELINKYES_CITER(base) ((DMA_TCD13_CITER_ELINKYES_REG(base) & DMA_TCD13_CITER_ELINKYES_CITER_MASK) >> DMA_TCD13_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD13_CITER_ELINKYES_CITER(base) (DMA_RD_TCD13_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD13_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD13_CITER_ELINKYES(base, DMA_TCD13_CITER_ELINKYES_CITER_MASK, DMA_TCD13_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD13_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD13_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD13_CITER_ELINKYES_LINKCH(base) ((DMA_TCD13_CITER_ELINKYES_REG(base) & DMA_TCD13_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD13_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD13_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD13_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD13_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD13_CITER_ELINKYES(base, DMA_TCD13_CITER_ELINKYES_LINKCH_MASK, DMA_TCD13_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD13_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD13_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD13_CITER_ELINKYES_ELINK(base) ((DMA_TCD13_CITER_ELINKYES_REG(base) & DMA_TCD13_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD13_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD13_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD13_CITER_ELINKYES_REG(base), DMA_TCD13_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD13_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD13_CITER_ELINKYES(base, DMA_TCD13_CITER_ELINKYES_ELINK_MASK, DMA_TCD13_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD13_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CITER_ELINKYES_REG(base), DMA_TCD13_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD13_CITER_ELINKNO(base) (DMA_TCD13_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD13_CITER_ELINKNO(base, value) (DMA_TCD13_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD13_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD13_CITER_ELINKNO(base, (DMA_RD_TCD13_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_CITER_ELINKNO(base, value) (DMA_WR_TCD13_CITER_ELINKNO(base, DMA_RD_TCD13_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD13_CITER_ELINKNO(base, value) (DMA_WR_TCD13_CITER_ELINKNO(base, DMA_RD_TCD13_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD13_CITER_ELINKNO(base, value) (DMA_WR_TCD13_CITER_ELINKNO(base, DMA_RD_TCD13_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD13_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD13_CITER_ELINKNO_CITER(base) ((DMA_TCD13_CITER_ELINKNO_REG(base) & DMA_TCD13_CITER_ELINKNO_CITER_MASK) >> DMA_TCD13_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD13_CITER_ELINKNO_CITER(base) (DMA_RD_TCD13_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD13_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD13_CITER_ELINKNO(base, DMA_TCD13_CITER_ELINKNO_CITER_MASK, DMA_TCD13_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD13_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD13_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD13_CITER_ELINKNO_ELINK(base) ((DMA_TCD13_CITER_ELINKNO_REG(base) & DMA_TCD13_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD13_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD13_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD13_CITER_ELINKNO_REG(base), DMA_TCD13_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD13_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD13_CITER_ELINKNO(base, DMA_TCD13_CITER_ELINKNO_ELINK_MASK, DMA_TCD13_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD13_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CITER_ELINKNO_REG(base), DMA_TCD13_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD13_DLASTSGA(base) (DMA_TCD13_DLASTSGA_REG(base))
#define DMA_WR_TCD13_DLASTSGA(base, value) (DMA_TCD13_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD13_DLASTSGA(base, mask, value) (DMA_WR_TCD13_DLASTSGA(base, (DMA_RD_TCD13_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_DLASTSGA(base, value) (DMA_WR_TCD13_DLASTSGA(base, DMA_RD_TCD13_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD13_DLASTSGA(base, value) (DMA_WR_TCD13_DLASTSGA(base, DMA_RD_TCD13_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD13_DLASTSGA(base, value) (DMA_WR_TCD13_DLASTSGA(base, DMA_RD_TCD13_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_CSR register
 */
/*@{*/
#define DMA_RD_TCD13_CSR(base)   (DMA_TCD13_CSR_REG(base))
#define DMA_WR_TCD13_CSR(base, value) (DMA_TCD13_CSR_REG(base) = (value))
#define DMA_RMW_TCD13_CSR(base, mask, value) (DMA_WR_TCD13_CSR(base, (DMA_RD_TCD13_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_CSR(base, value) (DMA_WR_TCD13_CSR(base, DMA_RD_TCD13_CSR(base) |  (value)))
#define DMA_CLR_TCD13_CSR(base, value) (DMA_WR_TCD13_CSR(base, DMA_RD_TCD13_CSR(base) & ~(value)))
#define DMA_TOG_TCD13_CSR(base, value) (DMA_WR_TCD13_CSR(base, DMA_RD_TCD13_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_CSR bitfields
 */

/*!
 * @name Register DMA_TCD13_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_START field. */
#define DMA_RD_TCD13_CSR_START(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_START_MASK) >> DMA_TCD13_CSR_START_SHIFT)
#define DMA_BRD_TCD13_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD13_CSR_START(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_START_MASK, DMA_TCD13_CSR_START(value)))
#define DMA_BWR_TCD13_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_INTMAJOR field. */
#define DMA_RD_TCD13_CSR_INTMAJOR(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_INTMAJOR_MASK) >> DMA_TCD13_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD13_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD13_CSR_INTMAJOR(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_INTMAJOR_MASK, DMA_TCD13_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD13_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_INTHALF field. */
#define DMA_RD_TCD13_CSR_INTHALF(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_INTHALF_MASK) >> DMA_TCD13_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD13_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD13_CSR_INTHALF(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_INTHALF_MASK, DMA_TCD13_CSR_INTHALF(value)))
#define DMA_BWR_TCD13_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_DREQ field. */
#define DMA_RD_TCD13_CSR_DREQ(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_DREQ_MASK) >> DMA_TCD13_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD13_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD13_CSR_DREQ(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_DREQ_MASK, DMA_TCD13_CSR_DREQ(value)))
#define DMA_BWR_TCD13_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_ESG field. */
#define DMA_RD_TCD13_CSR_ESG(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_ESG_MASK) >> DMA_TCD13_CSR_ESG_SHIFT)
#define DMA_BRD_TCD13_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD13_CSR_ESG(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_ESG_MASK, DMA_TCD13_CSR_ESG(value)))
#define DMA_BWR_TCD13_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_MAJORELINK field. */
#define DMA_RD_TCD13_CSR_MAJORELINK(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_MAJORELINK_MASK) >> DMA_TCD13_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD13_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD13_CSR_MAJORELINK(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_MAJORELINK_MASK, DMA_TCD13_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD13_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_ACTIVE field. */
#define DMA_RD_TCD13_CSR_ACTIVE(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_ACTIVE_MASK) >> DMA_TCD13_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD13_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD13_CSR_ACTIVE(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_ACTIVE_MASK, DMA_TCD13_CSR_ACTIVE(value)))
#define DMA_BWR_TCD13_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_DONE field. */
#define DMA_RD_TCD13_CSR_DONE(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_DONE_MASK) >> DMA_TCD13_CSR_DONE_SHIFT)
#define DMA_BRD_TCD13_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD13_CSR_DONE(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_DONE_MASK, DMA_TCD13_CSR_DONE(value)))
#define DMA_BWR_TCD13_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD13_CSR_REG(base), DMA_TCD13_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD13_CSR_MAJORLINKCH(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_MAJORLINKCH_MASK) >> DMA_TCD13_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD13_CSR_MAJORLINKCH(base) (DMA_RD_TCD13_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD13_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_MAJORLINKCH_MASK, DMA_TCD13_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD13_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD13_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_CSR_BWC field. */
#define DMA_RD_TCD13_CSR_BWC(base) ((DMA_TCD13_CSR_REG(base) & DMA_TCD13_CSR_BWC_MASK) >> DMA_TCD13_CSR_BWC_SHIFT)
#define DMA_BRD_TCD13_CSR_BWC(base) (DMA_RD_TCD13_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD13_CSR_BWC(base, value) (DMA_RMW_TCD13_CSR(base, DMA_TCD13_CSR_BWC_MASK, DMA_TCD13_CSR_BWC(value)))
#define DMA_BWR_TCD13_CSR_BWC(base, value) (DMA_WR_TCD13_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD13_BITER_ELINKYES(base) (DMA_TCD13_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD13_BITER_ELINKYES(base, value) (DMA_TCD13_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD13_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD13_BITER_ELINKYES(base, (DMA_RD_TCD13_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_BITER_ELINKYES(base, value) (DMA_WR_TCD13_BITER_ELINKYES(base, DMA_RD_TCD13_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD13_BITER_ELINKYES(base, value) (DMA_WR_TCD13_BITER_ELINKYES(base, DMA_RD_TCD13_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD13_BITER_ELINKYES(base, value) (DMA_WR_TCD13_BITER_ELINKYES(base, DMA_RD_TCD13_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD13_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD13_BITER_ELINKYES_BITER(base) ((DMA_TCD13_BITER_ELINKYES_REG(base) & DMA_TCD13_BITER_ELINKYES_BITER_MASK) >> DMA_TCD13_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD13_BITER_ELINKYES_BITER(base) (DMA_RD_TCD13_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD13_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD13_BITER_ELINKYES(base, DMA_TCD13_BITER_ELINKYES_BITER_MASK, DMA_TCD13_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD13_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD13_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD13_BITER_ELINKYES_LINKCH(base) ((DMA_TCD13_BITER_ELINKYES_REG(base) & DMA_TCD13_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD13_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD13_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD13_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD13_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD13_BITER_ELINKYES(base, DMA_TCD13_BITER_ELINKYES_LINKCH_MASK, DMA_TCD13_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD13_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD13_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD13_BITER_ELINKYES_ELINK(base) ((DMA_TCD13_BITER_ELINKYES_REG(base) & DMA_TCD13_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD13_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD13_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD13_BITER_ELINKYES_REG(base), DMA_TCD13_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD13_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD13_BITER_ELINKYES(base, DMA_TCD13_BITER_ELINKYES_ELINK_MASK, DMA_TCD13_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD13_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD13_BITER_ELINKYES_REG(base), DMA_TCD13_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD13_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD13_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD13_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD13_BITER_ELINKNO(base) (DMA_TCD13_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD13_BITER_ELINKNO(base, value) (DMA_TCD13_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD13_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD13_BITER_ELINKNO(base, (DMA_RD_TCD13_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD13_BITER_ELINKNO(base, value) (DMA_WR_TCD13_BITER_ELINKNO(base, DMA_RD_TCD13_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD13_BITER_ELINKNO(base, value) (DMA_WR_TCD13_BITER_ELINKNO(base, DMA_RD_TCD13_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD13_BITER_ELINKNO(base, value) (DMA_WR_TCD13_BITER_ELINKNO(base, DMA_RD_TCD13_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD13_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD13_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD13_BITER_ELINKNO_BITER(base) ((DMA_TCD13_BITER_ELINKNO_REG(base) & DMA_TCD13_BITER_ELINKNO_BITER_MASK) >> DMA_TCD13_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD13_BITER_ELINKNO_BITER(base) (DMA_RD_TCD13_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD13_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD13_BITER_ELINKNO(base, DMA_TCD13_BITER_ELINKNO_BITER_MASK, DMA_TCD13_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD13_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD13_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD13_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD13_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD13_BITER_ELINKNO_ELINK(base) ((DMA_TCD13_BITER_ELINKNO_REG(base) & DMA_TCD13_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD13_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD13_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD13_BITER_ELINKNO_REG(base), DMA_TCD13_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD13_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD13_BITER_ELINKNO(base, DMA_TCD13_BITER_ELINKNO_ELINK_MASK, DMA_TCD13_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD13_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD13_BITER_ELINKNO_REG(base), DMA_TCD13_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_SADDR register
 */
/*@{*/
#define DMA_RD_TCD14_SADDR(base) (DMA_TCD14_SADDR_REG(base))
#define DMA_WR_TCD14_SADDR(base, value) (DMA_TCD14_SADDR_REG(base) = (value))
#define DMA_RMW_TCD14_SADDR(base, mask, value) (DMA_WR_TCD14_SADDR(base, (DMA_RD_TCD14_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_SADDR(base, value) (DMA_WR_TCD14_SADDR(base, DMA_RD_TCD14_SADDR(base) |  (value)))
#define DMA_CLR_TCD14_SADDR(base, value) (DMA_WR_TCD14_SADDR(base, DMA_RD_TCD14_SADDR(base) & ~(value)))
#define DMA_TOG_TCD14_SADDR(base, value) (DMA_WR_TCD14_SADDR(base, DMA_RD_TCD14_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_SOFF register
 */
/*@{*/
#define DMA_RD_TCD14_SOFF(base)  (DMA_TCD14_SOFF_REG(base))
#define DMA_WR_TCD14_SOFF(base, value) (DMA_TCD14_SOFF_REG(base) = (value))
#define DMA_RMW_TCD14_SOFF(base, mask, value) (DMA_WR_TCD14_SOFF(base, (DMA_RD_TCD14_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_SOFF(base, value) (DMA_WR_TCD14_SOFF(base, DMA_RD_TCD14_SOFF(base) |  (value)))
#define DMA_CLR_TCD14_SOFF(base, value) (DMA_WR_TCD14_SOFF(base, DMA_RD_TCD14_SOFF(base) & ~(value)))
#define DMA_TOG_TCD14_SOFF(base, value) (DMA_WR_TCD14_SOFF(base, DMA_RD_TCD14_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_ATTR register
 */
/*@{*/
#define DMA_RD_TCD14_ATTR(base)  (DMA_TCD14_ATTR_REG(base))
#define DMA_WR_TCD14_ATTR(base, value) (DMA_TCD14_ATTR_REG(base) = (value))
#define DMA_RMW_TCD14_ATTR(base, mask, value) (DMA_WR_TCD14_ATTR(base, (DMA_RD_TCD14_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_ATTR(base, value) (DMA_WR_TCD14_ATTR(base, DMA_RD_TCD14_ATTR(base) |  (value)))
#define DMA_CLR_TCD14_ATTR(base, value) (DMA_WR_TCD14_ATTR(base, DMA_RD_TCD14_ATTR(base) & ~(value)))
#define DMA_TOG_TCD14_ATTR(base, value) (DMA_WR_TCD14_ATTR(base, DMA_RD_TCD14_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD14_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_ATTR_DSIZE field. */
#define DMA_RD_TCD14_ATTR_DSIZE(base) ((DMA_TCD14_ATTR_REG(base) & DMA_TCD14_ATTR_DSIZE_MASK) >> DMA_TCD14_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD14_ATTR_DSIZE(base) (DMA_RD_TCD14_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD14_ATTR_DSIZE(base, value) (DMA_RMW_TCD14_ATTR(base, DMA_TCD14_ATTR_DSIZE_MASK, DMA_TCD14_ATTR_DSIZE(value)))
#define DMA_BWR_TCD14_ATTR_DSIZE(base, value) (DMA_WR_TCD14_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_ATTR_DMOD field. */
#define DMA_RD_TCD14_ATTR_DMOD(base) ((DMA_TCD14_ATTR_REG(base) & DMA_TCD14_ATTR_DMOD_MASK) >> DMA_TCD14_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD14_ATTR_DMOD(base) (DMA_RD_TCD14_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD14_ATTR_DMOD(base, value) (DMA_RMW_TCD14_ATTR(base, DMA_TCD14_ATTR_DMOD_MASK, DMA_TCD14_ATTR_DMOD(value)))
#define DMA_BWR_TCD14_ATTR_DMOD(base, value) (DMA_WR_TCD14_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_ATTR_SSIZE field. */
#define DMA_RD_TCD14_ATTR_SSIZE(base) ((DMA_TCD14_ATTR_REG(base) & DMA_TCD14_ATTR_SSIZE_MASK) >> DMA_TCD14_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD14_ATTR_SSIZE(base) (DMA_RD_TCD14_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD14_ATTR_SSIZE(base, value) (DMA_RMW_TCD14_ATTR(base, DMA_TCD14_ATTR_SSIZE_MASK, DMA_TCD14_ATTR_SSIZE(value)))
#define DMA_BWR_TCD14_ATTR_SSIZE(base, value) (DMA_WR_TCD14_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_ATTR_SMOD field. */
#define DMA_RD_TCD14_ATTR_SMOD(base) ((DMA_TCD14_ATTR_REG(base) & DMA_TCD14_ATTR_SMOD_MASK) >> DMA_TCD14_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD14_ATTR_SMOD(base) (DMA_RD_TCD14_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD14_ATTR_SMOD(base, value) (DMA_RMW_TCD14_ATTR(base, DMA_TCD14_ATTR_SMOD_MASK, DMA_TCD14_ATTR_SMOD(value)))
#define DMA_BWR_TCD14_ATTR_SMOD(base, value) (DMA_WR_TCD14_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD14_NBYTES_MLOFFYES(base) (DMA_TCD14_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD14_NBYTES_MLOFFYES(base, value) (DMA_TCD14_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD14_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD14_NBYTES_MLOFFYES(base, (DMA_RD_TCD14_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD14_NBYTES_MLOFFYES(base, DMA_RD_TCD14_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD14_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD14_NBYTES_MLOFFYES(base, DMA_RD_TCD14_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD14_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD14_NBYTES_MLOFFYES(base, DMA_RD_TCD14_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD14_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD14_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD14_NBYTES_MLOFFYES_REG(base) & DMA_TCD14_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD14_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD14_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD14_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD14_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD14_NBYTES_MLOFFYES(base, DMA_TCD14_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD14_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD14_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD14_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD14_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD14_NBYTES_MLOFFYES_REG(base) & DMA_TCD14_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD14_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD14_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD14_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD14_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD14_NBYTES_MLOFFYES(base, DMA_TCD14_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD14_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD14_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD14_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD14_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD14_NBYTES_MLOFFYES_REG(base) & DMA_TCD14_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD14_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD14_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFYES_REG(base), DMA_TCD14_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD14_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD14_NBYTES_MLOFFYES(base, DMA_TCD14_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD14_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD14_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFYES_REG(base), DMA_TCD14_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD14_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD14_NBYTES_MLOFFYES_REG(base) & DMA_TCD14_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD14_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD14_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFYES_REG(base), DMA_TCD14_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD14_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD14_NBYTES_MLOFFYES(base, DMA_TCD14_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD14_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD14_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFYES_REG(base), DMA_TCD14_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD14_NBYTES_MLOFFNO(base) (DMA_TCD14_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD14_NBYTES_MLOFFNO(base, value) (DMA_TCD14_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD14_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD14_NBYTES_MLOFFNO(base, (DMA_RD_TCD14_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD14_NBYTES_MLOFFNO(base, DMA_RD_TCD14_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD14_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD14_NBYTES_MLOFFNO(base, DMA_RD_TCD14_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD14_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD14_NBYTES_MLOFFNO(base, DMA_RD_TCD14_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD14_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD14_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD14_NBYTES_MLOFFNO_REG(base) & DMA_TCD14_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD14_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD14_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD14_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD14_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD14_NBYTES_MLOFFNO(base, DMA_TCD14_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD14_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD14_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD14_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD14_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD14_NBYTES_MLOFFNO_REG(base) & DMA_TCD14_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD14_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD14_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFNO_REG(base), DMA_TCD14_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD14_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD14_NBYTES_MLOFFNO(base, DMA_TCD14_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD14_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD14_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFNO_REG(base), DMA_TCD14_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD14_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD14_NBYTES_MLOFFNO_REG(base) & DMA_TCD14_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD14_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD14_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFNO_REG(base), DMA_TCD14_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD14_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD14_NBYTES_MLOFFNO(base, DMA_TCD14_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD14_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD14_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD14_NBYTES_MLOFFNO_REG(base), DMA_TCD14_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD14_NBYTES_MLNO(base) (DMA_TCD14_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD14_NBYTES_MLNO(base, value) (DMA_TCD14_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD14_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD14_NBYTES_MLNO(base, (DMA_RD_TCD14_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_NBYTES_MLNO(base, value) (DMA_WR_TCD14_NBYTES_MLNO(base, DMA_RD_TCD14_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD14_NBYTES_MLNO(base, value) (DMA_WR_TCD14_NBYTES_MLNO(base, DMA_RD_TCD14_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD14_NBYTES_MLNO(base, value) (DMA_WR_TCD14_NBYTES_MLNO(base, DMA_RD_TCD14_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_SLAST register
 */
/*@{*/
#define DMA_RD_TCD14_SLAST(base) (DMA_TCD14_SLAST_REG(base))
#define DMA_WR_TCD14_SLAST(base, value) (DMA_TCD14_SLAST_REG(base) = (value))
#define DMA_RMW_TCD14_SLAST(base, mask, value) (DMA_WR_TCD14_SLAST(base, (DMA_RD_TCD14_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_SLAST(base, value) (DMA_WR_TCD14_SLAST(base, DMA_RD_TCD14_SLAST(base) |  (value)))
#define DMA_CLR_TCD14_SLAST(base, value) (DMA_WR_TCD14_SLAST(base, DMA_RD_TCD14_SLAST(base) & ~(value)))
#define DMA_TOG_TCD14_SLAST(base, value) (DMA_WR_TCD14_SLAST(base, DMA_RD_TCD14_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_DADDR register
 */
/*@{*/
#define DMA_RD_TCD14_DADDR(base) (DMA_TCD14_DADDR_REG(base))
#define DMA_WR_TCD14_DADDR(base, value) (DMA_TCD14_DADDR_REG(base) = (value))
#define DMA_RMW_TCD14_DADDR(base, mask, value) (DMA_WR_TCD14_DADDR(base, (DMA_RD_TCD14_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_DADDR(base, value) (DMA_WR_TCD14_DADDR(base, DMA_RD_TCD14_DADDR(base) |  (value)))
#define DMA_CLR_TCD14_DADDR(base, value) (DMA_WR_TCD14_DADDR(base, DMA_RD_TCD14_DADDR(base) & ~(value)))
#define DMA_TOG_TCD14_DADDR(base, value) (DMA_WR_TCD14_DADDR(base, DMA_RD_TCD14_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_DOFF register
 */
/*@{*/
#define DMA_RD_TCD14_DOFF(base)  (DMA_TCD14_DOFF_REG(base))
#define DMA_WR_TCD14_DOFF(base, value) (DMA_TCD14_DOFF_REG(base) = (value))
#define DMA_RMW_TCD14_DOFF(base, mask, value) (DMA_WR_TCD14_DOFF(base, (DMA_RD_TCD14_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_DOFF(base, value) (DMA_WR_TCD14_DOFF(base, DMA_RD_TCD14_DOFF(base) |  (value)))
#define DMA_CLR_TCD14_DOFF(base, value) (DMA_WR_TCD14_DOFF(base, DMA_RD_TCD14_DOFF(base) & ~(value)))
#define DMA_TOG_TCD14_DOFF(base, value) (DMA_WR_TCD14_DOFF(base, DMA_RD_TCD14_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD14_CITER_ELINKNO(base) (DMA_TCD14_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD14_CITER_ELINKNO(base, value) (DMA_TCD14_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD14_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD14_CITER_ELINKNO(base, (DMA_RD_TCD14_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_CITER_ELINKNO(base, value) (DMA_WR_TCD14_CITER_ELINKNO(base, DMA_RD_TCD14_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD14_CITER_ELINKNO(base, value) (DMA_WR_TCD14_CITER_ELINKNO(base, DMA_RD_TCD14_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD14_CITER_ELINKNO(base, value) (DMA_WR_TCD14_CITER_ELINKNO(base, DMA_RD_TCD14_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD14_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD14_CITER_ELINKNO_CITER(base) ((DMA_TCD14_CITER_ELINKNO_REG(base) & DMA_TCD14_CITER_ELINKNO_CITER_MASK) >> DMA_TCD14_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD14_CITER_ELINKNO_CITER(base) (DMA_RD_TCD14_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD14_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD14_CITER_ELINKNO(base, DMA_TCD14_CITER_ELINKNO_CITER_MASK, DMA_TCD14_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD14_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD14_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD14_CITER_ELINKNO_ELINK(base) ((DMA_TCD14_CITER_ELINKNO_REG(base) & DMA_TCD14_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD14_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD14_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD14_CITER_ELINKNO_REG(base), DMA_TCD14_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD14_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD14_CITER_ELINKNO(base, DMA_TCD14_CITER_ELINKNO_ELINK_MASK, DMA_TCD14_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD14_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CITER_ELINKNO_REG(base), DMA_TCD14_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD14_CITER_ELINKYES(base) (DMA_TCD14_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD14_CITER_ELINKYES(base, value) (DMA_TCD14_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD14_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD14_CITER_ELINKYES(base, (DMA_RD_TCD14_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_CITER_ELINKYES(base, value) (DMA_WR_TCD14_CITER_ELINKYES(base, DMA_RD_TCD14_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD14_CITER_ELINKYES(base, value) (DMA_WR_TCD14_CITER_ELINKYES(base, DMA_RD_TCD14_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD14_CITER_ELINKYES(base, value) (DMA_WR_TCD14_CITER_ELINKYES(base, DMA_RD_TCD14_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD14_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD14_CITER_ELINKYES_CITER(base) ((DMA_TCD14_CITER_ELINKYES_REG(base) & DMA_TCD14_CITER_ELINKYES_CITER_MASK) >> DMA_TCD14_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD14_CITER_ELINKYES_CITER(base) (DMA_RD_TCD14_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD14_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD14_CITER_ELINKYES(base, DMA_TCD14_CITER_ELINKYES_CITER_MASK, DMA_TCD14_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD14_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD14_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD14_CITER_ELINKYES_LINKCH(base) ((DMA_TCD14_CITER_ELINKYES_REG(base) & DMA_TCD14_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD14_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD14_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD14_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD14_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD14_CITER_ELINKYES(base, DMA_TCD14_CITER_ELINKYES_LINKCH_MASK, DMA_TCD14_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD14_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD14_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD14_CITER_ELINKYES_ELINK(base) ((DMA_TCD14_CITER_ELINKYES_REG(base) & DMA_TCD14_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD14_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD14_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD14_CITER_ELINKYES_REG(base), DMA_TCD14_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD14_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD14_CITER_ELINKYES(base, DMA_TCD14_CITER_ELINKYES_ELINK_MASK, DMA_TCD14_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD14_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CITER_ELINKYES_REG(base), DMA_TCD14_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD14_DLASTSGA(base) (DMA_TCD14_DLASTSGA_REG(base))
#define DMA_WR_TCD14_DLASTSGA(base, value) (DMA_TCD14_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD14_DLASTSGA(base, mask, value) (DMA_WR_TCD14_DLASTSGA(base, (DMA_RD_TCD14_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_DLASTSGA(base, value) (DMA_WR_TCD14_DLASTSGA(base, DMA_RD_TCD14_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD14_DLASTSGA(base, value) (DMA_WR_TCD14_DLASTSGA(base, DMA_RD_TCD14_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD14_DLASTSGA(base, value) (DMA_WR_TCD14_DLASTSGA(base, DMA_RD_TCD14_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_CSR register
 */
/*@{*/
#define DMA_RD_TCD14_CSR(base)   (DMA_TCD14_CSR_REG(base))
#define DMA_WR_TCD14_CSR(base, value) (DMA_TCD14_CSR_REG(base) = (value))
#define DMA_RMW_TCD14_CSR(base, mask, value) (DMA_WR_TCD14_CSR(base, (DMA_RD_TCD14_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_CSR(base, value) (DMA_WR_TCD14_CSR(base, DMA_RD_TCD14_CSR(base) |  (value)))
#define DMA_CLR_TCD14_CSR(base, value) (DMA_WR_TCD14_CSR(base, DMA_RD_TCD14_CSR(base) & ~(value)))
#define DMA_TOG_TCD14_CSR(base, value) (DMA_WR_TCD14_CSR(base, DMA_RD_TCD14_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_CSR bitfields
 */

/*!
 * @name Register DMA_TCD14_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_START field. */
#define DMA_RD_TCD14_CSR_START(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_START_MASK) >> DMA_TCD14_CSR_START_SHIFT)
#define DMA_BRD_TCD14_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD14_CSR_START(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_START_MASK, DMA_TCD14_CSR_START(value)))
#define DMA_BWR_TCD14_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_INTMAJOR field. */
#define DMA_RD_TCD14_CSR_INTMAJOR(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_INTMAJOR_MASK) >> DMA_TCD14_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD14_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD14_CSR_INTMAJOR(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_INTMAJOR_MASK, DMA_TCD14_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD14_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_INTHALF field. */
#define DMA_RD_TCD14_CSR_INTHALF(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_INTHALF_MASK) >> DMA_TCD14_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD14_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD14_CSR_INTHALF(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_INTHALF_MASK, DMA_TCD14_CSR_INTHALF(value)))
#define DMA_BWR_TCD14_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_DREQ field. */
#define DMA_RD_TCD14_CSR_DREQ(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_DREQ_MASK) >> DMA_TCD14_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD14_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD14_CSR_DREQ(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_DREQ_MASK, DMA_TCD14_CSR_DREQ(value)))
#define DMA_BWR_TCD14_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_ESG field. */
#define DMA_RD_TCD14_CSR_ESG(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_ESG_MASK) >> DMA_TCD14_CSR_ESG_SHIFT)
#define DMA_BRD_TCD14_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD14_CSR_ESG(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_ESG_MASK, DMA_TCD14_CSR_ESG(value)))
#define DMA_BWR_TCD14_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_MAJORELINK field. */
#define DMA_RD_TCD14_CSR_MAJORELINK(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_MAJORELINK_MASK) >> DMA_TCD14_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD14_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD14_CSR_MAJORELINK(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_MAJORELINK_MASK, DMA_TCD14_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD14_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_ACTIVE field. */
#define DMA_RD_TCD14_CSR_ACTIVE(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_ACTIVE_MASK) >> DMA_TCD14_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD14_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD14_CSR_ACTIVE(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_ACTIVE_MASK, DMA_TCD14_CSR_ACTIVE(value)))
#define DMA_BWR_TCD14_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_DONE field. */
#define DMA_RD_TCD14_CSR_DONE(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_DONE_MASK) >> DMA_TCD14_CSR_DONE_SHIFT)
#define DMA_BRD_TCD14_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD14_CSR_DONE(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_DONE_MASK, DMA_TCD14_CSR_DONE(value)))
#define DMA_BWR_TCD14_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD14_CSR_REG(base), DMA_TCD14_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD14_CSR_MAJORLINKCH(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_MAJORLINKCH_MASK) >> DMA_TCD14_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD14_CSR_MAJORLINKCH(base) (DMA_RD_TCD14_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD14_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_MAJORLINKCH_MASK, DMA_TCD14_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD14_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD14_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_CSR_BWC field. */
#define DMA_RD_TCD14_CSR_BWC(base) ((DMA_TCD14_CSR_REG(base) & DMA_TCD14_CSR_BWC_MASK) >> DMA_TCD14_CSR_BWC_SHIFT)
#define DMA_BRD_TCD14_CSR_BWC(base) (DMA_RD_TCD14_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD14_CSR_BWC(base, value) (DMA_RMW_TCD14_CSR(base, DMA_TCD14_CSR_BWC_MASK, DMA_TCD14_CSR_BWC(value)))
#define DMA_BWR_TCD14_CSR_BWC(base, value) (DMA_WR_TCD14_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD14_BITER_ELINKNO(base) (DMA_TCD14_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD14_BITER_ELINKNO(base, value) (DMA_TCD14_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD14_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD14_BITER_ELINKNO(base, (DMA_RD_TCD14_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_BITER_ELINKNO(base, value) (DMA_WR_TCD14_BITER_ELINKNO(base, DMA_RD_TCD14_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD14_BITER_ELINKNO(base, value) (DMA_WR_TCD14_BITER_ELINKNO(base, DMA_RD_TCD14_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD14_BITER_ELINKNO(base, value) (DMA_WR_TCD14_BITER_ELINKNO(base, DMA_RD_TCD14_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD14_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD14_BITER_ELINKNO_BITER(base) ((DMA_TCD14_BITER_ELINKNO_REG(base) & DMA_TCD14_BITER_ELINKNO_BITER_MASK) >> DMA_TCD14_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD14_BITER_ELINKNO_BITER(base) (DMA_RD_TCD14_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD14_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD14_BITER_ELINKNO(base, DMA_TCD14_BITER_ELINKNO_BITER_MASK, DMA_TCD14_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD14_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD14_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD14_BITER_ELINKNO_ELINK(base) ((DMA_TCD14_BITER_ELINKNO_REG(base) & DMA_TCD14_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD14_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD14_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD14_BITER_ELINKNO_REG(base), DMA_TCD14_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD14_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD14_BITER_ELINKNO(base, DMA_TCD14_BITER_ELINKNO_ELINK_MASK, DMA_TCD14_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD14_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD14_BITER_ELINKNO_REG(base), DMA_TCD14_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD14_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD14_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD14_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD14_BITER_ELINKYES(base) (DMA_TCD14_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD14_BITER_ELINKYES(base, value) (DMA_TCD14_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD14_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD14_BITER_ELINKYES(base, (DMA_RD_TCD14_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD14_BITER_ELINKYES(base, value) (DMA_WR_TCD14_BITER_ELINKYES(base, DMA_RD_TCD14_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD14_BITER_ELINKYES(base, value) (DMA_WR_TCD14_BITER_ELINKYES(base, DMA_RD_TCD14_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD14_BITER_ELINKYES(base, value) (DMA_WR_TCD14_BITER_ELINKYES(base, DMA_RD_TCD14_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD14_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD14_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD14_BITER_ELINKYES_BITER(base) ((DMA_TCD14_BITER_ELINKYES_REG(base) & DMA_TCD14_BITER_ELINKYES_BITER_MASK) >> DMA_TCD14_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD14_BITER_ELINKYES_BITER(base) (DMA_RD_TCD14_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD14_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD14_BITER_ELINKYES(base, DMA_TCD14_BITER_ELINKYES_BITER_MASK, DMA_TCD14_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD14_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD14_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD14_BITER_ELINKYES_LINKCH(base) ((DMA_TCD14_BITER_ELINKYES_REG(base) & DMA_TCD14_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD14_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD14_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD14_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD14_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD14_BITER_ELINKYES(base, DMA_TCD14_BITER_ELINKYES_LINKCH_MASK, DMA_TCD14_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD14_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD14_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD14_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD14_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD14_BITER_ELINKYES_ELINK(base) ((DMA_TCD14_BITER_ELINKYES_REG(base) & DMA_TCD14_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD14_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD14_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD14_BITER_ELINKYES_REG(base), DMA_TCD14_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD14_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD14_BITER_ELINKYES(base, DMA_TCD14_BITER_ELINKYES_ELINK_MASK, DMA_TCD14_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD14_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD14_BITER_ELINKYES_REG(base), DMA_TCD14_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_SADDR register
 */
/*@{*/
#define DMA_RD_TCD15_SADDR(base) (DMA_TCD15_SADDR_REG(base))
#define DMA_WR_TCD15_SADDR(base, value) (DMA_TCD15_SADDR_REG(base) = (value))
#define DMA_RMW_TCD15_SADDR(base, mask, value) (DMA_WR_TCD15_SADDR(base, (DMA_RD_TCD15_SADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_SADDR(base, value) (DMA_WR_TCD15_SADDR(base, DMA_RD_TCD15_SADDR(base) |  (value)))
#define DMA_CLR_TCD15_SADDR(base, value) (DMA_WR_TCD15_SADDR(base, DMA_RD_TCD15_SADDR(base) & ~(value)))
#define DMA_TOG_TCD15_SADDR(base, value) (DMA_WR_TCD15_SADDR(base, DMA_RD_TCD15_SADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_SOFF register
 */
/*@{*/
#define DMA_RD_TCD15_SOFF(base)  (DMA_TCD15_SOFF_REG(base))
#define DMA_WR_TCD15_SOFF(base, value) (DMA_TCD15_SOFF_REG(base) = (value))
#define DMA_RMW_TCD15_SOFF(base, mask, value) (DMA_WR_TCD15_SOFF(base, (DMA_RD_TCD15_SOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_SOFF(base, value) (DMA_WR_TCD15_SOFF(base, DMA_RD_TCD15_SOFF(base) |  (value)))
#define DMA_CLR_TCD15_SOFF(base, value) (DMA_WR_TCD15_SOFF(base, DMA_RD_TCD15_SOFF(base) & ~(value)))
#define DMA_TOG_TCD15_SOFF(base, value) (DMA_WR_TCD15_SOFF(base, DMA_RD_TCD15_SOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_ATTR register
 */
/*@{*/
#define DMA_RD_TCD15_ATTR(base)  (DMA_TCD15_ATTR_REG(base))
#define DMA_WR_TCD15_ATTR(base, value) (DMA_TCD15_ATTR_REG(base) = (value))
#define DMA_RMW_TCD15_ATTR(base, mask, value) (DMA_WR_TCD15_ATTR(base, (DMA_RD_TCD15_ATTR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_ATTR(base, value) (DMA_WR_TCD15_ATTR(base, DMA_RD_TCD15_ATTR(base) |  (value)))
#define DMA_CLR_TCD15_ATTR(base, value) (DMA_WR_TCD15_ATTR(base, DMA_RD_TCD15_ATTR(base) & ~(value)))
#define DMA_TOG_TCD15_ATTR(base, value) (DMA_WR_TCD15_ATTR(base, DMA_RD_TCD15_ATTR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_ATTR bitfields
 */

/*!
 * @name Register DMA_TCD15_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_ATTR_DSIZE field. */
#define DMA_RD_TCD15_ATTR_DSIZE(base) ((DMA_TCD15_ATTR_REG(base) & DMA_TCD15_ATTR_DSIZE_MASK) >> DMA_TCD15_ATTR_DSIZE_SHIFT)
#define DMA_BRD_TCD15_ATTR_DSIZE(base) (DMA_RD_TCD15_ATTR_DSIZE(base))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_TCD15_ATTR_DSIZE(base, value) (DMA_RMW_TCD15_ATTR(base, DMA_TCD15_ATTR_DSIZE_MASK, DMA_TCD15_ATTR_DSIZE(value)))
#define DMA_BWR_TCD15_ATTR_DSIZE(base, value) (DMA_WR_TCD15_ATTR_DSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_ATTR_DMOD field. */
#define DMA_RD_TCD15_ATTR_DMOD(base) ((DMA_TCD15_ATTR_REG(base) & DMA_TCD15_ATTR_DMOD_MASK) >> DMA_TCD15_ATTR_DMOD_SHIFT)
#define DMA_BRD_TCD15_ATTR_DMOD(base) (DMA_RD_TCD15_ATTR_DMOD(base))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_TCD15_ATTR_DMOD(base, value) (DMA_RMW_TCD15_ATTR(base, DMA_TCD15_ATTR_DMOD_MASK, DMA_TCD15_ATTR_DMOD(value)))
#define DMA_BWR_TCD15_ATTR_DMOD(base, value) (DMA_WR_TCD15_ATTR_DMOD(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_ATTR_SSIZE field. */
#define DMA_RD_TCD15_ATTR_SSIZE(base) ((DMA_TCD15_ATTR_REG(base) & DMA_TCD15_ATTR_SSIZE_MASK) >> DMA_TCD15_ATTR_SSIZE_SHIFT)
#define DMA_BRD_TCD15_ATTR_SSIZE(base) (DMA_RD_TCD15_ATTR_SSIZE(base))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_TCD15_ATTR_SSIZE(base, value) (DMA_RMW_TCD15_ATTR(base, DMA_TCD15_ATTR_SSIZE_MASK, DMA_TCD15_ATTR_SSIZE(value)))
#define DMA_BWR_TCD15_ATTR_SSIZE(base, value) (DMA_WR_TCD15_ATTR_SSIZE(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_ATTR_SMOD field. */
#define DMA_RD_TCD15_ATTR_SMOD(base) ((DMA_TCD15_ATTR_REG(base) & DMA_TCD15_ATTR_SMOD_MASK) >> DMA_TCD15_ATTR_SMOD_SHIFT)
#define DMA_BRD_TCD15_ATTR_SMOD(base) (DMA_RD_TCD15_ATTR_SMOD(base))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_TCD15_ATTR_SMOD(base, value) (DMA_RMW_TCD15_ATTR(base, DMA_TCD15_ATTR_SMOD_MASK, DMA_TCD15_ATTR_SMOD(value)))
#define DMA_BWR_TCD15_ATTR_SMOD(base, value) (DMA_WR_TCD15_ATTR_SMOD(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_TCD15_NBYTES_MLOFFYES(base) (DMA_TCD15_NBYTES_MLOFFYES_REG(base))
#define DMA_WR_TCD15_NBYTES_MLOFFYES(base, value) (DMA_TCD15_NBYTES_MLOFFYES_REG(base) = (value))
#define DMA_RMW_TCD15_NBYTES_MLOFFYES(base, mask, value) (DMA_WR_TCD15_NBYTES_MLOFFYES(base, (DMA_RD_TCD15_NBYTES_MLOFFYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD15_NBYTES_MLOFFYES(base, DMA_RD_TCD15_NBYTES_MLOFFYES(base) |  (value)))
#define DMA_CLR_TCD15_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD15_NBYTES_MLOFFYES(base, DMA_RD_TCD15_NBYTES_MLOFFYES(base) & ~(value)))
#define DMA_TOG_TCD15_NBYTES_MLOFFYES(base, value) (DMA_WR_TCD15_NBYTES_MLOFFYES(base, DMA_RD_TCD15_NBYTES_MLOFFYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_TCD15_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_TCD15_NBYTES_MLOFFYES_NBYTES(base) ((DMA_TCD15_NBYTES_MLOFFYES_REG(base) & DMA_TCD15_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_TCD15_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_TCD15_NBYTES_MLOFFYES_NBYTES(base) (DMA_RD_TCD15_NBYTES_MLOFFYES_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD15_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_RMW_TCD15_NBYTES_MLOFFYES(base, DMA_TCD15_NBYTES_MLOFFYES_NBYTES_MASK, DMA_TCD15_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_TCD15_NBYTES_MLOFFYES_NBYTES(base, value) (DMA_WR_TCD15_NBYTES_MLOFFYES_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_TCD15_NBYTES_MLOFFYES_MLOFF(base) ((DMA_TCD15_NBYTES_MLOFFYES_REG(base) & DMA_TCD15_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_TCD15_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_TCD15_NBYTES_MLOFFYES_MLOFF(base) (DMA_RD_TCD15_NBYTES_MLOFFYES_MLOFF(base))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_TCD15_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_RMW_TCD15_NBYTES_MLOFFYES(base, DMA_TCD15_NBYTES_MLOFFYES_MLOFF_MASK, DMA_TCD15_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_TCD15_NBYTES_MLOFFYES_MLOFF(base, value) (DMA_WR_TCD15_NBYTES_MLOFFYES_MLOFF(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_TCD15_NBYTES_MLOFFYES_DMLOE(base) ((DMA_TCD15_NBYTES_MLOFFYES_REG(base) & DMA_TCD15_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_TCD15_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_TCD15_NBYTES_MLOFFYES_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFYES_REG(base), DMA_TCD15_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD15_NBYTES_MLOFFYES_DMLOE(base, value) (DMA_RMW_TCD15_NBYTES_MLOFFYES(base, DMA_TCD15_NBYTES_MLOFFYES_DMLOE_MASK, DMA_TCD15_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_TCD15_NBYTES_MLOFFYES_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFYES_REG(base), DMA_TCD15_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_TCD15_NBYTES_MLOFFYES_SMLOE(base) ((DMA_TCD15_NBYTES_MLOFFYES_REG(base) & DMA_TCD15_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_TCD15_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_TCD15_NBYTES_MLOFFYES_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFYES_REG(base), DMA_TCD15_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD15_NBYTES_MLOFFYES_SMLOE(base, value) (DMA_RMW_TCD15_NBYTES_MLOFFYES(base, DMA_TCD15_NBYTES_MLOFFYES_SMLOE_MASK, DMA_TCD15_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_TCD15_NBYTES_MLOFFYES_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFYES_REG(base), DMA_TCD15_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_TCD15_NBYTES_MLNO(base) (DMA_TCD15_NBYTES_MLNO_REG(base))
#define DMA_WR_TCD15_NBYTES_MLNO(base, value) (DMA_TCD15_NBYTES_MLNO_REG(base) = (value))
#define DMA_RMW_TCD15_NBYTES_MLNO(base, mask, value) (DMA_WR_TCD15_NBYTES_MLNO(base, (DMA_RD_TCD15_NBYTES_MLNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_NBYTES_MLNO(base, value) (DMA_WR_TCD15_NBYTES_MLNO(base, DMA_RD_TCD15_NBYTES_MLNO(base) |  (value)))
#define DMA_CLR_TCD15_NBYTES_MLNO(base, value) (DMA_WR_TCD15_NBYTES_MLNO(base, DMA_RD_TCD15_NBYTES_MLNO(base) & ~(value)))
#define DMA_TOG_TCD15_NBYTES_MLNO(base, value) (DMA_WR_TCD15_NBYTES_MLNO(base, DMA_RD_TCD15_NBYTES_MLNO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_TCD15_NBYTES_MLOFFNO(base) (DMA_TCD15_NBYTES_MLOFFNO_REG(base))
#define DMA_WR_TCD15_NBYTES_MLOFFNO(base, value) (DMA_TCD15_NBYTES_MLOFFNO_REG(base) = (value))
#define DMA_RMW_TCD15_NBYTES_MLOFFNO(base, mask, value) (DMA_WR_TCD15_NBYTES_MLOFFNO(base, (DMA_RD_TCD15_NBYTES_MLOFFNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD15_NBYTES_MLOFFNO(base, DMA_RD_TCD15_NBYTES_MLOFFNO(base) |  (value)))
#define DMA_CLR_TCD15_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD15_NBYTES_MLOFFNO(base, DMA_RD_TCD15_NBYTES_MLOFFNO(base) & ~(value)))
#define DMA_TOG_TCD15_NBYTES_MLOFFNO(base, value) (DMA_WR_TCD15_NBYTES_MLOFFNO(base, DMA_RD_TCD15_NBYTES_MLOFFNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_TCD15_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_TCD15_NBYTES_MLOFFNO_NBYTES(base) ((DMA_TCD15_NBYTES_MLOFFNO_REG(base) & DMA_TCD15_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_TCD15_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_TCD15_NBYTES_MLOFFNO_NBYTES(base) (DMA_RD_TCD15_NBYTES_MLOFFNO_NBYTES(base))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_TCD15_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_RMW_TCD15_NBYTES_MLOFFNO(base, DMA_TCD15_NBYTES_MLOFFNO_NBYTES_MASK, DMA_TCD15_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_TCD15_NBYTES_MLOFFNO_NBYTES(base, value) (DMA_WR_TCD15_NBYTES_MLOFFNO_NBYTES(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_TCD15_NBYTES_MLOFFNO_DMLOE(base) ((DMA_TCD15_NBYTES_MLOFFNO_REG(base) & DMA_TCD15_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_TCD15_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_TCD15_NBYTES_MLOFFNO_DMLOE(base) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFNO_REG(base), DMA_TCD15_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_TCD15_NBYTES_MLOFFNO_DMLOE(base, value) (DMA_RMW_TCD15_NBYTES_MLOFFNO(base, DMA_TCD15_NBYTES_MLOFFNO_DMLOE_MASK, DMA_TCD15_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_TCD15_NBYTES_MLOFFNO_DMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFNO_REG(base), DMA_TCD15_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_TCD15_NBYTES_MLOFFNO_SMLOE(base) ((DMA_TCD15_NBYTES_MLOFFNO_REG(base) & DMA_TCD15_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_TCD15_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_TCD15_NBYTES_MLOFFNO_SMLOE(base) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFNO_REG(base), DMA_TCD15_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_TCD15_NBYTES_MLOFFNO_SMLOE(base, value) (DMA_RMW_TCD15_NBYTES_MLOFFNO(base, DMA_TCD15_NBYTES_MLOFFNO_SMLOE_MASK, DMA_TCD15_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_TCD15_NBYTES_MLOFFNO_SMLOE(base, value) (BITBAND_ACCESS32(&DMA_TCD15_NBYTES_MLOFFNO_REG(base), DMA_TCD15_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_SLAST register
 */
/*@{*/
#define DMA_RD_TCD15_SLAST(base) (DMA_TCD15_SLAST_REG(base))
#define DMA_WR_TCD15_SLAST(base, value) (DMA_TCD15_SLAST_REG(base) = (value))
#define DMA_RMW_TCD15_SLAST(base, mask, value) (DMA_WR_TCD15_SLAST(base, (DMA_RD_TCD15_SLAST(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_SLAST(base, value) (DMA_WR_TCD15_SLAST(base, DMA_RD_TCD15_SLAST(base) |  (value)))
#define DMA_CLR_TCD15_SLAST(base, value) (DMA_WR_TCD15_SLAST(base, DMA_RD_TCD15_SLAST(base) & ~(value)))
#define DMA_TOG_TCD15_SLAST(base, value) (DMA_WR_TCD15_SLAST(base, DMA_RD_TCD15_SLAST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_DADDR register
 */
/*@{*/
#define DMA_RD_TCD15_DADDR(base) (DMA_TCD15_DADDR_REG(base))
#define DMA_WR_TCD15_DADDR(base, value) (DMA_TCD15_DADDR_REG(base) = (value))
#define DMA_RMW_TCD15_DADDR(base, mask, value) (DMA_WR_TCD15_DADDR(base, (DMA_RD_TCD15_DADDR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_DADDR(base, value) (DMA_WR_TCD15_DADDR(base, DMA_RD_TCD15_DADDR(base) |  (value)))
#define DMA_CLR_TCD15_DADDR(base, value) (DMA_WR_TCD15_DADDR(base, DMA_RD_TCD15_DADDR(base) & ~(value)))
#define DMA_TOG_TCD15_DADDR(base, value) (DMA_WR_TCD15_DADDR(base, DMA_RD_TCD15_DADDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_DOFF register
 */
/*@{*/
#define DMA_RD_TCD15_DOFF(base)  (DMA_TCD15_DOFF_REG(base))
#define DMA_WR_TCD15_DOFF(base, value) (DMA_TCD15_DOFF_REG(base) = (value))
#define DMA_RMW_TCD15_DOFF(base, mask, value) (DMA_WR_TCD15_DOFF(base, (DMA_RD_TCD15_DOFF(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_DOFF(base, value) (DMA_WR_TCD15_DOFF(base, DMA_RD_TCD15_DOFF(base) |  (value)))
#define DMA_CLR_TCD15_DOFF(base, value) (DMA_WR_TCD15_DOFF(base, DMA_RD_TCD15_DOFF(base) & ~(value)))
#define DMA_TOG_TCD15_DOFF(base, value) (DMA_WR_TCD15_DOFF(base, DMA_RD_TCD15_DOFF(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD15_CITER_ELINKYES(base) (DMA_TCD15_CITER_ELINKYES_REG(base))
#define DMA_WR_TCD15_CITER_ELINKYES(base, value) (DMA_TCD15_CITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD15_CITER_ELINKYES(base, mask, value) (DMA_WR_TCD15_CITER_ELINKYES(base, (DMA_RD_TCD15_CITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_CITER_ELINKYES(base, value) (DMA_WR_TCD15_CITER_ELINKYES(base, DMA_RD_TCD15_CITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD15_CITER_ELINKYES(base, value) (DMA_WR_TCD15_CITER_ELINKYES(base, DMA_RD_TCD15_CITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD15_CITER_ELINKYES(base, value) (DMA_WR_TCD15_CITER_ELINKYES(base, DMA_RD_TCD15_CITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD15_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CITER_ELINKYES_CITER field. */
#define DMA_RD_TCD15_CITER_ELINKYES_CITER(base) ((DMA_TCD15_CITER_ELINKYES_REG(base) & DMA_TCD15_CITER_ELINKYES_CITER_MASK) >> DMA_TCD15_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_TCD15_CITER_ELINKYES_CITER(base) (DMA_RD_TCD15_CITER_ELINKYES_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD15_CITER_ELINKYES_CITER(base, value) (DMA_RMW_TCD15_CITER_ELINKYES(base, DMA_TCD15_CITER_ELINKYES_CITER_MASK, DMA_TCD15_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_TCD15_CITER_ELINKYES_CITER(base, value) (DMA_WR_TCD15_CITER_ELINKYES_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD15_CITER_ELINKYES_LINKCH(base) ((DMA_TCD15_CITER_ELINKYES_REG(base) & DMA_TCD15_CITER_ELINKYES_LINKCH_MASK) >> DMA_TCD15_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD15_CITER_ELINKYES_LINKCH(base) (DMA_RD_TCD15_CITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD15_CITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD15_CITER_ELINKYES(base, DMA_TCD15_CITER_ELINKYES_LINKCH_MASK, DMA_TCD15_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD15_CITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD15_CITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD15_CITER_ELINKYES_ELINK(base) ((DMA_TCD15_CITER_ELINKYES_REG(base) & DMA_TCD15_CITER_ELINKYES_ELINK_MASK) >> DMA_TCD15_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD15_CITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD15_CITER_ELINKYES_REG(base), DMA_TCD15_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD15_CITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD15_CITER_ELINKYES(base, DMA_TCD15_CITER_ELINKYES_ELINK_MASK, DMA_TCD15_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD15_CITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CITER_ELINKYES_REG(base), DMA_TCD15_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD15_CITER_ELINKNO(base) (DMA_TCD15_CITER_ELINKNO_REG(base))
#define DMA_WR_TCD15_CITER_ELINKNO(base, value) (DMA_TCD15_CITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD15_CITER_ELINKNO(base, mask, value) (DMA_WR_TCD15_CITER_ELINKNO(base, (DMA_RD_TCD15_CITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_CITER_ELINKNO(base, value) (DMA_WR_TCD15_CITER_ELINKNO(base, DMA_RD_TCD15_CITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD15_CITER_ELINKNO(base, value) (DMA_WR_TCD15_CITER_ELINKNO(base, DMA_RD_TCD15_CITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD15_CITER_ELINKNO(base, value) (DMA_WR_TCD15_CITER_ELINKNO(base, DMA_RD_TCD15_CITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD15_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CITER_ELINKNO_CITER field. */
#define DMA_RD_TCD15_CITER_ELINKNO_CITER(base) ((DMA_TCD15_CITER_ELINKNO_REG(base) & DMA_TCD15_CITER_ELINKNO_CITER_MASK) >> DMA_TCD15_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_TCD15_CITER_ELINKNO_CITER(base) (DMA_RD_TCD15_CITER_ELINKNO_CITER(base))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_TCD15_CITER_ELINKNO_CITER(base, value) (DMA_RMW_TCD15_CITER_ELINKNO(base, DMA_TCD15_CITER_ELINKNO_CITER_MASK, DMA_TCD15_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_TCD15_CITER_ELINKNO_CITER(base, value) (DMA_WR_TCD15_CITER_ELINKNO_CITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD15_CITER_ELINKNO_ELINK(base) ((DMA_TCD15_CITER_ELINKNO_REG(base) & DMA_TCD15_CITER_ELINKNO_ELINK_MASK) >> DMA_TCD15_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD15_CITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD15_CITER_ELINKNO_REG(base), DMA_TCD15_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD15_CITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD15_CITER_ELINKNO(base, DMA_TCD15_CITER_ELINKNO_ELINK_MASK, DMA_TCD15_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD15_CITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CITER_ELINKNO_REG(base), DMA_TCD15_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_DLASTSGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_DLASTSGA register
 */
/*@{*/
#define DMA_RD_TCD15_DLASTSGA(base) (DMA_TCD15_DLASTSGA_REG(base))
#define DMA_WR_TCD15_DLASTSGA(base, value) (DMA_TCD15_DLASTSGA_REG(base) = (value))
#define DMA_RMW_TCD15_DLASTSGA(base, mask, value) (DMA_WR_TCD15_DLASTSGA(base, (DMA_RD_TCD15_DLASTSGA(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_DLASTSGA(base, value) (DMA_WR_TCD15_DLASTSGA(base, DMA_RD_TCD15_DLASTSGA(base) |  (value)))
#define DMA_CLR_TCD15_DLASTSGA(base, value) (DMA_WR_TCD15_DLASTSGA(base, DMA_RD_TCD15_DLASTSGA(base) & ~(value)))
#define DMA_TOG_TCD15_DLASTSGA(base, value) (DMA_WR_TCD15_DLASTSGA(base, DMA_RD_TCD15_DLASTSGA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_CSR register
 */
/*@{*/
#define DMA_RD_TCD15_CSR(base)   (DMA_TCD15_CSR_REG(base))
#define DMA_WR_TCD15_CSR(base, value) (DMA_TCD15_CSR_REG(base) = (value))
#define DMA_RMW_TCD15_CSR(base, mask, value) (DMA_WR_TCD15_CSR(base, (DMA_RD_TCD15_CSR(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_CSR(base, value) (DMA_WR_TCD15_CSR(base, DMA_RD_TCD15_CSR(base) |  (value)))
#define DMA_CLR_TCD15_CSR(base, value) (DMA_WR_TCD15_CSR(base, DMA_RD_TCD15_CSR(base) & ~(value)))
#define DMA_TOG_TCD15_CSR(base, value) (DMA_WR_TCD15_CSR(base, DMA_RD_TCD15_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_CSR bitfields
 */

/*!
 * @name Register DMA_TCD15_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_START field. */
#define DMA_RD_TCD15_CSR_START(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_START_MASK) >> DMA_TCD15_CSR_START_SHIFT)
#define DMA_BRD_TCD15_CSR_START(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_TCD15_CSR_START(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_START_MASK, DMA_TCD15_CSR_START(value)))
#define DMA_BWR_TCD15_CSR_START(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_INTMAJOR field. */
#define DMA_RD_TCD15_CSR_INTMAJOR(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_INTMAJOR_MASK) >> DMA_TCD15_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_TCD15_CSR_INTMAJOR(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_TCD15_CSR_INTMAJOR(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_INTMAJOR_MASK, DMA_TCD15_CSR_INTMAJOR(value)))
#define DMA_BWR_TCD15_CSR_INTMAJOR(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_INTHALF field. */
#define DMA_RD_TCD15_CSR_INTHALF(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_INTHALF_MASK) >> DMA_TCD15_CSR_INTHALF_SHIFT)
#define DMA_BRD_TCD15_CSR_INTHALF(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_TCD15_CSR_INTHALF(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_INTHALF_MASK, DMA_TCD15_CSR_INTHALF(value)))
#define DMA_BWR_TCD15_CSR_INTHALF(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_DREQ field. */
#define DMA_RD_TCD15_CSR_DREQ(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_DREQ_MASK) >> DMA_TCD15_CSR_DREQ_SHIFT)
#define DMA_BRD_TCD15_CSR_DREQ(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_TCD15_CSR_DREQ(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_DREQ_MASK, DMA_TCD15_CSR_DREQ(value)))
#define DMA_BWR_TCD15_CSR_DREQ(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_ESG field. */
#define DMA_RD_TCD15_CSR_ESG(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_ESG_MASK) >> DMA_TCD15_CSR_ESG_SHIFT)
#define DMA_BRD_TCD15_CSR_ESG(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_TCD15_CSR_ESG(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_ESG_MASK, DMA_TCD15_CSR_ESG(value)))
#define DMA_BWR_TCD15_CSR_ESG(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_MAJORELINK field. */
#define DMA_RD_TCD15_CSR_MAJORELINK(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_MAJORELINK_MASK) >> DMA_TCD15_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_TCD15_CSR_MAJORELINK(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_TCD15_CSR_MAJORELINK(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_MAJORELINK_MASK, DMA_TCD15_CSR_MAJORELINK(value)))
#define DMA_BWR_TCD15_CSR_MAJORELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_ACTIVE field. */
#define DMA_RD_TCD15_CSR_ACTIVE(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_ACTIVE_MASK) >> DMA_TCD15_CSR_ACTIVE_SHIFT)
#define DMA_BRD_TCD15_CSR_ACTIVE(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_TCD15_CSR_ACTIVE(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_ACTIVE_MASK, DMA_TCD15_CSR_ACTIVE(value)))
#define DMA_BWR_TCD15_CSR_ACTIVE(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_DONE field. */
#define DMA_RD_TCD15_CSR_DONE(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_DONE_MASK) >> DMA_TCD15_CSR_DONE_SHIFT)
#define DMA_BRD_TCD15_CSR_DONE(base) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_TCD15_CSR_DONE(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_DONE_MASK, DMA_TCD15_CSR_DONE(value)))
#define DMA_BWR_TCD15_CSR_DONE(base, value) (BITBAND_ACCESS16(&DMA_TCD15_CSR_REG(base), DMA_TCD15_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_MAJORLINKCH field. */
#define DMA_RD_TCD15_CSR_MAJORLINKCH(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_MAJORLINKCH_MASK) >> DMA_TCD15_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_TCD15_CSR_MAJORLINKCH(base) (DMA_RD_TCD15_CSR_MAJORLINKCH(base))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_TCD15_CSR_MAJORLINKCH(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_MAJORLINKCH_MASK, DMA_TCD15_CSR_MAJORLINKCH(value)))
#define DMA_BWR_TCD15_CSR_MAJORLINKCH(base, value) (DMA_WR_TCD15_CSR_MAJORLINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_CSR_BWC field. */
#define DMA_RD_TCD15_CSR_BWC(base) ((DMA_TCD15_CSR_REG(base) & DMA_TCD15_CSR_BWC_MASK) >> DMA_TCD15_CSR_BWC_SHIFT)
#define DMA_BRD_TCD15_CSR_BWC(base) (DMA_RD_TCD15_CSR_BWC(base))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_TCD15_CSR_BWC(base, value) (DMA_RMW_TCD15_CSR(base, DMA_TCD15_CSR_BWC_MASK, DMA_TCD15_CSR_BWC(value)))
#define DMA_BWR_TCD15_CSR_BWC(base, value) (DMA_WR_TCD15_CSR_BWC(base, value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_TCD15_BITER_ELINKNO(base) (DMA_TCD15_BITER_ELINKNO_REG(base))
#define DMA_WR_TCD15_BITER_ELINKNO(base, value) (DMA_TCD15_BITER_ELINKNO_REG(base) = (value))
#define DMA_RMW_TCD15_BITER_ELINKNO(base, mask, value) (DMA_WR_TCD15_BITER_ELINKNO(base, (DMA_RD_TCD15_BITER_ELINKNO(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_BITER_ELINKNO(base, value) (DMA_WR_TCD15_BITER_ELINKNO(base, DMA_RD_TCD15_BITER_ELINKNO(base) |  (value)))
#define DMA_CLR_TCD15_BITER_ELINKNO(base, value) (DMA_WR_TCD15_BITER_ELINKNO(base, DMA_RD_TCD15_BITER_ELINKNO(base) & ~(value)))
#define DMA_TOG_TCD15_BITER_ELINKNO(base, value) (DMA_WR_TCD15_BITER_ELINKNO(base, DMA_RD_TCD15_BITER_ELINKNO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_TCD15_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_BITER_ELINKNO_BITER field. */
#define DMA_RD_TCD15_BITER_ELINKNO_BITER(base) ((DMA_TCD15_BITER_ELINKNO_REG(base) & DMA_TCD15_BITER_ELINKNO_BITER_MASK) >> DMA_TCD15_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_TCD15_BITER_ELINKNO_BITER(base) (DMA_RD_TCD15_BITER_ELINKNO_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD15_BITER_ELINKNO_BITER(base, value) (DMA_RMW_TCD15_BITER_ELINKNO(base, DMA_TCD15_BITER_ELINKNO_BITER_MASK, DMA_TCD15_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_TCD15_BITER_ELINKNO_BITER(base, value) (DMA_WR_TCD15_BITER_ELINKNO_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_BITER_ELINKNO_ELINK field. */
#define DMA_RD_TCD15_BITER_ELINKNO_ELINK(base) ((DMA_TCD15_BITER_ELINKNO_REG(base) & DMA_TCD15_BITER_ELINKNO_ELINK_MASK) >> DMA_TCD15_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_TCD15_BITER_ELINKNO_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD15_BITER_ELINKNO_REG(base), DMA_TCD15_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD15_BITER_ELINKNO_ELINK(base, value) (DMA_RMW_TCD15_BITER_ELINKNO(base, DMA_TCD15_BITER_ELINKNO_ELINK_MASK, DMA_TCD15_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_TCD15_BITER_ELINKNO_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD15_BITER_ELINKNO_REG(base), DMA_TCD15_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_TCD15_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_TCD15_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_TCD15_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_TCD15_BITER_ELINKYES(base) (DMA_TCD15_BITER_ELINKYES_REG(base))
#define DMA_WR_TCD15_BITER_ELINKYES(base, value) (DMA_TCD15_BITER_ELINKYES_REG(base) = (value))
#define DMA_RMW_TCD15_BITER_ELINKYES(base, mask, value) (DMA_WR_TCD15_BITER_ELINKYES(base, (DMA_RD_TCD15_BITER_ELINKYES(base) & ~(mask)) | (value)))
#define DMA_SET_TCD15_BITER_ELINKYES(base, value) (DMA_WR_TCD15_BITER_ELINKYES(base, DMA_RD_TCD15_BITER_ELINKYES(base) |  (value)))
#define DMA_CLR_TCD15_BITER_ELINKYES(base, value) (DMA_WR_TCD15_BITER_ELINKYES(base, DMA_RD_TCD15_BITER_ELINKYES(base) & ~(value)))
#define DMA_TOG_TCD15_BITER_ELINKYES(base, value) (DMA_WR_TCD15_BITER_ELINKYES(base, DMA_RD_TCD15_BITER_ELINKYES(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_TCD15_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_TCD15_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_BITER_ELINKYES_BITER field. */
#define DMA_RD_TCD15_BITER_ELINKYES_BITER(base) ((DMA_TCD15_BITER_ELINKYES_REG(base) & DMA_TCD15_BITER_ELINKYES_BITER_MASK) >> DMA_TCD15_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_TCD15_BITER_ELINKYES_BITER(base) (DMA_RD_TCD15_BITER_ELINKYES_BITER(base))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_TCD15_BITER_ELINKYES_BITER(base, value) (DMA_RMW_TCD15_BITER_ELINKYES(base, DMA_TCD15_BITER_ELINKYES_BITER_MASK, DMA_TCD15_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_TCD15_BITER_ELINKYES_BITER(base, value) (DMA_WR_TCD15_BITER_ELINKYES_BITER(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_TCD15_BITER_ELINKYES_LINKCH(base) ((DMA_TCD15_BITER_ELINKYES_REG(base) & DMA_TCD15_BITER_ELINKYES_LINKCH_MASK) >> DMA_TCD15_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_TCD15_BITER_ELINKYES_LINKCH(base) (DMA_RD_TCD15_BITER_ELINKYES_LINKCH(base))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_TCD15_BITER_ELINKYES_LINKCH(base, value) (DMA_RMW_TCD15_BITER_ELINKYES(base, DMA_TCD15_BITER_ELINKYES_LINKCH_MASK, DMA_TCD15_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_TCD15_BITER_ELINKYES_LINKCH(base, value) (DMA_WR_TCD15_BITER_ELINKYES_LINKCH(base, value))
/*@}*/

/*!
 * @name Register DMA_TCD15_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_TCD15_BITER_ELINKYES_ELINK field. */
#define DMA_RD_TCD15_BITER_ELINKYES_ELINK(base) ((DMA_TCD15_BITER_ELINKYES_REG(base) & DMA_TCD15_BITER_ELINKYES_ELINK_MASK) >> DMA_TCD15_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_TCD15_BITER_ELINKYES_ELINK(base) (BITBAND_ACCESS16(&DMA_TCD15_BITER_ELINKYES_REG(base), DMA_TCD15_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_TCD15_BITER_ELINKYES_ELINK(base, value) (DMA_RMW_TCD15_BITER_ELINKYES(base, DMA_TCD15_BITER_ELINKYES_ELINK_MASK, DMA_TCD15_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_TCD15_BITER_ELINKYES_ELINK(base, value) (BITBAND_ACCESS16(&DMA_TCD15_BITER_ELINKYES_REG(base), DMA_TCD15_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*
 * S32K144 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration register
 */

#define DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX_IDX (0U) /*!< Instance number for DMAMUX. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) |  (value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) & ~(value)))
#define DMAMUX_TOG_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (DMAMUX_RD_CHCFG_SOURCE(base, index))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (DMAMUX_WR_CHCFG_SOURCE(base, index, value))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0b0 - Triggering is disabled. If triggering is disabled and ENBL is set,
 *     the DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 0b1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_TRIG field. */
#define DMAMUX_RD_CHCFG_TRIG(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_TRIG_MASK) >> DMAMUX_CHCFG_TRIG_SHIFT)
#define DMAMUX_BRD_CHCFG_TRIG(base, index) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT))

/*! @brief Set the TRIG field to a new value. */
#define DMAMUX_WR_CHCFG_TRIG(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_TRIG_MASK, DMAMUX_CHCFG_TRIG(value)))
#define DMAMUX_BWR_CHCFG_TRIG(base, index, value) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0b0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 0b1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT) = (value))
/*@}*/

/*
 * S32K144 EWM
 *
 * External Watchdog Monitor
 *
 * Registers defined in this header file:
 * - EWM_CTRL - Control Register
 * - EWM_SERV - Service Register
 * - EWM_CMPL - Compare Low Register
 * - EWM_CMPH - Compare High Register
 * - EWM_CLKPRESCALER - Clock Prescaler Register
 */

#define EWM_INSTANCE_COUNT (1U) /*!< Number of instances of the EWM module. */
#define EWM_IDX (0U) /*!< Instance number for EWM. */

/*******************************************************************************
 * EWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CTRL register is cleared by any reset. INEN, ASSIN and EWMEN bits can be
 * written once after a CPU reset. Modifying these bits more than once, generates
 * a bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CTRL register
 */
/*@{*/
#define EWM_RD_CTRL(base)        (EWM_CTRL_REG(base))
#define EWM_WR_CTRL(base, value) (EWM_CTRL_REG(base) = (value))
#define EWM_RMW_CTRL(base, mask, value) (EWM_WR_CTRL(base, (EWM_RD_CTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) |  (value)))
#define EWM_CLR_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) & ~(value)))
#define EWM_TOG_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CTRL bitfields
 */

/*!
 * @name Register EWM_CTRL, field EWMEN[0] (RW)
 *
 * This bit when set, enables the EWM module. This resets the EWM counter to
 * zero and deasserts the EWM_out signal. Clearing EWMEN bit disables the EWM, and
 * therefore it cannot be enabled until a reset occurs, due to the write-once
 * nature of this bit.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_EWMEN field. */
#define EWM_RD_CTRL_EWMEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_EWMEN_MASK) >> EWM_CTRL_EWMEN_SHIFT)
#define EWM_BRD_CTRL_EWMEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT))

/*! @brief Set the EWMEN field to a new value. */
#define EWM_WR_CTRL_EWMEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_EWMEN_MASK, EWM_CTRL_EWMEN(value)))
#define EWM_BWR_CTRL_EWMEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field ASSIN[1] (RW)
 *
 * Default assert state of the EWM_in signal is logic zero. Setting ASSIN bit
 * inverts the assert state to a logic one.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_ASSIN field. */
#define EWM_RD_CTRL_ASSIN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_ASSIN_MASK) >> EWM_CTRL_ASSIN_SHIFT)
#define EWM_BRD_CTRL_ASSIN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT))

/*! @brief Set the ASSIN field to a new value. */
#define EWM_WR_CTRL_ASSIN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_ASSIN_MASK, EWM_CTRL_ASSIN(value)))
#define EWM_BWR_CTRL_ASSIN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INEN[2] (RW)
 *
 * This bit when set, enables the EWM_in port.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INEN field. */
#define EWM_RD_CTRL_INEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INEN_MASK) >> EWM_CTRL_INEN_SHIFT)
#define EWM_BRD_CTRL_INEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT))

/*! @brief Set the INEN field to a new value. */
#define EWM_WR_CTRL_INEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INEN_MASK, EWM_CTRL_INEN(value)))
#define EWM_BWR_CTRL_INEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INTEN[3] (RW)
 *
 * This bit when set and EWM_out is asserted, an interrupt request is generated.
 * To de-assert interrupt request, user should clear this bit by writing 0.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INTEN field. */
#define EWM_RD_CTRL_INTEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INTEN_MASK) >> EWM_CTRL_INTEN_SHIFT)
#define EWM_BRD_CTRL_INTEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT))

/*! @brief Set the INTEN field to a new value. */
#define EWM_WR_CTRL_INTEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INTEN_MASK, EWM_CTRL_INTEN(value)))
#define EWM_BWR_CTRL_INTEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * EWM_SERV - Service Register
 ******************************************************************************/

/*!
 * @brief EWM_SERV - Service Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERV register provides the interface from the CPU to the EWM module. It
 * is write-only and reads of this register return zero.
 */
/*!
 * @name Constants and macros for entire EWM_SERV register
 */
/*@{*/
#define EWM_RD_SERV(base)        (EWM_SERV_REG(base))
#define EWM_WR_SERV(base, value) (EWM_SERV_REG(base) = (value))
#define EWM_RMW_SERV(base, mask, value) (EWM_WR_SERV(base, (EWM_RD_SERV(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPL - Compare Low Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPL - Compare Low Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CMPL register is reset to zero after a CPU reset. This provides no
 * minimum time for the CPU to service the EWM counter. This register can be written
 * only once after a CPU reset. Writing this register more than once generates a
 * bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CMPL register
 */
/*@{*/
#define EWM_RD_CMPL(base)        (EWM_CMPL_REG(base))
#define EWM_WR_CMPL(base, value) (EWM_CMPL_REG(base) = (value))
#define EWM_RMW_CMPL(base, mask, value) (EWM_WR_CMPL(base, (EWM_RD_CMPL(base) & ~(mask)) | (value)))
#define EWM_SET_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) |  (value)))
#define EWM_CLR_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) & ~(value)))
#define EWM_TOG_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPH - Compare High Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPH - Compare High Register (RW)
 *
 * Reset value: 0xFFU
 *
 * The CMPH register is reset to 0xFF after a CPU reset. This provides a maximum
 * of 256 clocks time, for the CPU to service the EWM counter. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. The valid values for CMPH are up to 0xFE
 * because the EWM counter never expires when CMPH = 0xFF. The expiration happens only
 * if EWM counter is greater than CMPH.
 */
/*!
 * @name Constants and macros for entire EWM_CMPH register
 */
/*@{*/
#define EWM_RD_CMPH(base)        (EWM_CMPH_REG(base))
#define EWM_WR_CMPH(base, value) (EWM_CMPH_REG(base) = (value))
#define EWM_RMW_CMPH(base, mask, value) (EWM_WR_CMPH(base, (EWM_RD_CMPH(base) & ~(mask)) | (value)))
#define EWM_SET_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) |  (value)))
#define EWM_CLR_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) & ~(value)))
#define EWM_TOG_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * EWM_CLKPRESCALER - Clock Prescaler Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKPRESCALER - Clock Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKPRESCALER register is reset to 0x00 after a CPU reset. This register
 * can be written only once after a CPU reset. Writing this register more than
 * once generates a bus transfer error. Write the required prescaler value before
 * enabling the EWM. The implementation of this register is chip-specific. See the
 * Chip Configuration details.
 */
/*!
 * @name Constants and macros for entire EWM_CLKPRESCALER register
 */
/*@{*/
#define EWM_RD_CLKPRESCALER(base) (EWM_CLKPRESCALER_REG(base))
#define EWM_WR_CLKPRESCALER(base, value) (EWM_CLKPRESCALER_REG(base) = (value))
#define EWM_RMW_CLKPRESCALER(base, mask, value) (EWM_WR_CLKPRESCALER(base, (EWM_RD_CLKPRESCALER(base) & ~(mask)) | (value)))
#define EWM_SET_CLKPRESCALER(base, value) (EWM_WR_CLKPRESCALER(base, EWM_RD_CLKPRESCALER(base) |  (value)))
#define EWM_CLR_CLKPRESCALER(base, value) (EWM_WR_CLKPRESCALER(base, EWM_RD_CLKPRESCALER(base) & ~(value)))
#define EWM_TOG_CLKPRESCALER(base, value) (EWM_WR_CLKPRESCALER(base, EWM_RD_CLKPRESCALER(base) ^  (value)))
/*@}*/

/*
 * S32K144 FLEXIO
 *
 * The FLEXIO Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - FLEXIO_VERID - Version ID Register
 * - FLEXIO_PARAM - Parameter Register
 * - FLEXIO_CTRL - FlexIO Control Register
 * - FLEXIO_PIN - Pin State Register
 * - FLEXIO_SHIFTSTAT - Shifter Status Register
 * - FLEXIO_SHIFTERR - Shifter Error Register
 * - FLEXIO_TIMSTAT - Timer Status Register
 * - FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 * - FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 * - FLEXIO_TIMIEN - Timer Interrupt Enable Register
 * - FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 * - FLEXIO_SHIFTSTATE - Shifter State Register
 * - FLEXIO_SHIFTCTL - Shifter Control N Register
 * - FLEXIO_SHIFTCFG - Shifter Configuration N Register
 * - FLEXIO_SHIFTBUF - Shifter Buffer N Register
 * - FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register
 * - FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register
 * - FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register
 * - FLEXIO_TIMCTL - Timer Control N Register
 * - FLEXIO_TIMCFG - Timer Configuration N Register
 * - FLEXIO_TIMCMP - Timer Compare N Register
 */

#define FLEXIO_INSTANCE_COUNT (1U) /*!< Number of instances of the FLEXIO module. */
#define FLEXIO_IDX (0U) /*!< Instance number for FLEXIO. */

/*******************************************************************************
 * FLEXIO_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01010001U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_VERID register
 */
/*@{*/
#define FLEXIO_RD_VERID(base)    (FLEXIO_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_VERID bitfields
 */

/*!
 * @name Register FLEXIO_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000000 - Standard features implemented.
 * - 0b0000000000000001 - Supports state, logic and parallel modes.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_FEATURE field. */
#define FLEXIO_RD_VERID_FEATURE(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_FEATURE_MASK) >> FLEXIO_VERID_FEATURE_SHIFT)
#define FLEXIO_BRD_VERID_FEATURE(base) (FLEXIO_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_MINOR field. */
#define FLEXIO_RD_VERID_MINOR(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_MINOR_MASK) >> FLEXIO_VERID_MINOR_SHIFT)
#define FLEXIO_BRD_VERID_MINOR(base) (FLEXIO_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_MAJOR field. */
#define FLEXIO_RD_VERID_MAJOR(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_MAJOR_MASK) >> FLEXIO_VERID_MAJOR_SHIFT)
#define FLEXIO_BRD_VERID_MAJOR(base) (FLEXIO_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * FLEXIO_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x04080404U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_PARAM register
 */
/*@{*/
#define FLEXIO_RD_PARAM(base)    (FLEXIO_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_PARAM bitfields
 */

/*!
 * @name Register FLEXIO_PARAM, field SHIFTER[7:0] (RO)
 *
 * Number of Shifters implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_SHIFTER field. */
#define FLEXIO_RD_PARAM_SHIFTER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_SHIFTER_MASK) >> FLEXIO_PARAM_SHIFTER_SHIFT)
#define FLEXIO_BRD_PARAM_SHIFTER(base) (FLEXIO_RD_PARAM_SHIFTER(base))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TIMER[15:8] (RO)
 *
 * Number of Timers implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_TIMER field. */
#define FLEXIO_RD_PARAM_TIMER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_TIMER_MASK) >> FLEXIO_PARAM_TIMER_SHIFT)
#define FLEXIO_BRD_PARAM_TIMER(base) (FLEXIO_RD_PARAM_TIMER(base))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field PIN[23:16] (RO)
 *
 * Number of Pins implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_PIN field. */
#define FLEXIO_RD_PARAM_PIN(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_PIN_MASK) >> FLEXIO_PARAM_PIN_SHIFT)
#define FLEXIO_BRD_PARAM_PIN(base) (FLEXIO_RD_PARAM_PIN(base))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TRIGGER[31:24] (RO)
 *
 * Number of external triggers implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_TRIGGER field. */
#define FLEXIO_RD_PARAM_TRIGGER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_TRIGGER_MASK) >> FLEXIO_PARAM_TRIGGER_SHIFT)
#define FLEXIO_BRD_PARAM_TRIGGER(base) (FLEXIO_RD_PARAM_TRIGGER(base))
/*@}*/

/*******************************************************************************
 * FLEXIO_CTRL - FlexIO Control Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_CTRL - FlexIO Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_CTRL register
 */
/*@{*/
#define FLEXIO_RD_CTRL(base)     (FLEXIO_CTRL_REG(base))
#define FLEXIO_WR_CTRL(base, value) (FLEXIO_CTRL_REG(base) = (value))
#define FLEXIO_RMW_CTRL(base, mask, value) (FLEXIO_WR_CTRL(base, (FLEXIO_RD_CTRL(base) & ~(mask)) | (value)))
#define FLEXIO_SET_CTRL(base, value) (FLEXIO_WR_CTRL(base, FLEXIO_RD_CTRL(base) |  (value)))
#define FLEXIO_CLR_CTRL(base, value) (FLEXIO_WR_CTRL(base, FLEXIO_RD_CTRL(base) & ~(value)))
#define FLEXIO_TOG_CTRL(base, value) (FLEXIO_WR_CTRL(base, FLEXIO_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_CTRL bitfields
 */

/*!
 * @name Register FLEXIO_CTRL, field FLEXEN[0] (RW)
 *
 * Values:
 * - 0b0 - FlexIO module is disabled.
 * - 0b1 - FlexIO module is enabled.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_FLEXEN field. */
#define FLEXIO_RD_CTRL_FLEXEN(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_FLEXEN_MASK) >> FLEXIO_CTRL_FLEXEN_SHIFT)
#define FLEXIO_BRD_CTRL_FLEXEN(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FLEXEN_SHIFT))

/*! @brief Set the FLEXEN field to a new value. */
#define FLEXIO_WR_CTRL_FLEXEN(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_FLEXEN_MASK, FLEXIO_CTRL_FLEXEN(value)))
#define FLEXIO_BWR_CTRL_FLEXEN(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FLEXEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field SWRST[1] (RW)
 *
 * The FlexIO Control Register is not affected by the software reset, all other
 * logic in the FlexIO is affected by the software reset and register accesses
 * are ignored until this bit is cleared. This register bit will remain set until
 * cleared by software, and the reset has cleared in the FlexIO clock domain.
 *
 * Values:
 * - 0b0 - Software reset is disabled
 * - 0b1 - Software reset is enabled, all FlexIO registers except the Control
 *     Register are reset.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_SWRST field. */
#define FLEXIO_RD_CTRL_SWRST(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_SWRST_MASK) >> FLEXIO_CTRL_SWRST_SHIFT)
#define FLEXIO_BRD_CTRL_SWRST(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_SWRST_SHIFT))

/*! @brief Set the SWRST field to a new value. */
#define FLEXIO_WR_CTRL_SWRST(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_SWRST_MASK, FLEXIO_CTRL_SWRST(value)))
#define FLEXIO_BWR_CTRL_SWRST(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_SWRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field FASTACC[2] (RW)
 *
 * Enables fast register accesses to FlexIO registers, but requires the FlexIO
 * clock to be at least twice the frequency of the bus clock.
 *
 * Values:
 * - 0b0 - Configures for normal register accesses to FlexIO
 * - 0b1 - Configures for fast register accesses to FlexIO
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_FASTACC field. */
#define FLEXIO_RD_CTRL_FASTACC(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_FASTACC_MASK) >> FLEXIO_CTRL_FASTACC_SHIFT)
#define FLEXIO_BRD_CTRL_FASTACC(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FASTACC_SHIFT))

/*! @brief Set the FASTACC field to a new value. */
#define FLEXIO_WR_CTRL_FASTACC(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_FASTACC_MASK, FLEXIO_CTRL_FASTACC(value)))
#define FLEXIO_BWR_CTRL_FASTACC(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FASTACC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DBGE[30] (RW)
 *
 * Enables FlexIO operation in Debug mode.
 *
 * Values:
 * - 0b0 - FlexIO is disabled in debug modes.
 * - 0b1 - FlexIO is enabled in debug modes
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_DBGE field. */
#define FLEXIO_RD_CTRL_DBGE(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_DBGE_MASK) >> FLEXIO_CTRL_DBGE_SHIFT)
#define FLEXIO_BRD_CTRL_DBGE(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DBGE_SHIFT))

/*! @brief Set the DBGE field to a new value. */
#define FLEXIO_WR_CTRL_DBGE(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_DBGE_MASK, FLEXIO_CTRL_DBGE(value)))
#define FLEXIO_BWR_CTRL_DBGE(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DBGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DOZEN[31] (RW)
 *
 * Disables FlexIO operation in Doze modes. This field is ignored and the FlexIO
 * always disabled in low-leakage stop modes.
 *
 * Values:
 * - 0b0 - FlexIO enabled in Doze modes.
 * - 0b1 - FlexIO disabled in Doze modes.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_DOZEN field. */
#define FLEXIO_RD_CTRL_DOZEN(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_DOZEN_MASK) >> FLEXIO_CTRL_DOZEN_SHIFT)
#define FLEXIO_BRD_CTRL_DOZEN(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DOZEN_SHIFT))

/*! @brief Set the DOZEN field to a new value. */
#define FLEXIO_WR_CTRL_DOZEN(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_DOZEN_MASK, FLEXIO_CTRL_DOZEN(value)))
#define FLEXIO_BWR_CTRL_DOZEN(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DOZEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FLEXIO_PIN - Pin State Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_PIN - Pin State Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FLEXIO_PIN register
 */
/*@{*/
#define FLEXIO_RD_PIN(base)      (FLEXIO_PIN_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_PIN bitfields
 */

/*!
 * @name Register FLEXIO_PIN, field PDI[7:0] (RO)
 *
 * Returns the input data on each of the FlexIO pins.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PIN_PDI field. */
#define FLEXIO_RD_PIN_PDI(base) ((FLEXIO_PIN_REG(base) & FLEXIO_PIN_PDI_MASK) >> FLEXIO_PIN_PDI_SHIFT)
#define FLEXIO_BRD_PIN_PDI(base) (FLEXIO_RD_PIN_PDI(base))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSTAT - Shifter Status Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSTAT - Shifter Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSTAT register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSTAT(base) (FLEXIO_SHIFTSTAT_REG(base))
#define FLEXIO_WR_SHIFTSTAT(base, value) (FLEXIO_SHIFTSTAT_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSTAT(base, mask, value) (FLEXIO_WR_SHIFTSTAT(base, (FLEXIO_RD_SHIFTSTAT(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSTAT(base, value) (FLEXIO_WR_SHIFTSTAT(base, FLEXIO_RD_SHIFTSTAT(base) |  (value)))
#define FLEXIO_CLR_SHIFTSTAT(base, value) (FLEXIO_WR_SHIFTSTAT(base, FLEXIO_RD_SHIFTSTAT(base) & ~(value)))
#define FLEXIO_TOG_SHIFTSTAT(base, value) (FLEXIO_WR_SHIFTSTAT(base, FLEXIO_RD_SHIFTSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSTAT bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSTAT, field SSF[3:0] (W1C)
 *
 * The shifter status flag is updated when one of the following events occurs:
 * For SMOD=Receive, the status flag is set when SHIFTBUF has been loaded with
 * data from Shifter (SHIFTBUF is full), and the status flag is cleared when
 * SHIFTBUF register is read. For SMOD=Transmit, the status flag is set when SHIFTBUF
 * data has been transferred to the Shifter (SHIFTBUF is empty) or when initially
 * configured for SMOD=Transmit, and the status flag is cleared when the SHIFTBUF
 * register is written. For SMOD=Match Store, the status flag is set when a match
 * has occured between SHIFTBUF and Shifter, and the status flag is cleared when
 * the SHIFTBUF register is read. For SMOD=Match Continuous, returns the current
 * match result between the SHIFTBUF and Shifter. For SMOD=State, the status
 * flag for a shifter will set when it is selected by the current state pointer. For
 * SMOD=Logic, returns the current value of the programmable logic block output.
 * The status flag can also be cleared by writing a logic one to the flag for
 * all modes except Match Continuous/State /Logic.
 *
 * Values:
 * - 0b0000 - Status flag is clear
 * - 0b0001 - Status flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSTAT_SSF field. */
#define FLEXIO_RD_SHIFTSTAT_SSF(base) ((FLEXIO_SHIFTSTAT_REG(base) & FLEXIO_SHIFTSTAT_SSF_MASK) >> FLEXIO_SHIFTSTAT_SSF_SHIFT)
#define FLEXIO_BRD_SHIFTSTAT_SSF(base) (FLEXIO_RD_SHIFTSTAT_SSF(base))

/*! @brief Set the SSF field to a new value. */
#define FLEXIO_WR_SHIFTSTAT_SSF(base, value) (FLEXIO_RMW_SHIFTSTAT(base, FLEXIO_SHIFTSTAT_SSF_MASK, FLEXIO_SHIFTSTAT_SSF(value)))
#define FLEXIO_BWR_SHIFTSTAT_SSF(base, value) (FLEXIO_WR_SHIFTSTAT_SSF(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTERR - Shifter Error Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTERR - Shifter Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTERR register
 */
/*@{*/
#define FLEXIO_RD_SHIFTERR(base) (FLEXIO_SHIFTERR_REG(base))
#define FLEXIO_WR_SHIFTERR(base, value) (FLEXIO_SHIFTERR_REG(base) = (value))
#define FLEXIO_RMW_SHIFTERR(base, mask, value) (FLEXIO_WR_SHIFTERR(base, (FLEXIO_RD_SHIFTERR(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTERR(base, value) (FLEXIO_WR_SHIFTERR(base, FLEXIO_RD_SHIFTERR(base) |  (value)))
#define FLEXIO_CLR_SHIFTERR(base, value) (FLEXIO_WR_SHIFTERR(base, FLEXIO_RD_SHIFTERR(base) & ~(value)))
#define FLEXIO_TOG_SHIFTERR(base, value) (FLEXIO_WR_SHIFTERR(base, FLEXIO_RD_SHIFTERR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTERR bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTERR, field SEF[3:0] (W1C)
 *
 * The shifter error flag is set when one of the following events occurs: For
 * SMOD=Receive, indicates Shifter was ready to store new data into SHIFTBUF before
 * the previous data was read from SHIFTBUF (SHIFTBUF Overrun), or indicates
 * that the received start or stop bit does not match the expected value. For
 * SMOD=Transmit, indicates Shifter was ready to load new data from SHIFTBUF before new
 * data had been written into SHIFTBUF (SHIFTBUF Underrun). For SMOD=Match
 * Store, indicates a match event occured before the previous match data was read from
 * SHIFTBUF (SHIFTBUF Overrun). For SMOD=Match Continuous, the error flag is set
 * when a match has occured between SHIFTBUF and Shifter. For SMOD=Logic, the
 * error flag is set when the output of the programmable logic block has asserted.
 * Can be cleared by writing logic one to the flag. For SMOD=Match Continuous,
 * can also be cleared when the SHIFTBUF register is read.
 *
 * Values:
 * - 0b0000 - Shifter Error Flag is clear
 * - 0b0001 - Shifter Error Flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTERR_SEF field. */
#define FLEXIO_RD_SHIFTERR_SEF(base) ((FLEXIO_SHIFTERR_REG(base) & FLEXIO_SHIFTERR_SEF_MASK) >> FLEXIO_SHIFTERR_SEF_SHIFT)
#define FLEXIO_BRD_SHIFTERR_SEF(base) (FLEXIO_RD_SHIFTERR_SEF(base))

/*! @brief Set the SEF field to a new value. */
#define FLEXIO_WR_SHIFTERR_SEF(base, value) (FLEXIO_RMW_SHIFTERR(base, FLEXIO_SHIFTERR_SEF_MASK, FLEXIO_SHIFTERR_SEF(value)))
#define FLEXIO_BWR_SHIFTERR_SEF(base, value) (FLEXIO_WR_SHIFTERR_SEF(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMSTAT - Timer Status Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMSTAT - Timer Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMSTAT register
 */
/*@{*/
#define FLEXIO_RD_TIMSTAT(base)  (FLEXIO_TIMSTAT_REG(base))
#define FLEXIO_WR_TIMSTAT(base, value) (FLEXIO_TIMSTAT_REG(base) = (value))
#define FLEXIO_RMW_TIMSTAT(base, mask, value) (FLEXIO_WR_TIMSTAT(base, (FLEXIO_RD_TIMSTAT(base) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMSTAT(base, value) (FLEXIO_WR_TIMSTAT(base, FLEXIO_RD_TIMSTAT(base) |  (value)))
#define FLEXIO_CLR_TIMSTAT(base, value) (FLEXIO_WR_TIMSTAT(base, FLEXIO_RD_TIMSTAT(base) & ~(value)))
#define FLEXIO_TOG_TIMSTAT(base, value) (FLEXIO_WR_TIMSTAT(base, FLEXIO_RD_TIMSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMSTAT bitfields
 */

/*!
 * @name Register FLEXIO_TIMSTAT, field TSF[3:0] (W1C)
 *
 * The timer status flag sets depending on the timer mode, and can be cleared by
 * writing logic one to the flag. In 8-bit counter mode, the timer status flag
 * is set when the upper 8-bit counter equals zero and decrements, this also
 * causes the counter to reload with the value in the compare register. In 8-bit PWM
 * mode, the timer status flag is set when the upper 8-bit counter equals zero and
 * decrements, this also causes the counter to reload with the value in the
 * compare register.. In 16-bit counter mode, the timer status flag is set when the
 * 16-bit counter equals zero and decrements, this also causes the counter to
 * reload with the value in the compare register..
 *
 * Values:
 * - 0b0000 - Timer Status Flag is clear
 * - 0b0001 - Timer Status Flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMSTAT_TSF field. */
#define FLEXIO_RD_TIMSTAT_TSF(base) ((FLEXIO_TIMSTAT_REG(base) & FLEXIO_TIMSTAT_TSF_MASK) >> FLEXIO_TIMSTAT_TSF_SHIFT)
#define FLEXIO_BRD_TIMSTAT_TSF(base) (FLEXIO_RD_TIMSTAT_TSF(base))

/*! @brief Set the TSF field to a new value. */
#define FLEXIO_WR_TIMSTAT_TSF(base, value) (FLEXIO_RMW_TIMSTAT(base, FLEXIO_TIMSTAT_TSF_MASK, FLEXIO_TIMSTAT_TSF(value)))
#define FLEXIO_BWR_TIMSTAT_TSF(base, value) (FLEXIO_WR_TIMSTAT_TSF(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSIEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSIEN(base) (FLEXIO_SHIFTSIEN_REG(base))
#define FLEXIO_WR_SHIFTSIEN(base, value) (FLEXIO_SHIFTSIEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSIEN(base, mask, value) (FLEXIO_WR_SHIFTSIEN(base, (FLEXIO_RD_SHIFTSIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSIEN(base, value) (FLEXIO_WR_SHIFTSIEN(base, FLEXIO_RD_SHIFTSIEN(base) |  (value)))
#define FLEXIO_CLR_SHIFTSIEN(base, value) (FLEXIO_WR_SHIFTSIEN(base, FLEXIO_RD_SHIFTSIEN(base) & ~(value)))
#define FLEXIO_TOG_SHIFTSIEN(base, value) (FLEXIO_WR_SHIFTSIEN(base, FLEXIO_RD_SHIFTSIEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSIEN, field SSIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding SSF is set.
 *
 * Values:
 * - 0b0000 - Shifter Status Flag interrupt disabled
 * - 0b0001 - Shifter Status Flag interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSIEN_SSIE field. */
#define FLEXIO_RD_SHIFTSIEN_SSIE(base) ((FLEXIO_SHIFTSIEN_REG(base) & FLEXIO_SHIFTSIEN_SSIE_MASK) >> FLEXIO_SHIFTSIEN_SSIE_SHIFT)
#define FLEXIO_BRD_SHIFTSIEN_SSIE(base) (FLEXIO_RD_SHIFTSIEN_SSIE(base))

/*! @brief Set the SSIE field to a new value. */
#define FLEXIO_WR_SHIFTSIEN_SSIE(base, value) (FLEXIO_RMW_SHIFTSIEN(base, FLEXIO_SHIFTSIEN_SSIE_MASK, FLEXIO_SHIFTSIEN_SSIE(value)))
#define FLEXIO_BWR_SHIFTSIEN_SSIE(base, value) (FLEXIO_WR_SHIFTSIEN_SSIE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTEIEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTEIEN(base) (FLEXIO_SHIFTEIEN_REG(base))
#define FLEXIO_WR_SHIFTEIEN(base, value) (FLEXIO_SHIFTEIEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTEIEN(base, mask, value) (FLEXIO_WR_SHIFTEIEN(base, (FLEXIO_RD_SHIFTEIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTEIEN(base, value) (FLEXIO_WR_SHIFTEIEN(base, FLEXIO_RD_SHIFTEIEN(base) |  (value)))
#define FLEXIO_CLR_SHIFTEIEN(base, value) (FLEXIO_WR_SHIFTEIEN(base, FLEXIO_RD_SHIFTEIEN(base) & ~(value)))
#define FLEXIO_TOG_SHIFTEIEN(base, value) (FLEXIO_WR_SHIFTEIEN(base, FLEXIO_RD_SHIFTEIEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTEIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTEIEN, field SEIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding SEF is set.
 *
 * Values:
 * - 0b0000 - Shifter Error Flag interrupt disabled
 * - 0b0001 - Shifter Error Flag interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTEIEN_SEIE field. */
#define FLEXIO_RD_SHIFTEIEN_SEIE(base) ((FLEXIO_SHIFTEIEN_REG(base) & FLEXIO_SHIFTEIEN_SEIE_MASK) >> FLEXIO_SHIFTEIEN_SEIE_SHIFT)
#define FLEXIO_BRD_SHIFTEIEN_SEIE(base) (FLEXIO_RD_SHIFTEIEN_SEIE(base))

/*! @brief Set the SEIE field to a new value. */
#define FLEXIO_WR_SHIFTEIEN_SEIE(base, value) (FLEXIO_RMW_SHIFTEIEN(base, FLEXIO_SHIFTEIEN_SEIE_MASK, FLEXIO_SHIFTEIEN_SEIE(value)))
#define FLEXIO_BWR_SHIFTEIEN_SEIE(base, value) (FLEXIO_WR_SHIFTEIEN_SEIE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMIEN - Timer Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMIEN - Timer Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMIEN register
 */
/*@{*/
#define FLEXIO_RD_TIMIEN(base)   (FLEXIO_TIMIEN_REG(base))
#define FLEXIO_WR_TIMIEN(base, value) (FLEXIO_TIMIEN_REG(base) = (value))
#define FLEXIO_RMW_TIMIEN(base, mask, value) (FLEXIO_WR_TIMIEN(base, (FLEXIO_RD_TIMIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMIEN(base, value) (FLEXIO_WR_TIMIEN(base, FLEXIO_RD_TIMIEN(base) |  (value)))
#define FLEXIO_CLR_TIMIEN(base, value) (FLEXIO_WR_TIMIEN(base, FLEXIO_RD_TIMIEN(base) & ~(value)))
#define FLEXIO_TOG_TIMIEN(base, value) (FLEXIO_WR_TIMIEN(base, FLEXIO_RD_TIMIEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMIEN bitfields
 */

/*!
 * @name Register FLEXIO_TIMIEN, field TEIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding TSF is set.
 *
 * Values:
 * - 0b0000 - Timer Status Flag interrupt is disabled
 * - 0b0001 - Timer Status Flag interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMIEN_TEIE field. */
#define FLEXIO_RD_TIMIEN_TEIE(base) ((FLEXIO_TIMIEN_REG(base) & FLEXIO_TIMIEN_TEIE_MASK) >> FLEXIO_TIMIEN_TEIE_SHIFT)
#define FLEXIO_BRD_TIMIEN_TEIE(base) (FLEXIO_RD_TIMIEN_TEIE(base))

/*! @brief Set the TEIE field to a new value. */
#define FLEXIO_WR_TIMIEN_TEIE(base, value) (FLEXIO_RMW_TIMIEN(base, FLEXIO_TIMIEN_TEIE_MASK, FLEXIO_TIMIEN_TEIE(value)))
#define FLEXIO_BWR_TIMIEN_TEIE(base, value) (FLEXIO_WR_TIMIEN_TEIE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSDEN - Shifter Status DMA Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSDEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSDEN(base) (FLEXIO_SHIFTSDEN_REG(base))
#define FLEXIO_WR_SHIFTSDEN(base, value) (FLEXIO_SHIFTSDEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSDEN(base, mask, value) (FLEXIO_WR_SHIFTSDEN(base, (FLEXIO_RD_SHIFTSDEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSDEN(base, value) (FLEXIO_WR_SHIFTSDEN(base, FLEXIO_RD_SHIFTSDEN(base) |  (value)))
#define FLEXIO_CLR_SHIFTSDEN(base, value) (FLEXIO_WR_SHIFTSDEN(base, FLEXIO_RD_SHIFTSDEN(base) & ~(value)))
#define FLEXIO_TOG_SHIFTSDEN(base, value) (FLEXIO_WR_SHIFTSDEN(base, FLEXIO_RD_SHIFTSDEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSDEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSDEN, field SSDE[3:0] (RW)
 *
 * Enables DMA request generation when corresponding SSF is set.
 *
 * Values:
 * - 0b0000 - Shifter Status Flag DMA request is disabled
 * - 0b0001 - Shifter Status Flag DMA request is enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSDEN_SSDE field. */
#define FLEXIO_RD_SHIFTSDEN_SSDE(base) ((FLEXIO_SHIFTSDEN_REG(base) & FLEXIO_SHIFTSDEN_SSDE_MASK) >> FLEXIO_SHIFTSDEN_SSDE_SHIFT)
#define FLEXIO_BRD_SHIFTSDEN_SSDE(base) (FLEXIO_RD_SHIFTSDEN_SSDE(base))

/*! @brief Set the SSDE field to a new value. */
#define FLEXIO_WR_SHIFTSDEN_SSDE(base, value) (FLEXIO_RMW_SHIFTSDEN(base, FLEXIO_SHIFTSDEN_SSDE_MASK, FLEXIO_SHIFTSDEN_SSDE(value)))
#define FLEXIO_BWR_SHIFTSDEN_SSDE(base, value) (FLEXIO_WR_SHIFTSDEN_SSDE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSTATE - Shifter State Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSTATE - Shifter State Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSTATE register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSTATE(base) (FLEXIO_SHIFTSTATE_REG(base))
#define FLEXIO_WR_SHIFTSTATE(base, value) (FLEXIO_SHIFTSTATE_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSTATE(base, mask, value) (FLEXIO_WR_SHIFTSTATE(base, (FLEXIO_RD_SHIFTSTATE(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSTATE(base, value) (FLEXIO_WR_SHIFTSTATE(base, FLEXIO_RD_SHIFTSTATE(base) |  (value)))
#define FLEXIO_CLR_SHIFTSTATE(base, value) (FLEXIO_WR_SHIFTSTATE(base, FLEXIO_RD_SHIFTSTATE(base) & ~(value)))
#define FLEXIO_TOG_SHIFTSTATE(base, value) (FLEXIO_WR_SHIFTSTATE(base, FLEXIO_RD_SHIFTSTATE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSTATE bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSTATE, field STATE[2:0] (RW)
 *
 * The current state field maintains a pointer to keep track of the current
 * Shifter (configured for State mode) enabled to drive outputs and compute the next
 * state. See 'State Mode' section for more detail.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSTATE_STATE field. */
#define FLEXIO_RD_SHIFTSTATE_STATE(base) ((FLEXIO_SHIFTSTATE_REG(base) & FLEXIO_SHIFTSTATE_STATE_MASK) >> FLEXIO_SHIFTSTATE_STATE_SHIFT)
#define FLEXIO_BRD_SHIFTSTATE_STATE(base) (FLEXIO_RD_SHIFTSTATE_STATE(base))

/*! @brief Set the STATE field to a new value. */
#define FLEXIO_WR_SHIFTSTATE_STATE(base, value) (FLEXIO_RMW_SHIFTSTATE(base, FLEXIO_SHIFTSTATE_STATE_MASK, FLEXIO_SHIFTSTATE_STATE(value)))
#define FLEXIO_BWR_SHIFTSTATE_STATE(base, value) (FLEXIO_WR_SHIFTSTATE_STATE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTCTL - Shifter Control N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTCTL - Shifter Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCTL register
 */
/*@{*/
#define FLEXIO_RD_SHIFTCTL(base, index) (FLEXIO_SHIFTCTL_REG(base, index))
#define FLEXIO_WR_SHIFTCTL(base, index, value) (FLEXIO_SHIFTCTL_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTCTL(base, index, mask, value) (FLEXIO_WR_SHIFTCTL(base, index, (FLEXIO_RD_SHIFTCTL(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTCTL(base, index, value) (FLEXIO_WR_SHIFTCTL(base, index, FLEXIO_RD_SHIFTCTL(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTCTL(base, index, value) (FLEXIO_WR_SHIFTCTL(base, index, FLEXIO_RD_SHIFTCTL(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTCTL(base, index, value) (FLEXIO_WR_SHIFTCTL(base, index, FLEXIO_RD_SHIFTCTL(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCTL bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCTL, field SMOD[2:0] (RW)
 *
 * Configures the mode of the Shifter.
 *
 * Values:
 * - 0b000 - Disabled.
 * - 0b001 - Receive mode. Captures the current Shifter content into the
 *     SHIFTBUF on expiration of the Timer.
 * - 0b010 - Transmit mode. Load SHIFTBUF contents into the Shifter on
 *     expiration of the Timer.
 * - 0b011 - Reserved.
 * - 0b100 - Match Store mode. Shifter data is compared to SHIFTBUF content on
 *     expiration of the Timer.
 * - 0b101 - Match Continuous mode. Shifter data is continuously compared to
 *     SHIFTBUF contents.
 * - 0b110 - State mode. SHIFTBUF contents are used for storing programmable
 *     state attributes.
 * - 0b111 - Logic mode. SHIFTBUF contents are used for implementing
 *     programmable logic look up table.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_SMOD field. */
#define FLEXIO_RD_SHIFTCTL_SMOD(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_SMOD_MASK) >> FLEXIO_SHIFTCTL_SMOD_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_SMOD(base, index) (FLEXIO_RD_SHIFTCTL_SMOD(base, index))

/*! @brief Set the SMOD field to a new value. */
#define FLEXIO_WR_SHIFTCTL_SMOD(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_SMOD_MASK, FLEXIO_SHIFTCTL_SMOD(value)))
#define FLEXIO_BWR_SHIFTCTL_SMOD(base, index, value) (FLEXIO_WR_SHIFTCTL_SMOD(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINPOL[7] (RW)
 *
 * Values:
 * - 0b0 - Pin is active high
 * - 0b1 - Pin is active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINPOL field. */
#define FLEXIO_RD_SHIFTCTL_PINPOL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINPOL_MASK) >> FLEXIO_SHIFTCTL_PINPOL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_PINPOL_SHIFT))

/*! @brief Set the PINPOL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINPOL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINPOL_MASK, FLEXIO_SHIFTCTL_PINPOL(value)))
#define FLEXIO_BWR_SHIFTCTL_PINPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_PINPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINSEL[10:8] (RW)
 *
 * Selects which pin is used by the Shifter input or output.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINSEL field. */
#define FLEXIO_RD_SHIFTCTL_PINSEL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINSEL_MASK) >> FLEXIO_SHIFTCTL_PINSEL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINSEL(base, index) (FLEXIO_RD_SHIFTCTL_PINSEL(base, index))

/*! @brief Set the PINSEL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINSEL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINSEL_MASK, FLEXIO_SHIFTCTL_PINSEL(value)))
#define FLEXIO_BWR_SHIFTCTL_PINSEL(base, index, value) (FLEXIO_WR_SHIFTCTL_PINSEL(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 0b00 - Shifter pin output disabled
 * - 0b01 - Shifter pin open drain or bidirectional output enable
 * - 0b10 - Shifter pin bidirectional output data
 * - 0b11 - Shifter pin output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINCFG field. */
#define FLEXIO_RD_SHIFTCTL_PINCFG(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINCFG_MASK) >> FLEXIO_SHIFTCTL_PINCFG_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINCFG(base, index) (FLEXIO_RD_SHIFTCTL_PINCFG(base, index))

/*! @brief Set the PINCFG field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINCFG(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINCFG_MASK, FLEXIO_SHIFTCTL_PINCFG(value)))
#define FLEXIO_BWR_SHIFTCTL_PINCFG(base, index, value) (FLEXIO_WR_SHIFTCTL_PINCFG(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field TIMPOL[23] (RW)
 *
 * Values:
 * - 0b0 - Shift on posedge of Shift clock
 * - 0b1 - Shift on negedge of Shift clock
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_TIMPOL field. */
#define FLEXIO_RD_SHIFTCTL_TIMPOL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_TIMPOL_MASK) >> FLEXIO_SHIFTCTL_TIMPOL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_TIMPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_TIMPOL_SHIFT))

/*! @brief Set the TIMPOL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_TIMPOL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_TIMPOL_MASK, FLEXIO_SHIFTCTL_TIMPOL(value)))
#define FLEXIO_BWR_SHIFTCTL_TIMPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_TIMPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field TIMSEL[25:24] (RW)
 *
 * Selects which Timer is used for controlling the logic/shift register and
 * generating the Shift clock.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_TIMSEL field. */
#define FLEXIO_RD_SHIFTCTL_TIMSEL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_TIMSEL_MASK) >> FLEXIO_SHIFTCTL_TIMSEL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_TIMSEL(base, index) (FLEXIO_RD_SHIFTCTL_TIMSEL(base, index))

/*! @brief Set the TIMSEL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_TIMSEL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_TIMSEL_MASK, FLEXIO_SHIFTCTL_TIMSEL(value)))
#define FLEXIO_BWR_SHIFTCTL_TIMSEL(base, index, value) (FLEXIO_WR_SHIFTCTL_TIMSEL(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTCFG - Shifter Configuration N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTCFG - Shifter Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCFG register
 */
/*@{*/
#define FLEXIO_RD_SHIFTCFG(base, index) (FLEXIO_SHIFTCFG_REG(base, index))
#define FLEXIO_WR_SHIFTCFG(base, index, value) (FLEXIO_SHIFTCFG_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTCFG(base, index, mask, value) (FLEXIO_WR_SHIFTCFG(base, index, (FLEXIO_RD_SHIFTCFG(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTCFG(base, index, value) (FLEXIO_WR_SHIFTCFG(base, index, FLEXIO_RD_SHIFTCFG(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTCFG(base, index, value) (FLEXIO_WR_SHIFTCFG(base, index, FLEXIO_RD_SHIFTCFG(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTCFG(base, index, value) (FLEXIO_WR_SHIFTCFG(base, index, FLEXIO_RD_SHIFTCFG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCFG bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCFG, field SSTART[1:0] (RW)
 *
 * For SMOD=Transmit, this field allows automatic start bit insertion if the
 * selected timer has also enabled a start bit. For SMOD=Receive or Match Store,
 * this field allows automatic start bit checking if the selected timer has also
 * enabled a start bit. For SMOD=State, this field is used to disable state outputs.
 * See 'State Mode' section for more detail. For SMOD=Logic, this field is used
 * to mask logic pin inputs. See 'Logic Mode' section for more detail.
 *
 * Values:
 * - 0b00 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on enable
 * - 0b01 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on first shift
 * - 0b10 - Transmitter outputs start bit value 0 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 0
 * - 0b11 - Transmitter outputs start bit value 1 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 1
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_SSTART field. */
#define FLEXIO_RD_SHIFTCFG_SSTART(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_SSTART_MASK) >> FLEXIO_SHIFTCFG_SSTART_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_SSTART(base, index) (FLEXIO_RD_SHIFTCFG_SSTART(base, index))

/*! @brief Set the SSTART field to a new value. */
#define FLEXIO_WR_SHIFTCFG_SSTART(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_SSTART_MASK, FLEXIO_SHIFTCFG_SSTART(value)))
#define FLEXIO_BWR_SHIFTCFG_SSTART(base, index, value) (FLEXIO_WR_SHIFTCFG_SSTART(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field SSTOP[5:4] (RW)
 *
 * For SMOD=Transmit, this field allows automatic stop bit insertion if the
 * selected timer has also enabled a stop bit. For SMOD=Receive or Match Store, this
 * field allows automatic stop bit checking if the selected timer has also
 * enabled a stop bit. For SMOD=State, this field is used to disable state outputs. See
 * 'State Mode' section for more detail. For SMOD=Logic, this field is used to
 * mask logic pin inputs. See 'Logic Mode' section for more detail.
 *
 * Values:
 * - 0b00 - Stop bit disabled for transmitter/receiver/match store
 * - 0b01 - Reserved for transmitter/receiver/match store
 * - 0b10 - Transmitter outputs stop bit value 0 on store, receiver/match store
 *     sets error flag if stop bit is not 0
 * - 0b11 - Transmitter outputs stop bit value 1 on store, receiver/match store
 *     sets error flag if stop bit is not 1
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_SSTOP field. */
#define FLEXIO_RD_SHIFTCFG_SSTOP(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_SSTOP_MASK) >> FLEXIO_SHIFTCFG_SSTOP_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_SSTOP(base, index) (FLEXIO_RD_SHIFTCFG_SSTOP(base, index))

/*! @brief Set the SSTOP field to a new value. */
#define FLEXIO_WR_SHIFTCFG_SSTOP(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_SSTOP_MASK, FLEXIO_SHIFTCFG_SSTOP(value)))
#define FLEXIO_BWR_SHIFTCFG_SSTOP(base, index, value) (FLEXIO_WR_SHIFTCFG_SSTOP(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field INSRC[8] (RW)
 *
 * Selects the input source for the shifter.
 *
 * Values:
 * - 0b0 - Pin
 * - 0b1 - Shifter N+1 Output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_INSRC field. */
#define FLEXIO_RD_SHIFTCFG_INSRC(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_INSRC_MASK) >> FLEXIO_SHIFTCFG_INSRC_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_INSRC(base, index) (BITBAND_ACCESS32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_INSRC_SHIFT))

/*! @brief Set the INSRC field to a new value. */
#define FLEXIO_WR_SHIFTCFG_INSRC(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_INSRC_MASK, FLEXIO_SHIFTCFG_INSRC(value)))
#define FLEXIO_BWR_SHIFTCFG_INSRC(base, index, value) (BITBAND_ACCESS32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_INSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field PWIDTH[20:16] (RW)
 *
 * For all Shifters, this register field configures the number of bits to be
 * shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4-bit shift for
 * PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift for PWIDTH=8...15
 * 32-bit shift for PWIDTH=16...31 For Shifters which support parallel transmit
 * (SHIFTER0, SHIFTER4) or parallel receive (SHIFTER3, SHIFTER7), this register field,
 * together with PSEL, also selects the pins to be driven or sampled on each
 * Shift clock as follows: FXIO_D[PSEL+PWIDTH]:FXIO_D[PSEL] For SMOD=State, this
 * field is used to disable state outputs. See 'State Mode' section for more detail.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_PWIDTH field. */
#define FLEXIO_RD_SHIFTCFG_PWIDTH(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_PWIDTH_MASK) >> FLEXIO_SHIFTCFG_PWIDTH_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_PWIDTH(base, index) (FLEXIO_RD_SHIFTCFG_PWIDTH(base, index))

/*! @brief Set the PWIDTH field to a new value. */
#define FLEXIO_WR_SHIFTCFG_PWIDTH(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_PWIDTH_MASK, FLEXIO_SHIFTCFG_PWIDTH(value)))
#define FLEXIO_BWR_SHIFTCFG_PWIDTH(base, index, value) (FLEXIO_WR_SHIFTCFG_PWIDTH(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUF - Shifter Buffer N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUF - Shifter Buffer N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUF register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUF(base, index) (FLEXIO_SHIFTBUF_REG(base, index))
#define FLEXIO_WR_SHIFTBUF(base, index, value) (FLEXIO_SHIFTBUF_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUF(base, index, mask, value) (FLEXIO_WR_SHIFTBUF(base, index, (FLEXIO_RD_SHIFTBUF(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUF(base, index, value) (FLEXIO_WR_SHIFTBUF(base, index, FLEXIO_RD_SHIFTBUF(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUF(base, index, value) (FLEXIO_WR_SHIFTBUF(base, index, FLEXIO_RD_SHIFTBUF(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUF(base, index, value) (FLEXIO_WR_SHIFTBUF(base, index, FLEXIO_RD_SHIFTBUF(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBIS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBIS(base, index) (FLEXIO_SHIFTBUFBIS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBIS(base, index, value) (FLEXIO_SHIFTBUFBIS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBIS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, (FLEXIO_RD_SHIFTBUFBIS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBIS(base, index, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, FLEXIO_RD_SHIFTBUFBIS(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUFBIS(base, index, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, FLEXIO_RD_SHIFTBUFBIS(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUFBIS(base, index, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, FLEXIO_RD_SHIFTBUFBIS(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBYS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBYS(base, index) (FLEXIO_SHIFTBUFBYS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBYS(base, index, value) (FLEXIO_SHIFTBUFBYS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBYS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, (FLEXIO_RD_SHIFTBUFBYS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBYS(base, index, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, FLEXIO_RD_SHIFTBUFBYS(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUFBYS(base, index, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, FLEXIO_RD_SHIFTBUFBYS(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUFBYS(base, index, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, FLEXIO_RD_SHIFTBUFBYS(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBBS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBBS(base, index) (FLEXIO_SHIFTBUFBBS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBBS(base, index, value) (FLEXIO_SHIFTBUFBBS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBBS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, (FLEXIO_RD_SHIFTBUFBBS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBBS(base, index, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, FLEXIO_RD_SHIFTBUFBBS(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUFBBS(base, index, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, FLEXIO_RD_SHIFTBUFBBS(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUFBBS(base, index, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, FLEXIO_RD_SHIFTBUFBBS(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCTL - Timer Control N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCTL - Timer Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCTL register
 */
/*@{*/
#define FLEXIO_RD_TIMCTL(base, index) (FLEXIO_TIMCTL_REG(base, index))
#define FLEXIO_WR_TIMCTL(base, index, value) (FLEXIO_TIMCTL_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCTL(base, index, mask, value) (FLEXIO_WR_TIMCTL(base, index, (FLEXIO_RD_TIMCTL(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCTL(base, index, value) (FLEXIO_WR_TIMCTL(base, index, FLEXIO_RD_TIMCTL(base, index) |  (value)))
#define FLEXIO_CLR_TIMCTL(base, index, value) (FLEXIO_WR_TIMCTL(base, index, FLEXIO_RD_TIMCTL(base, index) & ~(value)))
#define FLEXIO_TOG_TIMCTL(base, index, value) (FLEXIO_WR_TIMCTL(base, index, FLEXIO_RD_TIMCTL(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCTL bitfields
 */

/*!
 * @name Register FLEXIO_TIMCTL, field TIMOD[1:0] (RW)
 *
 * In 8-bit counter mode, the lower 8-bits of the counter and compare register
 * are used to configure the baud rate of the timer shift clock and the upper
 * 8-bits are used to configure the shifter bit count. In 8-bit PWM mode, the lower
 * 8-bits of the counter and compare register are used to configure the high
 * period of the timer shift clock and the upper 8-bits are used to configure the low
 * period of the timer shift clock. The shifter bit count is configured using
 * another timer or external signal. In 16-bit counter mode, the full 16-bits of the
 * counter and compare register are used to configure either the baud rate of
 * the shift clock or the shifter bit count.
 *
 * Values:
 * - 0b00 - Timer Disabled.
 * - 0b01 - Dual 8-bit counters baud/bit mode.
 * - 0b10 - Dual 8-bit counters PWM mode.
 * - 0b11 - Single 16-bit counter mode.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TIMOD field. */
#define FLEXIO_RD_TIMCTL_TIMOD(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TIMOD_MASK) >> FLEXIO_TIMCTL_TIMOD_SHIFT)
#define FLEXIO_BRD_TIMCTL_TIMOD(base, index) (FLEXIO_RD_TIMCTL_TIMOD(base, index))

/*! @brief Set the TIMOD field to a new value. */
#define FLEXIO_WR_TIMCTL_TIMOD(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TIMOD_MASK, FLEXIO_TIMCTL_TIMOD(value)))
#define FLEXIO_BWR_TIMCTL_TIMOD(base, index, value) (FLEXIO_WR_TIMCTL_TIMOD(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINPOL[7] (RW)
 *
 * Values:
 * - 0b0 - Pin is active high
 * - 0b1 - Pin is active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINPOL field. */
#define FLEXIO_RD_TIMCTL_PINPOL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINPOL_MASK) >> FLEXIO_TIMCTL_PINPOL_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_PINPOL_SHIFT))

/*! @brief Set the PINPOL field to a new value. */
#define FLEXIO_WR_TIMCTL_PINPOL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINPOL_MASK, FLEXIO_TIMCTL_PINPOL(value)))
#define FLEXIO_BWR_TIMCTL_PINPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_PINPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINSEL[10:8] (RW)
 *
 * Selects which pin is used by the Timer input or output.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINSEL field. */
#define FLEXIO_RD_TIMCTL_PINSEL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINSEL_MASK) >> FLEXIO_TIMCTL_PINSEL_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINSEL(base, index) (FLEXIO_RD_TIMCTL_PINSEL(base, index))

/*! @brief Set the PINSEL field to a new value. */
#define FLEXIO_WR_TIMCTL_PINSEL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINSEL_MASK, FLEXIO_TIMCTL_PINSEL(value)))
#define FLEXIO_BWR_TIMCTL_PINSEL(base, index, value) (FLEXIO_WR_TIMCTL_PINSEL(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 0b00 - Timer pin output disabled
 * - 0b01 - Timer pin open drain or bidirectional output enable
 * - 0b10 - Timer pin bidirectional output data
 * - 0b11 - Timer pin output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINCFG field. */
#define FLEXIO_RD_TIMCTL_PINCFG(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINCFG_MASK) >> FLEXIO_TIMCTL_PINCFG_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINCFG(base, index) (FLEXIO_RD_TIMCTL_PINCFG(base, index))

/*! @brief Set the PINCFG field to a new value. */
#define FLEXIO_WR_TIMCTL_PINCFG(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINCFG_MASK, FLEXIO_TIMCTL_PINCFG(value)))
#define FLEXIO_BWR_TIMCTL_PINCFG(base, index, value) (FLEXIO_WR_TIMCTL_PINCFG(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGSRC[22] (RW)
 *
 * Values:
 * - 0b0 - External trigger selected
 * - 0b1 - Internal trigger selected
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGSRC field. */
#define FLEXIO_RD_TIMCTL_TRGSRC(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGSRC_MASK) >> FLEXIO_TIMCTL_TRGSRC_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGSRC(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGSRC_SHIFT))

/*! @brief Set the TRGSRC field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGSRC(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGSRC_MASK, FLEXIO_TIMCTL_TRGSRC(value)))
#define FLEXIO_BWR_TIMCTL_TRGSRC(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGPOL[23] (RW)
 *
 * Values:
 * - 0b0 - Trigger active high
 * - 0b1 - Trigger active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGPOL field. */
#define FLEXIO_RD_TIMCTL_TRGPOL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGPOL_MASK) >> FLEXIO_TIMCTL_TRGPOL_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGPOL_SHIFT))

/*! @brief Set the TRGPOL field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGPOL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGPOL_MASK, FLEXIO_TIMCTL_TRGPOL(value)))
#define FLEXIO_BWR_TIMCTL_TRGPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGSEL[27:24] (RW)
 *
 * The valid values for TRGSEL will depend on the FLEXIO_PARAM register. When
 * TRGSRC = 1, the valid values for N will depend on PIN, TIMER, SHIFTER fields in
 * the FLEXIO_PARAM register. When TRGSRC = 0, valid values for N will depend on
 * TRIGGER field in FLEXIO_PARAM register. Refer to the chip configuration
 * section for external trigger selection. The internal trigger selection is configured
 * as follows.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGSEL field. */
#define FLEXIO_RD_TIMCTL_TRGSEL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGSEL_MASK) >> FLEXIO_TIMCTL_TRGSEL_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGSEL(base, index) (FLEXIO_RD_TIMCTL_TRGSEL(base, index))

/*! @brief Set the TRGSEL field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGSEL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGSEL_MASK, FLEXIO_TIMCTL_TRGSEL(value)))
#define FLEXIO_BWR_TIMCTL_TRGSEL(base, index, value) (FLEXIO_WR_TIMCTL_TRGSEL(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCFG - Timer Configuration N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCFG - Timer Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The options to enable or disable the timer using the Timer N-1 enable or
 * disable are reserved when N is evenly divisible by 4 (eg: Timer 0).
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCFG register
 */
/*@{*/
#define FLEXIO_RD_TIMCFG(base, index) (FLEXIO_TIMCFG_REG(base, index))
#define FLEXIO_WR_TIMCFG(base, index, value) (FLEXIO_TIMCFG_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCFG(base, index, mask, value) (FLEXIO_WR_TIMCFG(base, index, (FLEXIO_RD_TIMCFG(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCFG(base, index, value) (FLEXIO_WR_TIMCFG(base, index, FLEXIO_RD_TIMCFG(base, index) |  (value)))
#define FLEXIO_CLR_TIMCFG(base, index, value) (FLEXIO_WR_TIMCFG(base, index, FLEXIO_RD_TIMCFG(base, index) & ~(value)))
#define FLEXIO_TOG_TIMCFG(base, index, value) (FLEXIO_WR_TIMCFG(base, index, FLEXIO_RD_TIMCFG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCFG bitfields
 */

/*!
 * @name Register FLEXIO_TIMCFG, field TSTART[1] (RW)
 *
 * When start bit is enabled, configured shifters will output the contents of
 * the start bit when the timer is enabled and the timer counter will reload from
 * the compare register on the first rising edge of the shift clock.
 *
 * Values:
 * - 0b0 - Start bit disabled
 * - 0b1 - Start bit enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TSTART field. */
#define FLEXIO_RD_TIMCFG_TSTART(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TSTART_MASK) >> FLEXIO_TIMCFG_TSTART_SHIFT)
#define FLEXIO_BRD_TIMCFG_TSTART(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TSTART_SHIFT))

/*! @brief Set the TSTART field to a new value. */
#define FLEXIO_WR_TIMCFG_TSTART(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TSTART_MASK, FLEXIO_TIMCFG_TSTART(value)))
#define FLEXIO_BWR_TIMCFG_TSTART(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TSTART_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TSTOP[5:4] (RW)
 *
 * The stop bit can be added on a timer compare (between each word) or on a
 * timer disable. When stop bit is enabled, configured shifters will output the
 * contents of the stop bit when the timer is disabled. When stop bit is enabled on
 * timer disable, the timer remains disabled until the next rising edge of the
 * shift clock. If configured for both timer compare and timer disable, only one stop
 * bit is inserted on timer disable.
 *
 * Values:
 * - 0b00 - Stop bit disabled
 * - 0b01 - Stop bit is enabled on timer compare
 * - 0b10 - Stop bit is enabled on timer disable
 * - 0b11 - Stop bit is enabled on timer compare and timer disable
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TSTOP field. */
#define FLEXIO_RD_TIMCFG_TSTOP(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TSTOP_MASK) >> FLEXIO_TIMCFG_TSTOP_SHIFT)
#define FLEXIO_BRD_TIMCFG_TSTOP(base, index) (FLEXIO_RD_TIMCFG_TSTOP(base, index))

/*! @brief Set the TSTOP field to a new value. */
#define FLEXIO_WR_TIMCFG_TSTOP(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TSTOP_MASK, FLEXIO_TIMCFG_TSTOP(value)))
#define FLEXIO_BWR_TIMCFG_TSTOP(base, index, value) (FLEXIO_WR_TIMCFG_TSTOP(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMENA[10:8] (RW)
 *
 * Configures the condition that causes the Timer to be enabled and start
 * decrementing.
 *
 * Values:
 * - 0b000 - Timer always enabled
 * - 0b001 - Timer enabled on Timer N-1 enable
 * - 0b010 - Timer enabled on Trigger high
 * - 0b011 - Timer enabled on Trigger high and Pin high
 * - 0b100 - Timer enabled on Pin rising edge
 * - 0b101 - Timer enabled on Pin rising edge and Trigger high
 * - 0b110 - Timer enabled on Trigger rising edge
 * - 0b111 - Timer enabled on Trigger rising or falling edge
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMENA field. */
#define FLEXIO_RD_TIMCFG_TIMENA(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMENA_MASK) >> FLEXIO_TIMCFG_TIMENA_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMENA(base, index) (FLEXIO_RD_TIMCFG_TIMENA(base, index))

/*! @brief Set the TIMENA field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMENA(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMENA_MASK, FLEXIO_TIMCFG_TIMENA(value)))
#define FLEXIO_BWR_TIMCFG_TIMENA(base, index, value) (FLEXIO_WR_TIMCFG_TIMENA(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMDIS[14:12] (RW)
 *
 * Configures the condition that causes the Timer to be disabled and stop
 * decrementing.
 *
 * Values:
 * - 0b000 - Timer never disabled
 * - 0b001 - Timer disabled on Timer N-1 disable
 * - 0b010 - Timer disabled on Timer compare
 * - 0b011 - Timer disabled on Timer compare and Trigger Low
 * - 0b100 - Timer disabled on Pin rising or falling edge
 * - 0b101 - Timer disabled on Pin rising or falling edge provided Trigger is
 *     high
 * - 0b110 - Timer disabled on Trigger falling edge
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMDIS field. */
#define FLEXIO_RD_TIMCFG_TIMDIS(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMDIS_MASK) >> FLEXIO_TIMCFG_TIMDIS_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMDIS(base, index) (FLEXIO_RD_TIMCFG_TIMDIS(base, index))

/*! @brief Set the TIMDIS field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMDIS(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMDIS_MASK, FLEXIO_TIMCFG_TIMDIS(value)))
#define FLEXIO_BWR_TIMCFG_TIMDIS(base, index, value) (FLEXIO_WR_TIMCFG_TIMDIS(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMRST[18:16] (RW)
 *
 * Configures the condition that causes the timer counter (and optionally the
 * timer output) to be reset. In 8-bit counter mode, the timer reset will only
 * reset the lower 8-bits that configure the baud rate. In all other modes, the timer
 * reset will reset the full 16-bits of the counter.
 *
 * Values:
 * - 0b000 - Timer never reset
 * - 0b001 - Reserved
 * - 0b010 - Timer reset on Timer Pin equal to Timer Output
 * - 0b011 - Timer reset on Timer Trigger equal to Timer Output
 * - 0b100 - Timer reset on Timer Pin rising edge
 * - 0b101 - Reserved
 * - 0b110 - Timer reset on Trigger rising edge
 * - 0b111 - Timer reset on Trigger rising or falling edge
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMRST field. */
#define FLEXIO_RD_TIMCFG_TIMRST(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMRST_MASK) >> FLEXIO_TIMCFG_TIMRST_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMRST(base, index) (FLEXIO_RD_TIMCFG_TIMRST(base, index))

/*! @brief Set the TIMRST field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMRST(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMRST_MASK, FLEXIO_TIMCFG_TIMRST(value)))
#define FLEXIO_BWR_TIMCFG_TIMRST(base, index, value) (FLEXIO_WR_TIMCFG_TIMRST(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMDEC[21:20] (RW)
 *
 * Configures the source of the Timer decrement and the source of the Shift
 * clock.
 *
 * Values:
 * - 0b00 - Decrement counter on FlexIO clock, Shift clock equals Timer output.
 * - 0b01 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Timer output.
 * - 0b10 - Decrement counter on Pin input (both edges), Shift clock equals Pin
 *     input.
 * - 0b11 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Trigger input.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMDEC field. */
#define FLEXIO_RD_TIMCFG_TIMDEC(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMDEC_MASK) >> FLEXIO_TIMCFG_TIMDEC_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMDEC(base, index) (FLEXIO_RD_TIMCFG_TIMDEC(base, index))

/*! @brief Set the TIMDEC field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMDEC(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMDEC_MASK, FLEXIO_TIMCFG_TIMDEC(value)))
#define FLEXIO_BWR_TIMCFG_TIMDEC(base, index, value) (FLEXIO_WR_TIMCFG_TIMDEC(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMOUT[25:24] (RW)
 *
 * Configures the initial state of the Timer Output and whether it is affected
 * by the Timer reset.
 *
 * Values:
 * - 0b00 - Timer output is logic one when enabled and is not affected by timer
 *     reset
 * - 0b01 - Timer output is logic zero when enabled and is not affected by timer
 *     reset
 * - 0b10 - Timer output is logic one when enabled and on timer reset
 * - 0b11 - Timer output is logic zero when enabled and on timer reset
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMOUT field. */
#define FLEXIO_RD_TIMCFG_TIMOUT(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMOUT_MASK) >> FLEXIO_TIMCFG_TIMOUT_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMOUT(base, index) (FLEXIO_RD_TIMCFG_TIMOUT(base, index))

/*! @brief Set the TIMOUT field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMOUT(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMOUT_MASK, FLEXIO_TIMCFG_TIMOUT(value)))
#define FLEXIO_BWR_TIMCFG_TIMOUT(base, index, value) (FLEXIO_WR_TIMCFG_TIMOUT(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCMP - Timer Compare N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCMP - Timer Compare N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCMP register
 */
/*@{*/
#define FLEXIO_RD_TIMCMP(base, index) (FLEXIO_TIMCMP_REG(base, index))
#define FLEXIO_WR_TIMCMP(base, index, value) (FLEXIO_TIMCMP_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCMP(base, index, mask, value) (FLEXIO_WR_TIMCMP(base, index, (FLEXIO_RD_TIMCMP(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCMP(base, index, value) (FLEXIO_WR_TIMCMP(base, index, FLEXIO_RD_TIMCMP(base, index) |  (value)))
#define FLEXIO_CLR_TIMCMP(base, index, value) (FLEXIO_WR_TIMCMP(base, index, FLEXIO_RD_TIMCMP(base, index) & ~(value)))
#define FLEXIO_TOG_TIMCMP(base, index, value) (FLEXIO_WR_TIMCMP(base, index, FLEXIO_RD_TIMCMP(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCMP bitfields
 */

/*!
 * @name Register FLEXIO_TIMCMP, field CMP[15:0] (RW)
 *
 * The timer compare value is loaded into the timer counter when the timer is
 * first enabled, when the timer is reset and when the timer decrements down to
 * zero. In dual 8-bit counters baud/bit mode, the lower 8-bits configures the baud
 * rate divider equal to (CMP[7:0] + 1) * 2. The upper 8-bits configure the
 * number of bits in each word equal to (CMP[15:8] + 1) / 2. In dual 8-bit counters
 * PWM mode, the lower 8-bits configure the high period of the output to (CMP[7:0]
 * + 1) * 2. The upper 8-bits configure the low period of the output to
 * (CMP[15:8] + 1) * 2. In 16-bit counter mode, the compare value can be used to generate
 * the baud rate divider (if shift clock source is timer output) to equal
 * (CMP[15:0] + 1) * 2. When the shift clock source is a pin or trigger input, the
 * compare register is used to set the number of bits in each word equal to (CMP[15:0]
 * + 1) / 2.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCMP_CMP field. */
#define FLEXIO_RD_TIMCMP_CMP(base, index) ((FLEXIO_TIMCMP_REG(base, index) & FLEXIO_TIMCMP_CMP_MASK) >> FLEXIO_TIMCMP_CMP_SHIFT)
#define FLEXIO_BRD_TIMCMP_CMP(base, index) (FLEXIO_RD_TIMCMP_CMP(base, index))

/*! @brief Set the CMP field to a new value. */
#define FLEXIO_WR_TIMCMP_CMP(base, index, value) (FLEXIO_RMW_TIMCMP(base, index, FLEXIO_TIMCMP_CMP_MASK, FLEXIO_TIMCMP_CMP(value)))
#define FLEXIO_BWR_TIMCMP_CMP(base, index, value) (FLEXIO_WR_TIMCMP_CMP(base, index, value))
/*@}*/

/*
 * S32K144 FTFE
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFE_FSTAT - Flash Status Register
 * - FTFE_FCNFG - Flash Configuration Register
 * - FTFE_FSEC - Flash Security Register
 * - FTFE_FOPT - Flash Option Register
 * - FTFE_FCCOB - Flash Common Command Object Registers
 * - FTFE_FPROT - Program Flash Protection Registers
 * - FTFE_FEPROT - EEPROM Protection Register
 * - FTFE_FDPROT - Data Flash Protection Register
 * - FTFE_FERSTAT - Flash Error Status Register
 * - FTFE_FERCNFG - Flash Error Configuration Register
 */

#define FTFE_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFE module. */
#define FTFE_IDX (0U) /*!< Instance number for FTFE. */

/*******************************************************************************
 * FTFE_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFE_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the FTFE module. The
 * CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The MGSTAT0
 * bit is read only. The unassigned bits read 0 and are not writable. When set, the
 * Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in this
 * register prevent the launch of any more commands or writes to the FlexRAM (when
 * EEERDY is set) until the flag is cleared (by writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFE_FSTAT register
 */
/*@{*/
#define FTFE_RD_FSTAT(base)      (FTFE_FSTAT_REG(base))
#define FTFE_WR_FSTAT(base, value) (FTFE_FSTAT_REG(base) = (value))
#define FTFE_RMW_FSTAT(base, mask, value) (FTFE_WR_FSTAT(base, (FTFE_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFE_SET_FSTAT(base, value) (FTFE_WR_FSTAT(base, FTFE_RD_FSTAT(base) |  (value)))
#define FTFE_CLR_FSTAT(base, value) (FTFE_WR_FSTAT(base, FTFE_RD_FSTAT(base) & ~(value)))
#define FTFE_TOG_FSTAT(base, value) (FTFE_WR_FSTAT(base, FTFE_RD_FSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FSTAT bitfields
 */

/*!
 * @name Register FTFE_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of an
 * FTFE command or during the flash reset sequence. As a status flag, this bit
 * cannot (and need not) be cleared by the user like the other error flags in this
 * register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the previous
 * result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_MGSTAT0 field. */
#define FTFE_RD_FSTAT_MGSTAT0(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_MGSTAT0_MASK) >> FTFE_FSTAT_MGSTAT0_SHIFT)
#define FTFE_BRD_FSTAT_MGSTAT0(base) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_MGSTAT0_SHIFT))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field FPVIOL[4] (W1C)
 *
 * The FPVIOL error bit indicates an attempt was made to program or erase an
 * address in a protected area of program flash or data flash memory during a
 * command write sequence or a write was attempted to a protected area of the FlexRAM
 * while enabled for EEPROM. While FPVIOL is set, the CCIF flag cannot be cleared
 * to launch a command. The FPVIOL bit is cleared by writing a 1 to FPVIOL while
 * CCIF is set. Writing a 0 to the FPVIOL bit has no effect.
 *
 * Values:
 * - 0b0 - No protection violation detected
 * - 0b1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_FPVIOL field. */
#define FTFE_RD_FSTAT_FPVIOL(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_FPVIOL_MASK) >> FTFE_FSTAT_FPVIOL_SHIFT)
#define FTFE_BRD_FSTAT_FPVIOL(base) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_FPVIOL_SHIFT))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFE_WR_FSTAT_FPVIOL(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_RDCOLERR_MASK | FTFE_FSTAT_CCIF_MASK), FTFE_FSTAT_FPVIOL(value)))
#define FTFE_BWR_FSTAT_FPVIOL(base, value) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_FPVIOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field ACCERR[5] (W1C)
 *
 * The ACCERR error bit indicates an illegal access has occurred to an FTFE
 * resource caused by a violation of the command write sequence or issuing an illegal
 * FTFE command. While ACCERR is set, the CCIF flag cannot be cleared to launch
 * a command. The ACCERR bit is cleared by writing a 1 to ACCERR while CCIF is
 * set. Writing a 0 to the ACCERR bit has no effect.
 *
 * Values:
 * - 0b0 - No access error detected
 * - 0b1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_ACCERR field. */
#define FTFE_RD_FSTAT_ACCERR(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_ACCERR_MASK) >> FTFE_FSTAT_ACCERR_SHIFT)
#define FTFE_BRD_FSTAT_ACCERR(base) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_ACCERR_SHIFT))

/*! @brief Set the ACCERR field to a new value. */
#define FTFE_WR_FSTAT_ACCERR(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_RDCOLERR_MASK | FTFE_FSTAT_CCIF_MASK), FTFE_FSTAT_ACCERR(value)))
#define FTFE_BWR_FSTAT_ACCERR(base, value) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_ACCERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field RDCOLERR[6] (W1C)
 *
 * The RDCOLERR error bit indicates that the MCU attempted a read from an FTFE
 * resource that was being manipulated by an FTFE command (CCIF=0). Any
 * simultaneous access is detected as a collision error by the block arbitration logic. The
 * read data in this case cannot be guaranteed. The RDCOLERR bit is cleared by
 * writing a 1 to it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0b0 - No collision error detected
 * - 0b1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_RDCOLERR field. */
#define FTFE_RD_FSTAT_RDCOLERR(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_RDCOLERR_MASK) >> FTFE_FSTAT_RDCOLERR_SHIFT)
#define FTFE_BRD_FSTAT_RDCOLERR(base) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_RDCOLERR_SHIFT))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFE_WR_FSTAT_RDCOLERR(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_RDCOLERR_MASK | FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_CCIF_MASK), FTFE_FSTAT_RDCOLERR(value)))
#define FTFE_BWR_FSTAT_RDCOLERR(base, value) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_RDCOLERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field CCIF[7] (W1C)
 *
 * The CCIF flag indicates that a FTFE command or EEPROM file system operation
 * has completed. The CCIF flag is cleared by writing a 1 to CCIF to launch a
 * command, and CCIF stays low until command completion or command violation. The
 * CCIF flag is also cleared by a successful write to FlexRAM while enabled for EEE,
 * and CCIF stays low until the EEPROM file system has created the associated
 * EEPROM data record. The CCIF bit is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0b0 - FTFE command or EEPROM file system operation in progress
 * - 0b1 - FTFE command or EEPROM file system operation has completed
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_CCIF field. */
#define FTFE_RD_FSTAT_CCIF(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_CCIF_MASK) >> FTFE_FSTAT_CCIF_SHIFT)
#define FTFE_BRD_FSTAT_CCIF(base) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_CCIF_SHIFT))

/*! @brief Set the CCIF field to a new value. */
#define FTFE_WR_FSTAT_CCIF(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_CCIF_MASK | FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_RDCOLERR_MASK), FTFE_FSTAT_CCIF(value)))
#define FTFE_BWR_FSTAT_CCIF(base, value) (BITBAND_ACCESS8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_CCIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTFE_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFE_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * FTFE module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. PFLSH, RAMRDY, and EEERDY are read-only status bits. The reset values for
 * the PFLSH, RAMRDY, and EEERDY bits are determined during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFE_FCNFG register
 */
/*@{*/
#define FTFE_RD_FCNFG(base)      (FTFE_FCNFG_REG(base))
#define FTFE_WR_FCNFG(base, value) (FTFE_FCNFG_REG(base) = (value))
#define FTFE_RMW_FCNFG(base, mask, value) (FTFE_WR_FCNFG(base, (FTFE_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFE_SET_FCNFG(base, value) (FTFE_WR_FCNFG(base, FTFE_RD_FCNFG(base) |  (value)))
#define FTFE_CLR_FCNFG(base, value) (FTFE_WR_FCNFG(base, FTFE_RD_FCNFG(base) & ~(value)))
#define FTFE_TOG_FCNFG(base, value) (FTFE_WR_FCNFG(base, FTFE_RD_FCNFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCNFG bitfields
 */

/*!
 * @name Register FTFE_FCNFG, field EEERDY[0] (RO)
 *
 * This flag indicates if the EEPROM backup data has been copied to the FlexRAM
 * and is therefore available for read access. During the reset sequence, the
 * EEERDY flag remains clear while CCIF=0 and only sets if the FlexNVM block is
 * partitioned for EEPROM.
 *
 * Values:
 * - 0b0 - FlexRAM is not available for EEPROM operation
 * - 0b1 - FlexRAM is available for EEPROM operations where: reads from the
 *     FlexRAM return data previously written to the FlexRAM in EEPROM mode and
 *     writes launch an EEPROM operation to store the written data in the FlexRAM and
 *     EEPROM backup
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_EEERDY field. */
#define FTFE_RD_FCNFG_EEERDY(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_EEERDY_MASK) >> FTFE_FCNFG_EEERDY_SHIFT)
#define FTFE_BRD_FCNFG_EEERDY(base) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_EEERDY_SHIFT))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field RAMRDY[1] (RO)
 *
 * This flag indicates the current status of the FlexRAM. The state of the
 * RAMRDY flag is normally controlled by the Set FlexRAM Function command. During the
 * reset sequence, the RAMRDY flag is cleared if the FlexNVM block is partitioned
 * for EEPROM and will be set if the FlexNVM block is not partitioned for EEPROM
 * . The RAMRDY flag is cleared if the Program Partition command is run to
 * partition the FlexNVM block for EEPROM. The RAMRDY flag sets after completion of
 * the Erase All Blocks command or execution of the erase-all operation triggered
 * external to the FTFE.
 *
 * Values:
 * - 0b0 - FlexRAM is not available for traditional RAM access
 * - 0b1 - FlexRAM is available as traditional RAM only; writes to the FlexRAM
 *     do not trigger EEPROM operations
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_RAMRDY field. */
#define FTFE_RD_FCNFG_RAMRDY(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_RAMRDY_MASK) >> FTFE_FCNFG_RAMRDY_SHIFT)
#define FTFE_BRD_FCNFG_RAMRDY(base) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_RAMRDY_SHIFT))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field PFLSH[2] (RO)
 *
 * Values:
 * - 0b0 - FTFE configuration supports two program flash blocks and two FlexNVM
 *     blocks
 * - 0b1 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_PFLSH field. */
#define FTFE_RD_FCNFG_PFLSH(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_PFLSH_MASK) >> FTFE_FCNFG_PFLSH_SHIFT)
#define FTFE_BRD_FCNFG_PFLSH(base) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_PFLSH_SHIFT))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field ERSSUSP[4] (RW)
 *
 * The ERSSUSP bit allows the user to suspend (interrupt) the Erase Flash Sector
 * command while it is executing.
 *
 * Values:
 * - 0b0 - No suspend requested
 * - 0b1 - Suspend the current Erase Flash Sector command execution
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_ERSSUSP field. */
#define FTFE_RD_FCNFG_ERSSUSP(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_ERSSUSP_MASK) >> FTFE_FCNFG_ERSSUSP_SHIFT)
#define FTFE_BRD_FCNFG_ERSSUSP(base) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_ERSSUSP_SHIFT))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFE_WR_FCNFG_ERSSUSP(base, value) (FTFE_RMW_FCNFG(base, FTFE_FCNFG_ERSSUSP_MASK, FTFE_FCNFG_ERSSUSP(value)))
#define FTFE_BWR_FCNFG_ERSSUSP(base, value) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_ERSSUSP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field ERSAREQ[5] (RO)
 *
 * This bit issues a request to the memory controller to execute the Erase All
 * Blocks command and release security. ERSAREQ is not directly writable but is
 * under indirect user control. Refer to the device's Chip Configuration details on
 * how to request this command. The ERSAREQ bit sets when an erase all request
 * is triggered external to the FTFE and CCIF is set (no command is currently
 * being executed). ERSAREQ is cleared by the FTFE when the operation completes.
 *
 * Values:
 * - 0b0 - No request or request complete
 * - 0b1 - Request to: run the Erase All Blocks command, verify the erased
 *     state, program the security byte in the Flash Configuration Field to the
 *     unsecure state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_ERSAREQ field. */
#define FTFE_RD_FCNFG_ERSAREQ(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_ERSAREQ_MASK) >> FTFE_FCNFG_ERSAREQ_SHIFT)
#define FTFE_BRD_FCNFG_ERSAREQ(base) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_ERSAREQ_SHIFT))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field RDCOLLIE[6] (RW)
 *
 * The RDCOLLIE bit controls interrupt generation when an FTFE read collision
 * error occurs.
 *
 * Values:
 * - 0b0 - Read collision error interrupt disabled
 * - 0b1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever an FTFE read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_RDCOLLIE field. */
#define FTFE_RD_FCNFG_RDCOLLIE(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_RDCOLLIE_MASK) >> FTFE_FCNFG_RDCOLLIE_SHIFT)
#define FTFE_BRD_FCNFG_RDCOLLIE(base) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_RDCOLLIE_SHIFT))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFE_WR_FCNFG_RDCOLLIE(base, value) (FTFE_RMW_FCNFG(base, FTFE_FCNFG_RDCOLLIE_MASK, FTFE_FCNFG_RDCOLLIE(value)))
#define FTFE_BWR_FCNFG_RDCOLLIE(base, value) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_RDCOLLIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field CCIE[7] (RW)
 *
 * The CCIE bit controls interrupt generation when an FTFE command completes.
 *
 * Values:
 * - 0b0 - Command complete interrupt disabled
 * - 0b1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_CCIE field. */
#define FTFE_RD_FCNFG_CCIE(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_CCIE_MASK) >> FTFE_FCNFG_CCIE_SHIFT)
#define FTFE_BRD_FCNFG_CCIE(base) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_CCIE_SHIFT))

/*! @brief Set the CCIE field to a new value. */
#define FTFE_WR_FCNFG_CCIE(base, value) (FTFE_RMW_FCNFG(base, FTFE_FCNFG_CCIE_MASK, FTFE_FCNFG_CCIE(value)))
#define FTFE_BWR_FCNFG_CCIE(base, value) (BITBAND_ACCESS8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_CCIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTFE_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFE_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and FTFE module. During the reset sequence, the register is loaded with the
 * contents of the flash security byte in the Flash Configuration Field located
 * in program flash memory. The Flash basis for the values is signified by X in
 * the reset value.
 */
/*!
 * @name Constants and macros for entire FTFE_FSEC register
 */
/*@{*/
#define FTFE_RD_FSEC(base)       (FTFE_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFE_FSEC bitfields
 */

/*!
 * @name Register FTFE_FSEC, field SEC[1:0] (RO)
 *
 * These bits define the security state of the MCU. In the secure state, the MCU
 * limits access to FTFE module resources. The limitations are defined per
 * device and are detailed in the Chip Configuration details. If the FTFE module is
 * unsecured using backdoor key access, the SEC bits are forced to 10b.
 *
 * Values:
 * - 0b00 - MCU security status is secure
 * - 0b01 - MCU security status is secure
 * - 0b10 - MCU security status is unsecure (The standard shipping condition of
 *     the FTFE is unsecure.)
 * - 0b11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_SEC field. */
#define FTFE_RD_FSEC_SEC(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_SEC_MASK) >> FTFE_FSEC_SEC_SHIFT)
#define FTFE_BRD_FSEC_SEC(base) (FTFE_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register FTFE_FSEC, field FSLACC[3:2] (RO)
 *
 * These bits enable or disable access to the flash memory contents during
 * returned part failure analysis at Freescale. When SEC is secure and FSLACC is
 * denied, access to the program flash contents is denied and any failure analysis
 * performed by Freescale factory test must begin with a full erase to unsecure the
 * part. When access is granted (SEC is unsecure, or SEC is secure and FSLACC is
 * granted), Freescale factory testing has visibility of the current flash
 * contents. The state of the FSLACC bits is only relevant when the SEC bits are set to
 * secure. When the SEC field is set to unsecure, the FSLACC setting does not
 * matter.
 *
 * Values:
 * - 0b00 - Freescale factory access granted
 * - 0b01 - Freescale factory access denied
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_FSLACC field. */
#define FTFE_RD_FSEC_FSLACC(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_FSLACC_MASK) >> FTFE_FSEC_FSLACC_SHIFT)
#define FTFE_BRD_FSEC_FSLACC(base) (FTFE_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register FTFE_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the FTFE module. The state of
 * the MEEN bits is only relevant when the SEC bits are set to secure outside of
 * NVM Normal Mode. When the SEC field is set to unsecure, the MEEN setting does
 * not matter.
 *
 * Values:
 * - 0b00 - Mass erase is enabled
 * - 0b01 - Mass erase is enabled
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_MEEN field. */
#define FTFE_RD_FSEC_MEEN(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_MEEN_MASK) >> FTFE_FSEC_MEEN_SHIFT)
#define FTFE_BRD_FSEC_MEEN(base) (FTFE_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register FTFE_FSEC, field KEYEN[7:6] (RO)
 *
 * These bits enable and disable backdoor key access to the FTFE module.
 *
 * Values:
 * - 0b00 - Backdoor key access disabled
 * - 0b01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_KEYEN field. */
#define FTFE_RD_FSEC_KEYEN(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_KEYEN_MASK) >> FTFE_FSEC_KEYEN_SHIFT)
#define FTFE_BRD_FSEC_KEYEN(base) (FTFE_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * FTFE_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFE_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only. During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFE_FOPT register
 */
/*@{*/
#define FTFE_RD_FOPT(base)       (FTFE_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB register
 */
/*@{*/
#define FTFE_RD_FCCOB(base, index) (FTFE_FCCOB_REG(base, index))
#define FTFE_WR_FCCOB(base, index, value) (FTFE_FCCOB_REG(base, index) = (value))
#define FTFE_RMW_FCCOB(base, index, mask, value) (FTFE_WR_FCCOB(base, index, (FTFE_RD_FCCOB(base, index) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB(base, index, value) (FTFE_WR_FCCOB(base, index, FTFE_RD_FCCOB(base, index) |  (value)))
#define FTFE_CLR_FCCOB(base, index, value) (FTFE_WR_FCCOB(base, index, FTFE_RD_FCCOB(base, index) & ~(value)))
#define FTFE_TOG_FCCOB(base, index, value) (FTFE_WR_FCCOB(base, index, FTFE_RD_FCCOB(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFE_FPROT - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FPROT - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFE_FPROT register
 */
/*@{*/
#define FTFE_RD_FPROT(base, index) (FTFE_FPROT_REG(base, index))
#define FTFE_WR_FPROT(base, index, value) (FTFE_FPROT_REG(base, index) = (value))
#define FTFE_RMW_FPROT(base, index, mask, value) (FTFE_WR_FPROT(base, index, (FTFE_RD_FPROT(base, index) & ~(mask)) | (value)))
#define FTFE_SET_FPROT(base, index, value) (FTFE_WR_FPROT(base, index, FTFE_RD_FPROT(base, index) |  (value)))
#define FTFE_CLR_FPROT(base, index, value) (FTFE_WR_FPROT(base, index, FTFE_RD_FPROT(base, index) & ~(value)))
#define FTFE_TOG_FPROT(base, index, value) (FTFE_WR_FPROT(base, index, FTFE_RD_FPROT(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFE_FEPROT - EEPROM Protection Register
 ******************************************************************************/

/*!
 * @brief FTFE_FEPROT - EEPROM Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FEPROT register defines which EEPROM regions of the FlexRAM are protected
 * against program and erase operations. Protected EEPROM regions cannot have
 * their content changed by writing to it. Unprotected regions can be changed by
 * writing to the FlexRAM.
 */
/*!
 * @name Constants and macros for entire FTFE_FEPROT register
 */
/*@{*/
#define FTFE_RD_FEPROT(base)     (FTFE_FEPROT_REG(base))
#define FTFE_WR_FEPROT(base, value) (FTFE_FEPROT_REG(base) = (value))
#define FTFE_RMW_FEPROT(base, mask, value) (FTFE_WR_FEPROT(base, (FTFE_RD_FEPROT(base) & ~(mask)) | (value)))
#define FTFE_SET_FEPROT(base, value) (FTFE_WR_FEPROT(base, FTFE_RD_FEPROT(base) |  (value)))
#define FTFE_CLR_FEPROT(base, value) (FTFE_WR_FEPROT(base, FTFE_RD_FEPROT(base) & ~(value)))
#define FTFE_TOG_FEPROT(base, value) (FTFE_WR_FEPROT(base, FTFE_RD_FEPROT(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFE_FDPROT - Data Flash Protection Register
 ******************************************************************************/

/*!
 * @brief FTFE_FDPROT - Data Flash Protection Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FDPROT register defines which data flash regions are protected against
 * program and erase operations. Protected Flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by both program and erase
 * operations.
 */
/*!
 * @name Constants and macros for entire FTFE_FDPROT register
 */
/*@{*/
#define FTFE_RD_FDPROT(base)     (FTFE_FDPROT_REG(base))
#define FTFE_WR_FDPROT(base, value) (FTFE_FDPROT_REG(base) = (value))
#define FTFE_RMW_FDPROT(base, mask, value) (FTFE_WR_FDPROT(base, (FTFE_RD_FDPROT(base) & ~(mask)) | (value)))
#define FTFE_SET_FDPROT(base, value) (FTFE_WR_FDPROT(base, FTFE_RD_FDPROT(base) |  (value)))
#define FTFE_CLR_FDPROT(base, value) (FTFE_WR_FDPROT(base, FTFE_RD_FDPROT(base) & ~(value)))
#define FTFE_TOG_FDPROT(base, value) (FTFE_WR_FDPROT(base, FTFE_RD_FDPROT(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFE_FERSTAT - Flash Error Status Register
 ******************************************************************************/

/*!
 * @brief FTFE_FERSTAT - Flash Error Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register reports the detection of uncorrected ECC errors during read
 * access to the FTFE module. The DFDIF flag is readable and writable. The
 * unassigned bits read 0 and are not writable.
 */
/*!
 * @name Constants and macros for entire FTFE_FERSTAT register
 */
/*@{*/
#define FTFE_RD_FERSTAT(base)    (FTFE_FERSTAT_REG(base))
#define FTFE_WR_FERSTAT(base, value) (FTFE_FERSTAT_REG(base) = (value))
#define FTFE_RMW_FERSTAT(base, mask, value) (FTFE_WR_FERSTAT(base, (FTFE_RD_FERSTAT(base) & ~(mask)) | (value)))
#define FTFE_SET_FERSTAT(base, value) (FTFE_WR_FERSTAT(base, FTFE_RD_FERSTAT(base) |  (value)))
#define FTFE_CLR_FERSTAT(base, value) (FTFE_WR_FERSTAT(base, FTFE_RD_FERSTAT(base) & ~(value)))
#define FTFE_TOG_FERSTAT(base, value) (FTFE_WR_FERSTAT(base, FTFE_RD_FERSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FERSTAT bitfields
 */

/*!
 * @name Register FTFE_FERSTAT, field DFDIF[1] (W1C)
 *
 * The DFDIF flag indicates an uncorrectable ECC fault was detected during a
 * valid flash read access from the platform flash controller. The DFDIF flag is
 * cleared by writing a 1 to it. Writing a 0 to DFDIF has no effect.
 *
 * Values:
 * - 0b0 - Double bit fault not detected during a valid flash read access from
 *     the platform flash controller
 * - 0b1 - Double bit fault detected (or FERCNFG[FDFD] is set) during a valid
 *     flash read access from the platform flash controller
 */
/*@{*/
/*! @brief Read current value of the FTFE_FERSTAT_DFDIF field. */
#define FTFE_RD_FERSTAT_DFDIF(base) ((FTFE_FERSTAT_REG(base) & FTFE_FERSTAT_DFDIF_MASK) >> FTFE_FERSTAT_DFDIF_SHIFT)
#define FTFE_BRD_FERSTAT_DFDIF(base) (BITBAND_ACCESS8(&FTFE_FERSTAT_REG(base), FTFE_FERSTAT_DFDIF_SHIFT))

/*! @brief Set the DFDIF field to a new value. */
#define FTFE_WR_FERSTAT_DFDIF(base, value) (FTFE_RMW_FERSTAT(base, FTFE_FERSTAT_DFDIF_MASK, FTFE_FERSTAT_DFDIF(value)))
#define FTFE_BWR_FERSTAT_DFDIF(base, value) (BITBAND_ACCESS8(&FTFE_FERSTAT_REG(base), FTFE_FERSTAT_DFDIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTFE_FERCNFG - Flash Error Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFE_FERCNFG - Flash Error Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register enables the force and interrupt of uncorrected ECC errors
 * detected during read access to the FTFE module. The FDFD and DFDIE bits are
 * readable and writable. The unassigned bits read 0 and are not writable.
 */
/*!
 * @name Constants and macros for entire FTFE_FERCNFG register
 */
/*@{*/
#define FTFE_RD_FERCNFG(base)    (FTFE_FERCNFG_REG(base))
#define FTFE_WR_FERCNFG(base, value) (FTFE_FERCNFG_REG(base) = (value))
#define FTFE_RMW_FERCNFG(base, mask, value) (FTFE_WR_FERCNFG(base, (FTFE_RD_FERCNFG(base) & ~(mask)) | (value)))
#define FTFE_SET_FERCNFG(base, value) (FTFE_WR_FERCNFG(base, FTFE_RD_FERCNFG(base) |  (value)))
#define FTFE_CLR_FERCNFG(base, value) (FTFE_WR_FERCNFG(base, FTFE_RD_FERCNFG(base) & ~(value)))
#define FTFE_TOG_FERCNFG(base, value) (FTFE_WR_FERCNFG(base, FTFE_RD_FERCNFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FERCNFG bitfields
 */

/*!
 * @name Register FTFE_FERCNFG, field DFDIE[1] (RW)
 *
 * The DFDIE bit controls interrupt generation when an uncorrectable ECC fault
 * is detected during a valid flash read access from the platform flash controller.
 *
 * Values:
 * - 0b0 - Double bit fault detect interrupt disabled
 * - 0b1 - Double bit fault detect interrupt enabled. An interrupt request is
 *     generated whenever the FERSTAT[DFDIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFE_FERCNFG_DFDIE field. */
#define FTFE_RD_FERCNFG_DFDIE(base) ((FTFE_FERCNFG_REG(base) & FTFE_FERCNFG_DFDIE_MASK) >> FTFE_FERCNFG_DFDIE_SHIFT)
#define FTFE_BRD_FERCNFG_DFDIE(base) (BITBAND_ACCESS8(&FTFE_FERCNFG_REG(base), FTFE_FERCNFG_DFDIE_SHIFT))

/*! @brief Set the DFDIE field to a new value. */
#define FTFE_WR_FERCNFG_DFDIE(base, value) (FTFE_RMW_FERCNFG(base, FTFE_FERCNFG_DFDIE_MASK, FTFE_FERCNFG_DFDIE(value)))
#define FTFE_BWR_FERCNFG_DFDIE(base, value) (BITBAND_ACCESS8(&FTFE_FERCNFG_REG(base), FTFE_FERCNFG_DFDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFE_FERCNFG, field FDFD[5] (RW)
 *
 * The FDFD bit enables the user to emulate the setting of the FERSTAT[DFDIF]
 * flag to check the associated interrupt routine. The FDFD bit is cleared by
 * writing a 0 to FDFD.
 *
 * Values:
 * - 0b0 - FERSTAT[DFDIF] sets only if a double bit fault is detected during
 *     read access from the platform flash controller
 * - 0b1 - FERSTAT[DFDIF] sets during any valid flash read access from the
 *     platform flash controller. An interrupt request is generated if the DFDIE bit
 *     is set.
 */
/*@{*/
/*! @brief Read current value of the FTFE_FERCNFG_FDFD field. */
#define FTFE_RD_FERCNFG_FDFD(base) ((FTFE_FERCNFG_REG(base) & FTFE_FERCNFG_FDFD_MASK) >> FTFE_FERCNFG_FDFD_SHIFT)
#define FTFE_BRD_FERCNFG_FDFD(base) (BITBAND_ACCESS8(&FTFE_FERCNFG_REG(base), FTFE_FERCNFG_FDFD_SHIFT))

/*! @brief Set the FDFD field to a new value. */
#define FTFE_WR_FERCNFG_FDFD(base, value) (FTFE_RMW_FERCNFG(base, FTFE_FERCNFG_FDFD_MASK, FTFE_FERCNFG_FDFD(value)))
#define FTFE_BWR_FERCNFG_FDFD(base, value) (BITBAND_ACCESS8(&FTFE_FERCNFG_REG(base), FTFE_FERCNFG_FDFD_SHIFT) = (value))
/*@}*/

/*
 * S32K144 FTM
 *
 * FlexTimer Module
 *
 * Registers defined in this header file:
 * - FTM_SC - Status And Control
 * - FTM_CNT - Counter
 * - FTM_MOD - Modulo
 * - FTM_C0SC - Channel (n) Status And Control
 * - FTM_C0V - Channel (n) Value
 * - FTM_C1SC - Channel (n) Status And Control
 * - FTM_C1V - Channel (n) Value
 * - FTM_C2SC - Channel (n) Status And Control
 * - FTM_C2V - Channel (n) Value
 * - FTM_C3SC - Channel (n) Status And Control
 * - FTM_C3V - Channel (n) Value
 * - FTM_C4SC - Channel (n) Status And Control
 * - FTM_C4V - Channel (n) Value
 * - FTM_C5SC - Channel (n) Status And Control
 * - FTM_C5V - Channel (n) Value
 * - FTM_C6SC - Channel (n) Status And Control
 * - FTM_C6V - Channel (n) Value
 * - FTM_C7SC - Channel (n) Status And Control
 * - FTM_C7V - Channel (n) Value
 * - FTM_CNTIN - Counter Initial Value
 * - FTM_STATUS - Capture And Compare Status
 * - FTM_MODE - Features Mode Selection
 * - FTM_SYNC - Synchronization
 * - FTM_OUTINIT - Initial State For Channels Output
 * - FTM_OUTMASK - Output Mask
 * - FTM_COMBINE - Function For Linked Channels
 * - FTM_DEADTIME - Deadtime Insertion Control
 * - FTM_EXTTRIG - FTM External Trigger
 * - FTM_POL - Channels Polarity
 * - FTM_FMS - Fault Mode Status
 * - FTM_FILTER - Input Capture Filter Control
 * - FTM_FLTCTRL - Fault Control
 * - FTM_QDCTRL - Quadrature Decoder Control And Status
 * - FTM_CONF - Configuration
 * - FTM_FLTPOL - FTM Fault Input Polarity
 * - FTM_SYNCONF - Synchronization Configuration
 * - FTM_INVCTRL - FTM Inverting Control
 * - FTM_SWOCTRL - FTM Software Output Control
 * - FTM_PWMLOAD - FTM PWM Load
 * - FTM_HCR - Half Cycle Register
 */

#define FTM_INSTANCE_COUNT (4U) /*!< Number of instances of the FTM module. */
#define FTM0_IDX (0U) /*!< Instance number for FTM0. */
#define FTM1_IDX (1U) /*!< Instance number for FTM1. */
#define FTM2_IDX (2U) /*!< Instance number for FTM2. */
#define FTM3_IDX (3U) /*!< Instance number for FTM3. */

/*******************************************************************************
 * FTM_SC - Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_SC - Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, FTM configuration, clock source, and prescaler factor. This
 * register also contains the output enable control bits and the reload
 * opportunity flag control. These controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_SC register
 */
/*@{*/
#define FTM_RD_SC(base)          (FTM_SC_REG(base))
#define FTM_WR_SC(base, value)   (FTM_SC_REG(base) = (value))
#define FTM_RMW_SC(base, mask, value) (FTM_WR_SC(base, (FTM_RD_SC(base) & ~(mask)) | (value)))
#define FTM_SET_SC(base, value)  (FTM_WR_SC(base, FTM_RD_SC(base) |  (value)))
#define FTM_CLR_SC(base, value)  (FTM_WR_SC(base, FTM_RD_SC(base) & ~(value)))
#define FTM_TOG_SC(base, value)  (FTM_WR_SC(base, FTM_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SC bitfields
 */

/*!
 * @name Register FTM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock source selected by CLKS. The
 * new prescaler factor affects the clock source on the next system clock cycle
 * after the new value is updated into the register bits. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b000 - Divide by 1
 * - 0b001 - Divide by 2
 * - 0b010 - Divide by 4
 * - 0b011 - Divide by 8
 * - 0b100 - Divide by 16
 * - 0b101 - Divide by 32
 * - 0b110 - Divide by 64
 * - 0b111 - Divide by 128
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PS field. */
#define FTM_RD_SC_PS(base)   ((FTM_SC_REG(base) & FTM_SC_PS_MASK) >> FTM_SC_PS_SHIFT)
#define FTM_BRD_SC_PS(base)  (FTM_RD_SC_PS(base))

/*! @brief Set the PS field to a new value. */
#define FTM_WR_SC_PS(base, value) (FTM_RMW_SC(base, FTM_SC_PS_MASK, FTM_SC_PS(value)))
#define FTM_BWR_SC_PS(base, value) (FTM_WR_SC_PS(base, value))
/*@}*/

/*!
 * @name Register FTM_SC, field CLKS[4:3] (RW)
 *
 * Selects one of the three FTM counter clock sources. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b00 - No clock selected. This in effect disables the FTM counter.
 * - 0b01 - System clock
 * - 0b10 - Fixed frequency clock
 * - 0b11 - External clock
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CLKS field. */
#define FTM_RD_SC_CLKS(base) ((FTM_SC_REG(base) & FTM_SC_CLKS_MASK) >> FTM_SC_CLKS_SHIFT)
#define FTM_BRD_SC_CLKS(base) (FTM_RD_SC_CLKS(base))

/*! @brief Set the CLKS field to a new value. */
#define FTM_WR_SC_CLKS(base, value) (FTM_RMW_SC(base, FTM_SC_CLKS_MASK, FTM_SC_CLKS(value)))
#define FTM_BWR_SC_CLKS(base, value) (FTM_WR_SC_CLKS(base, value))
/*@}*/

/*!
 * @name Register FTM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the FTM to operate in Up-Down
 * Counting mode. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 *
 * Values:
 * - 0b0 - FTM counter operates in Up Counting mode.
 * - 0b1 - FTM counter operates in Up-Down Counting mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CPWMS field. */
#define FTM_RD_SC_CPWMS(base) ((FTM_SC_REG(base) & FTM_SC_CPWMS_MASK) >> FTM_SC_CPWMS_SHIFT)
#define FTM_BRD_SC_CPWMS(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_CPWMS_SHIFT))

/*! @brief Set the CPWMS field to a new value. */
#define FTM_WR_SC_CPWMS(base, value) (FTM_RMW_SC(base, FTM_SC_CPWMS_MASK, FTM_SC_CPWMS(value)))
#define FTM_BWR_SC_CPWMS(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_CPWMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field RIE[6] (RW)
 *
 * Enables the reload oportunity interrupt.
 *
 * Values:
 * - 0b0 - Reload interrupt is disabled.
 * - 0b1 - Reload interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_RIE field. */
#define FTM_RD_SC_RIE(base)  ((FTM_SC_REG(base) & FTM_SC_RIE_MASK) >> FTM_SC_RIE_SHIFT)
#define FTM_BRD_SC_RIE(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_RIE_SHIFT))

/*! @brief Set the RIE field to a new value. */
#define FTM_WR_SC_RIE(base, value) (FTM_RMW_SC(base, FTM_SC_RIE_MASK, FTM_SC_RIE(value)))
#define FTM_BWR_SC_RIE(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_RIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field RF[7] (ROWZ)
 *
 * Set by hardware when FTM counter matches the value of a reload point
 * configured by FTMxPWMLOAD register. The RF bit is cleared by reading the SC register
 * while RF is set and then writing a 0 to RF bit. Writing 1 to RF has no effect.
 * If another reload point is reached between the read and write operations, the
 * write operation has no effect; therefore, RF remains set.
 *
 * Values:
 * - 0b0 - FTM counter did not reach a reload point.
 * - 0b1 - FTM counter reached a reload point.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_RF field. */
#define FTM_RD_SC_RF(base)   ((FTM_SC_REG(base) & FTM_SC_RF_MASK) >> FTM_SC_RF_SHIFT)
#define FTM_BRD_SC_RF(base)  (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_RF_SHIFT))

/*! @brief Set the RF field to a new value. */
#define FTM_WR_SC_RF(base, value) (FTM_RMW_SC(base, FTM_SC_RF_MASK, FTM_SC_RF(value)))
#define FTM_BWR_SC_RF(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_RF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field TOIE[8] (RW)
 *
 * Enables FTM overflow interrupts.
 *
 * Values:
 * - 0b0 - Disable TOF interrupts. Use software polling.
 * - 0b1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOIE field. */
#define FTM_RD_SC_TOIE(base) ((FTM_SC_REG(base) & FTM_SC_TOIE_MASK) >> FTM_SC_TOIE_SHIFT)
#define FTM_BRD_SC_TOIE(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOIE_SHIFT))

/*! @brief Set the TOIE field to a new value. */
#define FTM_WR_SC_TOIE(base, value) (FTM_RMW_SC(base, FTM_SC_TOIE_MASK, FTM_SC_TOIE(value)))
#define FTM_BWR_SC_TOIE(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field TOF[9] (ROWZ)
 *
 * Set by hardware when the FTM counter passes the value in the MOD register.
 * The TOF bit is cleared by reading the SC register while TOF is set and then
 * writing a 0 to TOF bit. Writing a 1 to TOF has no effect. If another FTM overflow
 * occurs between the read and write operations, the write operation has no
 * effect; therefore, TOF remains set indicating an overflow has occurred. In this
 * case, a TOF interrupt request is not lost due to the clearing sequence for a
 * previous TOF.
 *
 * Values:
 * - 0b0 - FTM counter has not overflowed.
 * - 0b1 - FTM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOF field. */
#define FTM_RD_SC_TOF(base)  ((FTM_SC_REG(base) & FTM_SC_TOF_MASK) >> FTM_SC_TOF_SHIFT)
#define FTM_BRD_SC_TOF(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOF_SHIFT))

/*! @brief Set the TOF field to a new value. */
#define FTM_WR_SC_TOF(base, value) (FTM_RMW_SC(base, FTM_SC_TOF_MASK, FTM_SC_TOF(value)))
#define FTM_BWR_SC_TOF(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_TOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN0[16] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN0 field. */
#define FTM_RD_SC_PWMEN0(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN0_MASK) >> FTM_SC_PWMEN0_SHIFT)
#define FTM_BRD_SC_PWMEN0(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN0_SHIFT))

/*! @brief Set the PWMEN0 field to a new value. */
#define FTM_WR_SC_PWMEN0(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN0_MASK, FTM_SC_PWMEN0(value)))
#define FTM_BWR_SC_PWMEN0(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN1[17] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN1 field. */
#define FTM_RD_SC_PWMEN1(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN1_MASK) >> FTM_SC_PWMEN1_SHIFT)
#define FTM_BRD_SC_PWMEN1(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN1_SHIFT))

/*! @brief Set the PWMEN1 field to a new value. */
#define FTM_WR_SC_PWMEN1(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN1_MASK, FTM_SC_PWMEN1(value)))
#define FTM_BWR_SC_PWMEN1(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN2[18] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN2 field. */
#define FTM_RD_SC_PWMEN2(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN2_MASK) >> FTM_SC_PWMEN2_SHIFT)
#define FTM_BRD_SC_PWMEN2(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN2_SHIFT))

/*! @brief Set the PWMEN2 field to a new value. */
#define FTM_WR_SC_PWMEN2(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN2_MASK, FTM_SC_PWMEN2(value)))
#define FTM_BWR_SC_PWMEN2(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN3[19] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN3 field. */
#define FTM_RD_SC_PWMEN3(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN3_MASK) >> FTM_SC_PWMEN3_SHIFT)
#define FTM_BRD_SC_PWMEN3(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN3_SHIFT))

/*! @brief Set the PWMEN3 field to a new value. */
#define FTM_WR_SC_PWMEN3(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN3_MASK, FTM_SC_PWMEN3(value)))
#define FTM_BWR_SC_PWMEN3(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN4[20] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN4 field. */
#define FTM_RD_SC_PWMEN4(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN4_MASK) >> FTM_SC_PWMEN4_SHIFT)
#define FTM_BRD_SC_PWMEN4(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN4_SHIFT))

/*! @brief Set the PWMEN4 field to a new value. */
#define FTM_WR_SC_PWMEN4(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN4_MASK, FTM_SC_PWMEN4(value)))
#define FTM_BWR_SC_PWMEN4(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN5[21] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN5 field. */
#define FTM_RD_SC_PWMEN5(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN5_MASK) >> FTM_SC_PWMEN5_SHIFT)
#define FTM_BRD_SC_PWMEN5(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN5_SHIFT))

/*! @brief Set the PWMEN5 field to a new value. */
#define FTM_WR_SC_PWMEN5(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN5_MASK, FTM_SC_PWMEN5(value)))
#define FTM_BWR_SC_PWMEN5(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN6[22] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN6 field. */
#define FTM_RD_SC_PWMEN6(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN6_MASK) >> FTM_SC_PWMEN6_SHIFT)
#define FTM_BRD_SC_PWMEN6(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN6_SHIFT))

/*! @brief Set the PWMEN6 field to a new value. */
#define FTM_WR_SC_PWMEN6(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN6_MASK, FTM_SC_PWMEN6(value)))
#define FTM_BWR_SC_PWMEN6(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SC, field PWMEN7[23] (RW)
 *
 * This bit enables the PWM channel output. This bit should be set to 0 (output
 * disabled) when an input mode is used.
 *
 * Values:
 * - 0b0 - Channel output port is disabled
 * - 0b1 - Channel output port is enabled
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PWMEN7 field. */
#define FTM_RD_SC_PWMEN7(base) ((FTM_SC_REG(base) & FTM_SC_PWMEN7_MASK) >> FTM_SC_PWMEN7_SHIFT)
#define FTM_BRD_SC_PWMEN7(base) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN7_SHIFT))

/*! @brief Set the PWMEN7 field to a new value. */
#define FTM_WR_SC_PWMEN7(base, value) (FTM_RMW_SC(base, FTM_SC_PWMEN7_MASK, FTM_SC_PWMEN7(value)))
#define FTM_BWR_SC_PWMEN7(base, value) (BITBAND_ACCESS32(&FTM_SC_REG(base), FTM_SC_PWMEN7_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief FTM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the FTM counter value. Reset clears the CNT
 * register. Writing any value to COUNT updates the counter with its initial value,
 * CNTIN. When Debug is active, the FTM counter is frozen. This is the value that you
 * may read.
 */
/*!
 * @name Constants and macros for entire FTM_CNT register
 */
/*@{*/
#define FTM_RD_CNT(base)         (FTM_CNT_REG(base))
#define FTM_WR_CNT(base, value)  (FTM_CNT_REG(base) = (value))
#define FTM_RMW_CNT(base, mask, value) (FTM_WR_CNT(base, (FTM_RD_CNT(base) & ~(mask)) | (value)))
#define FTM_SET_CNT(base, value) (FTM_WR_CNT(base, FTM_RD_CNT(base) |  (value)))
#define FTM_CLR_CNT(base, value) (FTM_WR_CNT(base, FTM_RD_CNT(base) & ~(value)))
#define FTM_TOG_CNT(base, value) (FTM_WR_CNT(base, FTM_RD_CNT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNT bitfields
 */

/*!
 * @name Register FTM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CNT_COUNT field. */
#define FTM_RD_CNT_COUNT(base) ((FTM_CNT_REG(base) & FTM_CNT_COUNT_MASK) >> FTM_CNT_COUNT_SHIFT)
#define FTM_BRD_CNT_COUNT(base) (FTM_RD_CNT_COUNT(base))

/*! @brief Set the COUNT field to a new value. */
#define FTM_WR_CNT_COUNT(base, value) (FTM_RMW_CNT(base, FTM_CNT_COUNT_MASK, FTM_CNT_COUNT(value)))
#define FTM_BWR_CNT_COUNT(base, value) (FTM_WR_CNT_COUNT(base, value))
/*@}*/

/*******************************************************************************
 * FTM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief FTM_MOD - Modulo (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Modulo register contains the modulo value for the FTM counter. After the
 * FTM counter reaches the modulo value, the overflow flag (TOF) becomes set at
 * the next clock, and the next value of FTM counter depends on the selected
 * counting method; see Counter. Writing to the MOD register latches the value into a
 * buffer. The MOD register is updated with the value of its write buffer
 * according to Registers updated from write buffers. If FTMEN = 0, this write coherency
 * mechanism may be manually reset by writing to the SC register whether Debug
 * is active or not. Initialize the FTM counter, by writing to CNT, before writing
 * to the MOD register to avoid confusion about when the first counter overflow
 * will occur.
 */
/*!
 * @name Constants and macros for entire FTM_MOD register
 */
/*@{*/
#define FTM_RD_MOD(base)         (FTM_MOD_REG(base))
#define FTM_WR_MOD(base, value)  (FTM_MOD_REG(base) = (value))
#define FTM_RMW_MOD(base, mask, value) (FTM_WR_MOD(base, (FTM_RD_MOD(base) & ~(mask)) | (value)))
#define FTM_SET_MOD(base, value) (FTM_WR_MOD(base, FTM_RD_MOD(base) |  (value)))
#define FTM_CLR_MOD(base, value) (FTM_WR_MOD(base, FTM_RD_MOD(base) & ~(value)))
#define FTM_TOG_MOD(base, value) (FTM_WR_MOD(base, FTM_RD_MOD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MOD bitfields
 */

/*!
 * @name Register FTM_MOD, field MOD[15:0] (RW)
 *
 * Modulo Value
 */
/*@{*/
/*! @brief Read current value of the FTM_MOD_MOD field. */
#define FTM_RD_MOD_MOD(base) ((FTM_MOD_REG(base) & FTM_MOD_MOD_MASK) >> FTM_MOD_MOD_SHIFT)
#define FTM_BRD_MOD_MOD(base) (FTM_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define FTM_WR_MOD_MOD(base, value) (FTM_RMW_MOD(base, FTM_MOD_MOD_MASK, FTM_MOD_MOD(value)))
#define FTM_BWR_MOD_MOD(base, value) (FTM_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C0SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C0SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C0SC register
 */
/*@{*/
#define FTM_RD_C0SC(base)        (FTM_C0SC_REG(base))
#define FTM_WR_C0SC(base, value) (FTM_C0SC_REG(base) = (value))
#define FTM_RMW_C0SC(base, mask, value) (FTM_WR_C0SC(base, (FTM_RD_C0SC(base) & ~(mask)) | (value)))
#define FTM_SET_C0SC(base, value) (FTM_WR_C0SC(base, FTM_RD_C0SC(base) |  (value)))
#define FTM_CLR_C0SC(base, value) (FTM_WR_C0SC(base, FTM_RD_C0SC(base) & ~(value)))
#define FTM_TOG_C0SC(base, value) (FTM_WR_C0SC(base, FTM_RD_C0SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C0SC bitfields
 */

/*!
 * @name Register FTM_C0SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_DMA field. */
#define FTM_RD_C0SC_DMA(base) ((FTM_C0SC_REG(base) & FTM_C0SC_DMA_MASK) >> FTM_C0SC_DMA_SHIFT)
#define FTM_BRD_C0SC_DMA(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C0SC_DMA(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_DMA_MASK, FTM_C0SC_DMA(value)))
#define FTM_BWR_C0SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_ICRST field. */
#define FTM_RD_C0SC_ICRST(base) ((FTM_C0SC_REG(base) & FTM_C0SC_ICRST_MASK) >> FTM_C0SC_ICRST_SHIFT)
#define FTM_BRD_C0SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C0SC_ICRST(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_ICRST_MASK, FTM_C0SC_ICRST(value)))
#define FTM_BWR_C0SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_ELSA field. */
#define FTM_RD_C0SC_ELSA(base) ((FTM_C0SC_REG(base) & FTM_C0SC_ELSA_MASK) >> FTM_C0SC_ELSA_SHIFT)
#define FTM_BRD_C0SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C0SC_ELSA(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_ELSA_MASK, FTM_C0SC_ELSA(value)))
#define FTM_BWR_C0SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_ELSB field. */
#define FTM_RD_C0SC_ELSB(base) ((FTM_C0SC_REG(base) & FTM_C0SC_ELSB_MASK) >> FTM_C0SC_ELSB_SHIFT)
#define FTM_BRD_C0SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C0SC_ELSB(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_ELSB_MASK, FTM_C0SC_ELSB(value)))
#define FTM_BWR_C0SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_MSA field. */
#define FTM_RD_C0SC_MSA(base) ((FTM_C0SC_REG(base) & FTM_C0SC_MSA_MASK) >> FTM_C0SC_MSA_SHIFT)
#define FTM_BRD_C0SC_MSA(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C0SC_MSA(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_MSA_MASK, FTM_C0SC_MSA(value)))
#define FTM_BWR_C0SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_MSB field. */
#define FTM_RD_C0SC_MSB(base) ((FTM_C0SC_REG(base) & FTM_C0SC_MSB_MASK) >> FTM_C0SC_MSB_SHIFT)
#define FTM_BRD_C0SC_MSB(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C0SC_MSB(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_MSB_MASK, FTM_C0SC_MSB(value)))
#define FTM_BWR_C0SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_CHIE field. */
#define FTM_RD_C0SC_CHIE(base) ((FTM_C0SC_REG(base) & FTM_C0SC_CHIE_MASK) >> FTM_C0SC_CHIE_SHIFT)
#define FTM_BRD_C0SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C0SC_CHIE(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_CHIE_MASK, FTM_C0SC_CHIE(value)))
#define FTM_BWR_C0SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_CHF field. */
#define FTM_RD_C0SC_CHF(base) ((FTM_C0SC_REG(base) & FTM_C0SC_CHF_MASK) >> FTM_C0SC_CHF_SHIFT)
#define FTM_BRD_C0SC_CHF(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C0SC_CHF(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_CHF_MASK, FTM_C0SC_CHF(value)))
#define FTM_BWR_C0SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_TRIGMODE field. */
#define FTM_RD_C0SC_TRIGMODE(base) ((FTM_C0SC_REG(base) & FTM_C0SC_TRIGMODE_MASK) >> FTM_C0SC_TRIGMODE_SHIFT)
#define FTM_BRD_C0SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C0SC_TRIGMODE(base, value) (FTM_RMW_C0SC(base, FTM_C0SC_TRIGMODE_MASK, FTM_C0SC_TRIGMODE(value)))
#define FTM_BWR_C0SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C0SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C0SC_CHIS field. */
#define FTM_RD_C0SC_CHIS(base) ((FTM_C0SC_REG(base) & FTM_C0SC_CHIS_MASK) >> FTM_C0SC_CHIS_SHIFT)
#define FTM_BRD_C0SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C0SC_REG(base), FTM_C0SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C0V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C0V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C0V register
 */
/*@{*/
#define FTM_RD_C0V(base)         (FTM_C0V_REG(base))
#define FTM_WR_C0V(base, value)  (FTM_C0V_REG(base) = (value))
#define FTM_RMW_C0V(base, mask, value) (FTM_WR_C0V(base, (FTM_RD_C0V(base) & ~(mask)) | (value)))
#define FTM_SET_C0V(base, value) (FTM_WR_C0V(base, FTM_RD_C0V(base) |  (value)))
#define FTM_CLR_C0V(base, value) (FTM_WR_C0V(base, FTM_RD_C0V(base) & ~(value)))
#define FTM_TOG_C0V(base, value) (FTM_WR_C0V(base, FTM_RD_C0V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C0V bitfields
 */

/*!
 * @name Register FTM_C0V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C0V_VAL field. */
#define FTM_RD_C0V_VAL(base) ((FTM_C0V_REG(base) & FTM_C0V_VAL_MASK) >> FTM_C0V_VAL_SHIFT)
#define FTM_BRD_C0V_VAL(base) (FTM_RD_C0V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C0V_VAL(base, value) (FTM_RMW_C0V(base, FTM_C0V_VAL_MASK, FTM_C0V_VAL(value)))
#define FTM_BWR_C0V_VAL(base, value) (FTM_WR_C0V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C1SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C1SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C1SC register
 */
/*@{*/
#define FTM_RD_C1SC(base)        (FTM_C1SC_REG(base))
#define FTM_WR_C1SC(base, value) (FTM_C1SC_REG(base) = (value))
#define FTM_RMW_C1SC(base, mask, value) (FTM_WR_C1SC(base, (FTM_RD_C1SC(base) & ~(mask)) | (value)))
#define FTM_SET_C1SC(base, value) (FTM_WR_C1SC(base, FTM_RD_C1SC(base) |  (value)))
#define FTM_CLR_C1SC(base, value) (FTM_WR_C1SC(base, FTM_RD_C1SC(base) & ~(value)))
#define FTM_TOG_C1SC(base, value) (FTM_WR_C1SC(base, FTM_RD_C1SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C1SC bitfields
 */

/*!
 * @name Register FTM_C1SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_DMA field. */
#define FTM_RD_C1SC_DMA(base) ((FTM_C1SC_REG(base) & FTM_C1SC_DMA_MASK) >> FTM_C1SC_DMA_SHIFT)
#define FTM_BRD_C1SC_DMA(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C1SC_DMA(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_DMA_MASK, FTM_C1SC_DMA(value)))
#define FTM_BWR_C1SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_ICRST field. */
#define FTM_RD_C1SC_ICRST(base) ((FTM_C1SC_REG(base) & FTM_C1SC_ICRST_MASK) >> FTM_C1SC_ICRST_SHIFT)
#define FTM_BRD_C1SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C1SC_ICRST(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_ICRST_MASK, FTM_C1SC_ICRST(value)))
#define FTM_BWR_C1SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_ELSA field. */
#define FTM_RD_C1SC_ELSA(base) ((FTM_C1SC_REG(base) & FTM_C1SC_ELSA_MASK) >> FTM_C1SC_ELSA_SHIFT)
#define FTM_BRD_C1SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C1SC_ELSA(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_ELSA_MASK, FTM_C1SC_ELSA(value)))
#define FTM_BWR_C1SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_ELSB field. */
#define FTM_RD_C1SC_ELSB(base) ((FTM_C1SC_REG(base) & FTM_C1SC_ELSB_MASK) >> FTM_C1SC_ELSB_SHIFT)
#define FTM_BRD_C1SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C1SC_ELSB(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_ELSB_MASK, FTM_C1SC_ELSB(value)))
#define FTM_BWR_C1SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_MSA field. */
#define FTM_RD_C1SC_MSA(base) ((FTM_C1SC_REG(base) & FTM_C1SC_MSA_MASK) >> FTM_C1SC_MSA_SHIFT)
#define FTM_BRD_C1SC_MSA(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C1SC_MSA(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_MSA_MASK, FTM_C1SC_MSA(value)))
#define FTM_BWR_C1SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_MSB field. */
#define FTM_RD_C1SC_MSB(base) ((FTM_C1SC_REG(base) & FTM_C1SC_MSB_MASK) >> FTM_C1SC_MSB_SHIFT)
#define FTM_BRD_C1SC_MSB(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C1SC_MSB(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_MSB_MASK, FTM_C1SC_MSB(value)))
#define FTM_BWR_C1SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_CHIE field. */
#define FTM_RD_C1SC_CHIE(base) ((FTM_C1SC_REG(base) & FTM_C1SC_CHIE_MASK) >> FTM_C1SC_CHIE_SHIFT)
#define FTM_BRD_C1SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C1SC_CHIE(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_CHIE_MASK, FTM_C1SC_CHIE(value)))
#define FTM_BWR_C1SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_CHF field. */
#define FTM_RD_C1SC_CHF(base) ((FTM_C1SC_REG(base) & FTM_C1SC_CHF_MASK) >> FTM_C1SC_CHF_SHIFT)
#define FTM_BRD_C1SC_CHF(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C1SC_CHF(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_CHF_MASK, FTM_C1SC_CHF(value)))
#define FTM_BWR_C1SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_TRIGMODE field. */
#define FTM_RD_C1SC_TRIGMODE(base) ((FTM_C1SC_REG(base) & FTM_C1SC_TRIGMODE_MASK) >> FTM_C1SC_TRIGMODE_SHIFT)
#define FTM_BRD_C1SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C1SC_TRIGMODE(base, value) (FTM_RMW_C1SC(base, FTM_C1SC_TRIGMODE_MASK, FTM_C1SC_TRIGMODE(value)))
#define FTM_BWR_C1SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C1SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C1SC_CHIS field. */
#define FTM_RD_C1SC_CHIS(base) ((FTM_C1SC_REG(base) & FTM_C1SC_CHIS_MASK) >> FTM_C1SC_CHIS_SHIFT)
#define FTM_BRD_C1SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C1SC_REG(base), FTM_C1SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C1V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C1V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C1V register
 */
/*@{*/
#define FTM_RD_C1V(base)         (FTM_C1V_REG(base))
#define FTM_WR_C1V(base, value)  (FTM_C1V_REG(base) = (value))
#define FTM_RMW_C1V(base, mask, value) (FTM_WR_C1V(base, (FTM_RD_C1V(base) & ~(mask)) | (value)))
#define FTM_SET_C1V(base, value) (FTM_WR_C1V(base, FTM_RD_C1V(base) |  (value)))
#define FTM_CLR_C1V(base, value) (FTM_WR_C1V(base, FTM_RD_C1V(base) & ~(value)))
#define FTM_TOG_C1V(base, value) (FTM_WR_C1V(base, FTM_RD_C1V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C1V bitfields
 */

/*!
 * @name Register FTM_C1V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C1V_VAL field. */
#define FTM_RD_C1V_VAL(base) ((FTM_C1V_REG(base) & FTM_C1V_VAL_MASK) >> FTM_C1V_VAL_SHIFT)
#define FTM_BRD_C1V_VAL(base) (FTM_RD_C1V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C1V_VAL(base, value) (FTM_RMW_C1V(base, FTM_C1V_VAL_MASK, FTM_C1V_VAL(value)))
#define FTM_BWR_C1V_VAL(base, value) (FTM_WR_C1V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C2SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C2SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C2SC register
 */
/*@{*/
#define FTM_RD_C2SC(base)        (FTM_C2SC_REG(base))
#define FTM_WR_C2SC(base, value) (FTM_C2SC_REG(base) = (value))
#define FTM_RMW_C2SC(base, mask, value) (FTM_WR_C2SC(base, (FTM_RD_C2SC(base) & ~(mask)) | (value)))
#define FTM_SET_C2SC(base, value) (FTM_WR_C2SC(base, FTM_RD_C2SC(base) |  (value)))
#define FTM_CLR_C2SC(base, value) (FTM_WR_C2SC(base, FTM_RD_C2SC(base) & ~(value)))
#define FTM_TOG_C2SC(base, value) (FTM_WR_C2SC(base, FTM_RD_C2SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C2SC bitfields
 */

/*!
 * @name Register FTM_C2SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_DMA field. */
#define FTM_RD_C2SC_DMA(base) ((FTM_C2SC_REG(base) & FTM_C2SC_DMA_MASK) >> FTM_C2SC_DMA_SHIFT)
#define FTM_BRD_C2SC_DMA(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C2SC_DMA(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_DMA_MASK, FTM_C2SC_DMA(value)))
#define FTM_BWR_C2SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_ICRST field. */
#define FTM_RD_C2SC_ICRST(base) ((FTM_C2SC_REG(base) & FTM_C2SC_ICRST_MASK) >> FTM_C2SC_ICRST_SHIFT)
#define FTM_BRD_C2SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C2SC_ICRST(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_ICRST_MASK, FTM_C2SC_ICRST(value)))
#define FTM_BWR_C2SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_ELSA field. */
#define FTM_RD_C2SC_ELSA(base) ((FTM_C2SC_REG(base) & FTM_C2SC_ELSA_MASK) >> FTM_C2SC_ELSA_SHIFT)
#define FTM_BRD_C2SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C2SC_ELSA(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_ELSA_MASK, FTM_C2SC_ELSA(value)))
#define FTM_BWR_C2SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_ELSB field. */
#define FTM_RD_C2SC_ELSB(base) ((FTM_C2SC_REG(base) & FTM_C2SC_ELSB_MASK) >> FTM_C2SC_ELSB_SHIFT)
#define FTM_BRD_C2SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C2SC_ELSB(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_ELSB_MASK, FTM_C2SC_ELSB(value)))
#define FTM_BWR_C2SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_MSA field. */
#define FTM_RD_C2SC_MSA(base) ((FTM_C2SC_REG(base) & FTM_C2SC_MSA_MASK) >> FTM_C2SC_MSA_SHIFT)
#define FTM_BRD_C2SC_MSA(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C2SC_MSA(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_MSA_MASK, FTM_C2SC_MSA(value)))
#define FTM_BWR_C2SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_MSB field. */
#define FTM_RD_C2SC_MSB(base) ((FTM_C2SC_REG(base) & FTM_C2SC_MSB_MASK) >> FTM_C2SC_MSB_SHIFT)
#define FTM_BRD_C2SC_MSB(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C2SC_MSB(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_MSB_MASK, FTM_C2SC_MSB(value)))
#define FTM_BWR_C2SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_CHIE field. */
#define FTM_RD_C2SC_CHIE(base) ((FTM_C2SC_REG(base) & FTM_C2SC_CHIE_MASK) >> FTM_C2SC_CHIE_SHIFT)
#define FTM_BRD_C2SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C2SC_CHIE(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_CHIE_MASK, FTM_C2SC_CHIE(value)))
#define FTM_BWR_C2SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_CHF field. */
#define FTM_RD_C2SC_CHF(base) ((FTM_C2SC_REG(base) & FTM_C2SC_CHF_MASK) >> FTM_C2SC_CHF_SHIFT)
#define FTM_BRD_C2SC_CHF(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C2SC_CHF(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_CHF_MASK, FTM_C2SC_CHF(value)))
#define FTM_BWR_C2SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_TRIGMODE field. */
#define FTM_RD_C2SC_TRIGMODE(base) ((FTM_C2SC_REG(base) & FTM_C2SC_TRIGMODE_MASK) >> FTM_C2SC_TRIGMODE_SHIFT)
#define FTM_BRD_C2SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C2SC_TRIGMODE(base, value) (FTM_RMW_C2SC(base, FTM_C2SC_TRIGMODE_MASK, FTM_C2SC_TRIGMODE(value)))
#define FTM_BWR_C2SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C2SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C2SC_CHIS field. */
#define FTM_RD_C2SC_CHIS(base) ((FTM_C2SC_REG(base) & FTM_C2SC_CHIS_MASK) >> FTM_C2SC_CHIS_SHIFT)
#define FTM_BRD_C2SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C2SC_REG(base), FTM_C2SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C2V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C2V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C2V register
 */
/*@{*/
#define FTM_RD_C2V(base)         (FTM_C2V_REG(base))
#define FTM_WR_C2V(base, value)  (FTM_C2V_REG(base) = (value))
#define FTM_RMW_C2V(base, mask, value) (FTM_WR_C2V(base, (FTM_RD_C2V(base) & ~(mask)) | (value)))
#define FTM_SET_C2V(base, value) (FTM_WR_C2V(base, FTM_RD_C2V(base) |  (value)))
#define FTM_CLR_C2V(base, value) (FTM_WR_C2V(base, FTM_RD_C2V(base) & ~(value)))
#define FTM_TOG_C2V(base, value) (FTM_WR_C2V(base, FTM_RD_C2V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C2V bitfields
 */

/*!
 * @name Register FTM_C2V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C2V_VAL field. */
#define FTM_RD_C2V_VAL(base) ((FTM_C2V_REG(base) & FTM_C2V_VAL_MASK) >> FTM_C2V_VAL_SHIFT)
#define FTM_BRD_C2V_VAL(base) (FTM_RD_C2V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C2V_VAL(base, value) (FTM_RMW_C2V(base, FTM_C2V_VAL_MASK, FTM_C2V_VAL(value)))
#define FTM_BWR_C2V_VAL(base, value) (FTM_WR_C2V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C3SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C3SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C3SC register
 */
/*@{*/
#define FTM_RD_C3SC(base)        (FTM_C3SC_REG(base))
#define FTM_WR_C3SC(base, value) (FTM_C3SC_REG(base) = (value))
#define FTM_RMW_C3SC(base, mask, value) (FTM_WR_C3SC(base, (FTM_RD_C3SC(base) & ~(mask)) | (value)))
#define FTM_SET_C3SC(base, value) (FTM_WR_C3SC(base, FTM_RD_C3SC(base) |  (value)))
#define FTM_CLR_C3SC(base, value) (FTM_WR_C3SC(base, FTM_RD_C3SC(base) & ~(value)))
#define FTM_TOG_C3SC(base, value) (FTM_WR_C3SC(base, FTM_RD_C3SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C3SC bitfields
 */

/*!
 * @name Register FTM_C3SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_DMA field. */
#define FTM_RD_C3SC_DMA(base) ((FTM_C3SC_REG(base) & FTM_C3SC_DMA_MASK) >> FTM_C3SC_DMA_SHIFT)
#define FTM_BRD_C3SC_DMA(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C3SC_DMA(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_DMA_MASK, FTM_C3SC_DMA(value)))
#define FTM_BWR_C3SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_ICRST field. */
#define FTM_RD_C3SC_ICRST(base) ((FTM_C3SC_REG(base) & FTM_C3SC_ICRST_MASK) >> FTM_C3SC_ICRST_SHIFT)
#define FTM_BRD_C3SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C3SC_ICRST(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_ICRST_MASK, FTM_C3SC_ICRST(value)))
#define FTM_BWR_C3SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_ELSA field. */
#define FTM_RD_C3SC_ELSA(base) ((FTM_C3SC_REG(base) & FTM_C3SC_ELSA_MASK) >> FTM_C3SC_ELSA_SHIFT)
#define FTM_BRD_C3SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C3SC_ELSA(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_ELSA_MASK, FTM_C3SC_ELSA(value)))
#define FTM_BWR_C3SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_ELSB field. */
#define FTM_RD_C3SC_ELSB(base) ((FTM_C3SC_REG(base) & FTM_C3SC_ELSB_MASK) >> FTM_C3SC_ELSB_SHIFT)
#define FTM_BRD_C3SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C3SC_ELSB(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_ELSB_MASK, FTM_C3SC_ELSB(value)))
#define FTM_BWR_C3SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_MSA field. */
#define FTM_RD_C3SC_MSA(base) ((FTM_C3SC_REG(base) & FTM_C3SC_MSA_MASK) >> FTM_C3SC_MSA_SHIFT)
#define FTM_BRD_C3SC_MSA(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C3SC_MSA(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_MSA_MASK, FTM_C3SC_MSA(value)))
#define FTM_BWR_C3SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_MSB field. */
#define FTM_RD_C3SC_MSB(base) ((FTM_C3SC_REG(base) & FTM_C3SC_MSB_MASK) >> FTM_C3SC_MSB_SHIFT)
#define FTM_BRD_C3SC_MSB(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C3SC_MSB(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_MSB_MASK, FTM_C3SC_MSB(value)))
#define FTM_BWR_C3SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_CHIE field. */
#define FTM_RD_C3SC_CHIE(base) ((FTM_C3SC_REG(base) & FTM_C3SC_CHIE_MASK) >> FTM_C3SC_CHIE_SHIFT)
#define FTM_BRD_C3SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C3SC_CHIE(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_CHIE_MASK, FTM_C3SC_CHIE(value)))
#define FTM_BWR_C3SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_CHF field. */
#define FTM_RD_C3SC_CHF(base) ((FTM_C3SC_REG(base) & FTM_C3SC_CHF_MASK) >> FTM_C3SC_CHF_SHIFT)
#define FTM_BRD_C3SC_CHF(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C3SC_CHF(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_CHF_MASK, FTM_C3SC_CHF(value)))
#define FTM_BWR_C3SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_TRIGMODE field. */
#define FTM_RD_C3SC_TRIGMODE(base) ((FTM_C3SC_REG(base) & FTM_C3SC_TRIGMODE_MASK) >> FTM_C3SC_TRIGMODE_SHIFT)
#define FTM_BRD_C3SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C3SC_TRIGMODE(base, value) (FTM_RMW_C3SC(base, FTM_C3SC_TRIGMODE_MASK, FTM_C3SC_TRIGMODE(value)))
#define FTM_BWR_C3SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C3SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C3SC_CHIS field. */
#define FTM_RD_C3SC_CHIS(base) ((FTM_C3SC_REG(base) & FTM_C3SC_CHIS_MASK) >> FTM_C3SC_CHIS_SHIFT)
#define FTM_BRD_C3SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C3SC_REG(base), FTM_C3SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C3V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C3V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C3V register
 */
/*@{*/
#define FTM_RD_C3V(base)         (FTM_C3V_REG(base))
#define FTM_WR_C3V(base, value)  (FTM_C3V_REG(base) = (value))
#define FTM_RMW_C3V(base, mask, value) (FTM_WR_C3V(base, (FTM_RD_C3V(base) & ~(mask)) | (value)))
#define FTM_SET_C3V(base, value) (FTM_WR_C3V(base, FTM_RD_C3V(base) |  (value)))
#define FTM_CLR_C3V(base, value) (FTM_WR_C3V(base, FTM_RD_C3V(base) & ~(value)))
#define FTM_TOG_C3V(base, value) (FTM_WR_C3V(base, FTM_RD_C3V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C3V bitfields
 */

/*!
 * @name Register FTM_C3V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C3V_VAL field. */
#define FTM_RD_C3V_VAL(base) ((FTM_C3V_REG(base) & FTM_C3V_VAL_MASK) >> FTM_C3V_VAL_SHIFT)
#define FTM_BRD_C3V_VAL(base) (FTM_RD_C3V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C3V_VAL(base, value) (FTM_RMW_C3V(base, FTM_C3V_VAL_MASK, FTM_C3V_VAL(value)))
#define FTM_BWR_C3V_VAL(base, value) (FTM_WR_C3V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C4SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C4SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C4SC register
 */
/*@{*/
#define FTM_RD_C4SC(base)        (FTM_C4SC_REG(base))
#define FTM_WR_C4SC(base, value) (FTM_C4SC_REG(base) = (value))
#define FTM_RMW_C4SC(base, mask, value) (FTM_WR_C4SC(base, (FTM_RD_C4SC(base) & ~(mask)) | (value)))
#define FTM_SET_C4SC(base, value) (FTM_WR_C4SC(base, FTM_RD_C4SC(base) |  (value)))
#define FTM_CLR_C4SC(base, value) (FTM_WR_C4SC(base, FTM_RD_C4SC(base) & ~(value)))
#define FTM_TOG_C4SC(base, value) (FTM_WR_C4SC(base, FTM_RD_C4SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C4SC bitfields
 */

/*!
 * @name Register FTM_C4SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_DMA field. */
#define FTM_RD_C4SC_DMA(base) ((FTM_C4SC_REG(base) & FTM_C4SC_DMA_MASK) >> FTM_C4SC_DMA_SHIFT)
#define FTM_BRD_C4SC_DMA(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C4SC_DMA(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_DMA_MASK, FTM_C4SC_DMA(value)))
#define FTM_BWR_C4SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_ICRST field. */
#define FTM_RD_C4SC_ICRST(base) ((FTM_C4SC_REG(base) & FTM_C4SC_ICRST_MASK) >> FTM_C4SC_ICRST_SHIFT)
#define FTM_BRD_C4SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C4SC_ICRST(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_ICRST_MASK, FTM_C4SC_ICRST(value)))
#define FTM_BWR_C4SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_ELSA field. */
#define FTM_RD_C4SC_ELSA(base) ((FTM_C4SC_REG(base) & FTM_C4SC_ELSA_MASK) >> FTM_C4SC_ELSA_SHIFT)
#define FTM_BRD_C4SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C4SC_ELSA(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_ELSA_MASK, FTM_C4SC_ELSA(value)))
#define FTM_BWR_C4SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_ELSB field. */
#define FTM_RD_C4SC_ELSB(base) ((FTM_C4SC_REG(base) & FTM_C4SC_ELSB_MASK) >> FTM_C4SC_ELSB_SHIFT)
#define FTM_BRD_C4SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C4SC_ELSB(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_ELSB_MASK, FTM_C4SC_ELSB(value)))
#define FTM_BWR_C4SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_MSA field. */
#define FTM_RD_C4SC_MSA(base) ((FTM_C4SC_REG(base) & FTM_C4SC_MSA_MASK) >> FTM_C4SC_MSA_SHIFT)
#define FTM_BRD_C4SC_MSA(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C4SC_MSA(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_MSA_MASK, FTM_C4SC_MSA(value)))
#define FTM_BWR_C4SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_MSB field. */
#define FTM_RD_C4SC_MSB(base) ((FTM_C4SC_REG(base) & FTM_C4SC_MSB_MASK) >> FTM_C4SC_MSB_SHIFT)
#define FTM_BRD_C4SC_MSB(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C4SC_MSB(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_MSB_MASK, FTM_C4SC_MSB(value)))
#define FTM_BWR_C4SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_CHIE field. */
#define FTM_RD_C4SC_CHIE(base) ((FTM_C4SC_REG(base) & FTM_C4SC_CHIE_MASK) >> FTM_C4SC_CHIE_SHIFT)
#define FTM_BRD_C4SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C4SC_CHIE(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_CHIE_MASK, FTM_C4SC_CHIE(value)))
#define FTM_BWR_C4SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_CHF field. */
#define FTM_RD_C4SC_CHF(base) ((FTM_C4SC_REG(base) & FTM_C4SC_CHF_MASK) >> FTM_C4SC_CHF_SHIFT)
#define FTM_BRD_C4SC_CHF(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C4SC_CHF(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_CHF_MASK, FTM_C4SC_CHF(value)))
#define FTM_BWR_C4SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_TRIGMODE field. */
#define FTM_RD_C4SC_TRIGMODE(base) ((FTM_C4SC_REG(base) & FTM_C4SC_TRIGMODE_MASK) >> FTM_C4SC_TRIGMODE_SHIFT)
#define FTM_BRD_C4SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C4SC_TRIGMODE(base, value) (FTM_RMW_C4SC(base, FTM_C4SC_TRIGMODE_MASK, FTM_C4SC_TRIGMODE(value)))
#define FTM_BWR_C4SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C4SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C4SC_CHIS field. */
#define FTM_RD_C4SC_CHIS(base) ((FTM_C4SC_REG(base) & FTM_C4SC_CHIS_MASK) >> FTM_C4SC_CHIS_SHIFT)
#define FTM_BRD_C4SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C4SC_REG(base), FTM_C4SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C4V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C4V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C4V register
 */
/*@{*/
#define FTM_RD_C4V(base)         (FTM_C4V_REG(base))
#define FTM_WR_C4V(base, value)  (FTM_C4V_REG(base) = (value))
#define FTM_RMW_C4V(base, mask, value) (FTM_WR_C4V(base, (FTM_RD_C4V(base) & ~(mask)) | (value)))
#define FTM_SET_C4V(base, value) (FTM_WR_C4V(base, FTM_RD_C4V(base) |  (value)))
#define FTM_CLR_C4V(base, value) (FTM_WR_C4V(base, FTM_RD_C4V(base) & ~(value)))
#define FTM_TOG_C4V(base, value) (FTM_WR_C4V(base, FTM_RD_C4V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C4V bitfields
 */

/*!
 * @name Register FTM_C4V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C4V_VAL field. */
#define FTM_RD_C4V_VAL(base) ((FTM_C4V_REG(base) & FTM_C4V_VAL_MASK) >> FTM_C4V_VAL_SHIFT)
#define FTM_BRD_C4V_VAL(base) (FTM_RD_C4V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C4V_VAL(base, value) (FTM_RMW_C4V(base, FTM_C4V_VAL_MASK, FTM_C4V_VAL(value)))
#define FTM_BWR_C4V_VAL(base, value) (FTM_WR_C4V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C5SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C5SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C5SC register
 */
/*@{*/
#define FTM_RD_C5SC(base)        (FTM_C5SC_REG(base))
#define FTM_WR_C5SC(base, value) (FTM_C5SC_REG(base) = (value))
#define FTM_RMW_C5SC(base, mask, value) (FTM_WR_C5SC(base, (FTM_RD_C5SC(base) & ~(mask)) | (value)))
#define FTM_SET_C5SC(base, value) (FTM_WR_C5SC(base, FTM_RD_C5SC(base) |  (value)))
#define FTM_CLR_C5SC(base, value) (FTM_WR_C5SC(base, FTM_RD_C5SC(base) & ~(value)))
#define FTM_TOG_C5SC(base, value) (FTM_WR_C5SC(base, FTM_RD_C5SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C5SC bitfields
 */

/*!
 * @name Register FTM_C5SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_DMA field. */
#define FTM_RD_C5SC_DMA(base) ((FTM_C5SC_REG(base) & FTM_C5SC_DMA_MASK) >> FTM_C5SC_DMA_SHIFT)
#define FTM_BRD_C5SC_DMA(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C5SC_DMA(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_DMA_MASK, FTM_C5SC_DMA(value)))
#define FTM_BWR_C5SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_ICRST field. */
#define FTM_RD_C5SC_ICRST(base) ((FTM_C5SC_REG(base) & FTM_C5SC_ICRST_MASK) >> FTM_C5SC_ICRST_SHIFT)
#define FTM_BRD_C5SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C5SC_ICRST(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_ICRST_MASK, FTM_C5SC_ICRST(value)))
#define FTM_BWR_C5SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_ELSA field. */
#define FTM_RD_C5SC_ELSA(base) ((FTM_C5SC_REG(base) & FTM_C5SC_ELSA_MASK) >> FTM_C5SC_ELSA_SHIFT)
#define FTM_BRD_C5SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C5SC_ELSA(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_ELSA_MASK, FTM_C5SC_ELSA(value)))
#define FTM_BWR_C5SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_ELSB field. */
#define FTM_RD_C5SC_ELSB(base) ((FTM_C5SC_REG(base) & FTM_C5SC_ELSB_MASK) >> FTM_C5SC_ELSB_SHIFT)
#define FTM_BRD_C5SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C5SC_ELSB(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_ELSB_MASK, FTM_C5SC_ELSB(value)))
#define FTM_BWR_C5SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_MSA field. */
#define FTM_RD_C5SC_MSA(base) ((FTM_C5SC_REG(base) & FTM_C5SC_MSA_MASK) >> FTM_C5SC_MSA_SHIFT)
#define FTM_BRD_C5SC_MSA(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C5SC_MSA(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_MSA_MASK, FTM_C5SC_MSA(value)))
#define FTM_BWR_C5SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_MSB field. */
#define FTM_RD_C5SC_MSB(base) ((FTM_C5SC_REG(base) & FTM_C5SC_MSB_MASK) >> FTM_C5SC_MSB_SHIFT)
#define FTM_BRD_C5SC_MSB(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C5SC_MSB(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_MSB_MASK, FTM_C5SC_MSB(value)))
#define FTM_BWR_C5SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_CHIE field. */
#define FTM_RD_C5SC_CHIE(base) ((FTM_C5SC_REG(base) & FTM_C5SC_CHIE_MASK) >> FTM_C5SC_CHIE_SHIFT)
#define FTM_BRD_C5SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C5SC_CHIE(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_CHIE_MASK, FTM_C5SC_CHIE(value)))
#define FTM_BWR_C5SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_CHF field. */
#define FTM_RD_C5SC_CHF(base) ((FTM_C5SC_REG(base) & FTM_C5SC_CHF_MASK) >> FTM_C5SC_CHF_SHIFT)
#define FTM_BRD_C5SC_CHF(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C5SC_CHF(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_CHF_MASK, FTM_C5SC_CHF(value)))
#define FTM_BWR_C5SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_TRIGMODE field. */
#define FTM_RD_C5SC_TRIGMODE(base) ((FTM_C5SC_REG(base) & FTM_C5SC_TRIGMODE_MASK) >> FTM_C5SC_TRIGMODE_SHIFT)
#define FTM_BRD_C5SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C5SC_TRIGMODE(base, value) (FTM_RMW_C5SC(base, FTM_C5SC_TRIGMODE_MASK, FTM_C5SC_TRIGMODE(value)))
#define FTM_BWR_C5SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C5SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C5SC_CHIS field. */
#define FTM_RD_C5SC_CHIS(base) ((FTM_C5SC_REG(base) & FTM_C5SC_CHIS_MASK) >> FTM_C5SC_CHIS_SHIFT)
#define FTM_BRD_C5SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C5SC_REG(base), FTM_C5SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C5V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C5V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C5V register
 */
/*@{*/
#define FTM_RD_C5V(base)         (FTM_C5V_REG(base))
#define FTM_WR_C5V(base, value)  (FTM_C5V_REG(base) = (value))
#define FTM_RMW_C5V(base, mask, value) (FTM_WR_C5V(base, (FTM_RD_C5V(base) & ~(mask)) | (value)))
#define FTM_SET_C5V(base, value) (FTM_WR_C5V(base, FTM_RD_C5V(base) |  (value)))
#define FTM_CLR_C5V(base, value) (FTM_WR_C5V(base, FTM_RD_C5V(base) & ~(value)))
#define FTM_TOG_C5V(base, value) (FTM_WR_C5V(base, FTM_RD_C5V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C5V bitfields
 */

/*!
 * @name Register FTM_C5V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C5V_VAL field. */
#define FTM_RD_C5V_VAL(base) ((FTM_C5V_REG(base) & FTM_C5V_VAL_MASK) >> FTM_C5V_VAL_SHIFT)
#define FTM_BRD_C5V_VAL(base) (FTM_RD_C5V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C5V_VAL(base, value) (FTM_RMW_C5V(base, FTM_C5V_VAL_MASK, FTM_C5V_VAL(value)))
#define FTM_BWR_C5V_VAL(base, value) (FTM_WR_C5V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C6SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C6SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C6SC register
 */
/*@{*/
#define FTM_RD_C6SC(base)        (FTM_C6SC_REG(base))
#define FTM_WR_C6SC(base, value) (FTM_C6SC_REG(base) = (value))
#define FTM_RMW_C6SC(base, mask, value) (FTM_WR_C6SC(base, (FTM_RD_C6SC(base) & ~(mask)) | (value)))
#define FTM_SET_C6SC(base, value) (FTM_WR_C6SC(base, FTM_RD_C6SC(base) |  (value)))
#define FTM_CLR_C6SC(base, value) (FTM_WR_C6SC(base, FTM_RD_C6SC(base) & ~(value)))
#define FTM_TOG_C6SC(base, value) (FTM_WR_C6SC(base, FTM_RD_C6SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C6SC bitfields
 */

/*!
 * @name Register FTM_C6SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_DMA field. */
#define FTM_RD_C6SC_DMA(base) ((FTM_C6SC_REG(base) & FTM_C6SC_DMA_MASK) >> FTM_C6SC_DMA_SHIFT)
#define FTM_BRD_C6SC_DMA(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C6SC_DMA(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_DMA_MASK, FTM_C6SC_DMA(value)))
#define FTM_BWR_C6SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_ICRST field. */
#define FTM_RD_C6SC_ICRST(base) ((FTM_C6SC_REG(base) & FTM_C6SC_ICRST_MASK) >> FTM_C6SC_ICRST_SHIFT)
#define FTM_BRD_C6SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C6SC_ICRST(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_ICRST_MASK, FTM_C6SC_ICRST(value)))
#define FTM_BWR_C6SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_ELSA field. */
#define FTM_RD_C6SC_ELSA(base) ((FTM_C6SC_REG(base) & FTM_C6SC_ELSA_MASK) >> FTM_C6SC_ELSA_SHIFT)
#define FTM_BRD_C6SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C6SC_ELSA(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_ELSA_MASK, FTM_C6SC_ELSA(value)))
#define FTM_BWR_C6SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_ELSB field. */
#define FTM_RD_C6SC_ELSB(base) ((FTM_C6SC_REG(base) & FTM_C6SC_ELSB_MASK) >> FTM_C6SC_ELSB_SHIFT)
#define FTM_BRD_C6SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C6SC_ELSB(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_ELSB_MASK, FTM_C6SC_ELSB(value)))
#define FTM_BWR_C6SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_MSA field. */
#define FTM_RD_C6SC_MSA(base) ((FTM_C6SC_REG(base) & FTM_C6SC_MSA_MASK) >> FTM_C6SC_MSA_SHIFT)
#define FTM_BRD_C6SC_MSA(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C6SC_MSA(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_MSA_MASK, FTM_C6SC_MSA(value)))
#define FTM_BWR_C6SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_MSB field. */
#define FTM_RD_C6SC_MSB(base) ((FTM_C6SC_REG(base) & FTM_C6SC_MSB_MASK) >> FTM_C6SC_MSB_SHIFT)
#define FTM_BRD_C6SC_MSB(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C6SC_MSB(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_MSB_MASK, FTM_C6SC_MSB(value)))
#define FTM_BWR_C6SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_CHIE field. */
#define FTM_RD_C6SC_CHIE(base) ((FTM_C6SC_REG(base) & FTM_C6SC_CHIE_MASK) >> FTM_C6SC_CHIE_SHIFT)
#define FTM_BRD_C6SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C6SC_CHIE(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_CHIE_MASK, FTM_C6SC_CHIE(value)))
#define FTM_BWR_C6SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_CHF field. */
#define FTM_RD_C6SC_CHF(base) ((FTM_C6SC_REG(base) & FTM_C6SC_CHF_MASK) >> FTM_C6SC_CHF_SHIFT)
#define FTM_BRD_C6SC_CHF(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C6SC_CHF(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_CHF_MASK, FTM_C6SC_CHF(value)))
#define FTM_BWR_C6SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_TRIGMODE field. */
#define FTM_RD_C6SC_TRIGMODE(base) ((FTM_C6SC_REG(base) & FTM_C6SC_TRIGMODE_MASK) >> FTM_C6SC_TRIGMODE_SHIFT)
#define FTM_BRD_C6SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C6SC_TRIGMODE(base, value) (FTM_RMW_C6SC(base, FTM_C6SC_TRIGMODE_MASK, FTM_C6SC_TRIGMODE(value)))
#define FTM_BWR_C6SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C6SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C6SC_CHIS field. */
#define FTM_RD_C6SC_CHIS(base) ((FTM_C6SC_REG(base) & FTM_C6SC_CHIS_MASK) >> FTM_C6SC_CHIS_SHIFT)
#define FTM_BRD_C6SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C6SC_REG(base), FTM_C6SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C6V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C6V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C6V register
 */
/*@{*/
#define FTM_RD_C6V(base)         (FTM_C6V_REG(base))
#define FTM_WR_C6V(base, value)  (FTM_C6V_REG(base) = (value))
#define FTM_RMW_C6V(base, mask, value) (FTM_WR_C6V(base, (FTM_RD_C6V(base) & ~(mask)) | (value)))
#define FTM_SET_C6V(base, value) (FTM_WR_C6V(base, FTM_RD_C6V(base) |  (value)))
#define FTM_CLR_C6V(base, value) (FTM_WR_C6V(base, FTM_RD_C6V(base) & ~(value)))
#define FTM_TOG_C6V(base, value) (FTM_WR_C6V(base, FTM_RD_C6V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C6V bitfields
 */

/*!
 * @name Register FTM_C6V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C6V_VAL field. */
#define FTM_RD_C6V_VAL(base) ((FTM_C6V_REG(base) & FTM_C6V_VAL_MASK) >> FTM_C6V_VAL_SHIFT)
#define FTM_BRD_C6V_VAL(base) (FTM_RD_C6V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C6V_VAL(base, value) (FTM_RMW_C6V(base, FTM_C6V_VAL_MASK, FTM_C6V_VAL(value)))
#define FTM_BWR_C6V_VAL(base, value) (FTM_WR_C6V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_C7SC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_C7SC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. This
 * register also contains the trigger mode control and input pin state bits. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the table. Dual Edge Capture
 * One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode - edge
 * polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0 Disabled No
 * edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled Rising and
 * falling edges
 */
/*!
 * @name Constants and macros for entire FTM_C7SC register
 */
/*@{*/
#define FTM_RD_C7SC(base)        (FTM_C7SC_REG(base))
#define FTM_WR_C7SC(base, value) (FTM_C7SC_REG(base) = (value))
#define FTM_RMW_C7SC(base, mask, value) (FTM_WR_C7SC(base, (FTM_RD_C7SC(base) & ~(mask)) | (value)))
#define FTM_SET_C7SC(base, value) (FTM_WR_C7SC(base, FTM_RD_C7SC(base) |  (value)))
#define FTM_CLR_C7SC(base, value) (FTM_WR_C7SC(base, FTM_RD_C7SC(base) & ~(value)))
#define FTM_TOG_C7SC(base, value) (FTM_WR_C7SC(base, FTM_RD_C7SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C7SC bitfields
 */

/*!
 * @name Register FTM_C7SC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_DMA field. */
#define FTM_RD_C7SC_DMA(base) ((FTM_C7SC_REG(base) & FTM_C7SC_DMA_MASK) >> FTM_C7SC_DMA_SHIFT)
#define FTM_BRD_C7SC_DMA(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_C7SC_DMA(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_DMA_MASK, FTM_C7SC_DMA(value)))
#define FTM_BWR_C7SC_DMA(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_ICRST field. */
#define FTM_RD_C7SC_ICRST(base) ((FTM_C7SC_REG(base) & FTM_C7SC_ICRST_MASK) >> FTM_C7SC_ICRST_SHIFT)
#define FTM_BRD_C7SC_ICRST(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_ICRST_SHIFT))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_C7SC_ICRST(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_ICRST_MASK, FTM_C7SC_ICRST(value)))
#define FTM_BWR_C7SC_ICRST(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_ICRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_ELSA field. */
#define FTM_RD_C7SC_ELSA(base) ((FTM_C7SC_REG(base) & FTM_C7SC_ELSA_MASK) >> FTM_C7SC_ELSA_SHIFT)
#define FTM_BRD_C7SC_ELSA(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_C7SC_ELSA(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_ELSA_MASK, FTM_C7SC_ELSA(value)))
#define FTM_BWR_C7SC_ELSA(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See the
 * table. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_ELSB field. */
#define FTM_RD_C7SC_ELSB(base) ((FTM_C7SC_REG(base) & FTM_C7SC_ELSB_MASK) >> FTM_C7SC_ELSB_SHIFT)
#define FTM_BRD_C7SC_ELSB(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_C7SC_ELSB(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_ELSB_MASK, FTM_C7SC_ELSB(value)))
#define FTM_BWR_C7SC_ELSB(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_MSA field. */
#define FTM_RD_C7SC_MSA(base) ((FTM_C7SC_REG(base) & FTM_C7SC_MSA_MASK) >> FTM_C7SC_MSA_SHIFT)
#define FTM_BRD_C7SC_MSA(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_C7SC_MSA(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_MSA_MASK, FTM_C7SC_MSA(value)))
#define FTM_BWR_C7SC_MSA(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See the table. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_MSB field. */
#define FTM_RD_C7SC_MSB(base) ((FTM_C7SC_REG(base) & FTM_C7SC_MSB_MASK) >> FTM_C7SC_MSB_SHIFT)
#define FTM_BRD_C7SC_MSB(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_C7SC_MSB(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_MSB_MASK, FTM_C7SC_MSB(value)))
#define FTM_BWR_C7SC_MSB(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_CHIE field. */
#define FTM_RD_C7SC_CHIE(base) ((FTM_C7SC_REG(base) & FTM_C7SC_CHIE_MASK) >> FTM_C7SC_CHIE_SHIFT)
#define FTM_BRD_C7SC_CHIE(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_C7SC_CHIE(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_CHIE_MASK, FTM_C7SC_CHIE(value)))
#define FTM_BWR_C7SC_CHIE(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_CHF field. */
#define FTM_RD_C7SC_CHF(base) ((FTM_C7SC_REG(base) & FTM_C7SC_CHF_MASK) >> FTM_C7SC_CHF_SHIFT)
#define FTM_BRD_C7SC_CHF(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_C7SC_CHF(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_CHF_MASK, FTM_C7SC_CHF(value)))
#define FTM_BWR_C7SC_CHF(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_CHF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field TRIGMODE[8] (RW)
 *
 * This bit controls the trigger generation on FTM channel outputs. This mode is
 * allowed only when FTM channel is configured to EPWM (up counting) or CPWM
 * (up-down counting) modes. If a match in the channel occurs, a trigger pulse with
 * one FTM clock cycle width will be generated in the channel output. See Channel
 * trigger output for more details about trigger mode feature. This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channel outputs will generate the normal PWM outputs without
 *     generating a pulse.
 * - 0b1 - If a match in the channel occurs, a trigger generation on channel
 *     output will happen. The trigger pulse width has one FTM clock cycle.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_TRIGMODE field. */
#define FTM_RD_C7SC_TRIGMODE(base) ((FTM_C7SC_REG(base) & FTM_C7SC_TRIGMODE_MASK) >> FTM_C7SC_TRIGMODE_SHIFT)
#define FTM_BRD_C7SC_TRIGMODE(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_TRIGMODE_SHIFT))

/*! @brief Set the TRIGMODE field to a new value. */
#define FTM_WR_C7SC_TRIGMODE(base, value) (FTM_RMW_C7SC(base, FTM_C7SC_TRIGMODE_MASK, FTM_C7SC_TRIGMODE(value)))
#define FTM_BWR_C7SC_TRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_TRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_C7SC, field CHIS[9] (RO)
 *
 * This bit returns the value of channel input pin after filter mechanism (if
 * enabled to the specific channel).
 *
 * Values:
 * - 0b0 - Channel input pin is at low state.
 * - 0b1 - Channel input pin is at high state.
 */
/*@{*/
/*! @brief Read current value of the FTM_C7SC_CHIS field. */
#define FTM_RD_C7SC_CHIS(base) ((FTM_C7SC_REG(base) & FTM_C7SC_CHIS_MASK) >> FTM_C7SC_CHIS_SHIFT)
#define FTM_BRD_C7SC_CHIS(base) (BITBAND_ACCESS32(&FTM_C7SC_REG(base), FTM_C7SC_CHIS_SHIFT))
/*@}*/

/*******************************************************************************
 * FTM_C7V - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_C7V - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether Debug mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_C7V register
 */
/*@{*/
#define FTM_RD_C7V(base)         (FTM_C7V_REG(base))
#define FTM_WR_C7V(base, value)  (FTM_C7V_REG(base) = (value))
#define FTM_RMW_C7V(base, mask, value) (FTM_WR_C7V(base, (FTM_RD_C7V(base) & ~(mask)) | (value)))
#define FTM_SET_C7V(base, value) (FTM_WR_C7V(base, FTM_RD_C7V(base) |  (value)))
#define FTM_CLR_C7V(base, value) (FTM_WR_C7V(base, FTM_RD_C7V(base) & ~(value)))
#define FTM_TOG_C7V(base, value) (FTM_WR_C7V(base, FTM_RD_C7V(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_C7V bitfields
 */

/*!
 * @name Register FTM_C7V, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_C7V_VAL field. */
#define FTM_RD_C7V_VAL(base) ((FTM_C7V_REG(base) & FTM_C7V_VAL_MASK) >> FTM_C7V_VAL_SHIFT)
#define FTM_BRD_C7V_VAL(base) (FTM_RD_C7V_VAL(base))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_C7V_VAL(base, value) (FTM_RMW_C7V(base, FTM_C7V_VAL_MASK, FTM_C7V_VAL(value)))
#define FTM_BWR_C7V_VAL(base, value) (FTM_WR_C7V_VAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_CNTIN - Counter Initial Value
 ******************************************************************************/

/*!
 * @brief FTM_CNTIN - Counter Initial Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Counter Initial Value register contains the initial value for the FTM
 * counter. Writing to the CNTIN register latches the value into a buffer. The CNTIN
 * register is updated with the value of its write buffer according to Registers
 * updated from write buffers. When the FTM clock is initially selected, by
 * writing a non-zero value to the CLKS bits, the FTM counter starts with the value
 * 0x0000. To avoid this behavior, before the first write to select the FTM clock,
 * write the new value to the the CNTIN register and then initialize the FTM
 * counter by writing any value to the CNT register.
 */
/*!
 * @name Constants and macros for entire FTM_CNTIN register
 */
/*@{*/
#define FTM_RD_CNTIN(base)       (FTM_CNTIN_REG(base))
#define FTM_WR_CNTIN(base, value) (FTM_CNTIN_REG(base) = (value))
#define FTM_RMW_CNTIN(base, mask, value) (FTM_WR_CNTIN(base, (FTM_RD_CNTIN(base) & ~(mask)) | (value)))
#define FTM_SET_CNTIN(base, value) (FTM_WR_CNTIN(base, FTM_RD_CNTIN(base) |  (value)))
#define FTM_CLR_CNTIN(base, value) (FTM_WR_CNTIN(base, FTM_RD_CNTIN(base) & ~(value)))
#define FTM_TOG_CNTIN(base, value) (FTM_WR_CNTIN(base, FTM_RD_CNTIN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNTIN bitfields
 */

/*!
 * @name Register FTM_CNTIN, field INIT[15:0] (RW)
 *
 * Initial Value Of The FTM Counter
 */
/*@{*/
/*! @brief Read current value of the FTM_CNTIN_INIT field. */
#define FTM_RD_CNTIN_INIT(base) ((FTM_CNTIN_REG(base) & FTM_CNTIN_INIT_MASK) >> FTM_CNTIN_INIT_SHIFT)
#define FTM_BRD_CNTIN_INIT(base) (FTM_RD_CNTIN_INIT(base))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_CNTIN_INIT(base, value) (FTM_RMW_CNTIN(base, FTM_CNTIN_INIT_MASK, FTM_CNTIN_INIT(value)))
#define FTM_BWR_CNTIN_INIT(base, value) (FTM_WR_CNTIN_INIT(base, value))
/*@}*/

/*******************************************************************************
 * FTM_STATUS - Capture And Compare Status
 ******************************************************************************/

/*!
 * @brief FTM_STATUS - Capture And Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag CHnF bit in CnSC for
 * each FTM channel for software convenience. Each CHnF bit in STATUS is a mirror
 * of CHnF bit in CnSC. All CHnF bits can be checked using only one read of
 * STATUS. All CHnF bits can be cleared by reading STATUS followed by writing 0x00 to
 * STATUS. Hardware sets the individual channel flags when an event occurs on the
 * channel. CHnF is cleared by reading STATUS while CHnF is set and then writing
 * a 0 to the CHnF bit. Writing a 1 to CHnF has no effect. If another event
 * occurs between the read and write operations, the write operation has no effect;
 * therefore, CHnF remains set indicating an event has occurred. In this case, a
 * CHnF interrupt request is not lost due to the clearing sequence for a previous
 * CHnF.
 */
/*!
 * @name Constants and macros for entire FTM_STATUS register
 */
/*@{*/
#define FTM_RD_STATUS(base)      (FTM_STATUS_REG(base))
#define FTM_WR_STATUS(base, value) (FTM_STATUS_REG(base) = (value))
#define FTM_RMW_STATUS(base, mask, value) (FTM_WR_STATUS(base, (FTM_RD_STATUS(base) & ~(mask)) | (value)))
#define FTM_SET_STATUS(base, value) (FTM_WR_STATUS(base, FTM_RD_STATUS(base) |  (value)))
#define FTM_CLR_STATUS(base, value) (FTM_WR_STATUS(base, FTM_RD_STATUS(base) & ~(value)))
#define FTM_TOG_STATUS(base, value) (FTM_WR_STATUS(base, FTM_RD_STATUS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_STATUS bitfields
 */

/*!
 * @name Register FTM_STATUS, field CH0F[0] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH0F field. */
#define FTM_RD_STATUS_CH0F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH0F_MASK) >> FTM_STATUS_CH0F_SHIFT)
#define FTM_BRD_STATUS_CH0F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH0F_SHIFT))

/*! @brief Set the CH0F field to a new value. */
#define FTM_WR_STATUS_CH0F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH0F_MASK, FTM_STATUS_CH0F(value)))
#define FTM_BWR_STATUS_CH0F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH0F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH1F[1] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH1F field. */
#define FTM_RD_STATUS_CH1F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH1F_MASK) >> FTM_STATUS_CH1F_SHIFT)
#define FTM_BRD_STATUS_CH1F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH1F_SHIFT))

/*! @brief Set the CH1F field to a new value. */
#define FTM_WR_STATUS_CH1F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH1F_MASK, FTM_STATUS_CH1F(value)))
#define FTM_BWR_STATUS_CH1F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH2F[2] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH2F field. */
#define FTM_RD_STATUS_CH2F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH2F_MASK) >> FTM_STATUS_CH2F_SHIFT)
#define FTM_BRD_STATUS_CH2F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH2F_SHIFT))

/*! @brief Set the CH2F field to a new value. */
#define FTM_WR_STATUS_CH2F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH2F_MASK, FTM_STATUS_CH2F(value)))
#define FTM_BWR_STATUS_CH2F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH2F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH3F[3] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH3F field. */
#define FTM_RD_STATUS_CH3F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH3F_MASK) >> FTM_STATUS_CH3F_SHIFT)
#define FTM_BRD_STATUS_CH3F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH3F_SHIFT))

/*! @brief Set the CH3F field to a new value. */
#define FTM_WR_STATUS_CH3F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH3F_MASK, FTM_STATUS_CH3F(value)))
#define FTM_BWR_STATUS_CH3F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH3F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH4F[4] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH4F field. */
#define FTM_RD_STATUS_CH4F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH4F_MASK) >> FTM_STATUS_CH4F_SHIFT)
#define FTM_BRD_STATUS_CH4F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH4F_SHIFT))

/*! @brief Set the CH4F field to a new value. */
#define FTM_WR_STATUS_CH4F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH4F_MASK, FTM_STATUS_CH4F(value)))
#define FTM_BWR_STATUS_CH4F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH4F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH5F[5] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH5F field. */
#define FTM_RD_STATUS_CH5F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH5F_MASK) >> FTM_STATUS_CH5F_SHIFT)
#define FTM_BRD_STATUS_CH5F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH5F_SHIFT))

/*! @brief Set the CH5F field to a new value. */
#define FTM_WR_STATUS_CH5F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH5F_MASK, FTM_STATUS_CH5F(value)))
#define FTM_BWR_STATUS_CH5F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH5F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH6F[6] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH6F field. */
#define FTM_RD_STATUS_CH6F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH6F_MASK) >> FTM_STATUS_CH6F_SHIFT)
#define FTM_BRD_STATUS_CH6F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH6F_SHIFT))

/*! @brief Set the CH6F field to a new value. */
#define FTM_WR_STATUS_CH6F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH6F_MASK, FTM_STATUS_CH6F(value)))
#define FTM_BWR_STATUS_CH6F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH6F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH7F[7] (ROWZ)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH7F field. */
#define FTM_RD_STATUS_CH7F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH7F_MASK) >> FTM_STATUS_CH7F_SHIFT)
#define FTM_BRD_STATUS_CH7F(base) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH7F_SHIFT))

/*! @brief Set the CH7F field to a new value. */
#define FTM_WR_STATUS_CH7F(base, value) (FTM_RMW_STATUS(base, FTM_STATUS_CH7F_MASK, FTM_STATUS_CH7F(value)))
#define FTM_BWR_STATUS_CH7F(base, value) (BITBAND_ACCESS32(&FTM_STATUS_REG(base), FTM_STATUS_CH7F_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_MODE - Features Mode Selection
 ******************************************************************************/

/*!
 * @brief FTM_MODE - Features Mode Selection (RW)
 *
 * Reset value: 0x00000004U
 *
 * This register contains the global enable bit for FTM-specific features and
 * the control bits used to configure: Fault control mode and interrupt Capture
 * Test mode PWM synchronization Write protection Channel output initialization
 * These controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_MODE register
 */
/*@{*/
#define FTM_RD_MODE(base)        (FTM_MODE_REG(base))
#define FTM_WR_MODE(base, value) (FTM_MODE_REG(base) = (value))
#define FTM_RMW_MODE(base, mask, value) (FTM_WR_MODE(base, (FTM_RD_MODE(base) & ~(mask)) | (value)))
#define FTM_SET_MODE(base, value) (FTM_WR_MODE(base, FTM_RD_MODE(base) |  (value)))
#define FTM_CLR_MODE(base, value) (FTM_WR_MODE(base, FTM_RD_MODE(base) & ~(value)))
#define FTM_TOG_MODE(base, value) (FTM_WR_MODE(base, FTM_RD_MODE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MODE bitfields
 */

/*!
 * @name Register FTM_MODE, field FTMEN[0] (RW)
 *
 * This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - TPM compatibility. Free running counter and synchronization
 *     compatible with TPM.
 * - 0b1 - Free running counter and synchronization are different from TPM
 *     behavior.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FTMEN field. */
#define FTM_RD_MODE_FTMEN(base) ((FTM_MODE_REG(base) & FTM_MODE_FTMEN_MASK) >> FTM_MODE_FTMEN_SHIFT)
#define FTM_BRD_MODE_FTMEN(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FTMEN_SHIFT))

/*! @brief Set the FTMEN field to a new value. */
#define FTM_WR_MODE_FTMEN(base, value) (FTM_RMW_MODE(base, FTM_MODE_FTMEN_MASK, FTM_MODE_FTMEN(value)))
#define FTM_BWR_MODE_FTMEN(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FTMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field INIT[1] (RW)
 *
 * When a 1 is written to INIT bit the channels output is initialized according
 * to the state of their corresponding bit in the OUTINIT register. Writing a 0
 * to INIT bit has no effect. The INIT bit is always read as 0.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_INIT field. */
#define FTM_RD_MODE_INIT(base) ((FTM_MODE_REG(base) & FTM_MODE_INIT_MASK) >> FTM_MODE_INIT_SHIFT)
#define FTM_BRD_MODE_INIT(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_INIT_SHIFT))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_MODE_INIT(base, value) (FTM_RMW_MODE(base, FTM_MODE_INIT_MASK, FTM_MODE_INIT(value)))
#define FTM_BWR_MODE_INIT(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_INIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field WPDIS[2] (RW)
 *
 * When write protection is enabled (WPDIS = 0), write protected bits cannot be
 * written. When write protection is disabled (WPDIS = 1), write protected bits
 * can be written. The WPDIS bit is the negation of the WPEN bit. WPDIS is cleared
 * when 1 is written to WPEN. WPDIS is set when WPEN bit is read as a 1 and then
 * 1 is written to WPDIS. Writing 0 to WPDIS has no effect.
 *
 * Values:
 * - 0b0 - Write protection is enabled.
 * - 0b1 - Write protection is disabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_WPDIS field. */
#define FTM_RD_MODE_WPDIS(base) ((FTM_MODE_REG(base) & FTM_MODE_WPDIS_MASK) >> FTM_MODE_WPDIS_SHIFT)
#define FTM_BRD_MODE_WPDIS(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_WPDIS_SHIFT))

/*! @brief Set the WPDIS field to a new value. */
#define FTM_WR_MODE_WPDIS(base, value) (FTM_RMW_MODE(base, FTM_MODE_WPDIS_MASK, FTM_MODE_WPDIS(value)))
#define FTM_BWR_MODE_WPDIS(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_WPDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field PWMSYNC[3] (RW)
 *
 * Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM counter
 * synchronization. See PWM synchronization. The PWMSYNC bit configures the
 * synchronization when SYNCMODE is 0.
 *
 * Values:
 * - 0b0 - No restrictions. Software and hardware triggers can be used by MOD,
 *     CnV, OUTMASK, and FTM counter synchronization.
 * - 0b1 - Software trigger can only be used by MOD and CnV synchronization, and
 *     hardware triggers can only be used by OUTMASK and FTM counter
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_PWMSYNC field. */
#define FTM_RD_MODE_PWMSYNC(base) ((FTM_MODE_REG(base) & FTM_MODE_PWMSYNC_MASK) >> FTM_MODE_PWMSYNC_SHIFT)
#define FTM_BRD_MODE_PWMSYNC(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_PWMSYNC_SHIFT))

/*! @brief Set the PWMSYNC field to a new value. */
#define FTM_WR_MODE_PWMSYNC(base, value) (FTM_RMW_MODE(base, FTM_MODE_PWMSYNC_MASK, FTM_MODE_PWMSYNC(value)))
#define FTM_BWR_MODE_PWMSYNC(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_PWMSYNC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field CAPTEST[4] (RW)
 *
 * Enables the capture test mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Capture test mode is disabled.
 * - 0b1 - Capture test mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_CAPTEST field. */
#define FTM_RD_MODE_CAPTEST(base) ((FTM_MODE_REG(base) & FTM_MODE_CAPTEST_MASK) >> FTM_MODE_CAPTEST_SHIFT)
#define FTM_BRD_MODE_CAPTEST(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_CAPTEST_SHIFT))

/*! @brief Set the CAPTEST field to a new value. */
#define FTM_WR_MODE_CAPTEST(base, value) (FTM_RMW_MODE(base, FTM_MODE_CAPTEST_MASK, FTM_MODE_CAPTEST(value)))
#define FTM_BWR_MODE_CAPTEST(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_CAPTEST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTM[6:5] (RW)
 *
 * Defines the FTM fault control mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b00 - Fault control is disabled for all channels.
 * - 0b01 - Fault control is enabled for even channels only (channels 0, 2, 4,
 *     and 6), and the selected mode is the manual fault clearing.
 * - 0b10 - Fault control is enabled for all channels, and the selected mode is
 *     the manual fault clearing.
 * - 0b11 - Fault control is enabled for all channels, and the selected mode is
 *     the automatic fault clearing.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTM field. */
#define FTM_RD_MODE_FAULTM(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTM_MASK) >> FTM_MODE_FAULTM_SHIFT)
#define FTM_BRD_MODE_FAULTM(base) (FTM_RD_MODE_FAULTM(base))

/*! @brief Set the FAULTM field to a new value. */
#define FTM_WR_MODE_FAULTM(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTM_MASK, FTM_MODE_FAULTM(value)))
#define FTM_BWR_MODE_FAULTM(base, value) (FTM_WR_MODE_FAULTM(base, value))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTIE[7] (RW)
 *
 * Enables the generation of an interrupt when a fault is detected by FTM and
 * the FTM fault control is enabled.
 *
 * Values:
 * - 0b0 - Fault control interrupt is disabled.
 * - 0b1 - Fault control interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTIE field. */
#define FTM_RD_MODE_FAULTIE(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTIE_MASK) >> FTM_MODE_FAULTIE_SHIFT)
#define FTM_BRD_MODE_FAULTIE(base) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FAULTIE_SHIFT))

/*! @brief Set the FAULTIE field to a new value. */
#define FTM_WR_MODE_FAULTIE(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTIE_MASK, FTM_MODE_FAULTIE(value)))
#define FTM_BWR_MODE_FAULTIE(base, value) (BITBAND_ACCESS32(&FTM_MODE_REG(base), FTM_MODE_FAULTIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_SYNC - Synchronization
 ******************************************************************************/

/*!
 * @brief FTM_SYNC - Synchronization (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the PWM synchronization. A synchronization event can
 * perform the synchronized update of MOD, CV, and OUTMASK registers with the
 * value of their write buffer and the FTM counter initialization. The software
 * trigger, SWSYNC bit, and hardware triggers TRIG0, TRIG1, and TRIG2 bits have a
 * potential conflict if used together when SYNCMODE = 0. Use only hardware or
 * software triggers but not both at the same time, otherwise unpredictable behavior
 * is likely to happen. The selection of the loading point, CNTMAX and CNTMIN
 * bits, is intended to provide the update of MOD, CNTIN, and CnV registers across
 * all enabled channels simultaneously. The use of the loading point selection
 * together with SYNCMODE = 0 and hardware trigger selection, TRIG0, TRIG1, or TRIG2
 * bits, is likely to result in unpredictable behavior. The synchronization
 * event selection also depends on the PWMSYNC (MODE register) and SYNCMODE (SYNCONF
 * register) bits. See PWM synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SYNC register
 */
/*@{*/
#define FTM_RD_SYNC(base)        (FTM_SYNC_REG(base))
#define FTM_WR_SYNC(base, value) (FTM_SYNC_REG(base) = (value))
#define FTM_RMW_SYNC(base, mask, value) (FTM_WR_SYNC(base, (FTM_RD_SYNC(base) & ~(mask)) | (value)))
#define FTM_SET_SYNC(base, value) (FTM_WR_SYNC(base, FTM_RD_SYNC(base) |  (value)))
#define FTM_CLR_SYNC(base, value) (FTM_WR_SYNC(base, FTM_RD_SYNC(base) & ~(value)))
#define FTM_TOG_SYNC(base, value) (FTM_WR_SYNC(base, FTM_RD_SYNC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNC bitfields
 */

/*!
 * @name Register FTM_SYNC, field CNTMIN[0] (RW)
 *
 * Selects the minimum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMIN is one, the selected loading point is when the
 * FTM counter reaches its minimum value (CNTIN register).
 *
 * Values:
 * - 0b0 - The minimum loading point is disabled.
 * - 0b1 - The minimum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMIN field. */
#define FTM_RD_SYNC_CNTMIN(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMIN_MASK) >> FTM_SYNC_CNTMIN_SHIFT)
#define FTM_BRD_SYNC_CNTMIN(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMIN_SHIFT))

/*! @brief Set the CNTMIN field to a new value. */
#define FTM_WR_SYNC_CNTMIN(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMIN_MASK, FTM_SYNC_CNTMIN(value)))
#define FTM_BWR_SYNC_CNTMIN(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field CNTMAX[1] (RW)
 *
 * Selects the maximum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMAX is 1, the selected loading point is when the FTM
 * counter reaches its maximum value (MOD register).
 *
 * Values:
 * - 0b0 - The maximum loading point is disabled.
 * - 0b1 - The maximum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMAX field. */
#define FTM_RD_SYNC_CNTMAX(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMAX_MASK) >> FTM_SYNC_CNTMAX_SHIFT)
#define FTM_BRD_SYNC_CNTMAX(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMAX_SHIFT))

/*! @brief Set the CNTMAX field to a new value. */
#define FTM_WR_SYNC_CNTMAX(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMAX_MASK, FTM_SYNC_CNTMAX(value)))
#define FTM_BWR_SYNC_CNTMAX(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMAX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field REINIT[2] (RW)
 *
 * Determines if the FTM counter is reinitialized when the selected trigger for
 * the synchronization is detected. The REINIT bit configures the synchronization
 * when SYNCMODE is zero.
 *
 * Values:
 * - 0b0 - FTM counter continues to count normally.
 * - 0b1 - FTM counter is updated with its initial value when the selected
 *     trigger is detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_REINIT field. */
#define FTM_RD_SYNC_REINIT(base) ((FTM_SYNC_REG(base) & FTM_SYNC_REINIT_MASK) >> FTM_SYNC_REINIT_SHIFT)
#define FTM_BRD_SYNC_REINIT(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_REINIT_SHIFT))

/*! @brief Set the REINIT field to a new value. */
#define FTM_WR_SYNC_REINIT(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_REINIT_MASK, FTM_SYNC_REINIT(value)))
#define FTM_BWR_SYNC_REINIT(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_REINIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SYNCHOM[3] (RW)
 *
 * Selects when the OUTMASK register is updated with the value of its buffer.
 *
 * Values:
 * - 0b0 - OUTMASK register is updated with the value of its buffer in all
 *     rising edges of the system clock.
 * - 0b1 - OUTMASK register is updated with the value of its buffer only by the
 *     PWM synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SYNCHOM field. */
#define FTM_RD_SYNC_SYNCHOM(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SYNCHOM_MASK) >> FTM_SYNC_SYNCHOM_SHIFT)
#define FTM_BRD_SYNC_SYNCHOM(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SYNCHOM_SHIFT))

/*! @brief Set the SYNCHOM field to a new value. */
#define FTM_WR_SYNC_SYNCHOM(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SYNCHOM_MASK, FTM_SYNC_SYNCHOM(value)))
#define FTM_BWR_SYNC_SYNCHOM(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SYNCHOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG0[4] (RW)
 *
 * Enables hardware trigger 0 to the PWM synchronization. Hardware trigger 0
 * occurs when a rising edge is detected at the trigger 0 input signal.
 *
 * Values:
 * - 0b0 - Trigger is disabled.
 * - 0b1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG0 field. */
#define FTM_RD_SYNC_TRIG0(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG0_MASK) >> FTM_SYNC_TRIG0_SHIFT)
#define FTM_BRD_SYNC_TRIG0(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG0_SHIFT))

/*! @brief Set the TRIG0 field to a new value. */
#define FTM_WR_SYNC_TRIG0(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG0_MASK, FTM_SYNC_TRIG0(value)))
#define FTM_BWR_SYNC_TRIG0(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG1[5] (RW)
 *
 * Enables hardware trigger 1 to the PWM synchronization. Hardware trigger 1
 * happens when a rising edge is detected at the trigger 1 input signal.
 *
 * Values:
 * - 0b0 - Trigger is disabled.
 * - 0b1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG1 field. */
#define FTM_RD_SYNC_TRIG1(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG1_MASK) >> FTM_SYNC_TRIG1_SHIFT)
#define FTM_BRD_SYNC_TRIG1(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG1_SHIFT))

/*! @brief Set the TRIG1 field to a new value. */
#define FTM_WR_SYNC_TRIG1(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG1_MASK, FTM_SYNC_TRIG1(value)))
#define FTM_BWR_SYNC_TRIG1(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG2[6] (RW)
 *
 * Enables hardware trigger 2 to the PWM synchronization. Hardware trigger 2
 * happens when a rising edge is detected at the trigger 2 input signal.
 *
 * Values:
 * - 0b0 - Trigger is disabled.
 * - 0b1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG2 field. */
#define FTM_RD_SYNC_TRIG2(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG2_MASK) >> FTM_SYNC_TRIG2_SHIFT)
#define FTM_BRD_SYNC_TRIG2(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG2_SHIFT))

/*! @brief Set the TRIG2 field to a new value. */
#define FTM_WR_SYNC_TRIG2(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG2_MASK, FTM_SYNC_TRIG2(value)))
#define FTM_BWR_SYNC_TRIG2(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SWSYNC[7] (RW)
 *
 * Selects the software trigger as the PWM synchronization trigger. The software
 * trigger happens when a 1 is written to SWSYNC bit.
 *
 * Values:
 * - 0b0 - Software trigger is not selected.
 * - 0b1 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SWSYNC field. */
#define FTM_RD_SYNC_SWSYNC(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SWSYNC_MASK) >> FTM_SYNC_SWSYNC_SHIFT)
#define FTM_BRD_SYNC_SWSYNC(base) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SWSYNC_SHIFT))

/*! @brief Set the SWSYNC field to a new value. */
#define FTM_WR_SYNC_SWSYNC(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SWSYNC_MASK, FTM_SYNC_SWSYNC(value)))
#define FTM_BWR_SYNC_SWSYNC(base, value) (BITBAND_ACCESS32(&FTM_SYNC_REG(base), FTM_SYNC_SWSYNC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_OUTINIT - Initial State For Channels Output
 ******************************************************************************/

/*!
 * @brief FTM_OUTINIT - Initial State For Channels Output (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FTM_OUTINIT register
 */
/*@{*/
#define FTM_RD_OUTINIT(base)     (FTM_OUTINIT_REG(base))
#define FTM_WR_OUTINIT(base, value) (FTM_OUTINIT_REG(base) = (value))
#define FTM_RMW_OUTINIT(base, mask, value) (FTM_WR_OUTINIT(base, (FTM_RD_OUTINIT(base) & ~(mask)) | (value)))
#define FTM_SET_OUTINIT(base, value) (FTM_WR_OUTINIT(base, FTM_RD_OUTINIT(base) |  (value)))
#define FTM_CLR_OUTINIT(base, value) (FTM_WR_OUTINIT(base, FTM_RD_OUTINIT(base) & ~(value)))
#define FTM_TOG_OUTINIT(base, value) (FTM_WR_OUTINIT(base, FTM_RD_OUTINIT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTINIT bitfields
 */

/*!
 * @name Register FTM_OUTINIT, field CH0OI[0] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH0OI field. */
#define FTM_RD_OUTINIT_CH0OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH0OI_MASK) >> FTM_OUTINIT_CH0OI_SHIFT)
#define FTM_BRD_OUTINIT_CH0OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH0OI_SHIFT))

/*! @brief Set the CH0OI field to a new value. */
#define FTM_WR_OUTINIT_CH0OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH0OI_MASK, FTM_OUTINIT_CH0OI(value)))
#define FTM_BWR_OUTINIT_CH0OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH0OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH1OI[1] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH1OI field. */
#define FTM_RD_OUTINIT_CH1OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH1OI_MASK) >> FTM_OUTINIT_CH1OI_SHIFT)
#define FTM_BRD_OUTINIT_CH1OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH1OI_SHIFT))

/*! @brief Set the CH1OI field to a new value. */
#define FTM_WR_OUTINIT_CH1OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH1OI_MASK, FTM_OUTINIT_CH1OI(value)))
#define FTM_BWR_OUTINIT_CH1OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH1OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH2OI[2] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH2OI field. */
#define FTM_RD_OUTINIT_CH2OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH2OI_MASK) >> FTM_OUTINIT_CH2OI_SHIFT)
#define FTM_BRD_OUTINIT_CH2OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH2OI_SHIFT))

/*! @brief Set the CH2OI field to a new value. */
#define FTM_WR_OUTINIT_CH2OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH2OI_MASK, FTM_OUTINIT_CH2OI(value)))
#define FTM_BWR_OUTINIT_CH2OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH2OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH3OI[3] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH3OI field. */
#define FTM_RD_OUTINIT_CH3OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH3OI_MASK) >> FTM_OUTINIT_CH3OI_SHIFT)
#define FTM_BRD_OUTINIT_CH3OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH3OI_SHIFT))

/*! @brief Set the CH3OI field to a new value. */
#define FTM_WR_OUTINIT_CH3OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH3OI_MASK, FTM_OUTINIT_CH3OI(value)))
#define FTM_BWR_OUTINIT_CH3OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH3OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH4OI[4] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH4OI field. */
#define FTM_RD_OUTINIT_CH4OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH4OI_MASK) >> FTM_OUTINIT_CH4OI_SHIFT)
#define FTM_BRD_OUTINIT_CH4OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH4OI_SHIFT))

/*! @brief Set the CH4OI field to a new value. */
#define FTM_WR_OUTINIT_CH4OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH4OI_MASK, FTM_OUTINIT_CH4OI(value)))
#define FTM_BWR_OUTINIT_CH4OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH4OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH5OI[5] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH5OI field. */
#define FTM_RD_OUTINIT_CH5OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH5OI_MASK) >> FTM_OUTINIT_CH5OI_SHIFT)
#define FTM_BRD_OUTINIT_CH5OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH5OI_SHIFT))

/*! @brief Set the CH5OI field to a new value. */
#define FTM_WR_OUTINIT_CH5OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH5OI_MASK, FTM_OUTINIT_CH5OI(value)))
#define FTM_BWR_OUTINIT_CH5OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH5OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH6OI[6] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH6OI field. */
#define FTM_RD_OUTINIT_CH6OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH6OI_MASK) >> FTM_OUTINIT_CH6OI_SHIFT)
#define FTM_BRD_OUTINIT_CH6OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH6OI_SHIFT))

/*! @brief Set the CH6OI field to a new value. */
#define FTM_WR_OUTINIT_CH6OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH6OI_MASK, FTM_OUTINIT_CH6OI(value)))
#define FTM_BWR_OUTINIT_CH6OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH6OI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH7OI[7] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH7OI field. */
#define FTM_RD_OUTINIT_CH7OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH7OI_MASK) >> FTM_OUTINIT_CH7OI_SHIFT)
#define FTM_BRD_OUTINIT_CH7OI(base) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH7OI_SHIFT))

/*! @brief Set the CH7OI field to a new value. */
#define FTM_WR_OUTINIT_CH7OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH7OI_MASK, FTM_OUTINIT_CH7OI(value)))
#define FTM_BWR_OUTINIT_CH7OI(base, value) (BITBAND_ACCESS32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH7OI_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_OUTMASK - Output Mask
 ******************************************************************************/

/*!
 * @brief FTM_OUTMASK - Output Mask (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides a mask for each FTM channel. The mask of a channel
 * determines if its output responds, that is, it is masked or not, when a match
 * occurs. This feature is used for BLDC control where the PWM signal is presented
 * to an electric motor at specific times to provide electronic commutation. Any
 * write to the OUTMASK register, stores the value in its write buffer. The
 * register is updated with the value of its write buffer according to PWM
 * synchronization. Output Mask bits must not be set for trigger mode.
 */
/*!
 * @name Constants and macros for entire FTM_OUTMASK register
 */
/*@{*/
#define FTM_RD_OUTMASK(base)     (FTM_OUTMASK_REG(base))
#define FTM_WR_OUTMASK(base, value) (FTM_OUTMASK_REG(base) = (value))
#define FTM_RMW_OUTMASK(base, mask, value) (FTM_WR_OUTMASK(base, (FTM_RD_OUTMASK(base) & ~(mask)) | (value)))
#define FTM_SET_OUTMASK(base, value) (FTM_WR_OUTMASK(base, FTM_RD_OUTMASK(base) |  (value)))
#define FTM_CLR_OUTMASK(base, value) (FTM_WR_OUTMASK(base, FTM_RD_OUTMASK(base) & ~(value)))
#define FTM_TOG_OUTMASK(base, value) (FTM_WR_OUTMASK(base, FTM_RD_OUTMASK(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTMASK bitfields
 */

/*!
 * @name Register FTM_OUTMASK, field CH0OM[0] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH0OM field. */
#define FTM_RD_OUTMASK_CH0OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH0OM_MASK) >> FTM_OUTMASK_CH0OM_SHIFT)
#define FTM_BRD_OUTMASK_CH0OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH0OM_SHIFT))

/*! @brief Set the CH0OM field to a new value. */
#define FTM_WR_OUTMASK_CH0OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH0OM_MASK, FTM_OUTMASK_CH0OM(value)))
#define FTM_BWR_OUTMASK_CH0OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH0OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH1OM[1] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH1OM field. */
#define FTM_RD_OUTMASK_CH1OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH1OM_MASK) >> FTM_OUTMASK_CH1OM_SHIFT)
#define FTM_BRD_OUTMASK_CH1OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH1OM_SHIFT))

/*! @brief Set the CH1OM field to a new value. */
#define FTM_WR_OUTMASK_CH1OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH1OM_MASK, FTM_OUTMASK_CH1OM(value)))
#define FTM_BWR_OUTMASK_CH1OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH1OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH2OM[2] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH2OM field. */
#define FTM_RD_OUTMASK_CH2OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH2OM_MASK) >> FTM_OUTMASK_CH2OM_SHIFT)
#define FTM_BRD_OUTMASK_CH2OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH2OM_SHIFT))

/*! @brief Set the CH2OM field to a new value. */
#define FTM_WR_OUTMASK_CH2OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH2OM_MASK, FTM_OUTMASK_CH2OM(value)))
#define FTM_BWR_OUTMASK_CH2OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH2OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH3OM[3] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH3OM field. */
#define FTM_RD_OUTMASK_CH3OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH3OM_MASK) >> FTM_OUTMASK_CH3OM_SHIFT)
#define FTM_BRD_OUTMASK_CH3OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH3OM_SHIFT))

/*! @brief Set the CH3OM field to a new value. */
#define FTM_WR_OUTMASK_CH3OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH3OM_MASK, FTM_OUTMASK_CH3OM(value)))
#define FTM_BWR_OUTMASK_CH3OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH3OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH4OM[4] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH4OM field. */
#define FTM_RD_OUTMASK_CH4OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH4OM_MASK) >> FTM_OUTMASK_CH4OM_SHIFT)
#define FTM_BRD_OUTMASK_CH4OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH4OM_SHIFT))

/*! @brief Set the CH4OM field to a new value. */
#define FTM_WR_OUTMASK_CH4OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH4OM_MASK, FTM_OUTMASK_CH4OM(value)))
#define FTM_BWR_OUTMASK_CH4OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH4OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH5OM[5] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH5OM field. */
#define FTM_RD_OUTMASK_CH5OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH5OM_MASK) >> FTM_OUTMASK_CH5OM_SHIFT)
#define FTM_BRD_OUTMASK_CH5OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH5OM_SHIFT))

/*! @brief Set the CH5OM field to a new value. */
#define FTM_WR_OUTMASK_CH5OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH5OM_MASK, FTM_OUTMASK_CH5OM(value)))
#define FTM_BWR_OUTMASK_CH5OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH5OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH6OM[6] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH6OM field. */
#define FTM_RD_OUTMASK_CH6OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH6OM_MASK) >> FTM_OUTMASK_CH6OM_SHIFT)
#define FTM_BRD_OUTMASK_CH6OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH6OM_SHIFT))

/*! @brief Set the CH6OM field to a new value. */
#define FTM_WR_OUTMASK_CH6OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH6OM_MASK, FTM_OUTMASK_CH6OM(value)))
#define FTM_BWR_OUTMASK_CH6OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH6OM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH7OM[7] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH7OM field. */
#define FTM_RD_OUTMASK_CH7OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH7OM_MASK) >> FTM_OUTMASK_CH7OM_SHIFT)
#define FTM_BRD_OUTMASK_CH7OM(base) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH7OM_SHIFT))

/*! @brief Set the CH7OM field to a new value. */
#define FTM_WR_OUTMASK_CH7OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH7OM_MASK, FTM_OUTMASK_CH7OM(value)))
#define FTM_BWR_OUTMASK_CH7OM(base, value) (BITBAND_ACCESS32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH7OM_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_COMBINE - Function For Linked Channels
 ******************************************************************************/

/*!
 * @brief FTM_COMBINE - Function For Linked Channels (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the fault control,
 * synchronization, deadtime insertion, Dual Edge Capture mode, Complementary,
 * and Combine mode for each pair of channels (n) and (n+1), where n equals 0, 2,
 * 4, and 6.
 */
/*!
 * @name Constants and macros for entire FTM_COMBINE register
 */
/*@{*/
#define FTM_RD_COMBINE(base)     (FTM_COMBINE_REG(base))
#define FTM_WR_COMBINE(base, value) (FTM_COMBINE_REG(base) = (value))
#define FTM_RMW_COMBINE(base, mask, value) (FTM_WR_COMBINE(base, (FTM_RD_COMBINE(base) & ~(mask)) | (value)))
#define FTM_SET_COMBINE(base, value) (FTM_WR_COMBINE(base, FTM_RD_COMBINE(base) |  (value)))
#define FTM_CLR_COMBINE(base, value) (FTM_WR_COMBINE(base, FTM_RD_COMBINE(base) & ~(value)))
#define FTM_TOG_COMBINE(base, value) (FTM_WR_COMBINE(base, FTM_RD_COMBINE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_COMBINE bitfields
 */

/*!
 * @name Register FTM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE0 field. */
#define FTM_RD_COMBINE_COMBINE0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE0_MASK) >> FTM_COMBINE_COMBINE0_SHIFT)
#define FTM_BRD_COMBINE_COMBINE0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE0_SHIFT))

/*! @brief Set the COMBINE0 field to a new value. */
#define FTM_WR_COMBINE_COMBINE0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE0_MASK, FTM_COMBINE_COMBINE0(value)))
#define FTM_BWR_COMBINE_COMBINE0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP0[1] (RW)
 *
 * Enables Complementary mode for the combined, EPWM and CPWMS channels. In
 * Complementary mode the channel (n+1) output is the inverse of the channel (n)
 * output. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP0 field. */
#define FTM_RD_COMBINE_COMP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP0_MASK) >> FTM_COMBINE_COMP0_SHIFT)
#define FTM_BRD_COMBINE_COMP0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP0_SHIFT))

/*! @brief Set the COMP0 field to a new value. */
#define FTM_WR_COMBINE_COMP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP0_MASK, FTM_COMBINE_COMP0(value)))
#define FTM_BWR_COMBINE_COMP0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN0[2] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to the table. This field is write protected.
 * It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN0 field. */
#define FTM_RD_COMBINE_DECAPEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN0_MASK) >> FTM_COMBINE_DECAPEN0_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN0_SHIFT))

/*! @brief Set the DECAPEN0 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN0_MASK, FTM_COMBINE_DECAPEN0(value)))
#define FTM_BWR_COMBINE_DECAPEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP0[3] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP0 field. */
#define FTM_RD_COMBINE_DECAP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP0_MASK) >> FTM_COMBINE_DECAP0_SHIFT)
#define FTM_BRD_COMBINE_DECAP0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP0_SHIFT))

/*! @brief Set the DECAP0 field to a new value. */
#define FTM_WR_COMBINE_DECAP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP0_MASK, FTM_COMBINE_DECAP0(value)))
#define FTM_BWR_COMBINE_DECAP0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN0[4] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN0 field. */
#define FTM_RD_COMBINE_DTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN0_MASK) >> FTM_COMBINE_DTEN0_SHIFT)
#define FTM_BRD_COMBINE_DTEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN0_SHIFT))

/*! @brief Set the DTEN0 field to a new value. */
#define FTM_WR_COMBINE_DTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN0_MASK, FTM_COMBINE_DTEN0(value)))
#define FTM_BWR_COMBINE_DTEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN0[5] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN0 field. */
#define FTM_RD_COMBINE_SYNCEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN0_MASK) >> FTM_COMBINE_SYNCEN0_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN0_SHIFT))

/*! @brief Set the SYNCEN0 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN0_MASK, FTM_COMBINE_SYNCEN0(value)))
#define FTM_BWR_COMBINE_SYNCEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN0[6] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN0 field. */
#define FTM_RD_COMBINE_FAULTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN0_MASK) >> FTM_COMBINE_FAULTEN0_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN0(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN0_SHIFT))

/*! @brief Set the FAULTEN0 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN0_MASK, FTM_COMBINE_FAULTEN0(value)))
#define FTM_BWR_COMBINE_FAULTEN0(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE1 field. */
#define FTM_RD_COMBINE_COMBINE1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE1_MASK) >> FTM_COMBINE_COMBINE1_SHIFT)
#define FTM_BRD_COMBINE_COMBINE1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE1_SHIFT))

/*! @brief Set the COMBINE1 field to a new value. */
#define FTM_WR_COMBINE_COMBINE1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE1_MASK, FTM_COMBINE_COMBINE1(value)))
#define FTM_BWR_COMBINE_COMBINE1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP1[9] (RW)
 *
 * Enables Complementary mode for the combined, EPWM and CPWMS channels. In
 * Complementary mode the channel (n+1) output is the inverse of the channel (n)
 * output. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP1 field. */
#define FTM_RD_COMBINE_COMP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP1_MASK) >> FTM_COMBINE_COMP1_SHIFT)
#define FTM_BRD_COMBINE_COMP1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP1_SHIFT))

/*! @brief Set the COMP1 field to a new value. */
#define FTM_WR_COMBINE_COMP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP1_MASK, FTM_COMBINE_COMP1(value)))
#define FTM_BWR_COMBINE_COMP1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN1[10] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to the table. This field is write protected.
 * It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN1 field. */
#define FTM_RD_COMBINE_DECAPEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN1_MASK) >> FTM_COMBINE_DECAPEN1_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN1_SHIFT))

/*! @brief Set the DECAPEN1 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN1_MASK, FTM_COMBINE_DECAPEN1(value)))
#define FTM_BWR_COMBINE_DECAPEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP1[11] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * Dual Edge Capture - One-Shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP1 field. */
#define FTM_RD_COMBINE_DECAP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP1_MASK) >> FTM_COMBINE_DECAP1_SHIFT)
#define FTM_BRD_COMBINE_DECAP1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP1_SHIFT))

/*! @brief Set the DECAP1 field to a new value. */
#define FTM_WR_COMBINE_DECAP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP1_MASK, FTM_COMBINE_DECAP1(value)))
#define FTM_BWR_COMBINE_DECAP1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN1[12] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN1 field. */
#define FTM_RD_COMBINE_DTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN1_MASK) >> FTM_COMBINE_DTEN1_SHIFT)
#define FTM_BRD_COMBINE_DTEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN1_SHIFT))

/*! @brief Set the DTEN1 field to a new value. */
#define FTM_WR_COMBINE_DTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN1_MASK, FTM_COMBINE_DTEN1(value)))
#define FTM_BWR_COMBINE_DTEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN1[13] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN1 field. */
#define FTM_RD_COMBINE_SYNCEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN1_MASK) >> FTM_COMBINE_SYNCEN1_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN1_SHIFT))

/*! @brief Set the SYNCEN1 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN1_MASK, FTM_COMBINE_SYNCEN1(value)))
#define FTM_BWR_COMBINE_SYNCEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN1[14] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN1 field. */
#define FTM_RD_COMBINE_FAULTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN1_MASK) >> FTM_COMBINE_FAULTEN1_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN1(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN1_SHIFT))

/*! @brief Set the FAULTEN1 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN1_MASK, FTM_COMBINE_FAULTEN1(value)))
#define FTM_BWR_COMBINE_FAULTEN1(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE2[16] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE2 field. */
#define FTM_RD_COMBINE_COMBINE2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE2_MASK) >> FTM_COMBINE_COMBINE2_SHIFT)
#define FTM_BRD_COMBINE_COMBINE2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE2_SHIFT))

/*! @brief Set the COMBINE2 field to a new value. */
#define FTM_WR_COMBINE_COMBINE2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE2_MASK, FTM_COMBINE_COMBINE2(value)))
#define FTM_BWR_COMBINE_COMBINE2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP2[17] (RW)
 *
 * Enables Complementary mode for the combined, EPWM and CPWMS channels. In
 * Complementary mode the channel (n+1) output is the inverse of the channel (n)
 * output. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP2 field. */
#define FTM_RD_COMBINE_COMP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP2_MASK) >> FTM_COMBINE_COMP2_SHIFT)
#define FTM_BRD_COMBINE_COMP2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP2_SHIFT))

/*! @brief Set the COMP2 field to a new value. */
#define FTM_WR_COMBINE_COMP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP2_MASK, FTM_COMBINE_COMP2(value)))
#define FTM_BWR_COMBINE_COMP2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN2[18] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to the table. This field is write protected.
 * It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN2 field. */
#define FTM_RD_COMBINE_DECAPEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN2_MASK) >> FTM_COMBINE_DECAPEN2_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN2_SHIFT))

/*! @brief Set the DECAPEN2 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN2_MASK, FTM_COMBINE_DECAPEN2(value)))
#define FTM_BWR_COMBINE_DECAPEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP2[19] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP2 field. */
#define FTM_RD_COMBINE_DECAP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP2_MASK) >> FTM_COMBINE_DECAP2_SHIFT)
#define FTM_BRD_COMBINE_DECAP2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP2_SHIFT))

/*! @brief Set the DECAP2 field to a new value. */
#define FTM_WR_COMBINE_DECAP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP2_MASK, FTM_COMBINE_DECAP2(value)))
#define FTM_BWR_COMBINE_DECAP2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN2[20] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN2 field. */
#define FTM_RD_COMBINE_DTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN2_MASK) >> FTM_COMBINE_DTEN2_SHIFT)
#define FTM_BRD_COMBINE_DTEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN2_SHIFT))

/*! @brief Set the DTEN2 field to a new value. */
#define FTM_WR_COMBINE_DTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN2_MASK, FTM_COMBINE_DTEN2(value)))
#define FTM_BWR_COMBINE_DTEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN2[21] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN2 field. */
#define FTM_RD_COMBINE_SYNCEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN2_MASK) >> FTM_COMBINE_SYNCEN2_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN2_SHIFT))

/*! @brief Set the SYNCEN2 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN2_MASK, FTM_COMBINE_SYNCEN2(value)))
#define FTM_BWR_COMBINE_SYNCEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN2[22] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN2 field. */
#define FTM_RD_COMBINE_FAULTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN2_MASK) >> FTM_COMBINE_FAULTEN2_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN2(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN2_SHIFT))

/*! @brief Set the FAULTEN2 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN2_MASK, FTM_COMBINE_FAULTEN2(value)))
#define FTM_BWR_COMBINE_FAULTEN2(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE3[24] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE3 field. */
#define FTM_RD_COMBINE_COMBINE3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE3_MASK) >> FTM_COMBINE_COMBINE3_SHIFT)
#define FTM_BRD_COMBINE_COMBINE3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE3_SHIFT))

/*! @brief Set the COMBINE3 field to a new value. */
#define FTM_WR_COMBINE_COMBINE3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE3_MASK, FTM_COMBINE_COMBINE3(value)))
#define FTM_BWR_COMBINE_COMBINE3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP3[25] (RW)
 *
 * Enables Complementary mode for the combined, EPWM and CPWMS channels. In
 * Complementary mode the channel (n+1) output is the inverse of the channel (n)
 * output. This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP3 field. */
#define FTM_RD_COMBINE_COMP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP3_MASK) >> FTM_COMBINE_COMP3_SHIFT)
#define FTM_BRD_COMBINE_COMP3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP3_SHIFT))

/*! @brief Set the COMP3 field to a new value. */
#define FTM_WR_COMBINE_COMP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP3_MASK, FTM_COMBINE_COMP3(value)))
#define FTM_BWR_COMBINE_COMP3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN3[26] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to the table. This field is write protected.
 * It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN3 field. */
#define FTM_RD_COMBINE_DECAPEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN3_MASK) >> FTM_COMBINE_DECAPEN3_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN3_SHIFT))

/*! @brief Set the DECAPEN3 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN3_MASK, FTM_COMBINE_DECAPEN3(value)))
#define FTM_BWR_COMBINE_DECAPEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP3[27] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP3 field. */
#define FTM_RD_COMBINE_DECAP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP3_MASK) >> FTM_COMBINE_DECAP3_SHIFT)
#define FTM_BRD_COMBINE_DECAP3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP3_SHIFT))

/*! @brief Set the DECAP3 field to a new value. */
#define FTM_WR_COMBINE_DECAP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP3_MASK, FTM_COMBINE_DECAP3(value)))
#define FTM_BWR_COMBINE_DECAP3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN3[28] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN3 field. */
#define FTM_RD_COMBINE_DTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN3_MASK) >> FTM_COMBINE_DTEN3_SHIFT)
#define FTM_BRD_COMBINE_DTEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN3_SHIFT))

/*! @brief Set the DTEN3 field to a new value. */
#define FTM_WR_COMBINE_DTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN3_MASK, FTM_COMBINE_DTEN3(value)))
#define FTM_BWR_COMBINE_DTEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN3[29] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN3 field. */
#define FTM_RD_COMBINE_SYNCEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN3_MASK) >> FTM_COMBINE_SYNCEN3_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN3_SHIFT))

/*! @brief Set the SYNCEN3 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN3_MASK, FTM_COMBINE_SYNCEN3(value)))
#define FTM_BWR_COMBINE_SYNCEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN3[30] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN3 field. */
#define FTM_RD_COMBINE_FAULTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN3_MASK) >> FTM_COMBINE_FAULTEN3_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN3(base) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN3_SHIFT))

/*! @brief Set the FAULTEN3 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN3_MASK, FTM_COMBINE_FAULTEN3(value)))
#define FTM_BWR_COMBINE_FAULTEN3(base, value) (BITBAND_ACCESS32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_DEADTIME - Deadtime Insertion Control
 ******************************************************************************/

/*!
 * @brief FTM_DEADTIME - Deadtime Insertion Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the deadtime prescaler factor and deadtime value. All
 * FTM channels use this clock prescaler and this deadtime value for the deadtime
 * insertion.
 */
/*!
 * @name Constants and macros for entire FTM_DEADTIME register
 */
/*@{*/
#define FTM_RD_DEADTIME(base)    (FTM_DEADTIME_REG(base))
#define FTM_WR_DEADTIME(base, value) (FTM_DEADTIME_REG(base) = (value))
#define FTM_RMW_DEADTIME(base, mask, value) (FTM_WR_DEADTIME(base, (FTM_RD_DEADTIME(base) & ~(mask)) | (value)))
#define FTM_SET_DEADTIME(base, value) (FTM_WR_DEADTIME(base, FTM_RD_DEADTIME(base) |  (value)))
#define FTM_CLR_DEADTIME(base, value) (FTM_WR_DEADTIME(base, FTM_RD_DEADTIME(base) & ~(value)))
#define FTM_TOG_DEADTIME(base, value) (FTM_WR_DEADTIME(base, FTM_RD_DEADTIME(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_DEADTIME bitfields
 */

/*!
 * @name Register FTM_DEADTIME, field DTVAL[5:0] (RW)
 *
 * Selects the deadtime insertion value for the deadtime counter. The deadtime
 * counter is clocked by a scaled version of the system clock. See the description
 * of DTPS. Deadtime insert value = (DTPS * DTVAL). DTVAL selects the number of
 * deadtime counts inserted as follows: When DTVAL is 0, no counts are inserted.
 * When DTVAL is 1, 1 count is inserted. When DTVAL is 2, 2 counts are inserted.
 * This pattern continues up to a possible 63 counts. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTVAL field. */
#define FTM_RD_DEADTIME_DTVAL(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTVAL_MASK) >> FTM_DEADTIME_DTVAL_SHIFT)
#define FTM_BRD_DEADTIME_DTVAL(base) (FTM_RD_DEADTIME_DTVAL(base))

/*! @brief Set the DTVAL field to a new value. */
#define FTM_WR_DEADTIME_DTVAL(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTVAL_MASK, FTM_DEADTIME_DTVAL(value)))
#define FTM_BWR_DEADTIME_DTVAL(base, value) (FTM_WR_DEADTIME_DTVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_DEADTIME, field DTPS[7:6] (RW)
 *
 * Selects the division factor of the system clock. This prescaled clock is used
 * by the deadtime counter. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0x - Divide the system clock by 1.
 * - 0b10 - Divide the system clock by 4.
 * - 0b11 - Divide the system clock by 16.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTPS field. */
#define FTM_RD_DEADTIME_DTPS(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTPS_MASK) >> FTM_DEADTIME_DTPS_SHIFT)
#define FTM_BRD_DEADTIME_DTPS(base) (FTM_RD_DEADTIME_DTPS(base))

/*! @brief Set the DTPS field to a new value. */
#define FTM_WR_DEADTIME_DTPS(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTPS_MASK, FTM_DEADTIME_DTPS(value)))
#define FTM_BWR_DEADTIME_DTPS(base, value) (FTM_WR_DEADTIME_DTPS(base, value))
/*@}*/

/*******************************************************************************
 * FTM_EXTTRIG - FTM External Trigger
 ******************************************************************************/

/*!
 * @brief FTM_EXTTRIG - FTM External Trigger (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register: Indicates when a channel trigger was generated Enables the
 * generation of a trigger when the FTM counter is equal to its initial value
 * Selects which channels are used in the generation of the channel triggers Several
 * channels can be selected to generate multiple triggers in one PWM period.
 */
/*!
 * @name Constants and macros for entire FTM_EXTTRIG register
 */
/*@{*/
#define FTM_RD_EXTTRIG(base)     (FTM_EXTTRIG_REG(base))
#define FTM_WR_EXTTRIG(base, value) (FTM_EXTTRIG_REG(base) = (value))
#define FTM_RMW_EXTTRIG(base, mask, value) (FTM_WR_EXTTRIG(base, (FTM_RD_EXTTRIG(base) & ~(mask)) | (value)))
#define FTM_SET_EXTTRIG(base, value) (FTM_WR_EXTTRIG(base, FTM_RD_EXTTRIG(base) |  (value)))
#define FTM_CLR_EXTTRIG(base, value) (FTM_WR_EXTTRIG(base, FTM_RD_EXTTRIG(base) & ~(value)))
#define FTM_TOG_EXTTRIG(base, value) (FTM_WR_EXTTRIG(base, FTM_RD_EXTTRIG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_EXTTRIG bitfields
 */

/*!
 * @name Register FTM_EXTTRIG, field CH2TRIG[0] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH2TRIG field. */
#define FTM_RD_EXTTRIG_CH2TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH2TRIG_MASK) >> FTM_EXTTRIG_CH2TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH2TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH2TRIG_SHIFT))

/*! @brief Set the CH2TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH2TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH2TRIG_MASK, FTM_EXTTRIG_CH2TRIG(value)))
#define FTM_BWR_EXTTRIG_CH2TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH2TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH3TRIG[1] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH3TRIG field. */
#define FTM_RD_EXTTRIG_CH3TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH3TRIG_MASK) >> FTM_EXTTRIG_CH3TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH3TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH3TRIG_SHIFT))

/*! @brief Set the CH3TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH3TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH3TRIG_MASK, FTM_EXTTRIG_CH3TRIG(value)))
#define FTM_BWR_EXTTRIG_CH3TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH3TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH4TRIG[2] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH4TRIG field. */
#define FTM_RD_EXTTRIG_CH4TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH4TRIG_MASK) >> FTM_EXTTRIG_CH4TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH4TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH4TRIG_SHIFT))

/*! @brief Set the CH4TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH4TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH4TRIG_MASK, FTM_EXTTRIG_CH4TRIG(value)))
#define FTM_BWR_EXTTRIG_CH4TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH4TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH5TRIG[3] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH5TRIG field. */
#define FTM_RD_EXTTRIG_CH5TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH5TRIG_MASK) >> FTM_EXTTRIG_CH5TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH5TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH5TRIG_SHIFT))

/*! @brief Set the CH5TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH5TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH5TRIG_MASK, FTM_EXTTRIG_CH5TRIG(value)))
#define FTM_BWR_EXTTRIG_CH5TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH5TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH0TRIG[4] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH0TRIG field. */
#define FTM_RD_EXTTRIG_CH0TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH0TRIG_MASK) >> FTM_EXTTRIG_CH0TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH0TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH0TRIG_SHIFT))

/*! @brief Set the CH0TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH0TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH0TRIG_MASK, FTM_EXTTRIG_CH0TRIG(value)))
#define FTM_BWR_EXTTRIG_CH0TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH0TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH1TRIG[5] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH1TRIG field. */
#define FTM_RD_EXTTRIG_CH1TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH1TRIG_MASK) >> FTM_EXTTRIG_CH1TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH1TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH1TRIG_SHIFT))

/*! @brief Set the CH1TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH1TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH1TRIG_MASK, FTM_EXTTRIG_CH1TRIG(value)))
#define FTM_BWR_EXTTRIG_CH1TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH1TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field INITTRIGEN[6] (RW)
 *
 * Enables the generation of the trigger when the FTM counter is equal to the
 * CNTIN register.
 *
 * Values:
 * - 0b0 - The generation of initialization trigger is disabled.
 * - 0b1 - The generation of initialization trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_INITTRIGEN field. */
#define FTM_RD_EXTTRIG_INITTRIGEN(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_INITTRIGEN_MASK) >> FTM_EXTTRIG_INITTRIGEN_SHIFT)
#define FTM_BRD_EXTTRIG_INITTRIGEN(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_INITTRIGEN_SHIFT))

/*! @brief Set the INITTRIGEN field to a new value. */
#define FTM_WR_EXTTRIG_INITTRIGEN(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_INITTRIGEN_MASK, FTM_EXTTRIG_INITTRIGEN(value)))
#define FTM_BWR_EXTTRIG_INITTRIGEN(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_INITTRIGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field TRIGF[7] (ROWZ)
 *
 * Set by hardware when a channel trigger is generated. Clear TRIGF by reading
 * EXTTRIG while TRIGF is set and then writing a 0 to TRIGF. Writing a 1 to TRIGF
 * has no effect. If another channel trigger is generated before the clearing
 * sequence is completed, the sequence is reset so TRIGF remains set after the clear
 * sequence is completed for the earlier TRIGF.
 *
 * Values:
 * - 0b0 - No channel trigger was generated.
 * - 0b1 - A channel trigger was generated.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_TRIGF field. */
#define FTM_RD_EXTTRIG_TRIGF(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_TRIGF_MASK) >> FTM_EXTTRIG_TRIGF_SHIFT)
#define FTM_BRD_EXTTRIG_TRIGF(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_TRIGF_SHIFT))

/*! @brief Set the TRIGF field to a new value. */
#define FTM_WR_EXTTRIG_TRIGF(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_TRIGF_MASK, FTM_EXTTRIG_TRIGF(value)))
#define FTM_BWR_EXTTRIG_TRIGF(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_TRIGF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH6TRIG[8] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH6TRIG field. */
#define FTM_RD_EXTTRIG_CH6TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH6TRIG_MASK) >> FTM_EXTTRIG_CH6TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH6TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH6TRIG_SHIFT))

/*! @brief Set the CH6TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH6TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH6TRIG_MASK, FTM_EXTTRIG_CH6TRIG(value)))
#define FTM_BWR_EXTTRIG_CH6TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH6TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH7TRIG[9] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH7TRIG field. */
#define FTM_RD_EXTTRIG_CH7TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH7TRIG_MASK) >> FTM_EXTTRIG_CH7TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH7TRIG(base) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH7TRIG_SHIFT))

/*! @brief Set the CH7TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH7TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH7TRIG_MASK, FTM_EXTTRIG_CH7TRIG(value)))
#define FTM_BWR_EXTTRIG_CH7TRIG(base, value) (BITBAND_ACCESS32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH7TRIG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_POL - Channels Polarity
 ******************************************************************************/

/*!
 * @brief FTM_POL - Channels Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the output polarity of the FTM channels. The safe value
 * that is driven in a channel output when the fault control is enabled and a
 * fault condition is detected is the inactive state of the channel. That is, the
 * safe value of a channel is the value of its POL bit.
 */
/*!
 * @name Constants and macros for entire FTM_POL register
 */
/*@{*/
#define FTM_RD_POL(base)         (FTM_POL_REG(base))
#define FTM_WR_POL(base, value)  (FTM_POL_REG(base) = (value))
#define FTM_RMW_POL(base, mask, value) (FTM_WR_POL(base, (FTM_RD_POL(base) & ~(mask)) | (value)))
#define FTM_SET_POL(base, value) (FTM_WR_POL(base, FTM_RD_POL(base) |  (value)))
#define FTM_CLR_POL(base, value) (FTM_WR_POL(base, FTM_RD_POL(base) & ~(value)))
#define FTM_TOG_POL(base, value) (FTM_WR_POL(base, FTM_RD_POL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_POL bitfields
 */

/*!
 * @name Register FTM_POL, field POL0[0] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL0 field. */
#define FTM_RD_POL_POL0(base) ((FTM_POL_REG(base) & FTM_POL_POL0_MASK) >> FTM_POL_POL0_SHIFT)
#define FTM_BRD_POL_POL0(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL0_SHIFT))

/*! @brief Set the POL0 field to a new value. */
#define FTM_WR_POL_POL0(base, value) (FTM_RMW_POL(base, FTM_POL_POL0_MASK, FTM_POL_POL0(value)))
#define FTM_BWR_POL_POL0(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL1[1] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL1 field. */
#define FTM_RD_POL_POL1(base) ((FTM_POL_REG(base) & FTM_POL_POL1_MASK) >> FTM_POL_POL1_SHIFT)
#define FTM_BRD_POL_POL1(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL1_SHIFT))

/*! @brief Set the POL1 field to a new value. */
#define FTM_WR_POL_POL1(base, value) (FTM_RMW_POL(base, FTM_POL_POL1_MASK, FTM_POL_POL1(value)))
#define FTM_BWR_POL_POL1(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL2[2] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL2 field. */
#define FTM_RD_POL_POL2(base) ((FTM_POL_REG(base) & FTM_POL_POL2_MASK) >> FTM_POL_POL2_SHIFT)
#define FTM_BRD_POL_POL2(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL2_SHIFT))

/*! @brief Set the POL2 field to a new value. */
#define FTM_WR_POL_POL2(base, value) (FTM_RMW_POL(base, FTM_POL_POL2_MASK, FTM_POL_POL2(value)))
#define FTM_BWR_POL_POL2(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL3[3] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL3 field. */
#define FTM_RD_POL_POL3(base) ((FTM_POL_REG(base) & FTM_POL_POL3_MASK) >> FTM_POL_POL3_SHIFT)
#define FTM_BRD_POL_POL3(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL3_SHIFT))

/*! @brief Set the POL3 field to a new value. */
#define FTM_WR_POL_POL3(base, value) (FTM_RMW_POL(base, FTM_POL_POL3_MASK, FTM_POL_POL3(value)))
#define FTM_BWR_POL_POL3(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL4[4] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL4 field. */
#define FTM_RD_POL_POL4(base) ((FTM_POL_REG(base) & FTM_POL_POL4_MASK) >> FTM_POL_POL4_SHIFT)
#define FTM_BRD_POL_POL4(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL4_SHIFT))

/*! @brief Set the POL4 field to a new value. */
#define FTM_WR_POL_POL4(base, value) (FTM_RMW_POL(base, FTM_POL_POL4_MASK, FTM_POL_POL4(value)))
#define FTM_BWR_POL_POL4(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL5[5] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL5 field. */
#define FTM_RD_POL_POL5(base) ((FTM_POL_REG(base) & FTM_POL_POL5_MASK) >> FTM_POL_POL5_SHIFT)
#define FTM_BRD_POL_POL5(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL5_SHIFT))

/*! @brief Set the POL5 field to a new value. */
#define FTM_WR_POL_POL5(base, value) (FTM_RMW_POL(base, FTM_POL_POL5_MASK, FTM_POL_POL5(value)))
#define FTM_BWR_POL_POL5(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL6[6] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL6 field. */
#define FTM_RD_POL_POL6(base) ((FTM_POL_REG(base) & FTM_POL_POL6_MASK) >> FTM_POL_POL6_SHIFT)
#define FTM_BRD_POL_POL6(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL6_SHIFT))

/*! @brief Set the POL6 field to a new value. */
#define FTM_WR_POL_POL6(base, value) (FTM_RMW_POL(base, FTM_POL_POL6_MASK, FTM_POL_POL6(value)))
#define FTM_BWR_POL_POL6(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_POL, field POL7[7] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL7 field. */
#define FTM_RD_POL_POL7(base) ((FTM_POL_REG(base) & FTM_POL_POL7_MASK) >> FTM_POL_POL7_SHIFT)
#define FTM_BRD_POL_POL7(base) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL7_SHIFT))

/*! @brief Set the POL7 field to a new value. */
#define FTM_WR_POL_POL7(base, value) (FTM_RMW_POL(base, FTM_POL_POL7_MASK, FTM_POL_POL7(value)))
#define FTM_BWR_POL_POL7(base, value) (BITBAND_ACCESS32(&FTM_POL_REG(base), FTM_POL_POL7_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_FMS - Fault Mode Status
 ******************************************************************************/

/*!
 * @brief FTM_FMS - Fault Mode Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the fault detection flags, write protection enable
 * bit, and the logic OR of the enabled fault inputs.
 */
/*!
 * @name Constants and macros for entire FTM_FMS register
 */
/*@{*/
#define FTM_RD_FMS(base)         (FTM_FMS_REG(base))
#define FTM_WR_FMS(base, value)  (FTM_FMS_REG(base) = (value))
#define FTM_RMW_FMS(base, mask, value) (FTM_WR_FMS(base, (FTM_RD_FMS(base) & ~(mask)) | (value)))
#define FTM_SET_FMS(base, value) (FTM_WR_FMS(base, FTM_RD_FMS(base) |  (value)))
#define FTM_CLR_FMS(base, value) (FTM_WR_FMS(base, FTM_RD_FMS(base) & ~(value)))
#define FTM_TOG_FMS(base, value) (FTM_WR_FMS(base, FTM_RD_FMS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FMS bitfields
 */

/*!
 * @name Register FTM_FMS, field FAULTF0[0] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF0
 * by reading the FMS register while FAULTF0 is set and then writing a 0 to
 * FAULTF0 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF0 has no effect. FAULTF0 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF0 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF0 field. */
#define FTM_RD_FMS_FAULTF0(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF0_MASK) >> FTM_FMS_FAULTF0_SHIFT)
#define FTM_BRD_FMS_FAULTF0(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF0_SHIFT))

/*! @brief Set the FAULTF0 field to a new value. */
#define FTM_WR_FMS_FAULTF0(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF0_MASK, FTM_FMS_FAULTF0(value)))
#define FTM_BWR_FMS_FAULTF0(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF1[1] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF1
 * by reading the FMS register while FAULTF1 is set and then writing a 0 to
 * FAULTF1 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF1 has no effect. FAULTF1 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF1 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF1 field. */
#define FTM_RD_FMS_FAULTF1(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF1_MASK) >> FTM_FMS_FAULTF1_SHIFT)
#define FTM_BRD_FMS_FAULTF1(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF1_SHIFT))

/*! @brief Set the FAULTF1 field to a new value. */
#define FTM_WR_FMS_FAULTF1(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF1_MASK, FTM_FMS_FAULTF1(value)))
#define FTM_BWR_FMS_FAULTF1(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF2[2] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF2
 * by reading the FMS register while FAULTF2 is set and then writing a 0 to
 * FAULTF2 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF2 has no effect. FAULTF2 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF2 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF2 field. */
#define FTM_RD_FMS_FAULTF2(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF2_MASK) >> FTM_FMS_FAULTF2_SHIFT)
#define FTM_BRD_FMS_FAULTF2(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF2_SHIFT))

/*! @brief Set the FAULTF2 field to a new value. */
#define FTM_WR_FMS_FAULTF2(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF2_MASK, FTM_FMS_FAULTF2(value)))
#define FTM_BWR_FMS_FAULTF2(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF3[3] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF3
 * by reading the FMS register while FAULTF3 is set and then writing a 0 to
 * FAULTF3 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF3 has no effect. FAULTF3 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF3 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF3 field. */
#define FTM_RD_FMS_FAULTF3(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF3_MASK) >> FTM_FMS_FAULTF3_SHIFT)
#define FTM_BRD_FMS_FAULTF3(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF3_SHIFT))

/*! @brief Set the FAULTF3 field to a new value. */
#define FTM_WR_FMS_FAULTF3(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF3_MASK, FTM_FMS_FAULTF3(value)))
#define FTM_BWR_FMS_FAULTF3(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTIN[5] (RO)
 *
 * Represents the logic OR of the enabled fault inputs after their filter (if
 * their filter is enabled) when fault control is enabled.
 *
 * Values:
 * - 0b0 - The logic OR of the enabled fault inputs is 0.
 * - 0b1 - The logic OR of the enabled fault inputs is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTIN field. */
#define FTM_RD_FMS_FAULTIN(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTIN_MASK) >> FTM_FMS_FAULTIN_SHIFT)
#define FTM_BRD_FMS_FAULTIN(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTIN_SHIFT))
/*@}*/

/*!
 * @name Register FTM_FMS, field WPEN[6] (RW)
 *
 * The WPEN bit is the negation of the WPDIS bit. WPEN is set when 1 is written
 * to it. WPEN is cleared when WPEN bit is read as a 1 and then 1 is written to
 * WPDIS. Writing 0 to WPEN has no effect.
 *
 * Values:
 * - 0b0 - Write protection is disabled. Write protected bits can be written.
 * - 0b1 - Write protection is enabled. Write protected bits cannot be written.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_WPEN field. */
#define FTM_RD_FMS_WPEN(base) ((FTM_FMS_REG(base) & FTM_FMS_WPEN_MASK) >> FTM_FMS_WPEN_SHIFT)
#define FTM_BRD_FMS_WPEN(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_WPEN_SHIFT))

/*! @brief Set the WPEN field to a new value. */
#define FTM_WR_FMS_WPEN(base, value) (FTM_RMW_FMS(base, FTM_FMS_WPEN_MASK, FTM_FMS_WPEN(value)))
#define FTM_BWR_FMS_WPEN(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_WPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF[7] (ROWZ)
 *
 * Represents the logic OR of the individual FAULTFj bits where j = 3, 2, 1, 0.
 * Clear FAULTF by reading the FMS register while FAULTF is set and then writing
 * a 0 to FAULTF while there is no existing fault condition at the enabled fault
 * inputs. Writing a 1 to FAULTF has no effect. If another fault condition is
 * detected in an enabled fault input before the clearing sequence is completed, the
 * sequence is reset so FAULTF remains set after the clearing sequence is
 * completed for the earlier fault condition. FAULTF is also cleared when FAULTFj bits
 * are cleared individually.
 *
 * Values:
 * - 0b0 - No fault condition was detected.
 * - 0b1 - A fault condition was detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF field. */
#define FTM_RD_FMS_FAULTF(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF_MASK) >> FTM_FMS_FAULTF_SHIFT)
#define FTM_BRD_FMS_FAULTF(base) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF_SHIFT))

/*! @brief Set the FAULTF field to a new value. */
#define FTM_WR_FMS_FAULTF(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF(value)))
#define FTM_BWR_FMS_FAULTF(base, value) (BITBAND_ACCESS32(&FTM_FMS_REG(base), FTM_FMS_FAULTF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_FILTER - Input Capture Filter Control
 ******************************************************************************/

/*!
 * @brief FTM_FILTER - Input Capture Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the inputs of channels. Channels
 * 4, 5, 6 and 7 do not have an input filter. Writing to the FILTER register has
 * immediate effect and must be done only when the channels 0, 1, 2, and 3 are not
 * in input modes. Failure to do this could result in a missing valid signal.
 */
/*!
 * @name Constants and macros for entire FTM_FILTER register
 */
/*@{*/
#define FTM_RD_FILTER(base)      (FTM_FILTER_REG(base))
#define FTM_WR_FILTER(base, value) (FTM_FILTER_REG(base) = (value))
#define FTM_RMW_FILTER(base, mask, value) (FTM_WR_FILTER(base, (FTM_RD_FILTER(base) & ~(mask)) | (value)))
#define FTM_SET_FILTER(base, value) (FTM_WR_FILTER(base, FTM_RD_FILTER(base) |  (value)))
#define FTM_CLR_FILTER(base, value) (FTM_WR_FILTER(base, FTM_RD_FILTER(base) & ~(value)))
#define FTM_TOG_FILTER(base, value) (FTM_WR_FILTER(base, FTM_RD_FILTER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FILTER bitfields
 */

/*!
 * @name Register FTM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH0FVAL field. */
#define FTM_RD_FILTER_CH0FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH0FVAL_MASK) >> FTM_FILTER_CH0FVAL_SHIFT)
#define FTM_BRD_FILTER_CH0FVAL(base) (FTM_RD_FILTER_CH0FVAL(base))

/*! @brief Set the CH0FVAL field to a new value. */
#define FTM_WR_FILTER_CH0FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH0FVAL_MASK, FTM_FILTER_CH0FVAL(value)))
#define FTM_BWR_FILTER_CH0FVAL(base, value) (FTM_WR_FILTER_CH0FVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH1FVAL field. */
#define FTM_RD_FILTER_CH1FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH1FVAL_MASK) >> FTM_FILTER_CH1FVAL_SHIFT)
#define FTM_BRD_FILTER_CH1FVAL(base) (FTM_RD_FILTER_CH1FVAL(base))

/*! @brief Set the CH1FVAL field to a new value. */
#define FTM_WR_FILTER_CH1FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH1FVAL_MASK, FTM_FILTER_CH1FVAL(value)))
#define FTM_BWR_FILTER_CH1FVAL(base, value) (FTM_WR_FILTER_CH1FVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH2FVAL field. */
#define FTM_RD_FILTER_CH2FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH2FVAL_MASK) >> FTM_FILTER_CH2FVAL_SHIFT)
#define FTM_BRD_FILTER_CH2FVAL(base) (FTM_RD_FILTER_CH2FVAL(base))

/*! @brief Set the CH2FVAL field to a new value. */
#define FTM_WR_FILTER_CH2FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH2FVAL_MASK, FTM_FILTER_CH2FVAL(value)))
#define FTM_BWR_FILTER_CH2FVAL(base, value) (FTM_WR_FILTER_CH2FVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH3FVAL field. */
#define FTM_RD_FILTER_CH3FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH3FVAL_MASK) >> FTM_FILTER_CH3FVAL_SHIFT)
#define FTM_BRD_FILTER_CH3FVAL(base) (FTM_RD_FILTER_CH3FVAL(base))

/*! @brief Set the CH3FVAL field to a new value. */
#define FTM_WR_FILTER_CH3FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH3FVAL_MASK, FTM_FILTER_CH3FVAL(value)))
#define FTM_BWR_FILTER_CH3FVAL(base, value) (FTM_WR_FILTER_CH3FVAL(base, value))
/*@}*/

/*******************************************************************************
 * FTM_FLTCTRL - Fault Control
 ******************************************************************************/

/*!
 * @brief FTM_FLTCTRL - Fault Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the fault inputs, enables the
 * fault inputs and the fault inputs filter. This register also controls the output
 * state when a fault event happens.
 */
/*!
 * @name Constants and macros for entire FTM_FLTCTRL register
 */
/*@{*/
#define FTM_RD_FLTCTRL(base)     (FTM_FLTCTRL_REG(base))
#define FTM_WR_FLTCTRL(base, value) (FTM_FLTCTRL_REG(base) = (value))
#define FTM_RMW_FLTCTRL(base, mask, value) (FTM_WR_FLTCTRL(base, (FTM_RD_FLTCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTCTRL(base, value) (FTM_WR_FLTCTRL(base, FTM_RD_FLTCTRL(base) |  (value)))
#define FTM_CLR_FLTCTRL(base, value) (FTM_WR_FLTCTRL(base, FTM_RD_FLTCTRL(base) & ~(value)))
#define FTM_TOG_FLTCTRL(base, value) (FTM_WR_FLTCTRL(base, FTM_RD_FLTCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTCTRL bitfields
 */

/*!
 * @name Register FTM_FLTCTRL, field FAULT0EN[0] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT0EN field. */
#define FTM_RD_FLTCTRL_FAULT0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT0EN_MASK) >> FTM_FLTCTRL_FAULT0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT0EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT0EN_SHIFT))

/*! @brief Set the FAULT0EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT0EN_MASK, FTM_FLTCTRL_FAULT0EN(value)))
#define FTM_BWR_FLTCTRL_FAULT0EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT0EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT1EN[1] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT1EN field. */
#define FTM_RD_FLTCTRL_FAULT1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT1EN_MASK) >> FTM_FLTCTRL_FAULT1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT1EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT1EN_SHIFT))

/*! @brief Set the FAULT1EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT1EN_MASK, FTM_FLTCTRL_FAULT1EN(value)))
#define FTM_BWR_FLTCTRL_FAULT1EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT1EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT2EN[2] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT2EN field. */
#define FTM_RD_FLTCTRL_FAULT2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT2EN_MASK) >> FTM_FLTCTRL_FAULT2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT2EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT2EN_SHIFT))

/*! @brief Set the FAULT2EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT2EN_MASK, FTM_FLTCTRL_FAULT2EN(value)))
#define FTM_BWR_FLTCTRL_FAULT2EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT2EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT3EN[3] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT3EN field. */
#define FTM_RD_FLTCTRL_FAULT3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT3EN_MASK) >> FTM_FLTCTRL_FAULT3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT3EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT3EN_SHIFT))

/*! @brief Set the FAULT3EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT3EN_MASK, FTM_FLTCTRL_FAULT3EN(value)))
#define FTM_BWR_FLTCTRL_FAULT3EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT3EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR0EN[4] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR0EN field. */
#define FTM_RD_FLTCTRL_FFLTR0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR0EN_MASK) >> FTM_FLTCTRL_FFLTR0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR0EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR0EN_SHIFT))

/*! @brief Set the FFLTR0EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR0EN_MASK, FTM_FLTCTRL_FFLTR0EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR0EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR0EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR1EN[5] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR1EN field. */
#define FTM_RD_FLTCTRL_FFLTR1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR1EN_MASK) >> FTM_FLTCTRL_FFLTR1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR1EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR1EN_SHIFT))

/*! @brief Set the FFLTR1EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR1EN_MASK, FTM_FLTCTRL_FFLTR1EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR1EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR1EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR2EN[6] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR2EN field. */
#define FTM_RD_FLTCTRL_FFLTR2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR2EN_MASK) >> FTM_FLTCTRL_FFLTR2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR2EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR2EN_SHIFT))

/*! @brief Set the FFLTR2EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR2EN_MASK, FTM_FLTCTRL_FFLTR2EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR2EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR2EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR3EN[7] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR3EN field. */
#define FTM_RD_FLTCTRL_FFLTR3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR3EN_MASK) >> FTM_FLTCTRL_FFLTR3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR3EN(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR3EN_SHIFT))

/*! @brief Set the FFLTR3EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR3EN_MASK, FTM_FLTCTRL_FFLTR3EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR3EN(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR3EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFVAL[11:8] (RW)
 *
 * Selects the filter value for the fault inputs. The fault filter is disabled
 * when the value is zero. Writing to this field has immediate effect and must be
 * done only when the fault control or all fault inputs are disabled. Failure to
 * do this could result in a missing fault detection.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFVAL field. */
#define FTM_RD_FLTCTRL_FFVAL(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFVAL_MASK) >> FTM_FLTCTRL_FFVAL_SHIFT)
#define FTM_BRD_FLTCTRL_FFVAL(base) (FTM_RD_FLTCTRL_FFVAL(base))

/*! @brief Set the FFVAL field to a new value. */
#define FTM_WR_FLTCTRL_FFVAL(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFVAL_MASK, FTM_FLTCTRL_FFVAL(value)))
#define FTM_BWR_FLTCTRL_FFVAL(base, value) (FTM_WR_FLTCTRL_FFVAL(base, value))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FSTATE[15] (RW)
 *
 * This configuration allows to put the FTM outputs tri-stated when a fault
 * event is ongoing. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM outputs will be placed into safe values when fault events in
 *     ongoing (defined by POL bits).
 * - 0b1 - FTM outputs will be tri-stated when fault event is ongoing
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FSTATE field. */
#define FTM_RD_FLTCTRL_FSTATE(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FSTATE_MASK) >> FTM_FLTCTRL_FSTATE_SHIFT)
#define FTM_BRD_FLTCTRL_FSTATE(base) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FSTATE_SHIFT))

/*! @brief Set the FSTATE field to a new value. */
#define FTM_WR_FLTCTRL_FSTATE(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FSTATE_MASK, FTM_FLTCTRL_FSTATE(value)))
#define FTM_BWR_FLTCTRL_FSTATE(base, value) (BITBAND_ACCESS32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FSTATE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_QDCTRL - Quadrature Decoder Control And Status
 ******************************************************************************/

/*!
 * @brief FTM_QDCTRL - Quadrature Decoder Control And Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the Quadrature Decoder mode.
 */
/*!
 * @name Constants and macros for entire FTM_QDCTRL register
 */
/*@{*/
#define FTM_RD_QDCTRL(base)      (FTM_QDCTRL_REG(base))
#define FTM_WR_QDCTRL(base, value) (FTM_QDCTRL_REG(base) = (value))
#define FTM_RMW_QDCTRL(base, mask, value) (FTM_WR_QDCTRL(base, (FTM_RD_QDCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_QDCTRL(base, value) (FTM_WR_QDCTRL(base, FTM_RD_QDCTRL(base) |  (value)))
#define FTM_CLR_QDCTRL(base, value) (FTM_WR_QDCTRL(base, FTM_RD_QDCTRL(base) & ~(value)))
#define FTM_TOG_QDCTRL(base, value) (FTM_WR_QDCTRL(base, FTM_RD_QDCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_QDCTRL bitfields
 */

/*!
 * @name Register FTM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the Quadrature Decoder mode. In this mode, the phase A and B input
 * signals control the FTM counter direction. The Quadrature Decoder mode has
 * precedence over the other modes. See the table. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Quadrature Decoder mode is disabled.
 * - 0b1 - Quadrature Decoder mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADEN field. */
#define FTM_RD_QDCTRL_QUADEN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADEN_MASK) >> FTM_QDCTRL_QUADEN_SHIFT)
#define FTM_BRD_QDCTRL_QUADEN(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADEN_SHIFT))

/*! @brief Set the QUADEN field to a new value. */
#define FTM_WR_QDCTRL_QUADEN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADEN_MASK, FTM_QDCTRL_QUADEN(value)))
#define FTM_BWR_QDCTRL_QUADEN(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0b0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (CNTIN register)
 *     to its maximum value (MOD register).
 * - 0b1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (CNTIN register).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_TOFDIR field. */
#define FTM_RD_QDCTRL_TOFDIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_TOFDIR_MASK) >> FTM_QDCTRL_TOFDIR_SHIFT)
#define FTM_BRD_QDCTRL_TOFDIR(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_TOFDIR_SHIFT))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0b0 - Counting direction is decreasing (FTM counter decrement).
 * - 0b1 - Counting direction is increasing (FTM counter increment).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADIR field. */
#define FTM_RD_QDCTRL_QUADIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADIR_MASK) >> FTM_QDCTRL_QUADIR_SHIFT)
#define FTM_BRD_QDCTRL_QUADIR(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADIR_SHIFT))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the Quadrature Decoder mode.
 *
 * Values:
 * - 0b0 - Phase A and phase B encoding mode.
 * - 0b1 - Count and direction encoding mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADMODE field. */
#define FTM_RD_QDCTRL_QUADMODE(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADMODE_MASK) >> FTM_QDCTRL_QUADMODE_SHIFT)
#define FTM_BRD_QDCTRL_QUADMODE(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADMODE_SHIFT))

/*! @brief Set the QUADMODE field to a new value. */
#define FTM_WR_QDCTRL_QUADMODE(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADMODE_MASK, FTM_QDCTRL_QUADMODE(value)))
#define FTM_BWR_QDCTRL_QUADMODE(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBPOL[4] (RW)
 *
 * Selects the polarity for the quadrature decoder phase B input.
 *
 * Values:
 * - 0b0 - Normal polarity. Phase B input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 0b1 - Inverted polarity. Phase B input signal is inverted before
 *     identifying the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBPOL field. */
#define FTM_RD_QDCTRL_PHBPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBPOL_MASK) >> FTM_QDCTRL_PHBPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHBPOL(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBPOL_SHIFT))

/*! @brief Set the PHBPOL field to a new value. */
#define FTM_WR_QDCTRL_PHBPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBPOL_MASK, FTM_QDCTRL_PHBPOL(value)))
#define FTM_BWR_QDCTRL_PHBPOL(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAPOL[5] (RW)
 *
 * Selects the polarity for the quadrature decoder phase A input.
 *
 * Values:
 * - 0b0 - Normal polarity. Phase A input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 0b1 - Inverted polarity. Phase A input signal is inverted before
 *     identifying the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAPOL field. */
#define FTM_RD_QDCTRL_PHAPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAPOL_MASK) >> FTM_QDCTRL_PHAPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHAPOL(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAPOL_SHIFT))

/*! @brief Set the PHAPOL field to a new value. */
#define FTM_WR_QDCTRL_PHAPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAPOL_MASK, FTM_QDCTRL_PHAPOL(value)))
#define FTM_BWR_QDCTRL_PHAPOL(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBFLTREN[6] (RW)
 *
 * Enables the filter for the quadrature decoder phase B input. The filter value
 * for the phase B input is defined by the CH1FVAL field of FILTER. The phase B
 * filter is also disabled when CH1FVAL is zero.
 *
 * Values:
 * - 0b0 - Phase B input filter is disabled.
 * - 0b1 - Phase B input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBFLTREN field. */
#define FTM_RD_QDCTRL_PHBFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBFLTREN_MASK) >> FTM_QDCTRL_PHBFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHBFLTREN(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBFLTREN_SHIFT))

/*! @brief Set the PHBFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHBFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBFLTREN_MASK, FTM_QDCTRL_PHBFLTREN(value)))
#define FTM_BWR_QDCTRL_PHBFLTREN(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBFLTREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAFLTREN[7] (RW)
 *
 * Enables the filter for the quadrature decoder phase A input. The filter value
 * for the phase A input is defined by the CH0FVAL field of FILTER. The phase A
 * filter is also disabled when CH0FVAL is zero.
 *
 * Values:
 * - 0b0 - Phase A input filter is disabled.
 * - 0b1 - Phase A input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAFLTREN field. */
#define FTM_RD_QDCTRL_PHAFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAFLTREN_MASK) >> FTM_QDCTRL_PHAFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHAFLTREN(base) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAFLTREN_SHIFT))

/*! @brief Set the PHAFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHAFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAFLTREN_MASK, FTM_QDCTRL_PHAFLTREN(value)))
#define FTM_BWR_QDCTRL_PHAFLTREN(base, value) (BITBAND_ACCESS32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAFLTREN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief FTM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the number of times that a reload opportunity should
 * occur before the RF bit is set, the FTM behavior in Debug modes, the use of an
 * external global time base, and the global time base signal generation. This
 * register also controls if initialization trigger should be generated when a
 * reload point is reached.
 */
/*!
 * @name Constants and macros for entire FTM_CONF register
 */
/*@{*/
#define FTM_RD_CONF(base)        (FTM_CONF_REG(base))
#define FTM_WR_CONF(base, value) (FTM_CONF_REG(base) = (value))
#define FTM_RMW_CONF(base, mask, value) (FTM_WR_CONF(base, (FTM_RD_CONF(base) & ~(mask)) | (value)))
#define FTM_SET_CONF(base, value) (FTM_WR_CONF(base, FTM_RD_CONF(base) |  (value)))
#define FTM_CLR_CONF(base, value) (FTM_WR_CONF(base, FTM_RD_CONF(base) & ~(value)))
#define FTM_TOG_CONF(base, value) (FTM_WR_CONF(base, FTM_RD_CONF(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CONF bitfields
 */

/*!
 * @name Register FTM_CONF, field LDFQ[4:0] (RW)
 *
 * Selects PWM reload frequency. LDFQ = 0: RF bit is set every reload
 * oportunity. LDFQ = 1: RF bit is set every 2 reload oportunities. LDFQ = 2: RF bit is set
 * every 3 reload oportunities. LDFQ = 3: RF bit is set every 4 reload
 * oportunities. This pattern continues up to a maximum of 32.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_LDFQ field. */
#define FTM_RD_CONF_LDFQ(base) ((FTM_CONF_REG(base) & FTM_CONF_LDFQ_MASK) >> FTM_CONF_LDFQ_SHIFT)
#define FTM_BRD_CONF_LDFQ(base) (FTM_RD_CONF_LDFQ(base))

/*! @brief Set the LDFQ field to a new value. */
#define FTM_WR_CONF_LDFQ(base, value) (FTM_RMW_CONF(base, FTM_CONF_LDFQ_MASK, FTM_CONF_LDFQ(value)))
#define FTM_BWR_CONF_LDFQ(base, value) (FTM_WR_CONF_LDFQ(base, value))
/*@}*/

/*!
 * @name Register FTM_CONF, field BDMMODE[7:6] (RW)
 *
 * Selects the FTM behavior in Debug mode. See Debug mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_BDMMODE field. */
#define FTM_RD_CONF_BDMMODE(base) ((FTM_CONF_REG(base) & FTM_CONF_BDMMODE_MASK) >> FTM_CONF_BDMMODE_SHIFT)
#define FTM_BRD_CONF_BDMMODE(base) (FTM_RD_CONF_BDMMODE(base))

/*! @brief Set the BDMMODE field to a new value. */
#define FTM_WR_CONF_BDMMODE(base, value) (FTM_RMW_CONF(base, FTM_CONF_BDMMODE_MASK, FTM_CONF_BDMMODE(value)))
#define FTM_BWR_CONF_BDMMODE(base, value) (FTM_WR_CONF_BDMMODE(base, value))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the FTM to use an external global time base signal that is
 * generated by another FTM.
 *
 * Values:
 * - 0b0 - Use of an external global time base is disabled.
 * - 0b1 - Use of an external global time base is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEEN field. */
#define FTM_RD_CONF_GTBEEN(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEEN_MASK) >> FTM_CONF_GTBEEN_SHIFT)
#define FTM_BRD_CONF_GTBEEN(base) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEEN_SHIFT))

/*! @brief Set the GTBEEN field to a new value. */
#define FTM_WR_CONF_GTBEEN(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEEN_MASK, FTM_CONF_GTBEEN(value)))
#define FTM_BWR_CONF_GTBEEN(base, value) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEOUT[10] (RW)
 *
 * Enables the global time base signal generation to other FTMs.
 *
 * Values:
 * - 0b0 - A global time base signal generation is disabled.
 * - 0b1 - A global time base signal generation is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEOUT field. */
#define FTM_RD_CONF_GTBEOUT(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEOUT_MASK) >> FTM_CONF_GTBEOUT_SHIFT)
#define FTM_BRD_CONF_GTBEOUT(base) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEOUT_SHIFT))

/*! @brief Set the GTBEOUT field to a new value. */
#define FTM_WR_CONF_GTBEOUT(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEOUT_MASK, FTM_CONF_GTBEOUT(value)))
#define FTM_BWR_CONF_GTBEOUT(base, value) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_GTBEOUT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_CONF, field ITRIGR[11] (RW)
 *
 * This bit controls whether an initialization trigger is generated when a
 * reload point configured by PWMLOAD register is reached considering the
 * FTM_CONF[LDFQ] settings.
 *
 * Values:
 * - 0b0 - Initialization trigger is generated on counter wrap events.
 * - 0b1 - Initialization trigger is generated when a reload point is reached.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_ITRIGR field. */
#define FTM_RD_CONF_ITRIGR(base) ((FTM_CONF_REG(base) & FTM_CONF_ITRIGR_MASK) >> FTM_CONF_ITRIGR_SHIFT)
#define FTM_BRD_CONF_ITRIGR(base) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_ITRIGR_SHIFT))

/*! @brief Set the ITRIGR field to a new value. */
#define FTM_WR_CONF_ITRIGR(base, value) (FTM_RMW_CONF(base, FTM_CONF_ITRIGR_MASK, FTM_CONF_ITRIGR(value)))
#define FTM_BWR_CONF_ITRIGR(base, value) (BITBAND_ACCESS32(&FTM_CONF_REG(base), FTM_CONF_ITRIGR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_FLTPOL - FTM Fault Input Polarity
 ******************************************************************************/

/*!
 * @brief FTM_FLTPOL - FTM Fault Input Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the fault inputs polarity.
 */
/*!
 * @name Constants and macros for entire FTM_FLTPOL register
 */
/*@{*/
#define FTM_RD_FLTPOL(base)      (FTM_FLTPOL_REG(base))
#define FTM_WR_FLTPOL(base, value) (FTM_FLTPOL_REG(base) = (value))
#define FTM_RMW_FLTPOL(base, mask, value) (FTM_WR_FLTPOL(base, (FTM_RD_FLTPOL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTPOL(base, value) (FTM_WR_FLTPOL(base, FTM_RD_FLTPOL(base) |  (value)))
#define FTM_CLR_FLTPOL(base, value) (FTM_WR_FLTPOL(base, FTM_RD_FLTPOL(base) & ~(value)))
#define FTM_TOG_FLTPOL(base, value) (FTM_WR_FLTPOL(base, FTM_RD_FLTPOL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTPOL bitfields
 */

/*!
 * @name Register FTM_FLTPOL, field FLT0POL[0] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT0POL field. */
#define FTM_RD_FLTPOL_FLT0POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT0POL_MASK) >> FTM_FLTPOL_FLT0POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT0POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT0POL_SHIFT))

/*! @brief Set the FLT0POL field to a new value. */
#define FTM_WR_FLTPOL_FLT0POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT0POL_MASK, FTM_FLTPOL_FLT0POL(value)))
#define FTM_BWR_FLTPOL_FLT0POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT0POL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT1POL[1] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT1POL field. */
#define FTM_RD_FLTPOL_FLT1POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT1POL_MASK) >> FTM_FLTPOL_FLT1POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT1POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT1POL_SHIFT))

/*! @brief Set the FLT1POL field to a new value. */
#define FTM_WR_FLTPOL_FLT1POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT1POL_MASK, FTM_FLTPOL_FLT1POL(value)))
#define FTM_BWR_FLTPOL_FLT1POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT1POL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT2POL[2] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT2POL field. */
#define FTM_RD_FLTPOL_FLT2POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT2POL_MASK) >> FTM_FLTPOL_FLT2POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT2POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT2POL_SHIFT))

/*! @brief Set the FLT2POL field to a new value. */
#define FTM_WR_FLTPOL_FLT2POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT2POL_MASK, FTM_FLTPOL_FLT2POL(value)))
#define FTM_BWR_FLTPOL_FLT2POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT2POL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT3POL[3] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT3POL field. */
#define FTM_RD_FLTPOL_FLT3POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT3POL_MASK) >> FTM_FLTPOL_FLT3POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT3POL(base) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT3POL_SHIFT))

/*! @brief Set the FLT3POL field to a new value. */
#define FTM_WR_FLTPOL_FLT3POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT3POL_MASK, FTM_FLTPOL_FLT3POL(value)))
#define FTM_BWR_FLTPOL_FLT3POL(base, value) (BITBAND_ACCESS32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT3POL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_SYNCONF - Synchronization Configuration
 ******************************************************************************/

/*!
 * @brief FTM_SYNCONF - Synchronization Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the PWM synchronization configuration, SWOCTRL, INVCTRL
 * and CNTIN registers synchronization, if FTM clears the TRIGj bit, where j =
 * 0, 1, 2, when the hardware trigger j is detected.
 */
/*!
 * @name Constants and macros for entire FTM_SYNCONF register
 */
/*@{*/
#define FTM_RD_SYNCONF(base)     (FTM_SYNCONF_REG(base))
#define FTM_WR_SYNCONF(base, value) (FTM_SYNCONF_REG(base) = (value))
#define FTM_RMW_SYNCONF(base, mask, value) (FTM_WR_SYNCONF(base, (FTM_RD_SYNCONF(base) & ~(mask)) | (value)))
#define FTM_SET_SYNCONF(base, value) (FTM_WR_SYNCONF(base, FTM_RD_SYNCONF(base) |  (value)))
#define FTM_CLR_SYNCONF(base, value) (FTM_WR_SYNCONF(base, FTM_RD_SYNCONF(base) & ~(value)))
#define FTM_TOG_SYNCONF(base, value) (FTM_WR_SYNCONF(base, FTM_RD_SYNCONF(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNCONF bitfields
 */

/*!
 * @name Register FTM_SYNCONF, field HWTRIGMODE[0] (RW)
 *
 * Values:
 * - 0b0 - FTM clears the TRIGj bit when the hardware trigger j is detected,
 *     where j = 0, 1,2.
 * - 0b1 - FTM does not clear the TRIGj bit when the hardware trigger j is
 *     detected, where j = 0, 1,2.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWTRIGMODE field. */
#define FTM_RD_SYNCONF_HWTRIGMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWTRIGMODE_MASK) >> FTM_SYNCONF_HWTRIGMODE_SHIFT)
#define FTM_BRD_SYNCONF_HWTRIGMODE(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWTRIGMODE_SHIFT))

/*! @brief Set the HWTRIGMODE field to a new value. */
#define FTM_WR_SYNCONF_HWTRIGMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWTRIGMODE_MASK, FTM_SYNCONF_HWTRIGMODE(value)))
#define FTM_BWR_SYNCONF_HWTRIGMODE(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWTRIGMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field CNTINC[2] (RW)
 *
 * Values:
 * - 0b0 - CNTIN register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 0b1 - CNTIN register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_CNTINC field. */
#define FTM_RD_SYNCONF_CNTINC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_CNTINC_MASK) >> FTM_SYNCONF_CNTINC_SHIFT)
#define FTM_BRD_SYNCONF_CNTINC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_CNTINC_SHIFT))

/*! @brief Set the CNTINC field to a new value. */
#define FTM_WR_SYNCONF_CNTINC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_CNTINC_MASK, FTM_SYNCONF_CNTINC(value)))
#define FTM_BWR_SYNCONF_CNTINC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_CNTINC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field INVC[4] (RW)
 *
 * Values:
 * - 0b0 - INVCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 0b1 - INVCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_INVC field. */
#define FTM_RD_SYNCONF_INVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_INVC_MASK) >> FTM_SYNCONF_INVC_SHIFT)
#define FTM_BRD_SYNCONF_INVC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_INVC_SHIFT))

/*! @brief Set the INVC field to a new value. */
#define FTM_WR_SYNCONF_INVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_INVC_MASK, FTM_SYNCONF_INVC(value)))
#define FTM_BWR_SYNCONF_INVC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_INVC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOC[5] (RW)
 *
 * Values:
 * - 0b0 - SWOCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 0b1 - SWOCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOC field. */
#define FTM_RD_SYNCONF_SWOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOC_MASK) >> FTM_SYNCONF_SWOC_SHIFT)
#define FTM_BRD_SYNCONF_SWOC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOC_SHIFT))

/*! @brief Set the SWOC field to a new value. */
#define FTM_WR_SYNCONF_SWOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOC_MASK, FTM_SYNCONF_SWOC(value)))
#define FTM_BWR_SYNCONF_SWOC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SYNCMODE[7] (RW)
 *
 * Selects the PWM Synchronization mode.
 *
 * Values:
 * - 0b0 - Legacy PWM synchronization is selected.
 * - 0b1 - Enhanced PWM synchronization is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SYNCMODE field. */
#define FTM_RD_SYNCONF_SYNCMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SYNCMODE_MASK) >> FTM_SYNCONF_SYNCMODE_SHIFT)
#define FTM_BRD_SYNCONF_SYNCMODE(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SYNCMODE_SHIFT))

/*! @brief Set the SYNCMODE field to a new value. */
#define FTM_WR_SYNCONF_SYNCMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SYNCMODE_MASK, FTM_SYNCONF_SYNCMODE(value)))
#define FTM_BWR_SYNCONF_SYNCMODE(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SYNCMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWRSTCNT[8] (RW)
 *
 * FTM counter synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the FTM counter
 *     synchronization.
 * - 0b1 - The software trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWRSTCNT field. */
#define FTM_RD_SYNCONF_SWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWRSTCNT_MASK) >> FTM_SYNCONF_SWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_SWRSTCNT(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWRSTCNT_SHIFT))

/*! @brief Set the SWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_SWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWRSTCNT_MASK, FTM_SYNCONF_SWRSTCNT(value)))
#define FTM_BWR_SYNCONF_SWRSTCNT(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWRSTCNT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWWRBUF[9] (RW)
 *
 * MOD, HCR, CNTIN, and CV registers synchronization is activated by the
 * software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate MOD, HCR, CNTIN, and CV
 *     registers synchronization.
 * - 0b1 - The software trigger activates MOD, HCR, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWWRBUF field. */
#define FTM_RD_SYNCONF_SWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWWRBUF_MASK) >> FTM_SYNCONF_SWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_SWWRBUF(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWWRBUF_SHIFT))

/*! @brief Set the SWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_SWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWWRBUF_MASK, FTM_SYNCONF_SWWRBUF(value)))
#define FTM_BWR_SYNCONF_SWWRBUF(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWWRBUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOM[10] (RW)
 *
 * Output mask synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the OUTMASK register
 *     synchronization.
 * - 0b1 - The software trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOM field. */
#define FTM_RD_SYNCONF_SWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOM_MASK) >> FTM_SYNCONF_SWOM_SHIFT)
#define FTM_BRD_SYNCONF_SWOM(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOM_SHIFT))

/*! @brief Set the SWOM field to a new value. */
#define FTM_WR_SYNCONF_SWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOM_MASK, FTM_SYNCONF_SWOM(value)))
#define FTM_BWR_SYNCONF_SWOM(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWINVC[11] (RW)
 *
 * Inverting control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the INVCTRL register
 *     synchronization.
 * - 0b1 - The software trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWINVC field. */
#define FTM_RD_SYNCONF_SWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWINVC_MASK) >> FTM_SYNCONF_SWINVC_SHIFT)
#define FTM_BRD_SYNCONF_SWINVC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWINVC_SHIFT))

/*! @brief Set the SWINVC field to a new value. */
#define FTM_WR_SYNCONF_SWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWINVC_MASK, FTM_SYNCONF_SWINVC(value)))
#define FTM_BWR_SYNCONF_SWINVC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWINVC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWSOC[12] (RW)
 *
 * Software output control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 0b1 - The software trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWSOC field. */
#define FTM_RD_SYNCONF_SWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWSOC_MASK) >> FTM_SYNCONF_SWSOC_SHIFT)
#define FTM_BRD_SYNCONF_SWSOC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWSOC_SHIFT))

/*! @brief Set the SWSOC field to a new value. */
#define FTM_WR_SYNCONF_SWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWSOC_MASK, FTM_SYNCONF_SWSOC(value)))
#define FTM_BWR_SYNCONF_SWSOC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWSOC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWRSTCNT[16] (RW)
 *
 * FTM counter synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the FTM counter synchronization.
 * - 0b1 - A hardware trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWRSTCNT field. */
#define FTM_RD_SYNCONF_HWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWRSTCNT_MASK) >> FTM_SYNCONF_HWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_HWRSTCNT(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWRSTCNT_SHIFT))

/*! @brief Set the HWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_HWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWRSTCNT_MASK, FTM_SYNCONF_HWRSTCNT(value)))
#define FTM_BWR_SYNCONF_HWRSTCNT(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWRSTCNT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWWRBUF[17] (RW)
 *
 * MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware
 * trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate MOD, HCR, CNTIN, and CV
 *     registers synchronization.
 * - 0b1 - A hardware trigger activates MOD, HCR, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWWRBUF field. */
#define FTM_RD_SYNCONF_HWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWWRBUF_MASK) >> FTM_SYNCONF_HWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_HWWRBUF(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWWRBUF_SHIFT))

/*! @brief Set the HWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_HWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWWRBUF_MASK, FTM_SYNCONF_HWWRBUF(value)))
#define FTM_BWR_SYNCONF_HWWRBUF(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWWRBUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWOM[18] (RW)
 *
 * Output mask synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the OUTMASK register
 *     synchronization.
 * - 0b1 - A hardware trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWOM field. */
#define FTM_RD_SYNCONF_HWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWOM_MASK) >> FTM_SYNCONF_HWOM_SHIFT)
#define FTM_BRD_SYNCONF_HWOM(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWOM_SHIFT))

/*! @brief Set the HWOM field to a new value. */
#define FTM_WR_SYNCONF_HWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWOM_MASK, FTM_SYNCONF_HWOM(value)))
#define FTM_BWR_SYNCONF_HWOM(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWINVC[19] (RW)
 *
 * Inverting control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the INVCTRL register
 *     synchronization.
 * - 0b1 - A hardware trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWINVC field. */
#define FTM_RD_SYNCONF_HWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWINVC_MASK) >> FTM_SYNCONF_HWINVC_SHIFT)
#define FTM_BRD_SYNCONF_HWINVC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWINVC_SHIFT))

/*! @brief Set the HWINVC field to a new value. */
#define FTM_WR_SYNCONF_HWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWINVC_MASK, FTM_SYNCONF_HWINVC(value)))
#define FTM_BWR_SYNCONF_HWINVC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWINVC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWSOC[20] (RW)
 *
 * Software output control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 0b1 - A hardware trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWSOC field. */
#define FTM_RD_SYNCONF_HWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWSOC_MASK) >> FTM_SYNCONF_HWSOC_SHIFT)
#define FTM_BRD_SYNCONF_HWSOC(base) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWSOC_SHIFT))

/*! @brief Set the HWSOC field to a new value. */
#define FTM_WR_SYNCONF_HWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWSOC_MASK, FTM_SYNCONF_HWSOC(value)))
#define FTM_BWR_SYNCONF_HWSOC(base, value) (BITBAND_ACCESS32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWSOC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_INVCTRL - FTM Inverting Control
 ******************************************************************************/

/*!
 * @brief FTM_INVCTRL - FTM Inverting Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls when the channel (n) output becomes the channel (n+1)
 * output, and channel (n+1) output becomes the channel (n) output. Each INVmEN
 * bit enables the inverting operation for the corresponding pair channels m. This
 * register has a write buffer. The INVmEN bit is updated by the INVCTRL
 * register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_INVCTRL register
 */
/*@{*/
#define FTM_RD_INVCTRL(base)     (FTM_INVCTRL_REG(base))
#define FTM_WR_INVCTRL(base, value) (FTM_INVCTRL_REG(base) = (value))
#define FTM_RMW_INVCTRL(base, mask, value) (FTM_WR_INVCTRL(base, (FTM_RD_INVCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_INVCTRL(base, value) (FTM_WR_INVCTRL(base, FTM_RD_INVCTRL(base) |  (value)))
#define FTM_CLR_INVCTRL(base, value) (FTM_WR_INVCTRL(base, FTM_RD_INVCTRL(base) & ~(value)))
#define FTM_TOG_INVCTRL(base, value) (FTM_WR_INVCTRL(base, FTM_RD_INVCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_INVCTRL bitfields
 */

/*!
 * @name Register FTM_INVCTRL, field INV0EN[0] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV0EN field. */
#define FTM_RD_INVCTRL_INV0EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV0EN_MASK) >> FTM_INVCTRL_INV0EN_SHIFT)
#define FTM_BRD_INVCTRL_INV0EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV0EN_SHIFT))

/*! @brief Set the INV0EN field to a new value. */
#define FTM_WR_INVCTRL_INV0EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV0EN_MASK, FTM_INVCTRL_INV0EN(value)))
#define FTM_BWR_INVCTRL_INV0EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV0EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV1EN[1] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV1EN field. */
#define FTM_RD_INVCTRL_INV1EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV1EN_MASK) >> FTM_INVCTRL_INV1EN_SHIFT)
#define FTM_BRD_INVCTRL_INV1EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV1EN_SHIFT))

/*! @brief Set the INV1EN field to a new value. */
#define FTM_WR_INVCTRL_INV1EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV1EN_MASK, FTM_INVCTRL_INV1EN(value)))
#define FTM_BWR_INVCTRL_INV1EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV1EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV2EN[2] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV2EN field. */
#define FTM_RD_INVCTRL_INV2EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV2EN_MASK) >> FTM_INVCTRL_INV2EN_SHIFT)
#define FTM_BRD_INVCTRL_INV2EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV2EN_SHIFT))

/*! @brief Set the INV2EN field to a new value. */
#define FTM_WR_INVCTRL_INV2EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV2EN_MASK, FTM_INVCTRL_INV2EN(value)))
#define FTM_BWR_INVCTRL_INV2EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV2EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV3EN[3] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV3EN field. */
#define FTM_RD_INVCTRL_INV3EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV3EN_MASK) >> FTM_INVCTRL_INV3EN_SHIFT)
#define FTM_BRD_INVCTRL_INV3EN(base) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV3EN_SHIFT))

/*! @brief Set the INV3EN field to a new value. */
#define FTM_WR_INVCTRL_INV3EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV3EN_MASK, FTM_INVCTRL_INV3EN(value)))
#define FTM_BWR_INVCTRL_INV3EN(base, value) (BITBAND_ACCESS32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV3EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_SWOCTRL - FTM Software Output Control
 ******************************************************************************/

/*!
 * @brief FTM_SWOCTRL - FTM Software Output Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register enables software control of channel (n) output and defines the
 * value forced to the channel (n) output: The CHnOC bits enable the control of
 * the corresponding channel (n) output by software. The CHnOCV bits select the
 * value that is forced at the corresponding channel (n) output. This register has
 * a write buffer. The fields are updated by the SWOCTRL register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SWOCTRL register
 */
/*@{*/
#define FTM_RD_SWOCTRL(base)     (FTM_SWOCTRL_REG(base))
#define FTM_WR_SWOCTRL(base, value) (FTM_SWOCTRL_REG(base) = (value))
#define FTM_RMW_SWOCTRL(base, mask, value) (FTM_WR_SWOCTRL(base, (FTM_RD_SWOCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_SWOCTRL(base, value) (FTM_WR_SWOCTRL(base, FTM_RD_SWOCTRL(base) |  (value)))
#define FTM_CLR_SWOCTRL(base, value) (FTM_WR_SWOCTRL(base, FTM_RD_SWOCTRL(base) & ~(value)))
#define FTM_TOG_SWOCTRL(base, value) (FTM_WR_SWOCTRL(base, FTM_RD_SWOCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SWOCTRL bitfields
 */

/*!
 * @name Register FTM_SWOCTRL, field CH0OC[0] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OC field. */
#define FTM_RD_SWOCTRL_CH0OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OC_MASK) >> FTM_SWOCTRL_CH0OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OC_SHIFT))

/*! @brief Set the CH0OC field to a new value. */
#define FTM_WR_SWOCTRL_CH0OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OC_MASK, FTM_SWOCTRL_CH0OC(value)))
#define FTM_BWR_SWOCTRL_CH0OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OC[1] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OC field. */
#define FTM_RD_SWOCTRL_CH1OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OC_MASK) >> FTM_SWOCTRL_CH1OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OC_SHIFT))

/*! @brief Set the CH1OC field to a new value. */
#define FTM_WR_SWOCTRL_CH1OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OC_MASK, FTM_SWOCTRL_CH1OC(value)))
#define FTM_BWR_SWOCTRL_CH1OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OC[2] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OC field. */
#define FTM_RD_SWOCTRL_CH2OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OC_MASK) >> FTM_SWOCTRL_CH2OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OC_SHIFT))

/*! @brief Set the CH2OC field to a new value. */
#define FTM_WR_SWOCTRL_CH2OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OC_MASK, FTM_SWOCTRL_CH2OC(value)))
#define FTM_BWR_SWOCTRL_CH2OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OC[3] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OC field. */
#define FTM_RD_SWOCTRL_CH3OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OC_MASK) >> FTM_SWOCTRL_CH3OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OC_SHIFT))

/*! @brief Set the CH3OC field to a new value. */
#define FTM_WR_SWOCTRL_CH3OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OC_MASK, FTM_SWOCTRL_CH3OC(value)))
#define FTM_BWR_SWOCTRL_CH3OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OC[4] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OC field. */
#define FTM_RD_SWOCTRL_CH4OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OC_MASK) >> FTM_SWOCTRL_CH4OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OC_SHIFT))

/*! @brief Set the CH4OC field to a new value. */
#define FTM_WR_SWOCTRL_CH4OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OC_MASK, FTM_SWOCTRL_CH4OC(value)))
#define FTM_BWR_SWOCTRL_CH4OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OC[5] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OC field. */
#define FTM_RD_SWOCTRL_CH5OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OC_MASK) >> FTM_SWOCTRL_CH5OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OC_SHIFT))

/*! @brief Set the CH5OC field to a new value. */
#define FTM_WR_SWOCTRL_CH5OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OC_MASK, FTM_SWOCTRL_CH5OC(value)))
#define FTM_BWR_SWOCTRL_CH5OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OC[6] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OC field. */
#define FTM_RD_SWOCTRL_CH6OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OC_MASK) >> FTM_SWOCTRL_CH6OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OC_SHIFT))

/*! @brief Set the CH6OC field to a new value. */
#define FTM_WR_SWOCTRL_CH6OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OC_MASK, FTM_SWOCTRL_CH6OC(value)))
#define FTM_BWR_SWOCTRL_CH6OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OC[7] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OC field. */
#define FTM_RD_SWOCTRL_CH7OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OC_MASK) >> FTM_SWOCTRL_CH7OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OC(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OC_SHIFT))

/*! @brief Set the CH7OC field to a new value. */
#define FTM_WR_SWOCTRL_CH7OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OC_MASK, FTM_SWOCTRL_CH7OC(value)))
#define FTM_BWR_SWOCTRL_CH7OC(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH0OCV[8] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OCV field. */
#define FTM_RD_SWOCTRL_CH0OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OCV_MASK) >> FTM_SWOCTRL_CH0OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OCV_SHIFT))

/*! @brief Set the CH0OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH0OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OCV_MASK, FTM_SWOCTRL_CH0OCV(value)))
#define FTM_BWR_SWOCTRL_CH0OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OCV[9] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OCV field. */
#define FTM_RD_SWOCTRL_CH1OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OCV_MASK) >> FTM_SWOCTRL_CH1OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OCV_SHIFT))

/*! @brief Set the CH1OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH1OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OCV_MASK, FTM_SWOCTRL_CH1OCV(value)))
#define FTM_BWR_SWOCTRL_CH1OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OCV[10] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OCV field. */
#define FTM_RD_SWOCTRL_CH2OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OCV_MASK) >> FTM_SWOCTRL_CH2OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OCV_SHIFT))

/*! @brief Set the CH2OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH2OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OCV_MASK, FTM_SWOCTRL_CH2OCV(value)))
#define FTM_BWR_SWOCTRL_CH2OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OCV[11] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OCV field. */
#define FTM_RD_SWOCTRL_CH3OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OCV_MASK) >> FTM_SWOCTRL_CH3OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OCV_SHIFT))

/*! @brief Set the CH3OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH3OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OCV_MASK, FTM_SWOCTRL_CH3OCV(value)))
#define FTM_BWR_SWOCTRL_CH3OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OCV[12] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OCV field. */
#define FTM_RD_SWOCTRL_CH4OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OCV_MASK) >> FTM_SWOCTRL_CH4OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OCV_SHIFT))

/*! @brief Set the CH4OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH4OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OCV_MASK, FTM_SWOCTRL_CH4OCV(value)))
#define FTM_BWR_SWOCTRL_CH4OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OCV[13] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OCV field. */
#define FTM_RD_SWOCTRL_CH5OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OCV_MASK) >> FTM_SWOCTRL_CH5OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OCV_SHIFT))

/*! @brief Set the CH5OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH5OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OCV_MASK, FTM_SWOCTRL_CH5OCV(value)))
#define FTM_BWR_SWOCTRL_CH5OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OCV[14] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OCV field. */
#define FTM_RD_SWOCTRL_CH6OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OCV_MASK) >> FTM_SWOCTRL_CH6OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OCV_SHIFT))

/*! @brief Set the CH6OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH6OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OCV_MASK, FTM_SWOCTRL_CH6OCV(value)))
#define FTM_BWR_SWOCTRL_CH6OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OCV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OCV[15] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OCV field. */
#define FTM_RD_SWOCTRL_CH7OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OCV_MASK) >> FTM_SWOCTRL_CH7OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OCV(base) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OCV_SHIFT))

/*! @brief Set the CH7OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH7OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OCV_MASK, FTM_SWOCTRL_CH7OCV(value)))
#define FTM_BWR_SWOCTRL_CH7OCV(base, value) (BITBAND_ACCESS32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OCV_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_PWMLOAD - FTM PWM Load
 ******************************************************************************/

/*!
 * @brief FTM_PWMLOAD - FTM PWM Load (RW)
 *
 * Reset value: 0x00000000U
 *
 * Enables the reload of the MOD, HCR, CNTIN, C(n)V, and C(n+1)V registers with
 * the values of their write buffers when the FTM counter changes from the MOD
 * register value to its next value or when a channel (j) match occurs. A match
 * occurs for channel (j) when FTM counter = C(j)V. A reload can also occurs when
 * FTM counter = HCR register at a half cycle match. This register also controls
 * the local and global load mechanisms.
 */
/*!
 * @name Constants and macros for entire FTM_PWMLOAD register
 */
/*@{*/
#define FTM_RD_PWMLOAD(base)     (FTM_PWMLOAD_REG(base))
#define FTM_WR_PWMLOAD(base, value) (FTM_PWMLOAD_REG(base) = (value))
#define FTM_RMW_PWMLOAD(base, mask, value) (FTM_WR_PWMLOAD(base, (FTM_RD_PWMLOAD(base) & ~(mask)) | (value)))
#define FTM_SET_PWMLOAD(base, value) (FTM_WR_PWMLOAD(base, FTM_RD_PWMLOAD(base) |  (value)))
#define FTM_CLR_PWMLOAD(base, value) (FTM_WR_PWMLOAD(base, FTM_RD_PWMLOAD(base) & ~(value)))
#define FTM_TOG_PWMLOAD(base, value) (FTM_WR_PWMLOAD(base, FTM_RD_PWMLOAD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_PWMLOAD bitfields
 */

/*!
 * @name Register FTM_PWMLOAD, field CH0SEL[0] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH0SEL field. */
#define FTM_RD_PWMLOAD_CH0SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH0SEL_MASK) >> FTM_PWMLOAD_CH0SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH0SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH0SEL_SHIFT))

/*! @brief Set the CH0SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH0SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH0SEL_MASK, FTM_PWMLOAD_CH0SEL(value)))
#define FTM_BWR_PWMLOAD_CH0SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH0SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH1SEL[1] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH1SEL field. */
#define FTM_RD_PWMLOAD_CH1SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH1SEL_MASK) >> FTM_PWMLOAD_CH1SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH1SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH1SEL_SHIFT))

/*! @brief Set the CH1SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH1SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH1SEL_MASK, FTM_PWMLOAD_CH1SEL(value)))
#define FTM_BWR_PWMLOAD_CH1SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH1SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH2SEL[2] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH2SEL field. */
#define FTM_RD_PWMLOAD_CH2SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH2SEL_MASK) >> FTM_PWMLOAD_CH2SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH2SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH2SEL_SHIFT))

/*! @brief Set the CH2SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH2SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH2SEL_MASK, FTM_PWMLOAD_CH2SEL(value)))
#define FTM_BWR_PWMLOAD_CH2SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH2SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH3SEL[3] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH3SEL field. */
#define FTM_RD_PWMLOAD_CH3SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH3SEL_MASK) >> FTM_PWMLOAD_CH3SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH3SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH3SEL_SHIFT))

/*! @brief Set the CH3SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH3SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH3SEL_MASK, FTM_PWMLOAD_CH3SEL(value)))
#define FTM_BWR_PWMLOAD_CH3SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH3SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH4SEL[4] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH4SEL field. */
#define FTM_RD_PWMLOAD_CH4SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH4SEL_MASK) >> FTM_PWMLOAD_CH4SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH4SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH4SEL_SHIFT))

/*! @brief Set the CH4SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH4SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH4SEL_MASK, FTM_PWMLOAD_CH4SEL(value)))
#define FTM_BWR_PWMLOAD_CH4SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH4SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH5SEL[5] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH5SEL field. */
#define FTM_RD_PWMLOAD_CH5SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH5SEL_MASK) >> FTM_PWMLOAD_CH5SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH5SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH5SEL_SHIFT))

/*! @brief Set the CH5SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH5SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH5SEL_MASK, FTM_PWMLOAD_CH5SEL(value)))
#define FTM_BWR_PWMLOAD_CH5SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH5SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH6SEL[6] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH6SEL field. */
#define FTM_RD_PWMLOAD_CH6SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH6SEL_MASK) >> FTM_PWMLOAD_CH6SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH6SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH6SEL_SHIFT))

/*! @brief Set the CH6SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH6SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH6SEL_MASK, FTM_PWMLOAD_CH6SEL(value)))
#define FTM_BWR_PWMLOAD_CH6SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH6SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH7SEL[7] (RW)
 *
 * Values:
 * - 0b0 - Channel match is not included as a reload opportunity.
 * - 0b1 - Channel match is included as a reload opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH7SEL field. */
#define FTM_RD_PWMLOAD_CH7SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH7SEL_MASK) >> FTM_PWMLOAD_CH7SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH7SEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH7SEL_SHIFT))

/*! @brief Set the CH7SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH7SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH7SEL_MASK, FTM_PWMLOAD_CH7SEL(value)))
#define FTM_BWR_PWMLOAD_CH7SEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH7SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field HCSEL[8] (RW)
 *
 * This bit enables the half cycle match as a reload oportunity. A half cycle is
 * defined by when the FTM counter matches the HCR register.
 *
 * Values:
 * - 0b0 - Half cycle reload is disabled and it is not considered as a reload
 *     opportunity.
 * - 0b1 - Half cycle reload is enabled and it is considered as a reload
 *     opportunity.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_HCSEL field. */
#define FTM_RD_PWMLOAD_HCSEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_HCSEL_MASK) >> FTM_PWMLOAD_HCSEL_SHIFT)
#define FTM_BRD_PWMLOAD_HCSEL(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_HCSEL_SHIFT))

/*! @brief Set the HCSEL field to a new value. */
#define FTM_WR_PWMLOAD_HCSEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_HCSEL_MASK, FTM_PWMLOAD_HCSEL(value)))
#define FTM_BWR_PWMLOAD_HCSEL(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_HCSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field LDOK[9] (RW)
 *
 * Enables the loading of the MOD, CNTIN, and CV registers with the values of
 * their write buffers.
 *
 * Values:
 * - 0b0 - Loading updated values is disabled.
 * - 0b1 - Loading updated values is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_LDOK field. */
#define FTM_RD_PWMLOAD_LDOK(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_LDOK_MASK) >> FTM_PWMLOAD_LDOK_SHIFT)
#define FTM_BRD_PWMLOAD_LDOK(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_LDOK_SHIFT))

/*! @brief Set the LDOK field to a new value. */
#define FTM_WR_PWMLOAD_LDOK(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_LDOK_MASK, FTM_PWMLOAD_LDOK(value)))
#define FTM_BWR_PWMLOAD_LDOK(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_LDOK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field GLEN[10] (RW)
 *
 * This bit enables the global load mechanism implemented by GLDOK. If enabled,
 * then an external event asserted by the FTM global load input can set the LDOK
 * bit. If disabled, the LDOK bit is controlled only locally with writes from
 * CPU, independently of the module global load input.
 *
 * Values:
 * - 0b0 - Global Load Ok disabled.
 * - 0b1 - Global Load OK enabled. A pulse event on the module global load input
 *     sets the LDOK bit.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_GLEN field. */
#define FTM_RD_PWMLOAD_GLEN(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_GLEN_MASK) >> FTM_PWMLOAD_GLEN_SHIFT)
#define FTM_BRD_PWMLOAD_GLEN(base) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_GLEN_SHIFT))

/*! @brief Set the GLEN field to a new value. */
#define FTM_WR_PWMLOAD_GLEN(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_GLEN_MASK, FTM_PWMLOAD_GLEN(value)))
#define FTM_BWR_PWMLOAD_GLEN(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_GLEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field GLDOK[11] (WORZ)
 *
 * This bit controls the global load mechanism. It generates a pulse at FTM
 * module global load output with one FTM clock cycle width, which is used to set
 * LDOK bits of FTM and other modules (including other FTMs). This bit is
 * self-cleared and read value is always zero. The global load mechanism depends on SoC
 * specific information. Refer to the Chip-specific FTM information for more details.
 *
 * Values:
 * - 0b0 - No action.
 * - 0b1 - LDOK bit is set.
 */
/*@{*/
/*! @brief Set the GLDOK field to a new value. */
#define FTM_WR_PWMLOAD_GLDOK(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_GLDOK_MASK, FTM_PWMLOAD_GLDOK(value)))
#define FTM_BWR_PWMLOAD_GLDOK(base, value) (BITBAND_ACCESS32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_GLDOK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTM_HCR - Half Cycle Register
 ******************************************************************************/

/*!
 * @brief FTM_HCR - Half Cycle Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Half Cycle Register contains the match value for FTM half cycle reload
 * feature. After FTM counter reaches this value, a reload opportunity is generated
 * if FTM_PWMLOAD[HCSEL] is enabled. Writing to the HCR register latches the
 * value into a buffer. The HCR register is updated with the value of its write
 * buffer according to Registers updated from write buffers.
 */
/*!
 * @name Constants and macros for entire FTM_HCR register
 */
/*@{*/
#define FTM_RD_HCR(base)         (FTM_HCR_REG(base))
#define FTM_WR_HCR(base, value)  (FTM_HCR_REG(base) = (value))
#define FTM_RMW_HCR(base, mask, value) (FTM_WR_HCR(base, (FTM_RD_HCR(base) & ~(mask)) | (value)))
#define FTM_SET_HCR(base, value) (FTM_WR_HCR(base, FTM_RD_HCR(base) |  (value)))
#define FTM_CLR_HCR(base, value) (FTM_WR_HCR(base, FTM_RD_HCR(base) & ~(value)))
#define FTM_TOG_HCR(base, value) (FTM_WR_HCR(base, FTM_RD_HCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTM_HCR bitfields
 */

/*!
 * @name Register FTM_HCR, field HCVAL[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_HCR_HCVAL field. */
#define FTM_RD_HCR_HCVAL(base) ((FTM_HCR_REG(base) & FTM_HCR_HCVAL_MASK) >> FTM_HCR_HCVAL_SHIFT)
#define FTM_BRD_HCR_HCVAL(base) (FTM_RD_HCR_HCVAL(base))

/*! @brief Set the HCVAL field to a new value. */
#define FTM_WR_HCR_HCVAL(base, value) (FTM_RMW_HCR(base, FTM_HCR_HCVAL_MASK, FTM_HCR_HCVAL(value)))
#define FTM_BWR_HCR_HCVAL(base, value) (FTM_WR_HCR_HCVAL(base, value))
/*@}*/

/*
 * S32K144 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 */

#define GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define PTA_IDX (0U) /*!< Instance number for PTA. */
#define PTB_IDX (1U) /*!< Instance number for PTB. */
#define PTC_IDX (2U) /*!< Instance number for PTC. */
#define PTD_IDX (3U) /*!< Instance number for PTD. */
#define PTE_IDX (4U) /*!< Instance number for PTE. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) |  (value)))
#define GPIO_CLR_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) & ~(value)))
#define GPIO_TOG_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) |  (value)))
#define GPIO_CLR_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) & ~(value)))
#define GPIO_TOG_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) ^  (value)))
/*@}*/

/*
 * S32K144 LMEM
 *
 * Local Memory Controller
 *
 * Registers defined in this header file:
 * - LMEM_PCCCR - Cache control register
 * - LMEM_PCCLCR - Cache line control register
 * - LMEM_PCCSAR - Cache search address register
 * - LMEM_PCCCVR - Cache read/write value register
 * - LMEM_PCCRMR - Cache regions mode register
 */

#define LMEM_INSTANCE_COUNT (1U) /*!< Number of instances of the LMEM module. */
#define LMEM_IDX (0U) /*!< Instance number for LMEM. */

/*******************************************************************************
 * LMEM_PCCCR - Cache control register
 ******************************************************************************/

/*!
 * @brief LMEM_PCCCR - Cache control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LMEM_PCCCR register
 */
/*@{*/
#define LMEM_RD_PCCCR(base)      (LMEM_PCCCR_REG(base))
#define LMEM_WR_PCCCR(base, value) (LMEM_PCCCR_REG(base) = (value))
#define LMEM_RMW_PCCCR(base, mask, value) (LMEM_WR_PCCCR(base, (LMEM_RD_PCCCR(base) & ~(mask)) | (value)))
#define LMEM_SET_PCCCR(base, value) (LMEM_WR_PCCCR(base, LMEM_RD_PCCCR(base) |  (value)))
#define LMEM_CLR_PCCCR(base, value) (LMEM_WR_PCCCR(base, LMEM_RD_PCCCR(base) & ~(value)))
#define LMEM_TOG_PCCCR(base, value) (LMEM_WR_PCCCR(base, LMEM_RD_PCCCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCCR bitfields
 */

/*!
 * @name Register LMEM_PCCCR, field ENCACHE[0] (RW)
 *
 * Values:
 * - 0b0 - Cache disabled
 * - 0b1 - Cache enabled
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_ENCACHE field. */
#define LMEM_RD_PCCCR_ENCACHE(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_ENCACHE_MASK) >> LMEM_PCCCR_ENCACHE_SHIFT)
#define LMEM_BRD_PCCCR_ENCACHE(base) (LMEM_RD_PCCCR_ENCACHE(base))

/*! @brief Set the ENCACHE field to a new value. */
#define LMEM_WR_PCCCR_ENCACHE(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_ENCACHE_MASK, LMEM_PCCCR_ENCACHE(value)))
#define LMEM_BWR_PCCCR_ENCACHE(base, value) (LMEM_WR_PCCCR_ENCACHE(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field ENWRBUF[1] (RW)
 *
 * Values:
 * - 0b0 - Write buffer disabled
 * - 0b1 - Write buffer enabled
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_ENWRBUF field. */
#define LMEM_RD_PCCCR_ENWRBUF(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_ENWRBUF_MASK) >> LMEM_PCCCR_ENWRBUF_SHIFT)
#define LMEM_BRD_PCCCR_ENWRBUF(base) (LMEM_RD_PCCCR_ENWRBUF(base))

/*! @brief Set the ENWRBUF field to a new value. */
#define LMEM_WR_PCCCR_ENWRBUF(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_ENWRBUF_MASK, LMEM_PCCCR_ENWRBUF(value)))
#define LMEM_BWR_PCCCR_ENWRBUF(base, value) (LMEM_WR_PCCCR_ENWRBUF(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field PCCR2[2] (RW)
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_PCCR2 field. */
#define LMEM_RD_PCCCR_PCCR2(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_PCCR2_MASK) >> LMEM_PCCCR_PCCR2_SHIFT)
#define LMEM_BRD_PCCCR_PCCR2(base) (LMEM_RD_PCCCR_PCCR2(base))

/*! @brief Set the PCCR2 field to a new value. */
#define LMEM_WR_PCCCR_PCCR2(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_PCCR2_MASK, LMEM_PCCCR_PCCR2(value)))
#define LMEM_BWR_PCCCR_PCCR2(base, value) (LMEM_WR_PCCCR_PCCR2(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field PCCR3[3] (RW)
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_PCCR3 field. */
#define LMEM_RD_PCCCR_PCCR3(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_PCCR3_MASK) >> LMEM_PCCCR_PCCR3_SHIFT)
#define LMEM_BRD_PCCCR_PCCR3(base) (LMEM_RD_PCCCR_PCCR3(base))

/*! @brief Set the PCCR3 field to a new value. */
#define LMEM_WR_PCCCR_PCCR3(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_PCCR3_MASK, LMEM_PCCCR_PCCR3(value)))
#define LMEM_BWR_PCCCR_PCCR3(base, value) (LMEM_WR_PCCCR_PCCR3(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field INVW0[24] (RW)
 *
 * If the PUSHW0 and INVW0 bits are set, then after setting the GO bit, push all
 * modified lines in way 0 and invalidate all lines in way 0 (clear way 0).
 *
 * Values:
 * - 0b0 - No operation
 * - 0b1 - When setting the GO bit, invalidate all lines in way 0.
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_INVW0 field. */
#define LMEM_RD_PCCCR_INVW0(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_INVW0_MASK) >> LMEM_PCCCR_INVW0_SHIFT)
#define LMEM_BRD_PCCCR_INVW0(base) (LMEM_RD_PCCCR_INVW0(base))

/*! @brief Set the INVW0 field to a new value. */
#define LMEM_WR_PCCCR_INVW0(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_INVW0_MASK, LMEM_PCCCR_INVW0(value)))
#define LMEM_BWR_PCCCR_INVW0(base, value) (LMEM_WR_PCCCR_INVW0(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field PUSHW0[25] (RW)
 *
 * Values:
 * - 0b0 - No operation
 * - 0b1 - When setting the GO bit, push all modified lines in way 0
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_PUSHW0 field. */
#define LMEM_RD_PCCCR_PUSHW0(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_PUSHW0_MASK) >> LMEM_PCCCR_PUSHW0_SHIFT)
#define LMEM_BRD_PCCCR_PUSHW0(base) (LMEM_RD_PCCCR_PUSHW0(base))

/*! @brief Set the PUSHW0 field to a new value. */
#define LMEM_WR_PCCCR_PUSHW0(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_PUSHW0_MASK, LMEM_PCCCR_PUSHW0(value)))
#define LMEM_BWR_PCCCR_PUSHW0(base, value) (LMEM_WR_PCCCR_PUSHW0(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field INVW1[26] (RW)
 *
 * If the PUSHW1 and INVW1 bits are set, then after setting the GO bit, push all
 * modified lines in way 1 and invalidate all lines in way 1 (clear way 1).
 *
 * Values:
 * - 0b0 - No operation
 * - 0b1 - When setting the GO bit, invalidate all lines in way 1
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_INVW1 field. */
#define LMEM_RD_PCCCR_INVW1(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_INVW1_MASK) >> LMEM_PCCCR_INVW1_SHIFT)
#define LMEM_BRD_PCCCR_INVW1(base) (LMEM_RD_PCCCR_INVW1(base))

/*! @brief Set the INVW1 field to a new value. */
#define LMEM_WR_PCCCR_INVW1(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_INVW1_MASK, LMEM_PCCCR_INVW1(value)))
#define LMEM_BWR_PCCCR_INVW1(base, value) (LMEM_WR_PCCCR_INVW1(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field PUSHW1[27] (RW)
 *
 * Values:
 * - 0b0 - No operation
 * - 0b1 - When setting the GO bit, push all modified lines in way 1
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_PUSHW1 field. */
#define LMEM_RD_PCCCR_PUSHW1(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_PUSHW1_MASK) >> LMEM_PCCCR_PUSHW1_SHIFT)
#define LMEM_BRD_PCCCR_PUSHW1(base) (LMEM_RD_PCCCR_PUSHW1(base))

/*! @brief Set the PUSHW1 field to a new value. */
#define LMEM_WR_PCCCR_PUSHW1(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_PUSHW1_MASK, LMEM_PCCCR_PUSHW1(value)))
#define LMEM_BWR_PCCCR_PUSHW1(base, value) (LMEM_WR_PCCCR_PUSHW1(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCCR, field GO[31] (RW)
 *
 * Setting this bit initiates the cache command indicated by bits 27-24. Reading
 * this bit indicates if a command is active This bit stays set until the
 * command completes. Writing zero has no effect.
 *
 * Values:
 * - 0b0 - Write: no effect. Read: no cache command active.
 * - 0b1 - Write: initiate command indicated by bits 27-24. Read: cache command
 *     active.
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCCR_GO field. */
#define LMEM_RD_PCCCR_GO(base) ((LMEM_PCCCR_REG(base) & LMEM_PCCCR_GO_MASK) >> LMEM_PCCCR_GO_SHIFT)
#define LMEM_BRD_PCCCR_GO(base) (LMEM_RD_PCCCR_GO(base))

/*! @brief Set the GO field to a new value. */
#define LMEM_WR_PCCCR_GO(base, value) (LMEM_RMW_PCCCR(base, LMEM_PCCCR_GO_MASK, LMEM_PCCCR_GO(value)))
#define LMEM_BWR_PCCCR_GO(base, value) (LMEM_WR_PCCCR_GO(base, value))
/*@}*/

/*******************************************************************************
 * LMEM_PCCLCR - Cache line control register
 ******************************************************************************/

/*!
 * @brief LMEM_PCCLCR - Cache line control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines specific line-sized cache operations to be performed
 * using a specific cache line address or a physical address. If a physical address
 * is specified, both ways of the cache are searched, and the command is only
 * performed on the way which hits.
 */
/*!
 * @name Constants and macros for entire LMEM_PCCLCR register
 */
/*@{*/
#define LMEM_RD_PCCLCR(base)     (LMEM_PCCLCR_REG(base))
#define LMEM_WR_PCCLCR(base, value) (LMEM_PCCLCR_REG(base) = (value))
#define LMEM_RMW_PCCLCR(base, mask, value) (LMEM_WR_PCCLCR(base, (LMEM_RD_PCCLCR(base) & ~(mask)) | (value)))
#define LMEM_SET_PCCLCR(base, value) (LMEM_WR_PCCLCR(base, LMEM_RD_PCCLCR(base) |  (value)))
#define LMEM_CLR_PCCLCR(base, value) (LMEM_WR_PCCLCR(base, LMEM_RD_PCCLCR(base) & ~(value)))
#define LMEM_TOG_PCCLCR(base, value) (LMEM_WR_PCCLCR(base, LMEM_RD_PCCLCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCLCR bitfields
 */

/*!
 * @name Register LMEM_PCCLCR, field LGO[0] (RW)
 *
 * Setting this bit initiates the cache line command indicated by bits 27-24.
 * Reading this bit indicates if a line command is active This bit stays set until
 * the command completes. Writing zero has no effect. This bit is shared with
 * CSAR[LGO]
 *
 * Values:
 * - 0b0 - Write: no effect. Read: no line command active.
 * - 0b1 - Write: initiate line command indicated by bits 27-24. Read: line
 *     command active.
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_LGO field. */
#define LMEM_RD_PCCLCR_LGO(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_LGO_MASK) >> LMEM_PCCLCR_LGO_SHIFT)
#define LMEM_BRD_PCCLCR_LGO(base) (LMEM_RD_PCCLCR_LGO(base))

/*! @brief Set the LGO field to a new value. */
#define LMEM_WR_PCCLCR_LGO(base, value) (LMEM_RMW_PCCLCR(base, LMEM_PCCLCR_LGO_MASK, LMEM_PCCLCR_LGO(value)))
#define LMEM_BWR_PCCLCR_LGO(base, value) (LMEM_WR_PCCLCR_LGO(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field CACHEADDR[11:2] (RW)
 *
 * CLCR[11:4] bits are used to access the tag arrays CLCR[11:2] bits are used to
 * access the data arrays
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_CACHEADDR field. */
#define LMEM_RD_PCCLCR_CACHEADDR(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_CACHEADDR_MASK) >> LMEM_PCCLCR_CACHEADDR_SHIFT)
#define LMEM_BRD_PCCLCR_CACHEADDR(base) (LMEM_RD_PCCLCR_CACHEADDR(base))

/*! @brief Set the CACHEADDR field to a new value. */
#define LMEM_WR_PCCLCR_CACHEADDR(base, value) (LMEM_RMW_PCCLCR(base, LMEM_PCCLCR_CACHEADDR_MASK, LMEM_PCCLCR_CACHEADDR(value)))
#define LMEM_BWR_PCCLCR_CACHEADDR(base, value) (LMEM_WR_PCCLCR_CACHEADDR(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field WSEL[14] (RW)
 *
 * Selects the way for line commands.
 *
 * Values:
 * - 0b0 - Way 0
 * - 0b1 - Way 1
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_WSEL field. */
#define LMEM_RD_PCCLCR_WSEL(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_WSEL_MASK) >> LMEM_PCCLCR_WSEL_SHIFT)
#define LMEM_BRD_PCCLCR_WSEL(base) (LMEM_RD_PCCLCR_WSEL(base))

/*! @brief Set the WSEL field to a new value. */
#define LMEM_WR_PCCLCR_WSEL(base, value) (LMEM_RMW_PCCLCR(base, LMEM_PCCLCR_WSEL_MASK, LMEM_PCCLCR_WSEL(value)))
#define LMEM_BWR_PCCLCR_WSEL(base, value) (LMEM_WR_PCCLCR_WSEL(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field TDSEL[16] (RW)
 *
 * Selects tag or data for search and read or write commands.
 *
 * Values:
 * - 0b0 - Data
 * - 0b1 - Tag
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_TDSEL field. */
#define LMEM_RD_PCCLCR_TDSEL(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_TDSEL_MASK) >> LMEM_PCCLCR_TDSEL_SHIFT)
#define LMEM_BRD_PCCLCR_TDSEL(base) (LMEM_RD_PCCLCR_TDSEL(base))

/*! @brief Set the TDSEL field to a new value. */
#define LMEM_WR_PCCLCR_TDSEL(base, value) (LMEM_RMW_PCCLCR(base, LMEM_PCCLCR_TDSEL_MASK, LMEM_PCCLCR_TDSEL(value)))
#define LMEM_BWR_PCCLCR_TDSEL(base, value) (LMEM_WR_PCCLCR_TDSEL(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCIVB[20] (RO)
 *
 * If command used cache address and way, then this bit shows the initial state
 * of the valid bit If command used physical address and a hit, then this bit
 * shows the initial state of the valid bit. If a miss, this bit reads zero.
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_LCIVB field. */
#define LMEM_RD_PCCLCR_LCIVB(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_LCIVB_MASK) >> LMEM_PCCLCR_LCIVB_SHIFT)
#define LMEM_BRD_PCCLCR_LCIVB(base) (LMEM_RD_PCCLCR_LCIVB(base))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCIMB[21] (RO)
 *
 * If command used cache address and way, then this bit shows the initial state
 * of the modified bit If command used physical address and a hit, then this bit
 * shows the initial state of the modified bit. If a miss, this bit reads zero.
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_LCIMB field. */
#define LMEM_RD_PCCLCR_LCIMB(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_LCIMB_MASK) >> LMEM_PCCLCR_LCIMB_SHIFT)
#define LMEM_BRD_PCCLCR_LCIMB(base) (LMEM_RD_PCCLCR_LCIMB(base))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCWAY[22] (RO)
 *
 * Indicates the way used by the line command.
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_LCWAY field. */
#define LMEM_RD_PCCLCR_LCWAY(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_LCWAY_MASK) >> LMEM_PCCLCR_LCWAY_SHIFT)
#define LMEM_BRD_PCCLCR_LCWAY(base) (LMEM_RD_PCCLCR_LCWAY(base))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LCMD[25:24] (RW)
 *
 * Values:
 * - 0b00 - Search and read or write
 * - 0b01 - Invalidate
 * - 0b10 - Push
 * - 0b11 - Clear
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_LCMD field. */
#define LMEM_RD_PCCLCR_LCMD(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_LCMD_MASK) >> LMEM_PCCLCR_LCMD_SHIFT)
#define LMEM_BRD_PCCLCR_LCMD(base) (LMEM_RD_PCCLCR_LCMD(base))

/*! @brief Set the LCMD field to a new value. */
#define LMEM_WR_PCCLCR_LCMD(base, value) (LMEM_RMW_PCCLCR(base, LMEM_PCCLCR_LCMD_MASK, LMEM_PCCLCR_LCMD(value)))
#define LMEM_BWR_PCCLCR_LCMD(base, value) (LMEM_WR_PCCLCR_LCMD(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LADSEL[26] (RW)
 *
 * When using the cache address, the way must also be specified in CLCR[WSEL].
 * When using the physical address, both ways are searched and the command is
 * performed only if a hit.
 *
 * Values:
 * - 0b0 - Cache address
 * - 0b1 - Physical address
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_LADSEL field. */
#define LMEM_RD_PCCLCR_LADSEL(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_LADSEL_MASK) >> LMEM_PCCLCR_LADSEL_SHIFT)
#define LMEM_BRD_PCCLCR_LADSEL(base) (LMEM_RD_PCCLCR_LADSEL(base))

/*! @brief Set the LADSEL field to a new value. */
#define LMEM_WR_PCCLCR_LADSEL(base, value) (LMEM_RMW_PCCLCR(base, LMEM_PCCLCR_LADSEL_MASK, LMEM_PCCLCR_LADSEL(value)))
#define LMEM_BWR_PCCLCR_LADSEL(base, value) (LMEM_WR_PCCLCR_LADSEL(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCLCR, field LACC[27] (RW)
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCLCR_LACC field. */
#define LMEM_RD_PCCLCR_LACC(base) ((LMEM_PCCLCR_REG(base) & LMEM_PCCLCR_LACC_MASK) >> LMEM_PCCLCR_LACC_SHIFT)
#define LMEM_BRD_PCCLCR_LACC(base) (LMEM_RD_PCCLCR_LACC(base))

/*! @brief Set the LACC field to a new value. */
#define LMEM_WR_PCCLCR_LACC(base, value) (LMEM_RMW_PCCLCR(base, LMEM_PCCLCR_LACC_MASK, LMEM_PCCLCR_LACC(value)))
#define LMEM_BWR_PCCLCR_LACC(base, value) (LMEM_WR_PCCLCR_LACC(base, value))
/*@}*/

/*******************************************************************************
 * LMEM_PCCSAR - Cache search address register
 ******************************************************************************/

/*!
 * @brief LMEM_PCCSAR - Cache search address register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CSAR register is used to define the explicit cache address or the
 * physical address for line-sized commands specified in the CLCR[LADSEL] bit.
 */
/*!
 * @name Constants and macros for entire LMEM_PCCSAR register
 */
/*@{*/
#define LMEM_RD_PCCSAR(base)     (LMEM_PCCSAR_REG(base))
#define LMEM_WR_PCCSAR(base, value) (LMEM_PCCSAR_REG(base) = (value))
#define LMEM_RMW_PCCSAR(base, mask, value) (LMEM_WR_PCCSAR(base, (LMEM_RD_PCCSAR(base) & ~(mask)) | (value)))
#define LMEM_SET_PCCSAR(base, value) (LMEM_WR_PCCSAR(base, LMEM_RD_PCCSAR(base) |  (value)))
#define LMEM_CLR_PCCSAR(base, value) (LMEM_WR_PCCSAR(base, LMEM_RD_PCCSAR(base) & ~(value)))
#define LMEM_TOG_PCCSAR(base, value) (LMEM_WR_PCCSAR(base, LMEM_RD_PCCSAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCSAR bitfields
 */

/*!
 * @name Register LMEM_PCCSAR, field LGO[0] (RW)
 *
 * Setting this bit initiates the cache line command indicated by bits 27-24.
 * Reading this bit indicates if a line command is active This bit stays set until
 * the command completes. Writing zero has no effect. This bit is shared with
 * CLCR[LGO]
 *
 * Values:
 * - 0b0 - Write: no effect. Read: no line command active.
 * - 0b1 - Write: initiate line command indicated by bits CLCR[27:24]. Read:
 *     line command active.
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCSAR_LGO field. */
#define LMEM_RD_PCCSAR_LGO(base) ((LMEM_PCCSAR_REG(base) & LMEM_PCCSAR_LGO_MASK) >> LMEM_PCCSAR_LGO_SHIFT)
#define LMEM_BRD_PCCSAR_LGO(base) (LMEM_RD_PCCSAR_LGO(base))

/*! @brief Set the LGO field to a new value. */
#define LMEM_WR_PCCSAR_LGO(base, value) (LMEM_RMW_PCCSAR(base, LMEM_PCCSAR_LGO_MASK, LMEM_PCCSAR_LGO(value)))
#define LMEM_BWR_PCCSAR_LGO(base, value) (LMEM_WR_PCCSAR_LGO(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCSAR, field PHYADDR[31:2] (RW)
 *
 * PHYADDR represents bits [31:2] of the system address. CSAR[31:12] bits are
 * used for tag compare CSAR[11:4] bits are used to access the tag arrays
 * CSAR[11:2] bits are used to access the data arrays
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCSAR_PHYADDR field. */
#define LMEM_RD_PCCSAR_PHYADDR(base) ((LMEM_PCCSAR_REG(base) & LMEM_PCCSAR_PHYADDR_MASK) >> LMEM_PCCSAR_PHYADDR_SHIFT)
#define LMEM_BRD_PCCSAR_PHYADDR(base) (LMEM_RD_PCCSAR_PHYADDR(base))

/*! @brief Set the PHYADDR field to a new value. */
#define LMEM_WR_PCCSAR_PHYADDR(base, value) (LMEM_RMW_PCCSAR(base, LMEM_PCCSAR_PHYADDR_MASK, LMEM_PCCSAR_PHYADDR(value)))
#define LMEM_BWR_PCCSAR_PHYADDR(base, value) (LMEM_WR_PCCSAR_PHYADDR(base, value))
/*@}*/

/*******************************************************************************
 * LMEM_PCCCVR - Cache read/write value register
 ******************************************************************************/

/*!
 * @brief LMEM_PCCCVR - Cache read/write value register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CCVR register is used to source write data or return read data for the
 * commands specified in the CLCR register.
 */
/*!
 * @name Constants and macros for entire LMEM_PCCCVR register
 */
/*@{*/
#define LMEM_RD_PCCCVR(base)     (LMEM_PCCCVR_REG(base))
#define LMEM_WR_PCCCVR(base, value) (LMEM_PCCCVR_REG(base) = (value))
#define LMEM_RMW_PCCCVR(base, mask, value) (LMEM_WR_PCCCVR(base, (LMEM_RD_PCCCVR(base) & ~(mask)) | (value)))
#define LMEM_SET_PCCCVR(base, value) (LMEM_WR_PCCCVR(base, LMEM_RD_PCCCVR(base) |  (value)))
#define LMEM_CLR_PCCCVR(base, value) (LMEM_WR_PCCCVR(base, LMEM_RD_PCCCVR(base) & ~(value)))
#define LMEM_TOG_PCCCVR(base, value) (LMEM_WR_PCCCVR(base, LMEM_RD_PCCCVR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * LMEM_PCCRMR - Cache regions mode register
 ******************************************************************************/

/*!
 * @brief LMEM_PCCRMR - Cache regions mode register (RW)
 *
 * Reset value: 0xAA0FA000U
 *
 * The CRMR register allows you to demote the cache mode of various subregions
 * within the device's memory map. Demoting the cache mode reduces the cache
 * function applied to a memory region from write-back to write-through to
 * non-cacheable. After a region is demoted, its cache mode can only be raised by a reset,
 * which returns it to its default state. To maintain cache coherency, changes to
 * the cache mode should be completed while the address space being changed is
 * not being accessed or the cache is disabled. Before a cache mode change,
 * complete a cache clear all command to push and invalidate any cache entries that may
 * have changed. The address/module assignment of the 16 subregions is
 * device-specific and are detailed in the Chip Configuration section. Some of the regions
 * may not be used (non-cacheable), and some regions may not be capable of
 * write-back.
 */
/*!
 * @name Constants and macros for entire LMEM_PCCRMR register
 */
/*@{*/
#define LMEM_RD_PCCRMR(base)     (LMEM_PCCRMR_REG(base))
#define LMEM_WR_PCCRMR(base, value) (LMEM_PCCRMR_REG(base) = (value))
#define LMEM_RMW_PCCRMR(base, mask, value) (LMEM_WR_PCCRMR(base, (LMEM_RD_PCCRMR(base) & ~(mask)) | (value)))
#define LMEM_SET_PCCRMR(base, value) (LMEM_WR_PCCRMR(base, LMEM_RD_PCCRMR(base) |  (value)))
#define LMEM_CLR_PCCRMR(base, value) (LMEM_WR_PCCRMR(base, LMEM_RD_PCCRMR(base) & ~(value)))
#define LMEM_TOG_PCCRMR(base, value) (LMEM_WR_PCCRMR(base, LMEM_RD_PCCRMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LMEM_PCCRMR bitfields
 */

/*!
 * @name Register LMEM_PCCRMR, field R15[1:0] (RW)
 *
 * Controls the cache mode for region 15
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R15 field. */
#define LMEM_RD_PCCRMR_R15(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R15_MASK) >> LMEM_PCCRMR_R15_SHIFT)
#define LMEM_BRD_PCCRMR_R15(base) (LMEM_RD_PCCRMR_R15(base))

/*! @brief Set the R15 field to a new value. */
#define LMEM_WR_PCCRMR_R15(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R15_MASK, LMEM_PCCRMR_R15(value)))
#define LMEM_BWR_PCCRMR_R15(base, value) (LMEM_WR_PCCRMR_R15(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R14[3:2] (RW)
 *
 * Controls the cache mode for region 14
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R14 field. */
#define LMEM_RD_PCCRMR_R14(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R14_MASK) >> LMEM_PCCRMR_R14_SHIFT)
#define LMEM_BRD_PCCRMR_R14(base) (LMEM_RD_PCCRMR_R14(base))

/*! @brief Set the R14 field to a new value. */
#define LMEM_WR_PCCRMR_R14(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R14_MASK, LMEM_PCCRMR_R14(value)))
#define LMEM_BWR_PCCRMR_R14(base, value) (LMEM_WR_PCCRMR_R14(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R13[5:4] (RW)
 *
 * Controls the cache mode for region 13
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R13 field. */
#define LMEM_RD_PCCRMR_R13(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R13_MASK) >> LMEM_PCCRMR_R13_SHIFT)
#define LMEM_BRD_PCCRMR_R13(base) (LMEM_RD_PCCRMR_R13(base))

/*! @brief Set the R13 field to a new value. */
#define LMEM_WR_PCCRMR_R13(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R13_MASK, LMEM_PCCRMR_R13(value)))
#define LMEM_BWR_PCCRMR_R13(base, value) (LMEM_WR_PCCRMR_R13(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R12[7:6] (RW)
 *
 * Controls the cache mode for region 12
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R12 field. */
#define LMEM_RD_PCCRMR_R12(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R12_MASK) >> LMEM_PCCRMR_R12_SHIFT)
#define LMEM_BRD_PCCRMR_R12(base) (LMEM_RD_PCCRMR_R12(base))

/*! @brief Set the R12 field to a new value. */
#define LMEM_WR_PCCRMR_R12(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R12_MASK, LMEM_PCCRMR_R12(value)))
#define LMEM_BWR_PCCRMR_R12(base, value) (LMEM_WR_PCCRMR_R12(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R11[9:8] (RW)
 *
 * Controls the cache mode for region 11
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R11 field. */
#define LMEM_RD_PCCRMR_R11(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R11_MASK) >> LMEM_PCCRMR_R11_SHIFT)
#define LMEM_BRD_PCCRMR_R11(base) (LMEM_RD_PCCRMR_R11(base))

/*! @brief Set the R11 field to a new value. */
#define LMEM_WR_PCCRMR_R11(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R11_MASK, LMEM_PCCRMR_R11(value)))
#define LMEM_BWR_PCCRMR_R11(base, value) (LMEM_WR_PCCRMR_R11(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R10[11:10] (RW)
 *
 * Controls the cache mode for region 10
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R10 field. */
#define LMEM_RD_PCCRMR_R10(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R10_MASK) >> LMEM_PCCRMR_R10_SHIFT)
#define LMEM_BRD_PCCRMR_R10(base) (LMEM_RD_PCCRMR_R10(base))

/*! @brief Set the R10 field to a new value. */
#define LMEM_WR_PCCRMR_R10(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R10_MASK, LMEM_PCCRMR_R10(value)))
#define LMEM_BWR_PCCRMR_R10(base, value) (LMEM_WR_PCCRMR_R10(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R9[13:12] (RW)
 *
 * Controls the cache mode for region 9
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R9 field. */
#define LMEM_RD_PCCRMR_R9(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R9_MASK) >> LMEM_PCCRMR_R9_SHIFT)
#define LMEM_BRD_PCCRMR_R9(base) (LMEM_RD_PCCRMR_R9(base))

/*! @brief Set the R9 field to a new value. */
#define LMEM_WR_PCCRMR_R9(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R9_MASK, LMEM_PCCRMR_R9(value)))
#define LMEM_BWR_PCCRMR_R9(base, value) (LMEM_WR_PCCRMR_R9(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R8[15:14] (RW)
 *
 * Controls the cache mode for region 8
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R8 field. */
#define LMEM_RD_PCCRMR_R8(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R8_MASK) >> LMEM_PCCRMR_R8_SHIFT)
#define LMEM_BRD_PCCRMR_R8(base) (LMEM_RD_PCCRMR_R8(base))

/*! @brief Set the R8 field to a new value. */
#define LMEM_WR_PCCRMR_R8(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R8_MASK, LMEM_PCCRMR_R8(value)))
#define LMEM_BWR_PCCRMR_R8(base, value) (LMEM_WR_PCCRMR_R8(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R7[17:16] (RW)
 *
 * Controls the cache mode for region 7
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R7 field. */
#define LMEM_RD_PCCRMR_R7(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R7_MASK) >> LMEM_PCCRMR_R7_SHIFT)
#define LMEM_BRD_PCCRMR_R7(base) (LMEM_RD_PCCRMR_R7(base))

/*! @brief Set the R7 field to a new value. */
#define LMEM_WR_PCCRMR_R7(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R7_MASK, LMEM_PCCRMR_R7(value)))
#define LMEM_BWR_PCCRMR_R7(base, value) (LMEM_WR_PCCRMR_R7(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R6[19:18] (RW)
 *
 * Controls the cache mode for region 6
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R6 field. */
#define LMEM_RD_PCCRMR_R6(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R6_MASK) >> LMEM_PCCRMR_R6_SHIFT)
#define LMEM_BRD_PCCRMR_R6(base) (LMEM_RD_PCCRMR_R6(base))

/*! @brief Set the R6 field to a new value. */
#define LMEM_WR_PCCRMR_R6(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R6_MASK, LMEM_PCCRMR_R6(value)))
#define LMEM_BWR_PCCRMR_R6(base, value) (LMEM_WR_PCCRMR_R6(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R5[21:20] (RW)
 *
 * Controls the cache mode for region 5
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R5 field. */
#define LMEM_RD_PCCRMR_R5(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R5_MASK) >> LMEM_PCCRMR_R5_SHIFT)
#define LMEM_BRD_PCCRMR_R5(base) (LMEM_RD_PCCRMR_R5(base))

/*! @brief Set the R5 field to a new value. */
#define LMEM_WR_PCCRMR_R5(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R5_MASK, LMEM_PCCRMR_R5(value)))
#define LMEM_BWR_PCCRMR_R5(base, value) (LMEM_WR_PCCRMR_R5(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R4[23:22] (RW)
 *
 * Controls the cache mode for region 4
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R4 field. */
#define LMEM_RD_PCCRMR_R4(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R4_MASK) >> LMEM_PCCRMR_R4_SHIFT)
#define LMEM_BRD_PCCRMR_R4(base) (LMEM_RD_PCCRMR_R4(base))

/*! @brief Set the R4 field to a new value. */
#define LMEM_WR_PCCRMR_R4(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R4_MASK, LMEM_PCCRMR_R4(value)))
#define LMEM_BWR_PCCRMR_R4(base, value) (LMEM_WR_PCCRMR_R4(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R3[25:24] (RW)
 *
 * Controls the cache mode for region 3
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R3 field. */
#define LMEM_RD_PCCRMR_R3(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R3_MASK) >> LMEM_PCCRMR_R3_SHIFT)
#define LMEM_BRD_PCCRMR_R3(base) (LMEM_RD_PCCRMR_R3(base))

/*! @brief Set the R3 field to a new value. */
#define LMEM_WR_PCCRMR_R3(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R3_MASK, LMEM_PCCRMR_R3(value)))
#define LMEM_BWR_PCCRMR_R3(base, value) (LMEM_WR_PCCRMR_R3(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R2[27:26] (RW)
 *
 * Controls the cache mode for region 2
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R2 field. */
#define LMEM_RD_PCCRMR_R2(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R2_MASK) >> LMEM_PCCRMR_R2_SHIFT)
#define LMEM_BRD_PCCRMR_R2(base) (LMEM_RD_PCCRMR_R2(base))

/*! @brief Set the R2 field to a new value. */
#define LMEM_WR_PCCRMR_R2(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R2_MASK, LMEM_PCCRMR_R2(value)))
#define LMEM_BWR_PCCRMR_R2(base, value) (LMEM_WR_PCCRMR_R2(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R1[29:28] (RW)
 *
 * Controls the cache mode for region 1
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R1 field. */
#define LMEM_RD_PCCRMR_R1(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R1_MASK) >> LMEM_PCCRMR_R1_SHIFT)
#define LMEM_BRD_PCCRMR_R1(base) (LMEM_RD_PCCRMR_R1(base))

/*! @brief Set the R1 field to a new value. */
#define LMEM_WR_PCCRMR_R1(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R1_MASK, LMEM_PCCRMR_R1(value)))
#define LMEM_BWR_PCCRMR_R1(base, value) (LMEM_WR_PCCRMR_R1(base, value))
/*@}*/

/*!
 * @name Register LMEM_PCCRMR, field R0[31:30] (RW)
 *
 * Controls the cache mode for region 0
 *
 * Values:
 * - 0b00 - Non-cacheable
 * - 0b01 - Non-cacheable
 * - 0b10 - Write-through
 * - 0b11 - Write-back
 */
/*@{*/
/*! @brief Read current value of the LMEM_PCCRMR_R0 field. */
#define LMEM_RD_PCCRMR_R0(base) ((LMEM_PCCRMR_REG(base) & LMEM_PCCRMR_R0_MASK) >> LMEM_PCCRMR_R0_SHIFT)
#define LMEM_BRD_PCCRMR_R0(base) (LMEM_RD_PCCRMR_R0(base))

/*! @brief Set the R0 field to a new value. */
#define LMEM_WR_PCCRMR_R0(base, value) (LMEM_RMW_PCCRMR(base, LMEM_PCCRMR_R0_MASK, LMEM_PCCRMR_R0(value)))
#define LMEM_BWR_PCCRMR_R0(base, value) (LMEM_WR_PCCRMR_R0(base, value))
/*@}*/

/*
 * S32K144 LPI2C
 *
 * The LPI2C Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - LPI2C_VERID - Version ID Register
 * - LPI2C_PARAM - Parameter Register
 * - LPI2C_MCR - Master Control Register
 * - LPI2C_MSR - Master Status Register
 * - LPI2C_MIER - Master Interrupt Enable Register
 * - LPI2C_MDER - Master DMA Enable Register
 * - LPI2C_MCFGR0 - Master Configuration Register 0
 * - LPI2C_MCFGR1 - Master Configuration Register 1
 * - LPI2C_MCFGR2 - Master Configuration Register 2
 * - LPI2C_MCFGR3 - Master Configuration Register 3
 * - LPI2C_MDMR - Master Data Match Register
 * - LPI2C_MCCR0 - Master Clock Configuration Register 0
 * - LPI2C_MCCR1 - Master Clock Configuration Register 1
 * - LPI2C_MFCR - Master FIFO Control Register
 * - LPI2C_MFSR - Master FIFO Status Register
 * - LPI2C_MTDR - Master Transmit Data Register
 * - LPI2C_MRDR - Master Receive Data Register
 * - LPI2C_SCR - Slave Control Register
 * - LPI2C_SSR - Slave Status Register
 * - LPI2C_SIER - Slave Interrupt Enable Register
 * - LPI2C_SDER - Slave DMA Enable Register
 * - LPI2C_SCFGR1 - Slave Configuration Register 1
 * - LPI2C_SCFGR2 - Slave Configuration Register 2
 * - LPI2C_SAMR - Slave Address Match Register
 * - LPI2C_SASR - Slave Address Status Register
 * - LPI2C_STAR - Slave Transmit ACK Register
 * - LPI2C_STDR - Slave Transmit Data Register
 * - LPI2C_SRDR - Slave Receive Data Register
 */

#define LPI2C_INSTANCE_COUNT (2U) /*!< Number of instances of the LPI2C module. */
#define LPI2C0_IDX (0U) /*!< Instance number for LPI2C0. */
#define LPI2C1_IDX (1U) /*!< Instance number for LPI2C1. */

/*******************************************************************************
 * LPI2C_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPI2C_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000003U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPI2C_VERID register
 */
/*@{*/
#define LPI2C_RD_VERID(base)     (LPI2C_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_VERID bitfields
 */

/*!
 * @name Register LPI2C_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000010 - Master only with standard feature set.
 * - 0b0000000000000011 - Master and slave with standard feature set.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_FEATURE field. */
#define LPI2C_RD_VERID_FEATURE(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_FEATURE_MASK) >> LPI2C_VERID_FEATURE_SHIFT)
#define LPI2C_BRD_VERID_FEATURE(base) (LPI2C_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPI2C_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_MINOR field. */
#define LPI2C_RD_VERID_MINOR(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_MINOR_MASK) >> LPI2C_VERID_MINOR_SHIFT)
#define LPI2C_BRD_VERID_MINOR(base) (LPI2C_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register LPI2C_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_MAJOR field. */
#define LPI2C_RD_VERID_MAJOR(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_MAJOR_MASK) >> LPI2C_VERID_MAJOR_SHIFT)
#define LPI2C_BRD_VERID_MAJOR(base) (LPI2C_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * LPI2C_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPI2C_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000202U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPI2C_PARAM register
 */
/*@{*/
#define LPI2C_RD_PARAM(base)     (LPI2C_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_PARAM bitfields
 */

/*!
 * @name Register LPI2C_PARAM, field MTXFIFO[3:0] (RO)
 *
 * The number of words in the master transmit FIFO is 2^MTXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_PARAM_MTXFIFO field. */
#define LPI2C_RD_PARAM_MTXFIFO(base) ((LPI2C_PARAM_REG(base) & LPI2C_PARAM_MTXFIFO_MASK) >> LPI2C_PARAM_MTXFIFO_SHIFT)
#define LPI2C_BRD_PARAM_MTXFIFO(base) (LPI2C_RD_PARAM_MTXFIFO(base))
/*@}*/

/*!
 * @name Register LPI2C_PARAM, field MRXFIFO[11:8] (RO)
 *
 * The number of words in the master receive FIFO is 2^MRXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_PARAM_MRXFIFO field. */
#define LPI2C_RD_PARAM_MRXFIFO(base) ((LPI2C_PARAM_REG(base) & LPI2C_PARAM_MRXFIFO_MASK) >> LPI2C_PARAM_MRXFIFO_SHIFT)
#define LPI2C_BRD_PARAM_MRXFIFO(base) (LPI2C_RD_PARAM_MRXFIFO(base))
/*@}*/

/*******************************************************************************
 * LPI2C_MCR - Master Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MCR - Master Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MCR register
 */
/*@{*/
#define LPI2C_RD_MCR(base)       (LPI2C_MCR_REG(base))
#define LPI2C_WR_MCR(base, value) (LPI2C_MCR_REG(base) = (value))
#define LPI2C_RMW_MCR(base, mask, value) (LPI2C_WR_MCR(base, (LPI2C_RD_MCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCR(base, value) (LPI2C_WR_MCR(base, LPI2C_RD_MCR(base) |  (value)))
#define LPI2C_CLR_MCR(base, value) (LPI2C_WR_MCR(base, LPI2C_RD_MCR(base) & ~(value)))
#define LPI2C_TOG_MCR(base, value) (LPI2C_WR_MCR(base, LPI2C_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCR bitfields
 */

/*!
 * @name Register LPI2C_MCR, field MEN[0] (RW)
 *
 * Values:
 * - 0b0 - Master logic is disabled.
 * - 0b1 - Master logic is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_MEN field. */
#define LPI2C_RD_MCR_MEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_MEN_MASK) >> LPI2C_MCR_MEN_SHIFT)
#define LPI2C_BRD_MCR_MEN(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_MEN_SHIFT))

/*! @brief Set the MEN field to a new value. */
#define LPI2C_WR_MCR_MEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_MEN_MASK, LPI2C_MCR_MEN(value)))
#define LPI2C_BWR_MCR_MEN(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_MEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RST[1] (RW)
 *
 * Reset all internal master logic and registers, except the Master Control
 * Register. Remains set until cleared by software.
 *
 * Values:
 * - 0b0 - Master logic is not reset.
 * - 0b1 - Master logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_RST field. */
#define LPI2C_RD_MCR_RST(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_RST_MASK) >> LPI2C_MCR_RST_SHIFT)
#define LPI2C_BRD_MCR_RST(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RST_SHIFT))

/*! @brief Set the RST field to a new value. */
#define LPI2C_WR_MCR_RST(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RST_MASK, LPI2C_MCR_RST(value)))
#define LPI2C_BWR_MCR_RST(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field DOZEN[2] (RW)
 *
 * Enables or disables Doze mode for the master.
 *
 * Values:
 * - 0b0 - Master is enabled in Doze mode.
 * - 0b1 - Master is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_DOZEN field. */
#define LPI2C_RD_MCR_DOZEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_DOZEN_MASK) >> LPI2C_MCR_DOZEN_SHIFT)
#define LPI2C_BRD_MCR_DOZEN(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DOZEN_SHIFT))

/*! @brief Set the DOZEN field to a new value. */
#define LPI2C_WR_MCR_DOZEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_DOZEN_MASK, LPI2C_MCR_DOZEN(value)))
#define LPI2C_BWR_MCR_DOZEN(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DOZEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field DBGEN[3] (RW)
 *
 * Values:
 * - 0b0 - Master is disabled in debug mode.
 * - 0b1 - Master is enabled in debug mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_DBGEN field. */
#define LPI2C_RD_MCR_DBGEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_DBGEN_MASK) >> LPI2C_MCR_DBGEN_SHIFT)
#define LPI2C_BRD_MCR_DBGEN(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DBGEN_SHIFT))

/*! @brief Set the DBGEN field to a new value. */
#define LPI2C_WR_MCR_DBGEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_DBGEN_MASK, LPI2C_MCR_DBGEN(value)))
#define LPI2C_BWR_MCR_DBGEN(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DBGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RTF[8] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Transmit FIFO is reset.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPI2C_WR_MCR_RTF(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RTF_MASK, LPI2C_MCR_RTF(value)))
#define LPI2C_BWR_MCR_RTF(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RRF[9] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Receive FIFO is reset.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPI2C_WR_MCR_RRF(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RRF_MASK, LPI2C_MCR_RRF(value)))
#define LPI2C_BWR_MCR_RRF(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RRF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MSR - Master Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MSR - Master Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire LPI2C_MSR register
 */
/*@{*/
#define LPI2C_RD_MSR(base)       (LPI2C_MSR_REG(base))
#define LPI2C_WR_MSR(base, value) (LPI2C_MSR_REG(base) = (value))
#define LPI2C_RMW_MSR(base, mask, value) (LPI2C_WR_MSR(base, (LPI2C_RD_MSR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MSR(base, value) (LPI2C_WR_MSR(base, LPI2C_RD_MSR(base) |  (value)))
#define LPI2C_CLR_MSR(base, value) (LPI2C_WR_MSR(base, LPI2C_RD_MSR(base) & ~(value)))
#define LPI2C_TOG_MSR(base, value) (LPI2C_WR_MSR(base, LPI2C_RD_MSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MSR bitfields
 */

/*!
 * @name Register LPI2C_MSR, field TDF[0] (RO)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER.
 *
 * Values:
 * - 0b0 - Transmit data not requested.
 * - 0b1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_TDF field. */
#define LPI2C_RD_MSR_TDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_TDF_MASK) >> LPI2C_MSR_TDF_SHIFT)
#define LPI2C_BRD_MSR_TDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_TDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field RDF[1] (RO)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER.
 *
 * Values:
 * - 0b0 - Receive Data is not ready.
 * - 0b1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_RDF field. */
#define LPI2C_RD_MSR_RDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_RDF_MASK) >> LPI2C_MSR_RDF_SHIFT)
#define LPI2C_BRD_MSR_RDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_RDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field EPF[8] (W1C)
 *
 * This flag will set when the LPI2C master generates either a repeated START or
 * a STOP condition. It does not set when the master first generates a START
 * condition.
 *
 * Values:
 * - 0b0 - Master has not generated a STOP or Repeated START condition.
 * - 0b1 - Master has generated a STOP or Repeated START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_EPF field. */
#define LPI2C_RD_MSR_EPF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_EPF_MASK) >> LPI2C_MSR_EPF_SHIFT)
#define LPI2C_BRD_MSR_EPF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_EPF_SHIFT))

/*! @brief Set the EPF field to a new value. */
#define LPI2C_WR_MSR_EPF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_EPF(value)))
#define LPI2C_BWR_MSR_EPF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_EPF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field SDF[9] (W1C)
 *
 * This flag will set when the LPI2C master generates a STOP condition.
 *
 * Values:
 * - 0b0 - Master has not generated a STOP condition.
 * - 0b1 - Master has generated a STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_SDF field. */
#define LPI2C_RD_MSR_SDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_SDF_MASK) >> LPI2C_MSR_SDF_SHIFT)
#define LPI2C_BRD_MSR_SDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_SDF_SHIFT))

/*! @brief Set the SDF field to a new value. */
#define LPI2C_WR_MSR_SDF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_SDF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_SDF(value)))
#define LPI2C_BWR_MSR_SDF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_SDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field NDF[10] (W1C)
 *
 * This flag will set if the LPI2C master detects a NACK when transmitting an
 * address or data. If a NACK is expected for a given address (as configured by the
 * command word) then the flag will set if a NACK is not generated. When set,
 * the master will transmit a STOP condition and will not initiate a new START
 * condition until this flag has been cleared.
 *
 * Values:
 * - 0b0 - Unexpected NACK not detected.
 * - 0b1 - Unexpected NACK was detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_NDF field. */
#define LPI2C_RD_MSR_NDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_NDF_MASK) >> LPI2C_MSR_NDF_SHIFT)
#define LPI2C_BRD_MSR_NDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_NDF_SHIFT))

/*! @brief Set the NDF field to a new value. */
#define LPI2C_WR_MSR_NDF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_NDF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_NDF(value)))
#define LPI2C_BWR_MSR_NDF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_NDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field ALF[11] (W1C)
 *
 * This flag will set if the LPI2C master transmits a logic one and detects a
 * logic zero on the I2C bus, or if it detects a START or STOP condition while it
 * is transmitting data. When this flag sets, the LPI2C master will release the
 * bus (go idle) and will not initiate a new START condition until this flag has
 * been cleared.
 *
 * Values:
 * - 0b0 - Master has not lost arbitration.
 * - 0b1 - Master has lost arbitration.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_ALF field. */
#define LPI2C_RD_MSR_ALF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_ALF_MASK) >> LPI2C_MSR_ALF_SHIFT)
#define LPI2C_BRD_MSR_ALF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_ALF_SHIFT))

/*! @brief Set the ALF field to a new value. */
#define LPI2C_WR_MSR_ALF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_ALF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_ALF(value)))
#define LPI2C_BWR_MSR_ALF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_ALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field FEF[12] (W1C)
 *
 * Detects an attempt to send or receive data without first generating a
 * (repeated) START condition. This can occur if the transmit FIFO underflows when the
 * AUTOSTOP bit is set. When this flag is set, the LPI2C master will send a STOP
 * condition (if busy) and will not initiate a new START condition until this flag
 * has been cleared.
 *
 * Values:
 * - 0b0 - No error.
 * - 0b1 - Master sending or receiving data without START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_FEF field. */
#define LPI2C_RD_MSR_FEF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_FEF_MASK) >> LPI2C_MSR_FEF_SHIFT)
#define LPI2C_BRD_MSR_FEF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define LPI2C_WR_MSR_FEF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_FEF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_FEF(value)))
#define LPI2C_BWR_MSR_FEF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field PLTF[13] (W1C)
 *
 * Will set when the SCL and/or SDA input is low for more than PINLOW cycles,
 * even when the LPI2C master is idle. Software is responsible for resolving the
 * pin low condition. This flag cannot be cleared for as long as the pin low
 * timeout continues and must be cleared before the LPI2C can initiate a START
 * condition.
 *
 * Values:
 * - 0b0 - Pin low timeout has not occurred or is disabled.
 * - 0b1 - Pin low timeout has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_PLTF field. */
#define LPI2C_RD_MSR_PLTF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_PLTF_MASK) >> LPI2C_MSR_PLTF_SHIFT)
#define LPI2C_BRD_MSR_PLTF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_PLTF_SHIFT))

/*! @brief Set the PLTF field to a new value. */
#define LPI2C_WR_MSR_PLTF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_PLTF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_PLTF(value)))
#define LPI2C_BWR_MSR_PLTF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_PLTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field DMF[14] (W1C)
 *
 * Indicates that the received data has matched the MATCH0 and/or MATCH1 fields
 * as configured by MATCFG. Received data that is discarded due to CMD field does
 * not cause this flag to set.
 *
 * Values:
 * - 0b0 - Have not received matching data.
 * - 0b1 - Have received matching data.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_DMF field. */
#define LPI2C_RD_MSR_DMF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_DMF_MASK) >> LPI2C_MSR_DMF_SHIFT)
#define LPI2C_BRD_MSR_DMF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_DMF_SHIFT))

/*! @brief Set the DMF field to a new value. */
#define LPI2C_WR_MSR_DMF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_DMF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK), LPI2C_MSR_DMF(value)))
#define LPI2C_BWR_MSR_DMF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_DMF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field MBF[24] (RO)
 *
 * Values:
 * - 0b0 - I2C Master is idle.
 * - 0b1 - I2C Master is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_MBF field. */
#define LPI2C_RD_MSR_MBF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_MBF_MASK) >> LPI2C_MSR_MBF_SHIFT)
#define LPI2C_BRD_MSR_MBF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_MBF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field BBF[25] (RO)
 *
 * Values:
 * - 0b0 - I2C Bus is idle.
 * - 0b1 - I2C Bus is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_BBF field. */
#define LPI2C_RD_MSR_BBF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_BBF_MASK) >> LPI2C_MSR_BBF_SHIFT)
#define LPI2C_BRD_MSR_BBF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_BBF_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_MIER - Master Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MIER - Master Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MIER register
 */
/*@{*/
#define LPI2C_RD_MIER(base)      (LPI2C_MIER_REG(base))
#define LPI2C_WR_MIER(base, value) (LPI2C_MIER_REG(base) = (value))
#define LPI2C_RMW_MIER(base, mask, value) (LPI2C_WR_MIER(base, (LPI2C_RD_MIER(base) & ~(mask)) | (value)))
#define LPI2C_SET_MIER(base, value) (LPI2C_WR_MIER(base, LPI2C_RD_MIER(base) |  (value)))
#define LPI2C_CLR_MIER(base, value) (LPI2C_WR_MIER(base, LPI2C_RD_MIER(base) & ~(value)))
#define LPI2C_TOG_MIER(base, value) (LPI2C_WR_MIER(base, LPI2C_RD_MIER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MIER bitfields
 */

/*!
 * @name Register LPI2C_MIER, field TDIE[0] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_TDIE field. */
#define LPI2C_RD_MIER_TDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_TDIE_MASK) >> LPI2C_MIER_TDIE_SHIFT)
#define LPI2C_BRD_MIER_TDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_TDIE_SHIFT))

/*! @brief Set the TDIE field to a new value. */
#define LPI2C_WR_MIER_TDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_TDIE_MASK, LPI2C_MIER_TDIE(value)))
#define LPI2C_BWR_MIER_TDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_TDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field RDIE[1] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_RDIE field. */
#define LPI2C_RD_MIER_RDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_RDIE_MASK) >> LPI2C_MIER_RDIE_SHIFT)
#define LPI2C_BRD_MIER_RDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_RDIE_SHIFT))

/*! @brief Set the RDIE field to a new value. */
#define LPI2C_WR_MIER_RDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_RDIE_MASK, LPI2C_MIER_RDIE(value)))
#define LPI2C_BWR_MIER_RDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_RDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field EPIE[8] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_EPIE field. */
#define LPI2C_RD_MIER_EPIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_EPIE_MASK) >> LPI2C_MIER_EPIE_SHIFT)
#define LPI2C_BRD_MIER_EPIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_EPIE_SHIFT))

/*! @brief Set the EPIE field to a new value. */
#define LPI2C_WR_MIER_EPIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_EPIE_MASK, LPI2C_MIER_EPIE(value)))
#define LPI2C_BWR_MIER_EPIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_EPIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field SDIE[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_SDIE field. */
#define LPI2C_RD_MIER_SDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_SDIE_MASK) >> LPI2C_MIER_SDIE_SHIFT)
#define LPI2C_BRD_MIER_SDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_SDIE_SHIFT))

/*! @brief Set the SDIE field to a new value. */
#define LPI2C_WR_MIER_SDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_SDIE_MASK, LPI2C_MIER_SDIE(value)))
#define LPI2C_BWR_MIER_SDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_SDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field NDIE[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_NDIE field. */
#define LPI2C_RD_MIER_NDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_NDIE_MASK) >> LPI2C_MIER_NDIE_SHIFT)
#define LPI2C_BRD_MIER_NDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_NDIE_SHIFT))

/*! @brief Set the NDIE field to a new value. */
#define LPI2C_WR_MIER_NDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_NDIE_MASK, LPI2C_MIER_NDIE(value)))
#define LPI2C_BWR_MIER_NDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_NDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field ALIE[11] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_ALIE field. */
#define LPI2C_RD_MIER_ALIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_ALIE_MASK) >> LPI2C_MIER_ALIE_SHIFT)
#define LPI2C_BRD_MIER_ALIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_ALIE_SHIFT))

/*! @brief Set the ALIE field to a new value. */
#define LPI2C_WR_MIER_ALIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_ALIE_MASK, LPI2C_MIER_ALIE(value)))
#define LPI2C_BWR_MIER_ALIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_ALIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field FEIE[12] (RW)
 *
 * Values:
 * - 0b0 - Interrupt enabled.
 * - 0b1 - Interrupt disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_FEIE field. */
#define LPI2C_RD_MIER_FEIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_FEIE_MASK) >> LPI2C_MIER_FEIE_SHIFT)
#define LPI2C_BRD_MIER_FEIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define LPI2C_WR_MIER_FEIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_FEIE_MASK, LPI2C_MIER_FEIE(value)))
#define LPI2C_BWR_MIER_FEIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field PLTIE[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_PLTIE field. */
#define LPI2C_RD_MIER_PLTIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_PLTIE_MASK) >> LPI2C_MIER_PLTIE_SHIFT)
#define LPI2C_BRD_MIER_PLTIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_PLTIE_SHIFT))

/*! @brief Set the PLTIE field to a new value. */
#define LPI2C_WR_MIER_PLTIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_PLTIE_MASK, LPI2C_MIER_PLTIE(value)))
#define LPI2C_BWR_MIER_PLTIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_PLTIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field DMIE[14] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_DMIE field. */
#define LPI2C_RD_MIER_DMIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_DMIE_MASK) >> LPI2C_MIER_DMIE_SHIFT)
#define LPI2C_BRD_MIER_DMIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_DMIE_SHIFT))

/*! @brief Set the DMIE field to a new value. */
#define LPI2C_WR_MIER_DMIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_DMIE_MASK, LPI2C_MIER_DMIE(value)))
#define LPI2C_BWR_MIER_DMIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_DMIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MDER - Master DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MDER - Master DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MDER register
 */
/*@{*/
#define LPI2C_RD_MDER(base)      (LPI2C_MDER_REG(base))
#define LPI2C_WR_MDER(base, value) (LPI2C_MDER_REG(base) = (value))
#define LPI2C_RMW_MDER(base, mask, value) (LPI2C_WR_MDER(base, (LPI2C_RD_MDER(base) & ~(mask)) | (value)))
#define LPI2C_SET_MDER(base, value) (LPI2C_WR_MDER(base, LPI2C_RD_MDER(base) |  (value)))
#define LPI2C_CLR_MDER(base, value) (LPI2C_WR_MDER(base, LPI2C_RD_MDER(base) & ~(value)))
#define LPI2C_TOG_MDER(base, value) (LPI2C_WR_MDER(base, LPI2C_RD_MDER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MDER bitfields
 */

/*!
 * @name Register LPI2C_MDER, field TDDE[0] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDER_TDDE field. */
#define LPI2C_RD_MDER_TDDE(base) ((LPI2C_MDER_REG(base) & LPI2C_MDER_TDDE_MASK) >> LPI2C_MDER_TDDE_SHIFT)
#define LPI2C_BRD_MDER_TDDE(base) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_TDDE_SHIFT))

/*! @brief Set the TDDE field to a new value. */
#define LPI2C_WR_MDER_TDDE(base, value) (LPI2C_RMW_MDER(base, LPI2C_MDER_TDDE_MASK, LPI2C_MDER_TDDE(value)))
#define LPI2C_BWR_MDER_TDDE(base, value) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_TDDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MDER, field RDDE[1] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDER_RDDE field. */
#define LPI2C_RD_MDER_RDDE(base) ((LPI2C_MDER_REG(base) & LPI2C_MDER_RDDE_MASK) >> LPI2C_MDER_RDDE_SHIFT)
#define LPI2C_BRD_MDER_RDDE(base) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_RDDE_SHIFT))

/*! @brief Set the RDDE field to a new value. */
#define LPI2C_WR_MDER_RDDE(base, value) (LPI2C_RMW_MDER(base, LPI2C_MDER_RDDE_MASK, LPI2C_MDER_RDDE(value)))
#define LPI2C_BWR_MDER_RDDE(base, value) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_RDDE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR0 - Master Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR0 - Master Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR0 register
 */
/*@{*/
#define LPI2C_RD_MCFGR0(base)    (LPI2C_MCFGR0_REG(base))
#define LPI2C_WR_MCFGR0(base, value) (LPI2C_MCFGR0_REG(base) = (value))
#define LPI2C_RMW_MCFGR0(base, mask, value) (LPI2C_WR_MCFGR0(base, (LPI2C_RD_MCFGR0(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR0(base, value) (LPI2C_WR_MCFGR0(base, LPI2C_RD_MCFGR0(base) |  (value)))
#define LPI2C_CLR_MCFGR0(base, value) (LPI2C_WR_MCFGR0(base, LPI2C_RD_MCFGR0(base) & ~(value)))
#define LPI2C_TOG_MCFGR0(base, value) (LPI2C_WR_MCFGR0(base, LPI2C_RD_MCFGR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR0 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR0, field HREN[0] (RW)
 *
 * When enabled, the LPI2C master will only initiate a START condition if the
 * host request input is asserted and the bus is idle. A repeated START is not
 * affected by the host request.
 *
 * Values:
 * - 0b0 - Host request input is disabled.
 * - 0b1 - Host request input is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HREN field. */
#define LPI2C_RD_MCFGR0_HREN(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HREN_MASK) >> LPI2C_MCFGR0_HREN_SHIFT)
#define LPI2C_BRD_MCFGR0_HREN(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HREN_SHIFT))

/*! @brief Set the HREN field to a new value. */
#define LPI2C_WR_MCFGR0_HREN(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HREN_MASK, LPI2C_MCFGR0_HREN(value)))
#define LPI2C_BWR_MCFGR0_HREN(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field HRPOL[1] (RW)
 *
 * Configures the polarity of the host request input pin.
 *
 * Values:
 * - 0b0 - Active low.
 * - 0b1 - Active high.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HRPOL field. */
#define LPI2C_RD_MCFGR0_HRPOL(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HRPOL_MASK) >> LPI2C_MCFGR0_HRPOL_SHIFT)
#define LPI2C_BRD_MCFGR0_HRPOL(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRPOL_SHIFT))

/*! @brief Set the HRPOL field to a new value. */
#define LPI2C_WR_MCFGR0_HRPOL(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HRPOL_MASK, LPI2C_MCFGR0_HRPOL(value)))
#define LPI2C_BWR_MCFGR0_HRPOL(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field HRSEL[2] (RW)
 *
 * Selects the source of the host request input.
 *
 * Values:
 * - 0b0 - Host request input is pin LPI2C_HREQ.
 * - 0b1 - Host request input is input trigger.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HRSEL field. */
#define LPI2C_RD_MCFGR0_HRSEL(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HRSEL_MASK) >> LPI2C_MCFGR0_HRSEL_SHIFT)
#define LPI2C_BRD_MCFGR0_HRSEL(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRSEL_SHIFT))

/*! @brief Set the HRSEL field to a new value. */
#define LPI2C_WR_MCFGR0_HRSEL(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HRSEL_MASK, LPI2C_MCFGR0_HRSEL(value)))
#define LPI2C_BWR_MCFGR0_HRSEL(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field CIRFIFO[8] (RW)
 *
 * When enabled, the transmit FIFO read pointer is saved to a temporary
 * register. The transmit FIFO will be emptied as normal, but once the LPI2C master is
 * idle and the transmit FIFO is empty, then the read pointer value will be
 * restored from the temporary register. This will cause the contents of the transmit
 * FIFO to be cycled through repeatedly. If AUTOSTOP is set, a STOP condition will
 * be sent whenever the transmit FIFO is empty and the read pointer is restored.
 *
 * Values:
 * - 0b0 - Circular FIFO is disabled.
 * - 0b1 - Circular FIFO is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_CIRFIFO field. */
#define LPI2C_RD_MCFGR0_CIRFIFO(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_CIRFIFO_MASK) >> LPI2C_MCFGR0_CIRFIFO_SHIFT)
#define LPI2C_BRD_MCFGR0_CIRFIFO(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_CIRFIFO_SHIFT))

/*! @brief Set the CIRFIFO field to a new value. */
#define LPI2C_WR_MCFGR0_CIRFIFO(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_CIRFIFO_MASK, LPI2C_MCFGR0_CIRFIFO(value)))
#define LPI2C_BWR_MCFGR0_CIRFIFO(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_CIRFIFO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field RDMO[9] (RW)
 *
 * When enabled, all received data that does not cause DMF to set is discarded.
 * Once DMF is set, the RDMO configuration is ignored. When disabling RDMO, clear
 * RDMO before clearing DMF to ensure no receive data is lost.
 *
 * Values:
 * - 0b0 - Received data is stored in the receive FIFO as normal.
 * - 0b1 - Received data is discarded unless the RMF is set.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_RDMO field. */
#define LPI2C_RD_MCFGR0_RDMO(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_RDMO_MASK) >> LPI2C_MCFGR0_RDMO_SHIFT)
#define LPI2C_BRD_MCFGR0_RDMO(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_RDMO_SHIFT))

/*! @brief Set the RDMO field to a new value. */
#define LPI2C_WR_MCFGR0_RDMO(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_RDMO_MASK, LPI2C_MCFGR0_RDMO(value)))
#define LPI2C_BWR_MCFGR0_RDMO(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_RDMO_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR1 - Master Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR1 - Master Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR1 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR1 register
 */
/*@{*/
#define LPI2C_RD_MCFGR1(base)    (LPI2C_MCFGR1_REG(base))
#define LPI2C_WR_MCFGR1(base, value) (LPI2C_MCFGR1_REG(base) = (value))
#define LPI2C_RMW_MCFGR1(base, mask, value) (LPI2C_WR_MCFGR1(base, (LPI2C_RD_MCFGR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR1(base, value) (LPI2C_WR_MCFGR1(base, LPI2C_RD_MCFGR1(base) |  (value)))
#define LPI2C_CLR_MCFGR1(base, value) (LPI2C_WR_MCFGR1(base, LPI2C_RD_MCFGR1(base) & ~(value)))
#define LPI2C_TOG_MCFGR1(base, value) (LPI2C_WR_MCFGR1(base, LPI2C_RD_MCFGR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR1 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR1, field PRESCALE[2:0] (RW)
 *
 * Configures the clock prescaler used for all LPI2C master logic, except the
 * digital glitch filters.
 *
 * Values:
 * - 0b000 - Divide by 1.
 * - 0b001 - Divide by 2.
 * - 0b010 - Divide by 4.
 * - 0b011 - Divide by 8.
 * - 0b100 - Divide by 16.
 * - 0b101 - Divide by 32.
 * - 0b110 - Divide by 64.
 * - 0b111 - Divide by 128.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_PRESCALE field. */
#define LPI2C_RD_MCFGR1_PRESCALE(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_PRESCALE_MASK) >> LPI2C_MCFGR1_PRESCALE_SHIFT)
#define LPI2C_BRD_MCFGR1_PRESCALE(base) (LPI2C_RD_MCFGR1_PRESCALE(base))

/*! @brief Set the PRESCALE field to a new value. */
#define LPI2C_WR_MCFGR1_PRESCALE(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_PRESCALE_MASK, LPI2C_MCFGR1_PRESCALE(value)))
#define LPI2C_BWR_MCFGR1_PRESCALE(base, value) (LPI2C_WR_MCFGR1_PRESCALE(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field AUTOSTOP[8] (RW)
 *
 * When enabled, a STOP condition is generated whenever the LPI2C master is busy
 * and the transmit FIFO is empty. The STOP condition can also be generated
 * using a transmit FIFO command.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - STOP condition is automatically generated whenever the transmit FIFO
 *     is empty and LPI2C master is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_AUTOSTOP field. */
#define LPI2C_RD_MCFGR1_AUTOSTOP(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_AUTOSTOP_MASK) >> LPI2C_MCFGR1_AUTOSTOP_SHIFT)
#define LPI2C_BRD_MCFGR1_AUTOSTOP(base) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_AUTOSTOP_SHIFT))

/*! @brief Set the AUTOSTOP field to a new value. */
#define LPI2C_WR_MCFGR1_AUTOSTOP(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_AUTOSTOP_MASK, LPI2C_MCFGR1_AUTOSTOP(value)))
#define LPI2C_BWR_MCFGR1_AUTOSTOP(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_AUTOSTOP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field IGNACK[9] (RW)
 *
 * When set, the received NACK field is ignored and assumed to be ACK. This bit
 * is required to be set in Ultra-Fast Mode.
 *
 * Values:
 * - 0b0 - LPI2C Master will receive ACK and NACK normally.
 * - 0b1 - LPI2C Master will treat a received NACK as if it was an ACK.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_IGNACK field. */
#define LPI2C_RD_MCFGR1_IGNACK(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_IGNACK_MASK) >> LPI2C_MCFGR1_IGNACK_SHIFT)
#define LPI2C_BRD_MCFGR1_IGNACK(base) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_IGNACK_SHIFT))

/*! @brief Set the IGNACK field to a new value. */
#define LPI2C_WR_MCFGR1_IGNACK(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_IGNACK_MASK, LPI2C_MCFGR1_IGNACK(value)))
#define LPI2C_BWR_MCFGR1_IGNACK(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_IGNACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field TIMECFG[10] (RW)
 *
 * Values:
 * - 0b0 - Pin Low Timeout Flag will set if SCL is low for longer than the
 *     configured timeout.
 * - 0b1 - Pin Low Timeout Flag will set if either SCL or SDA is low for longer
 *     than the configured timeout.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_TIMECFG field. */
#define LPI2C_RD_MCFGR1_TIMECFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_TIMECFG_MASK) >> LPI2C_MCFGR1_TIMECFG_SHIFT)
#define LPI2C_BRD_MCFGR1_TIMECFG(base) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_TIMECFG_SHIFT))

/*! @brief Set the TIMECFG field to a new value. */
#define LPI2C_WR_MCFGR1_TIMECFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_TIMECFG_MASK, LPI2C_MCFGR1_TIMECFG(value)))
#define LPI2C_BWR_MCFGR1_TIMECFG(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_TIMECFG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field MATCFG[18:16] (RW)
 *
 * Configures the condition that will cause the DMF to set.
 *
 * Values:
 * - 0b000 - Match disabled.
 * - 0b001 - Reserved.
 * - 0b010 - Match enabled (1st data word equals MATCH0 OR MATCH1).
 * - 0b011 - Match enabled (any data word equals MATCH0 OR MATCH1).
 * - 0b100 - Match enabled (1st data word equals MATCH0 AND 2nd data word equals
 *     MATCH1).
 * - 0b101 - Match enabled (any data word equals MATCH0 AND next data word
 *     equals MATCH1).
 * - 0b110 - Match enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1).
 * - 0b111 - Match enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_MATCFG field. */
#define LPI2C_RD_MCFGR1_MATCFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_MATCFG_MASK) >> LPI2C_MCFGR1_MATCFG_SHIFT)
#define LPI2C_BRD_MCFGR1_MATCFG(base) (LPI2C_RD_MCFGR1_MATCFG(base))

/*! @brief Set the MATCFG field to a new value. */
#define LPI2C_WR_MCFGR1_MATCFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_MATCFG_MASK, LPI2C_MCFGR1_MATCFG(value)))
#define LPI2C_BWR_MCFGR1_MATCFG(base, value) (LPI2C_WR_MCFGR1_MATCFG(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field PINCFG[26:24] (RW)
 *
 * Configures the pin mode.
 *
 * Values:
 * - 0b000 - LPI2C configured for 2-pin open drain mode.
 * - 0b001 - LPI2C configured for 2-pin output only mode (ultra-fast mode).
 * - 0b010 - LPI2C configured for 2-pin push-pull mode.
 * - 0b011 - LPI2C configured for 4-pin push-pull mode.
 * - 0b100 - LPI2C configured for 2-pin open drain mode with separate LPI2C
 *     slave.
 * - 0b101 - LPI2C configured for 2-pin output only mode (ultra-fast mode) with
 *     separate LPI2C slave.
 * - 0b110 - LPI2C configured for 2-pin push-pull mode with separate LPI2C slave.
 * - 0b111 - LPI2C configured for 4-pin push-pull mode (inverted outputs).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_PINCFG field. */
#define LPI2C_RD_MCFGR1_PINCFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_PINCFG_MASK) >> LPI2C_MCFGR1_PINCFG_SHIFT)
#define LPI2C_BRD_MCFGR1_PINCFG(base) (LPI2C_RD_MCFGR1_PINCFG(base))

/*! @brief Set the PINCFG field to a new value. */
#define LPI2C_WR_MCFGR1_PINCFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_PINCFG_MASK, LPI2C_MCFGR1_PINCFG(value)))
#define LPI2C_BWR_MCFGR1_PINCFG(base, value) (LPI2C_WR_MCFGR1_PINCFG(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR2 - Master Configuration Register 2
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR2 - Master Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR2 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR2 register
 */
/*@{*/
#define LPI2C_RD_MCFGR2(base)    (LPI2C_MCFGR2_REG(base))
#define LPI2C_WR_MCFGR2(base, value) (LPI2C_MCFGR2_REG(base) = (value))
#define LPI2C_RMW_MCFGR2(base, mask, value) (LPI2C_WR_MCFGR2(base, (LPI2C_RD_MCFGR2(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR2(base, value) (LPI2C_WR_MCFGR2(base, LPI2C_RD_MCFGR2(base) |  (value)))
#define LPI2C_CLR_MCFGR2(base, value) (LPI2C_WR_MCFGR2(base, LPI2C_RD_MCFGR2(base) & ~(value)))
#define LPI2C_TOG_MCFGR2(base, value) (LPI2C_WR_MCFGR2(base, LPI2C_RD_MCFGR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR2 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR2, field BUSIDLE[11:0] (RW)
 *
 * Configures the bus idle timeout period in clock cycles. If both SCL and SDA
 * are high for longer than BUSIDLE cycles, then the I2C bus is assumed to be idle
 * and the master can generate a START condition. When set to zero, this feature
 * is disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_BUSIDLE field. */
#define LPI2C_RD_MCFGR2_BUSIDLE(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_BUSIDLE_MASK) >> LPI2C_MCFGR2_BUSIDLE_SHIFT)
#define LPI2C_BRD_MCFGR2_BUSIDLE(base) (LPI2C_RD_MCFGR2_BUSIDLE(base))

/*! @brief Set the BUSIDLE field to a new value. */
#define LPI2C_WR_MCFGR2_BUSIDLE(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_BUSIDLE_MASK, LPI2C_MCFGR2_BUSIDLE(value)))
#define LPI2C_BWR_MCFGR2_BUSIDLE(base, value) (LPI2C_WR_MCFGR2_BUSIDLE(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR2, field FILTSCL[19:16] (RW)
 *
 * Configures the I2C master digital glitch filters for SCL input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSCL
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSCL cycles and must be configured less than the minimum
 * SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration and is automatically bypassed in High Speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_FILTSCL field. */
#define LPI2C_RD_MCFGR2_FILTSCL(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_FILTSCL_MASK) >> LPI2C_MCFGR2_FILTSCL_SHIFT)
#define LPI2C_BRD_MCFGR2_FILTSCL(base) (LPI2C_RD_MCFGR2_FILTSCL(base))

/*! @brief Set the FILTSCL field to a new value. */
#define LPI2C_WR_MCFGR2_FILTSCL(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_FILTSCL_MASK, LPI2C_MCFGR2_FILTSCL(value)))
#define LPI2C_BWR_MCFGR2_FILTSCL(base, value) (LPI2C_WR_MCFGR2_FILTSCL(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR2, field FILTSDA[27:24] (RW)
 *
 * Configures the I2C master digital glitch filters for SDA input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSDA
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSDA cycles and must be configured less than the minimum
 * SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration and is automatically bypassed in High Speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_FILTSDA field. */
#define LPI2C_RD_MCFGR2_FILTSDA(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_FILTSDA_MASK) >> LPI2C_MCFGR2_FILTSDA_SHIFT)
#define LPI2C_BRD_MCFGR2_FILTSDA(base) (LPI2C_RD_MCFGR2_FILTSDA(base))

/*! @brief Set the FILTSDA field to a new value. */
#define LPI2C_WR_MCFGR2_FILTSDA(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_FILTSDA_MASK, LPI2C_MCFGR2_FILTSDA(value)))
#define LPI2C_BWR_MCFGR2_FILTSDA(base, value) (LPI2C_WR_MCFGR2_FILTSDA(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR3 - Master Configuration Register 3
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR3 - Master Configuration Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR3 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR3 register
 */
/*@{*/
#define LPI2C_RD_MCFGR3(base)    (LPI2C_MCFGR3_REG(base))
#define LPI2C_WR_MCFGR3(base, value) (LPI2C_MCFGR3_REG(base) = (value))
#define LPI2C_RMW_MCFGR3(base, mask, value) (LPI2C_WR_MCFGR3(base, (LPI2C_RD_MCFGR3(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR3(base, value) (LPI2C_WR_MCFGR3(base, LPI2C_RD_MCFGR3(base) |  (value)))
#define LPI2C_CLR_MCFGR3(base, value) (LPI2C_WR_MCFGR3(base, LPI2C_RD_MCFGR3(base) & ~(value)))
#define LPI2C_TOG_MCFGR3(base, value) (LPI2C_WR_MCFGR3(base, LPI2C_RD_MCFGR3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR3 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR3, field PINLOW[19:8] (RW)
 *
 * Configures the pin low timeout flag in clock cycles. If SCL and/or SDA is low
 * for longer than (PINLOW * 256) cycles then PLTF is set. When set to zero,
 * this feature is disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR3_PINLOW field. */
#define LPI2C_RD_MCFGR3_PINLOW(base) ((LPI2C_MCFGR3_REG(base) & LPI2C_MCFGR3_PINLOW_MASK) >> LPI2C_MCFGR3_PINLOW_SHIFT)
#define LPI2C_BRD_MCFGR3_PINLOW(base) (LPI2C_RD_MCFGR3_PINLOW(base))

/*! @brief Set the PINLOW field to a new value. */
#define LPI2C_WR_MCFGR3_PINLOW(base, value) (LPI2C_RMW_MCFGR3(base, LPI2C_MCFGR3_PINLOW_MASK, LPI2C_MCFGR3_PINLOW(value)))
#define LPI2C_BWR_MCFGR3_PINLOW(base, value) (LPI2C_WR_MCFGR3_PINLOW(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MDMR - Master Data Match Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MDMR - Master Data Match Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MDMR register
 */
/*@{*/
#define LPI2C_RD_MDMR(base)      (LPI2C_MDMR_REG(base))
#define LPI2C_WR_MDMR(base, value) (LPI2C_MDMR_REG(base) = (value))
#define LPI2C_RMW_MDMR(base, mask, value) (LPI2C_WR_MDMR(base, (LPI2C_RD_MDMR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MDMR(base, value) (LPI2C_WR_MDMR(base, LPI2C_RD_MDMR(base) |  (value)))
#define LPI2C_CLR_MDMR(base, value) (LPI2C_WR_MDMR(base, LPI2C_RD_MDMR(base) & ~(value)))
#define LPI2C_TOG_MDMR(base, value) (LPI2C_WR_MDMR(base, LPI2C_RD_MDMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MDMR bitfields
 */

/*!
 * @name Register LPI2C_MDMR, field MATCH0[7:0] (RW)
 *
 * Compared against the received data when receive data match is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDMR_MATCH0 field. */
#define LPI2C_RD_MDMR_MATCH0(base) ((LPI2C_MDMR_REG(base) & LPI2C_MDMR_MATCH0_MASK) >> LPI2C_MDMR_MATCH0_SHIFT)
#define LPI2C_BRD_MDMR_MATCH0(base) (LPI2C_RD_MDMR_MATCH0(base))

/*! @brief Set the MATCH0 field to a new value. */
#define LPI2C_WR_MDMR_MATCH0(base, value) (LPI2C_RMW_MDMR(base, LPI2C_MDMR_MATCH0_MASK, LPI2C_MDMR_MATCH0(value)))
#define LPI2C_BWR_MDMR_MATCH0(base, value) (LPI2C_WR_MDMR_MATCH0(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MDMR, field MATCH1[23:16] (RW)
 *
 * Compared against the received data when receive data match is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDMR_MATCH1 field. */
#define LPI2C_RD_MDMR_MATCH1(base) ((LPI2C_MDMR_REG(base) & LPI2C_MDMR_MATCH1_MASK) >> LPI2C_MDMR_MATCH1_SHIFT)
#define LPI2C_BRD_MDMR_MATCH1(base) (LPI2C_RD_MDMR_MATCH1(base))

/*! @brief Set the MATCH1 field to a new value. */
#define LPI2C_WR_MDMR_MATCH1(base, value) (LPI2C_RMW_MDMR(base, LPI2C_MDMR_MATCH1_MASK, LPI2C_MDMR_MATCH1(value)))
#define LPI2C_BWR_MDMR_MATCH1(base, value) (LPI2C_WR_MDMR_MATCH1(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCCR0 - Master Clock Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPI2C_MCCR0 - Master Clock Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCCR0 cannot be changed when the I2C master is enabled and is used for
 * standard, fast, fast-mode plus and ultra-fast transfers.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCCR0 register
 */
/*@{*/
#define LPI2C_RD_MCCR0(base)     (LPI2C_MCCR0_REG(base))
#define LPI2C_WR_MCCR0(base, value) (LPI2C_MCCR0_REG(base) = (value))
#define LPI2C_RMW_MCCR0(base, mask, value) (LPI2C_WR_MCCR0(base, (LPI2C_RD_MCCR0(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCCR0(base, value) (LPI2C_WR_MCCR0(base, LPI2C_RD_MCCR0(base) |  (value)))
#define LPI2C_CLR_MCCR0(base, value) (LPI2C_WR_MCCR0(base, LPI2C_RD_MCCR0(base) & ~(value)))
#define LPI2C_TOG_MCCR0(base, value) (LPI2C_WR_MCCR0(base, LPI2C_RD_MCCR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCCR0 bitfields
 */

/*!
 * @name Register LPI2C_MCCR0, field CLKLO[5:0] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven low by the
 * master. This value is also used for the minimum bus free time between a STOP
 * and a START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_CLKLO field. */
#define LPI2C_RD_MCCR0_CLKLO(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_CLKLO_MASK) >> LPI2C_MCCR0_CLKLO_SHIFT)
#define LPI2C_BRD_MCCR0_CLKLO(base) (LPI2C_RD_MCCR0_CLKLO(base))

/*! @brief Set the CLKLO field to a new value. */
#define LPI2C_WR_MCCR0_CLKLO(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_CLKLO_MASK, LPI2C_MCCR0_CLKLO(value)))
#define LPI2C_BWR_MCCR0_CLKLO(base, value) (LPI2C_WR_MCCR0_CLKLO(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field CLKHI[13:8] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven high by the
 * master. The SCL high time is extended by the time it takes to detect a rising
 * edge on the external SCL pin. Ignoring any additional board delay due to
 * external loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_CLKHI field. */
#define LPI2C_RD_MCCR0_CLKHI(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_CLKHI_MASK) >> LPI2C_MCCR0_CLKHI_SHIFT)
#define LPI2C_BRD_MCCR0_CLKHI(base) (LPI2C_RD_MCCR0_CLKHI(base))

/*! @brief Set the CLKHI field to a new value. */
#define LPI2C_WR_MCCR0_CLKHI(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_CLKHI_MASK, LPI2C_MCCR0_CLKHI(value)))
#define LPI2C_BWR_MCCR0_CLKHI(base, value) (LPI2C_WR_MCCR0_CLKHI(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field SETHOLD[21:16] (RW)
 *
 * Minimum number of cycles (minus one) that is used by the master as the setup
 * and hold time for a (repeated) START condition and setup time for a STOP
 * condition. The setup time is extended by the time it takes to detect a rising edge
 * on the external SCL pin. Ignoring any additional board delay due to external
 * loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_SETHOLD field. */
#define LPI2C_RD_MCCR0_SETHOLD(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_SETHOLD_MASK) >> LPI2C_MCCR0_SETHOLD_SHIFT)
#define LPI2C_BRD_MCCR0_SETHOLD(base) (LPI2C_RD_MCCR0_SETHOLD(base))

/*! @brief Set the SETHOLD field to a new value. */
#define LPI2C_WR_MCCR0_SETHOLD(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_SETHOLD_MASK, LPI2C_MCCR0_SETHOLD(value)))
#define LPI2C_BWR_MCCR0_SETHOLD(base, value) (LPI2C_WR_MCCR0_SETHOLD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field DATAVD[29:24] (RW)
 *
 * Minimum number of cycles (minus one) that is used as the data hold time for
 * SDA. Must be configured less than the minimum SCL low period.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_DATAVD field. */
#define LPI2C_RD_MCCR0_DATAVD(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_DATAVD_MASK) >> LPI2C_MCCR0_DATAVD_SHIFT)
#define LPI2C_BRD_MCCR0_DATAVD(base) (LPI2C_RD_MCCR0_DATAVD(base))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_MCCR0_DATAVD(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_DATAVD_MASK, LPI2C_MCCR0_DATAVD(value)))
#define LPI2C_BWR_MCCR0_DATAVD(base, value) (LPI2C_WR_MCCR0_DATAVD(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCCR1 - Master Clock Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_MCCR1 - Master Clock Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCCR1 cannot be changed when the I2C master is enabled and is used for
 * high speed mode transfers. The separate clock configuration for high speed mode
 * allows arbitration to take place in Fast mode (with timing configured by
 * MCCR0), before switching to high speed mode (with timing configured by MCCR1).
 */
/*!
 * @name Constants and macros for entire LPI2C_MCCR1 register
 */
/*@{*/
#define LPI2C_RD_MCCR1(base)     (LPI2C_MCCR1_REG(base))
#define LPI2C_WR_MCCR1(base, value) (LPI2C_MCCR1_REG(base) = (value))
#define LPI2C_RMW_MCCR1(base, mask, value) (LPI2C_WR_MCCR1(base, (LPI2C_RD_MCCR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCCR1(base, value) (LPI2C_WR_MCCR1(base, LPI2C_RD_MCCR1(base) |  (value)))
#define LPI2C_CLR_MCCR1(base, value) (LPI2C_WR_MCCR1(base, LPI2C_RD_MCCR1(base) & ~(value)))
#define LPI2C_TOG_MCCR1(base, value) (LPI2C_WR_MCCR1(base, LPI2C_RD_MCCR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCCR1 bitfields
 */

/*!
 * @name Register LPI2C_MCCR1, field CLKLO[5:0] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven low by the
 * master. This value is also used for the minimum bus free time between a STOP
 * and a START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_CLKLO field. */
#define LPI2C_RD_MCCR1_CLKLO(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_CLKLO_MASK) >> LPI2C_MCCR1_CLKLO_SHIFT)
#define LPI2C_BRD_MCCR1_CLKLO(base) (LPI2C_RD_MCCR1_CLKLO(base))

/*! @brief Set the CLKLO field to a new value. */
#define LPI2C_WR_MCCR1_CLKLO(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_CLKLO_MASK, LPI2C_MCCR1_CLKLO(value)))
#define LPI2C_BWR_MCCR1_CLKLO(base, value) (LPI2C_WR_MCCR1_CLKLO(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field CLKHI[13:8] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven high by the
 * master. The SCL high time is extended by the time it takes to detect a rising
 * edge on the external SCL pin. Ignoring any additional board delay due to
 * external loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_CLKHI field. */
#define LPI2C_RD_MCCR1_CLKHI(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_CLKHI_MASK) >> LPI2C_MCCR1_CLKHI_SHIFT)
#define LPI2C_BRD_MCCR1_CLKHI(base) (LPI2C_RD_MCCR1_CLKHI(base))

/*! @brief Set the CLKHI field to a new value. */
#define LPI2C_WR_MCCR1_CLKHI(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_CLKHI_MASK, LPI2C_MCCR1_CLKHI(value)))
#define LPI2C_BWR_MCCR1_CLKHI(base, value) (LPI2C_WR_MCCR1_CLKHI(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field SETHOLD[21:16] (RW)
 *
 * Minimum number of cycles (minus one) that is used by the master as the setup
 * and hold time for a (repeated) START condition and setup time for a STOP
 * condition. The setup time is extended by the time it takes to detect a rising edge
 * on the external SCL pin. Ignoring any additional board delay due to external
 * loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_SETHOLD field. */
#define LPI2C_RD_MCCR1_SETHOLD(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_SETHOLD_MASK) >> LPI2C_MCCR1_SETHOLD_SHIFT)
#define LPI2C_BRD_MCCR1_SETHOLD(base) (LPI2C_RD_MCCR1_SETHOLD(base))

/*! @brief Set the SETHOLD field to a new value. */
#define LPI2C_WR_MCCR1_SETHOLD(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_SETHOLD_MASK, LPI2C_MCCR1_SETHOLD(value)))
#define LPI2C_BWR_MCCR1_SETHOLD(base, value) (LPI2C_WR_MCCR1_SETHOLD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field DATAVD[29:24] (RW)
 *
 * Minimum number of cycles (minus one) that is used as the data hold time for
 * SDA. Must be configured less than the minimum SCL low period.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_DATAVD field. */
#define LPI2C_RD_MCCR1_DATAVD(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_DATAVD_MASK) >> LPI2C_MCCR1_DATAVD_SHIFT)
#define LPI2C_BRD_MCCR1_DATAVD(base) (LPI2C_RD_MCCR1_DATAVD(base))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_MCCR1_DATAVD(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_DATAVD_MASK, LPI2C_MCCR1_DATAVD(value)))
#define LPI2C_BWR_MCCR1_DATAVD(base, value) (LPI2C_WR_MCCR1_DATAVD(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MFCR - Master FIFO Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MFCR - Master FIFO Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MFCR register
 */
/*@{*/
#define LPI2C_RD_MFCR(base)      (LPI2C_MFCR_REG(base))
#define LPI2C_WR_MFCR(base, value) (LPI2C_MFCR_REG(base) = (value))
#define LPI2C_RMW_MFCR(base, mask, value) (LPI2C_WR_MFCR(base, (LPI2C_RD_MFCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MFCR(base, value) (LPI2C_WR_MFCR(base, LPI2C_RD_MFCR(base) |  (value)))
#define LPI2C_CLR_MFCR(base, value) (LPI2C_WR_MFCR(base, LPI2C_RD_MFCR(base) & ~(value)))
#define LPI2C_TOG_MFCR(base, value) (LPI2C_WR_MFCR(base, LPI2C_RD_MFCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MFCR bitfields
 */

/*!
 * @name Register LPI2C_MFCR, field TXWATER[7:0] (RW)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER. Writing a value equal or greater than the
 * FIFO size will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFCR_TXWATER field. */
#define LPI2C_RD_MFCR_TXWATER(base) ((LPI2C_MFCR_REG(base) & LPI2C_MFCR_TXWATER_MASK) >> LPI2C_MFCR_TXWATER_SHIFT)
#define LPI2C_BRD_MFCR_TXWATER(base) (LPI2C_RD_MFCR_TXWATER(base))

/*! @brief Set the TXWATER field to a new value. */
#define LPI2C_WR_MFCR_TXWATER(base, value) (LPI2C_RMW_MFCR(base, LPI2C_MFCR_TXWATER_MASK, LPI2C_MFCR_TXWATER(value)))
#define LPI2C_BWR_MFCR_TXWATER(base, value) (LPI2C_WR_MFCR_TXWATER(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MFCR, field RXWATER[23:16] (RW)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER. Writing a value equal or greater than the FIFO size
 * will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFCR_RXWATER field. */
#define LPI2C_RD_MFCR_RXWATER(base) ((LPI2C_MFCR_REG(base) & LPI2C_MFCR_RXWATER_MASK) >> LPI2C_MFCR_RXWATER_SHIFT)
#define LPI2C_BRD_MFCR_RXWATER(base) (LPI2C_RD_MFCR_RXWATER(base))

/*! @brief Set the RXWATER field to a new value. */
#define LPI2C_WR_MFCR_RXWATER(base, value) (LPI2C_RMW_MFCR(base, LPI2C_MFCR_RXWATER_MASK, LPI2C_MFCR_RXWATER(value)))
#define LPI2C_BWR_MFCR_RXWATER(base, value) (LPI2C_WR_MFCR_RXWATER(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MFSR - Master FIFO Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MFSR - Master FIFO Status Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MFSR register
 */
/*@{*/
#define LPI2C_RD_MFSR(base)      (LPI2C_MFSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MFSR bitfields
 */

/*!
 * @name Register LPI2C_MFSR, field TXCOUNT[7:0] (RO)
 *
 * Returns the number of words in the transmit FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFSR_TXCOUNT field. */
#define LPI2C_RD_MFSR_TXCOUNT(base) ((LPI2C_MFSR_REG(base) & LPI2C_MFSR_TXCOUNT_MASK) >> LPI2C_MFSR_TXCOUNT_SHIFT)
#define LPI2C_BRD_MFSR_TXCOUNT(base) (LPI2C_RD_MFSR_TXCOUNT(base))
/*@}*/

/*!
 * @name Register LPI2C_MFSR, field RXCOUNT[23:16] (RO)
 *
 * Returns the number of words in the receive FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFSR_RXCOUNT field. */
#define LPI2C_RD_MFSR_RXCOUNT(base) ((LPI2C_MFSR_REG(base) & LPI2C_MFSR_RXCOUNT_MASK) >> LPI2C_MFSR_RXCOUNT_SHIFT)
#define LPI2C_BRD_MFSR_RXCOUNT(base) (LPI2C_RD_MFSR_RXCOUNT(base))
/*@}*/

/*******************************************************************************
 * LPI2C_MTDR - Master Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MTDR - Master Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 *
 * An 8-bit write to the CMD field will store the data in the Command FIFO, but
 * does not increment the FIFO write pointer. An 8-bit write to the DATA field
 * will zero extend the CMD field unless the CMD field has been written separately
 * since the last FIFO write, it also increments the FIFO write pointer. A 16-bit
 * or 32-bit will write both the CMD and DATA fields and increment the FIFO.
 */
/*!
 * @name Constants and macros for entire LPI2C_MTDR register
 */
/*@{*/
#define LPI2C_RD_MTDR(base)      (LPI2C_MTDR_REG(base))
#define LPI2C_WR_MTDR(base, value) (LPI2C_MTDR_REG(base) = (value))
#define LPI2C_RMW_MTDR(base, mask, value) (LPI2C_WR_MTDR(base, (LPI2C_RD_MTDR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MTDR bitfields
 */

/*!
 * @name Register LPI2C_MTDR, field DATA[7:0] (WO)
 *
 * Performing an 8-bit write to DATA will zero extend the CMD field.
 */
/*@{*/
/*! @brief Set the DATA field to a new value. */
#define LPI2C_WR_MTDR_DATA(base, value) (LPI2C_RMW_MTDR(base, LPI2C_MTDR_DATA_MASK, LPI2C_MTDR_DATA(value)))
#define LPI2C_BWR_MTDR_DATA(base, value) (LPI2C_WR_MTDR_DATA(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MTDR, field CMD[10:8] (WO)
 *
 * Values:
 * - 0b000 - Transmit DATA[7:0].
 * - 0b001 - Receive (DATA[7:0] + 1) bytes.
 * - 0b010 - Generate STOP condition.
 * - 0b011 - Receive and discard (DATA[7:0] + 1) bytes.
 * - 0b100 - Generate (repeated) START and transmit address in DATA[7:0].
 * - 0b101 - Generate (repeated) START and transmit address in DATA[7:0]. This
 *     transfer expects a NACK to be returned.
 * - 0b110 - Generate (repeated) START and transmit address in DATA[7:0] using
 *     high speed mode.
 * - 0b111 - Generate (repeated) START and transmit address in DATA[7:0] using
 *     high speed mode. This transfer expects a NACK to be returned.
 */
/*@{*/
/*! @brief Set the CMD field to a new value. */
#define LPI2C_WR_MTDR_CMD(base, value) (LPI2C_RMW_MTDR(base, LPI2C_MTDR_CMD_MASK, LPI2C_MTDR_CMD(value)))
#define LPI2C_BWR_MTDR_CMD(base, value) (LPI2C_WR_MTDR_CMD(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MRDR - Master Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MRDR - Master Receive Data Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MRDR register
 */
/*@{*/
#define LPI2C_RD_MRDR(base)      (LPI2C_MRDR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MRDR bitfields
 */

/*!
 * @name Register LPI2C_MRDR, field DATA[7:0] (RO)
 *
 * Reading this register returns the data received by the I2C master that has
 * not been discarded. Receive data can be discarded due to the CMD field or the
 * master can be configured to discard non-matching data.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MRDR_DATA field. */
#define LPI2C_RD_MRDR_DATA(base) ((LPI2C_MRDR_REG(base) & LPI2C_MRDR_DATA_MASK) >> LPI2C_MRDR_DATA_SHIFT)
#define LPI2C_BRD_MRDR_DATA(base) (LPI2C_RD_MRDR_DATA(base))
/*@}*/

/*!
 * @name Register LPI2C_MRDR, field RXEMPTY[14] (RO)
 *
 * Values:
 * - 0b0 - Receive FIFO is not empty.
 * - 0b1 - Receive FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MRDR_RXEMPTY field. */
#define LPI2C_RD_MRDR_RXEMPTY(base) ((LPI2C_MRDR_REG(base) & LPI2C_MRDR_RXEMPTY_MASK) >> LPI2C_MRDR_RXEMPTY_SHIFT)
#define LPI2C_BRD_MRDR_RXEMPTY(base) (BITBAND_ACCESS32(&LPI2C_MRDR_REG(base), LPI2C_MRDR_RXEMPTY_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_SCR - Slave Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SCR - Slave Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SCR register
 */
/*@{*/
#define LPI2C_RD_SCR(base)       (LPI2C_SCR_REG(base))
#define LPI2C_WR_SCR(base, value) (LPI2C_SCR_REG(base) = (value))
#define LPI2C_RMW_SCR(base, mask, value) (LPI2C_WR_SCR(base, (LPI2C_RD_SCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCR(base, value) (LPI2C_WR_SCR(base, LPI2C_RD_SCR(base) |  (value)))
#define LPI2C_CLR_SCR(base, value) (LPI2C_WR_SCR(base, LPI2C_RD_SCR(base) & ~(value)))
#define LPI2C_TOG_SCR(base, value) (LPI2C_WR_SCR(base, LPI2C_RD_SCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCR bitfields
 */

/*!
 * @name Register LPI2C_SCR, field SEN[0] (RW)
 *
 * Values:
 * - 0b0 - Slave mode is disabled.
 * - 0b1 - Slave mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_SEN field. */
#define LPI2C_RD_SCR_SEN(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_SEN_MASK) >> LPI2C_SCR_SEN_SHIFT)
#define LPI2C_BRD_SCR_SEN(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_SEN_SHIFT))

/*! @brief Set the SEN field to a new value. */
#define LPI2C_WR_SCR_SEN(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_SEN_MASK, LPI2C_SCR_SEN(value)))
#define LPI2C_BWR_SCR_SEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_SEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RST[1] (RW)
 *
 * Values:
 * - 0b0 - Slave logic is not reset.
 * - 0b1 - Slave logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_RST field. */
#define LPI2C_RD_SCR_RST(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_RST_MASK) >> LPI2C_SCR_RST_SHIFT)
#define LPI2C_BRD_SCR_RST(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RST_SHIFT))

/*! @brief Set the RST field to a new value. */
#define LPI2C_WR_SCR_RST(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RST_MASK, LPI2C_SCR_RST(value)))
#define LPI2C_BWR_SCR_RST(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field FILTEN[4] (RW)
 *
 * Values:
 * - 0b0 - Disable digital filter and output delay counter for slave mode.
 * - 0b1 - Enable digital filter and output delay counter for slave mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_FILTEN field. */
#define LPI2C_RD_SCR_FILTEN(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_FILTEN_MASK) >> LPI2C_SCR_FILTEN_SHIFT)
#define LPI2C_BRD_SCR_FILTEN(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTEN_SHIFT))

/*! @brief Set the FILTEN field to a new value. */
#define LPI2C_WR_SCR_FILTEN(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_FILTEN_MASK, LPI2C_SCR_FILTEN(value)))
#define LPI2C_BWR_SCR_FILTEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field FILTDZ[5] (RW)
 *
 * Values:
 * - 0b0 - Filter remains enabled in Doze mode.
 * - 0b1 - Filter is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_FILTDZ field. */
#define LPI2C_RD_SCR_FILTDZ(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_FILTDZ_MASK) >> LPI2C_SCR_FILTDZ_SHIFT)
#define LPI2C_BRD_SCR_FILTDZ(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTDZ_SHIFT))

/*! @brief Set the FILTDZ field to a new value. */
#define LPI2C_WR_SCR_FILTDZ(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_FILTDZ_MASK, LPI2C_SCR_FILTDZ(value)))
#define LPI2C_BWR_SCR_FILTDZ(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTDZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RTF[8] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Transmit Data Register is now empty.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPI2C_WR_SCR_RTF(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RTF_MASK, LPI2C_SCR_RTF(value)))
#define LPI2C_BWR_SCR_RTF(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RRF[9] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Receive Data Register is now empty.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPI2C_WR_SCR_RRF(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RRF_MASK, LPI2C_SCR_RRF(value)))
#define LPI2C_BWR_SCR_RRF(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RRF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_SSR - Slave Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SSR - Slave Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SSR register
 */
/*@{*/
#define LPI2C_RD_SSR(base)       (LPI2C_SSR_REG(base))
#define LPI2C_WR_SSR(base, value) (LPI2C_SSR_REG(base) = (value))
#define LPI2C_RMW_SSR(base, mask, value) (LPI2C_WR_SSR(base, (LPI2C_RD_SSR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SSR(base, value) (LPI2C_WR_SSR(base, LPI2C_RD_SSR(base) |  (value)))
#define LPI2C_CLR_SSR(base, value) (LPI2C_WR_SSR(base, LPI2C_RD_SSR(base) & ~(value)))
#define LPI2C_TOG_SSR(base, value) (LPI2C_WR_SSR(base, LPI2C_RD_SSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SSR bitfields
 */

/*!
 * @name Register LPI2C_SSR, field TDF[0] (RO)
 *
 * This flag is cleared by writing the transmit data register. When TXCFG is
 * clear, it is also cleared if a NACK or Repeated START or STOP condition is
 * detected.
 *
 * Values:
 * - 0b0 - Transmit data not requested.
 * - 0b1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_TDF field. */
#define LPI2C_RD_SSR_TDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_TDF_MASK) >> LPI2C_SSR_TDF_SHIFT)
#define LPI2C_BRD_SSR_TDF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_TDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field RDF[1] (RO)
 *
 * This flag is cleared by reading the receive data register. When RXCFG is set,
 * this flag is not cleared when reading the receive data register and AVF is
 * set.
 *
 * Values:
 * - 0b0 - Receive Data is not ready.
 * - 0b1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_RDF field. */
#define LPI2C_RD_SSR_RDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_RDF_MASK) >> LPI2C_SSR_RDF_SHIFT)
#define LPI2C_BRD_SSR_RDF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_RDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AVF[2] (RO)
 *
 * This flag is cleared by reading the address status register. When RXCFG is
 * set, this flag is also cleared by reading the receive data register.
 *
 * Values:
 * - 0b0 - Address Status Register is not valid.
 * - 0b1 - Address Status Register is valid.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AVF field. */
#define LPI2C_RD_SSR_AVF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AVF_MASK) >> LPI2C_SSR_AVF_SHIFT)
#define LPI2C_BRD_SSR_AVF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_AVF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field TAF[3] (RO)
 *
 * This flag is cleared by writing the transmit ACK register.
 *
 * Values:
 * - 0b0 - Transmit ACK/NACK is not required.
 * - 0b1 - Transmit ACK/NACK is required.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_TAF field. */
#define LPI2C_RD_SSR_TAF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_TAF_MASK) >> LPI2C_SSR_TAF_SHIFT)
#define LPI2C_BRD_SSR_TAF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_TAF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field RSF[8] (W1C)
 *
 * This flag will set when the LPI2C slave detects a repeated START condition,
 * provided the LPI2C slave matched the last address byte. It does not set when
 * the slave first detects a START condition.
 *
 * Values:
 * - 0b0 - Slave has not detected a Repeated START condition.
 * - 0b1 - Slave has detected a Repeated START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_RSF field. */
#define LPI2C_RD_SSR_RSF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_RSF_MASK) >> LPI2C_SSR_RSF_SHIFT)
#define LPI2C_BRD_SSR_RSF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_RSF_SHIFT))

/*! @brief Set the RSF field to a new value. */
#define LPI2C_WR_SSR_RSF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_BEF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_RSF(value)))
#define LPI2C_BWR_SSR_RSF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_RSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SDF[9] (W1C)
 *
 * This flag will set when the LPI2C slave detects a STOP condition, provided
 * the LPI2C slave matched the last address byte.
 *
 * Values:
 * - 0b0 - Slave has not detected a STOP condition.
 * - 0b1 - Slave has detected a STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SDF field. */
#define LPI2C_RD_SSR_SDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SDF_MASK) >> LPI2C_SSR_SDF_SHIFT)
#define LPI2C_BRD_SSR_SDF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SDF_SHIFT))

/*! @brief Set the SDF field to a new value. */
#define LPI2C_WR_SSR_SDF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_SDF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_BEF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_SDF(value)))
#define LPI2C_BWR_SSR_SDF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field BEF[10] (W1C)
 *
 * This flag will set if the LPI2C slave transmits a logic one and detects a
 * logic zero on the I2C bus. The slave will ignore the rest of the transfer until
 * the next (repeated) START condition.
 *
 * Values:
 * - 0b0 - Slave has not detected a bit error.
 * - 0b1 - Slave has detected a bit error.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_BEF field. */
#define LPI2C_RD_SSR_BEF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_BEF_MASK) >> LPI2C_SSR_BEF_SHIFT)
#define LPI2C_BRD_SSR_BEF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_BEF_SHIFT))

/*! @brief Set the BEF field to a new value. */
#define LPI2C_WR_SSR_BEF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_BEF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_BEF(value)))
#define LPI2C_BWR_SSR_BEF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_BEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field FEF[11] (W1C)
 *
 * FIFO error flag can only set when clock stretching is disabled.
 *
 * Values:
 * - 0b0 - FIFO underflow or overflow not detected.
 * - 0b1 - FIFO underflow or overflow detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_FEF field. */
#define LPI2C_RD_SSR_FEF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_FEF_MASK) >> LPI2C_SSR_FEF_SHIFT)
#define LPI2C_BRD_SSR_FEF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define LPI2C_WR_SSR_FEF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_FEF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_BEF_MASK), LPI2C_SSR_FEF(value)))
#define LPI2C_BWR_SSR_FEF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AM0F[12] (RO)
 *
 * Indicates that the received address has matched the ADDR0 field as configured
 * by ADDRCFG. This flag is cleared by reading the Address Status Register. This
 * flag cannot generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - Have not received ADDR0 matching address.
 * - 0b1 - Have received ADDR0 matching address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AM0F field. */
#define LPI2C_RD_SSR_AM0F(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AM0F_MASK) >> LPI2C_SSR_AM0F_SHIFT)
#define LPI2C_BRD_SSR_AM0F(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_AM0F_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AM1F[13] (RO)
 *
 * Indicates that the received address has matched the ADDR1 field or ADDR0 to
 * ADDR1 range as configured by ADDRCFG. This flag is cleared by reading the
 * Address Status Register. This flag cannot generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - Have not received ADDR1 or ADDR0/ADDR1 range matching address.
 * - 0b1 - Have received ADDR1 or ADDR0/ADDR1 range matching address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AM1F field. */
#define LPI2C_RD_SSR_AM1F(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AM1F_MASK) >> LPI2C_SSR_AM1F_SHIFT)
#define LPI2C_BRD_SSR_AM1F(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_AM1F_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field GCF[14] (RO)
 *
 * This flag is cleared by reading the Address Status Register. This flag cannot
 * generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - Slave has not detected the General Call Address or General Call
 *     Address disabled.
 * - 0b1 - Slave has detected the General Call Address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_GCF field. */
#define LPI2C_RD_SSR_GCF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_GCF_MASK) >> LPI2C_SSR_GCF_SHIFT)
#define LPI2C_BRD_SSR_GCF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_GCF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SARF[15] (RO)
 *
 * This flag is cleared by reading the Address Status Register. This flag cannot
 * generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - SMBus Alert Response disabled or not detected.
 * - 0b1 - SMBus Alert Response enabled and detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SARF field. */
#define LPI2C_RD_SSR_SARF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SARF_MASK) >> LPI2C_SSR_SARF_SHIFT)
#define LPI2C_BRD_SSR_SARF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SARF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SBF[24] (RO)
 *
 * Values:
 * - 0b0 - I2C Slave is idle.
 * - 0b1 - I2C Slave is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SBF field. */
#define LPI2C_RD_SSR_SBF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SBF_MASK) >> LPI2C_SSR_SBF_SHIFT)
#define LPI2C_BRD_SSR_SBF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SBF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field BBF[25] (RO)
 *
 * Values:
 * - 0b0 - I2C Bus is idle.
 * - 0b1 - I2C Bus is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_BBF field. */
#define LPI2C_RD_SSR_BBF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_BBF_MASK) >> LPI2C_SSR_BBF_SHIFT)
#define LPI2C_BRD_SSR_BBF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_BBF_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_SIER - Slave Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SIER - Slave Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SIER register
 */
/*@{*/
#define LPI2C_RD_SIER(base)      (LPI2C_SIER_REG(base))
#define LPI2C_WR_SIER(base, value) (LPI2C_SIER_REG(base) = (value))
#define LPI2C_RMW_SIER(base, mask, value) (LPI2C_WR_SIER(base, (LPI2C_RD_SIER(base) & ~(mask)) | (value)))
#define LPI2C_SET_SIER(base, value) (LPI2C_WR_SIER(base, LPI2C_RD_SIER(base) |  (value)))
#define LPI2C_CLR_SIER(base, value) (LPI2C_WR_SIER(base, LPI2C_RD_SIER(base) & ~(value)))
#define LPI2C_TOG_SIER(base, value) (LPI2C_WR_SIER(base, LPI2C_RD_SIER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SIER bitfields
 */

/*!
 * @name Register LPI2C_SIER, field TDIE[0] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_TDIE field. */
#define LPI2C_RD_SIER_TDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_TDIE_MASK) >> LPI2C_SIER_TDIE_SHIFT)
#define LPI2C_BRD_SIER_TDIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TDIE_SHIFT))

/*! @brief Set the TDIE field to a new value. */
#define LPI2C_WR_SIER_TDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_TDIE_MASK, LPI2C_SIER_TDIE(value)))
#define LPI2C_BWR_SIER_TDIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field RDIE[1] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_RDIE field. */
#define LPI2C_RD_SIER_RDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_RDIE_MASK) >> LPI2C_SIER_RDIE_SHIFT)
#define LPI2C_BRD_SIER_RDIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RDIE_SHIFT))

/*! @brief Set the RDIE field to a new value. */
#define LPI2C_WR_SIER_RDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_RDIE_MASK, LPI2C_SIER_RDIE(value)))
#define LPI2C_BWR_SIER_RDIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AVIE[2] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AVIE field. */
#define LPI2C_RD_SIER_AVIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AVIE_MASK) >> LPI2C_SIER_AVIE_SHIFT)
#define LPI2C_BRD_SIER_AVIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AVIE_SHIFT))

/*! @brief Set the AVIE field to a new value. */
#define LPI2C_WR_SIER_AVIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AVIE_MASK, LPI2C_SIER_AVIE(value)))
#define LPI2C_BWR_SIER_AVIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AVIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field TAIE[3] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_TAIE field. */
#define LPI2C_RD_SIER_TAIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_TAIE_MASK) >> LPI2C_SIER_TAIE_SHIFT)
#define LPI2C_BRD_SIER_TAIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TAIE_SHIFT))

/*! @brief Set the TAIE field to a new value. */
#define LPI2C_WR_SIER_TAIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_TAIE_MASK, LPI2C_SIER_TAIE(value)))
#define LPI2C_BWR_SIER_TAIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TAIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field RSIE[8] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_RSIE field. */
#define LPI2C_RD_SIER_RSIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_RSIE_MASK) >> LPI2C_SIER_RSIE_SHIFT)
#define LPI2C_BRD_SIER_RSIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RSIE_SHIFT))

/*! @brief Set the RSIE field to a new value. */
#define LPI2C_WR_SIER_RSIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_RSIE_MASK, LPI2C_SIER_RSIE(value)))
#define LPI2C_BWR_SIER_RSIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field SDIE[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_SDIE field. */
#define LPI2C_RD_SIER_SDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_SDIE_MASK) >> LPI2C_SIER_SDIE_SHIFT)
#define LPI2C_BRD_SIER_SDIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SDIE_SHIFT))

/*! @brief Set the SDIE field to a new value. */
#define LPI2C_WR_SIER_SDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_SDIE_MASK, LPI2C_SIER_SDIE(value)))
#define LPI2C_BWR_SIER_SDIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field BEIE[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_BEIE field. */
#define LPI2C_RD_SIER_BEIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_BEIE_MASK) >> LPI2C_SIER_BEIE_SHIFT)
#define LPI2C_BRD_SIER_BEIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_BEIE_SHIFT))

/*! @brief Set the BEIE field to a new value. */
#define LPI2C_WR_SIER_BEIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_BEIE_MASK, LPI2C_SIER_BEIE(value)))
#define LPI2C_BWR_SIER_BEIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_BEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field FEIE[11] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_FEIE field. */
#define LPI2C_RD_SIER_FEIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_FEIE_MASK) >> LPI2C_SIER_FEIE_SHIFT)
#define LPI2C_BRD_SIER_FEIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define LPI2C_WR_SIER_FEIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_FEIE_MASK, LPI2C_SIER_FEIE(value)))
#define LPI2C_BWR_SIER_FEIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AM0IE[12] (RW)
 *
 * Values:
 * - 0b0 - Interrupt enabled.
 * - 0b1 - Interrupt disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AM0IE field. */
#define LPI2C_RD_SIER_AM0IE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AM0IE_MASK) >> LPI2C_SIER_AM0IE_SHIFT)
#define LPI2C_BRD_SIER_AM0IE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM0IE_SHIFT))

/*! @brief Set the AM0IE field to a new value. */
#define LPI2C_WR_SIER_AM0IE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AM0IE_MASK, LPI2C_SIER_AM0IE(value)))
#define LPI2C_BWR_SIER_AM0IE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM0IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AM1F[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AM1F field. */
#define LPI2C_RD_SIER_AM1F(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AM1F_MASK) >> LPI2C_SIER_AM1F_SHIFT)
#define LPI2C_BRD_SIER_AM1F(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM1F_SHIFT))

/*! @brief Set the AM1F field to a new value. */
#define LPI2C_WR_SIER_AM1F(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AM1F_MASK, LPI2C_SIER_AM1F(value)))
#define LPI2C_BWR_SIER_AM1F(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field GCIE[14] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_GCIE field. */
#define LPI2C_RD_SIER_GCIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_GCIE_MASK) >> LPI2C_SIER_GCIE_SHIFT)
#define LPI2C_BRD_SIER_GCIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_GCIE_SHIFT))

/*! @brief Set the GCIE field to a new value. */
#define LPI2C_WR_SIER_GCIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_GCIE_MASK, LPI2C_SIER_GCIE(value)))
#define LPI2C_BWR_SIER_GCIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_GCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field SARIE[15] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_SARIE field. */
#define LPI2C_RD_SIER_SARIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_SARIE_MASK) >> LPI2C_SIER_SARIE_SHIFT)
#define LPI2C_BRD_SIER_SARIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SARIE_SHIFT))

/*! @brief Set the SARIE field to a new value. */
#define LPI2C_WR_SIER_SARIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_SARIE_MASK, LPI2C_SIER_SARIE(value)))
#define LPI2C_BWR_SIER_SARIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SARIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_SDER - Slave DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SDER - Slave DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SDER register
 */
/*@{*/
#define LPI2C_RD_SDER(base)      (LPI2C_SDER_REG(base))
#define LPI2C_WR_SDER(base, value) (LPI2C_SDER_REG(base) = (value))
#define LPI2C_RMW_SDER(base, mask, value) (LPI2C_WR_SDER(base, (LPI2C_RD_SDER(base) & ~(mask)) | (value)))
#define LPI2C_SET_SDER(base, value) (LPI2C_WR_SDER(base, LPI2C_RD_SDER(base) |  (value)))
#define LPI2C_CLR_SDER(base, value) (LPI2C_WR_SDER(base, LPI2C_RD_SDER(base) & ~(value)))
#define LPI2C_TOG_SDER(base, value) (LPI2C_WR_SDER(base, LPI2C_RD_SDER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SDER bitfields
 */

/*!
 * @name Register LPI2C_SDER, field TDDE[0] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_TDDE field. */
#define LPI2C_RD_SDER_TDDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_TDDE_MASK) >> LPI2C_SDER_TDDE_SHIFT)
#define LPI2C_BRD_SDER_TDDE(base) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_TDDE_SHIFT))

/*! @brief Set the TDDE field to a new value. */
#define LPI2C_WR_SDER_TDDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_TDDE_MASK, LPI2C_SDER_TDDE(value)))
#define LPI2C_BWR_SDER_TDDE(base, value) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_TDDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SDER, field RDDE[1] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_RDDE field. */
#define LPI2C_RD_SDER_RDDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_RDDE_MASK) >> LPI2C_SDER_RDDE_SHIFT)
#define LPI2C_BRD_SDER_RDDE(base) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_RDDE_SHIFT))

/*! @brief Set the RDDE field to a new value. */
#define LPI2C_WR_SDER_RDDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_RDDE_MASK, LPI2C_SDER_RDDE(value)))
#define LPI2C_BWR_SDER_RDDE(base, value) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_RDDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SDER, field AVDE[2] (RW)
 *
 * The Address Valid DMA request is shared with the Receive Data DMA request. If
 * both are enabled, then set RXCFG to allow the DMA to read the address from
 * the Receive Data Register.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_AVDE field. */
#define LPI2C_RD_SDER_AVDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_AVDE_MASK) >> LPI2C_SDER_AVDE_SHIFT)
#define LPI2C_BRD_SDER_AVDE(base) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_AVDE_SHIFT))

/*! @brief Set the AVDE field to a new value. */
#define LPI2C_WR_SDER_AVDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_AVDE_MASK, LPI2C_SDER_AVDE(value)))
#define LPI2C_BWR_SDER_AVDE(base, value) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_AVDE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_SCFGR1 - Slave Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_SCFGR1 - Slave Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SCFGR1 should only be written when the I2C Slave is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_SCFGR1 register
 */
/*@{*/
#define LPI2C_RD_SCFGR1(base)    (LPI2C_SCFGR1_REG(base))
#define LPI2C_WR_SCFGR1(base, value) (LPI2C_SCFGR1_REG(base) = (value))
#define LPI2C_RMW_SCFGR1(base, mask, value) (LPI2C_WR_SCFGR1(base, (LPI2C_RD_SCFGR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCFGR1(base, value) (LPI2C_WR_SCFGR1(base, LPI2C_RD_SCFGR1(base) |  (value)))
#define LPI2C_CLR_SCFGR1(base, value) (LPI2C_WR_SCFGR1(base, LPI2C_RD_SCFGR1(base) & ~(value)))
#define LPI2C_TOG_SCFGR1(base, value) (LPI2C_WR_SCFGR1(base, LPI2C_RD_SCFGR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCFGR1 bitfields
 */

/*!
 * @name Register LPI2C_SCFGR1, field ADRSTALL[0] (RW)
 *
 * Enables SCL clock stretching when the address valid flag is asserted. Clock
 * stretching only occurs following the 9th bit and is therefore compatible with
 * high speed mode.
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ADRSTALL field. */
#define LPI2C_RD_SCFGR1_ADRSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ADRSTALL_MASK) >> LPI2C_SCFGR1_ADRSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_ADRSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ADRSTALL_SHIFT))

/*! @brief Set the ADRSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_ADRSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ADRSTALL_MASK, LPI2C_SCFGR1_ADRSTALL(value)))
#define LPI2C_BWR_SCFGR1_ADRSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ADRSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field RXSTALL[1] (RW)
 *
 * Enables SCL clock stretching when receive data flag is set during a
 * slave-receive transfer. Clock stretching occurs following the 9th bit and is therefore
 * compatible with high speed mode.
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_RXSTALL field. */
#define LPI2C_RD_SCFGR1_RXSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_RXSTALL_MASK) >> LPI2C_SCFGR1_RXSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_RXSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXSTALL_SHIFT))

/*! @brief Set the RXSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_RXSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_RXSTALL_MASK, LPI2C_SCFGR1_RXSTALL(value)))
#define LPI2C_BWR_SCFGR1_RXSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field TXDSTALL[2] (RW)
 *
 * Enables SCL clock stretching when the transmit data flag is set during a
 * slave-transmit transfer. Clock stretching occurs following the 9th bit and is
 * therefore compatible with high speed mode.
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_TXDSTALL field. */
#define LPI2C_RD_SCFGR1_TXDSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_TXDSTALL_MASK) >> LPI2C_SCFGR1_TXDSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_TXDSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXDSTALL_SHIFT))

/*! @brief Set the TXDSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_TXDSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_TXDSTALL_MASK, LPI2C_SCFGR1_TXDSTALL(value)))
#define LPI2C_BWR_SCFGR1_TXDSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXDSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field ACKSTALL[3] (RW)
 *
 * Enables SCL clock stretching during slave-transmit address byte(s) and
 * slave-receiver address and data byte(s) to allow software to write the Transmit ACK
 * Register before the ACK or NACK is transmitted. Clock stretching occurs when
 * transmitting the 9th bit and is therefore not compatible with high speed mode.
 * When ACKSTALL is enabled, there is no need to set either RXSTALL or ADRSTALL
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ACKSTALL field. */
#define LPI2C_RD_SCFGR1_ACKSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ACKSTALL_MASK) >> LPI2C_SCFGR1_ACKSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_ACKSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ACKSTALL_SHIFT))

/*! @brief Set the ACKSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_ACKSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ACKSTALL_MASK, LPI2C_SCFGR1_ACKSTALL(value)))
#define LPI2C_BWR_SCFGR1_ACKSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ACKSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field GCEN[8] (RW)
 *
 * Values:
 * - 0b0 - General Call address is disabled.
 * - 0b1 - General call address is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_GCEN field. */
#define LPI2C_RD_SCFGR1_GCEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_GCEN_MASK) >> LPI2C_SCFGR1_GCEN_SHIFT)
#define LPI2C_BRD_SCFGR1_GCEN(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_GCEN_SHIFT))

/*! @brief Set the GCEN field to a new value. */
#define LPI2C_WR_SCFGR1_GCEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_GCEN_MASK, LPI2C_SCFGR1_GCEN(value)))
#define LPI2C_BWR_SCFGR1_GCEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_GCEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field SAEN[9] (RW)
 *
 * Values:
 * - 0b0 - Disables match on SMBus Alert.
 * - 0b1 - Enables match on SMBus Alert.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_SAEN field. */
#define LPI2C_RD_SCFGR1_SAEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_SAEN_MASK) >> LPI2C_SCFGR1_SAEN_SHIFT)
#define LPI2C_BRD_SCFGR1_SAEN(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_SAEN_SHIFT))

/*! @brief Set the SAEN field to a new value. */
#define LPI2C_WR_SCFGR1_SAEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_SAEN_MASK, LPI2C_SCFGR1_SAEN(value)))
#define LPI2C_BWR_SCFGR1_SAEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_SAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field TXCFG[10] (RW)
 *
 * The transmit data flag will always assert before a NACK is detected at the
 * end of a slave-transmit transfer. This can cause an extra word to be written to
 * the transmit data FIFO. When TXCFG=0, the transmit data register is
 * automatically emptied when a slave-transmit transfer is detected. This cause the
 * transmit data flag to assert whenever a slave-transmit transfer is detected and
 * negate at the end of the slave-transmit transfer. When TXCFG=1, the transmit data
 * flag will assert whenver the transit data register is empty and negate when the
 * transmit data register is full. This allows the transmit data register to be
 * filled before a slave-transmit transfer is detected, but can cause the
 * transmit data register to be written before a NACK is detected on the last byte of a
 * slave transmit transfer.
 *
 * Values:
 * - 0b0 - Transmit Data Flag will only assert during a slave-transmit transfer
 *     when the transmit data register is empty.
 * - 0b1 - Transmit Data Flag will assert whenever the transmit data register is
 *     empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_TXCFG field. */
#define LPI2C_RD_SCFGR1_TXCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_TXCFG_MASK) >> LPI2C_SCFGR1_TXCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_TXCFG(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXCFG_SHIFT))

/*! @brief Set the TXCFG field to a new value. */
#define LPI2C_WR_SCFGR1_TXCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_TXCFG_MASK, LPI2C_SCFGR1_TXCFG(value)))
#define LPI2C_BWR_SCFGR1_TXCFG(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXCFG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field RXCFG[11] (RW)
 *
 * Values:
 * - 0b0 - Reading the receive data register will return receive data and clear
 *     the receive data flag.
 * - 0b1 - Reading the receive data register when the address valid flag is set
 *     will return the address status register and clear the address valid flag.
 *     Reading the receive data register when the address valid flag is clear
 *     will return receive data and clear the receive data flag.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_RXCFG field. */
#define LPI2C_RD_SCFGR1_RXCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_RXCFG_MASK) >> LPI2C_SCFGR1_RXCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_RXCFG(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXCFG_SHIFT))

/*! @brief Set the RXCFG field to a new value. */
#define LPI2C_WR_SCFGR1_RXCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_RXCFG_MASK, LPI2C_SCFGR1_RXCFG(value)))
#define LPI2C_BWR_SCFGR1_RXCFG(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXCFG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field IGNACK[12] (RW)
 *
 * When set, the LPI2C slave will continue transfers after a NACK is detected.
 * This bit is required to be set in Ultra-Fast Mode.
 *
 * Values:
 * - 0b0 - Slave will end transfer when NACK detected.
 * - 0b1 - Slave will not end transfer when NACK detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_IGNACK field. */
#define LPI2C_RD_SCFGR1_IGNACK(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_IGNACK_MASK) >> LPI2C_SCFGR1_IGNACK_SHIFT)
#define LPI2C_BRD_SCFGR1_IGNACK(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_IGNACK_SHIFT))

/*! @brief Set the IGNACK field to a new value. */
#define LPI2C_WR_SCFGR1_IGNACK(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_IGNACK_MASK, LPI2C_SCFGR1_IGNACK(value)))
#define LPI2C_BWR_SCFGR1_IGNACK(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_IGNACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field HSMEN[13] (RW)
 *
 * Enables detection of the High-speed Mode master code of slave address
 * 0000_1XX, but does not cause an address match on this code. When set and any Hs-mode
 * master code is detected, the FILTEN and ACKSTALL bits are ignored until the
 * next STOP condition is detected.
 *
 * Values:
 * - 0b0 - Disables detection of Hs-mode master code.
 * - 0b1 - Enables detection of Hs-mode master code.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_HSMEN field. */
#define LPI2C_RD_SCFGR1_HSMEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_HSMEN_MASK) >> LPI2C_SCFGR1_HSMEN_SHIFT)
#define LPI2C_BRD_SCFGR1_HSMEN(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_HSMEN_SHIFT))

/*! @brief Set the HSMEN field to a new value. */
#define LPI2C_WR_SCFGR1_HSMEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_HSMEN_MASK, LPI2C_SCFGR1_HSMEN(value)))
#define LPI2C_BWR_SCFGR1_HSMEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_HSMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field ADDRCFG[18:16] (RW)
 *
 * Configures the condition that will cause an address to match.
 *
 * Values:
 * - 0b000 - Address match 0 (7-bit).
 * - 0b001 - Address match 0 (10-bit).
 * - 0b010 - Address match 0 (7-bit) or Address match 1 (7-bit).
 * - 0b011 - Address match 0 (10-bit) or Address match 1 (10-bit).
 * - 0b100 - Address match 0 (7-bit) or Address match 1 (10-bit).
 * - 0b101 - Address match 0 (10-bit) or Address match 1 (7-bit).
 * - 0b110 - From Address match 0 (7-bit) to Address match 1 (7-bit).
 * - 0b111 - From Address match 0 (10-bit) to Address match 1 (10-bit).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ADDRCFG field. */
#define LPI2C_RD_SCFGR1_ADDRCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ADDRCFG_MASK) >> LPI2C_SCFGR1_ADDRCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_ADDRCFG(base) (LPI2C_RD_SCFGR1_ADDRCFG(base))

/*! @brief Set the ADDRCFG field to a new value. */
#define LPI2C_WR_SCFGR1_ADDRCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ADDRCFG_MASK, LPI2C_SCFGR1_ADDRCFG(value)))
#define LPI2C_BWR_SCFGR1_ADDRCFG(base, value) (LPI2C_WR_SCFGR1_ADDRCFG(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SCFGR2 - Slave Configuration Register 2
 ******************************************************************************/

/*!
 * @brief LPI2C_SCFGR2 - Slave Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SCFGR2 should only be written when the I2C Slave is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_SCFGR2 register
 */
/*@{*/
#define LPI2C_RD_SCFGR2(base)    (LPI2C_SCFGR2_REG(base))
#define LPI2C_WR_SCFGR2(base, value) (LPI2C_SCFGR2_REG(base) = (value))
#define LPI2C_RMW_SCFGR2(base, mask, value) (LPI2C_WR_SCFGR2(base, (LPI2C_RD_SCFGR2(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCFGR2(base, value) (LPI2C_WR_SCFGR2(base, LPI2C_RD_SCFGR2(base) |  (value)))
#define LPI2C_CLR_SCFGR2(base, value) (LPI2C_WR_SCFGR2(base, LPI2C_RD_SCFGR2(base) & ~(value)))
#define LPI2C_TOG_SCFGR2(base, value) (LPI2C_WR_SCFGR2(base, LPI2C_RD_SCFGR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCFGR2 bitfields
 */

/*!
 * @name Register LPI2C_SCFGR2, field CLKHOLD[3:0] (RW)
 *
 * Configures the minimum clock hold time for the I2C slave, when clock
 * stretching is enabled. The minimum hold time is equal to CLKHOLD+3 cycles. The I2C
 * slave clock hold time is not affected by the PRESCALE configuration, and is
 * disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_CLKHOLD field. */
#define LPI2C_RD_SCFGR2_CLKHOLD(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_CLKHOLD_MASK) >> LPI2C_SCFGR2_CLKHOLD_SHIFT)
#define LPI2C_BRD_SCFGR2_CLKHOLD(base) (LPI2C_RD_SCFGR2_CLKHOLD(base))

/*! @brief Set the CLKHOLD field to a new value. */
#define LPI2C_WR_SCFGR2_CLKHOLD(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_CLKHOLD_MASK, LPI2C_SCFGR2_CLKHOLD(value)))
#define LPI2C_BWR_SCFGR2_CLKHOLD(base, value) (LPI2C_WR_SCFGR2_CLKHOLD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field DATAVD[13:8] (RW)
 *
 * Configures the SDA data valid delay time for the I2C slave equal to
 * FILTSCL+DATAVD+3 cycles. This data valid delay must be configured to less than the
 * minimum SCL low period. The I2C slave data valid delay time is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_DATAVD field. */
#define LPI2C_RD_SCFGR2_DATAVD(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_DATAVD_MASK) >> LPI2C_SCFGR2_DATAVD_SHIFT)
#define LPI2C_BRD_SCFGR2_DATAVD(base) (LPI2C_RD_SCFGR2_DATAVD(base))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_SCFGR2_DATAVD(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_DATAVD_MASK, LPI2C_SCFGR2_DATAVD(value)))
#define LPI2C_BWR_SCFGR2_DATAVD(base, value) (LPI2C_WR_SCFGR2_DATAVD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field FILTSCL[19:16] (RW)
 *
 * Configures the I2C slave digital glitch filters for SCL input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSCL
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSCL+3 cycles and must be configured less than the
 * minimum SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_FILTSCL field. */
#define LPI2C_RD_SCFGR2_FILTSCL(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_FILTSCL_MASK) >> LPI2C_SCFGR2_FILTSCL_SHIFT)
#define LPI2C_BRD_SCFGR2_FILTSCL(base) (LPI2C_RD_SCFGR2_FILTSCL(base))

/*! @brief Set the FILTSCL field to a new value. */
#define LPI2C_WR_SCFGR2_FILTSCL(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_FILTSCL_MASK, LPI2C_SCFGR2_FILTSCL(value)))
#define LPI2C_BWR_SCFGR2_FILTSCL(base, value) (LPI2C_WR_SCFGR2_FILTSCL(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field FILTSDA[27:24] (RW)
 *
 * Configures the I2C slave digital glitch filters for SDA input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSDA
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSDA+3 cycles and must be configured less than the
 * minimum SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_FILTSDA field. */
#define LPI2C_RD_SCFGR2_FILTSDA(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_FILTSDA_MASK) >> LPI2C_SCFGR2_FILTSDA_SHIFT)
#define LPI2C_BRD_SCFGR2_FILTSDA(base) (LPI2C_RD_SCFGR2_FILTSDA(base))

/*! @brief Set the FILTSDA field to a new value. */
#define LPI2C_WR_SCFGR2_FILTSDA(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_FILTSDA_MASK, LPI2C_SCFGR2_FILTSDA(value)))
#define LPI2C_BWR_SCFGR2_FILTSDA(base, value) (LPI2C_WR_SCFGR2_FILTSDA(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SAMR - Slave Address Match Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SAMR - Slave Address Match Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SAMR register
 */
/*@{*/
#define LPI2C_RD_SAMR(base)      (LPI2C_SAMR_REG(base))
#define LPI2C_WR_SAMR(base, value) (LPI2C_SAMR_REG(base) = (value))
#define LPI2C_RMW_SAMR(base, mask, value) (LPI2C_WR_SAMR(base, (LPI2C_RD_SAMR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SAMR(base, value) (LPI2C_WR_SAMR(base, LPI2C_RD_SAMR(base) |  (value)))
#define LPI2C_CLR_SAMR(base, value) (LPI2C_WR_SAMR(base, LPI2C_RD_SAMR(base) & ~(value)))
#define LPI2C_TOG_SAMR(base, value) (LPI2C_WR_SAMR(base, LPI2C_RD_SAMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SAMR bitfields
 */

/*!
 * @name Register LPI2C_SAMR, field ADDR0[10:1] (RW)
 *
 * Compared against the received address to detect the Slave Address. In 10-bit
 * mode, the first address byte is compared to { 11110, ADDR0[10:9] } and the
 * second address byte is compared to ADDR0[8:1]. In 7-bit mode, the address is
 * compared to ADDR0[7:1].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SAMR_ADDR0 field. */
#define LPI2C_RD_SAMR_ADDR0(base) ((LPI2C_SAMR_REG(base) & LPI2C_SAMR_ADDR0_MASK) >> LPI2C_SAMR_ADDR0_SHIFT)
#define LPI2C_BRD_SAMR_ADDR0(base) (LPI2C_RD_SAMR_ADDR0(base))

/*! @brief Set the ADDR0 field to a new value. */
#define LPI2C_WR_SAMR_ADDR0(base, value) (LPI2C_RMW_SAMR(base, LPI2C_SAMR_ADDR0_MASK, LPI2C_SAMR_ADDR0(value)))
#define LPI2C_BWR_SAMR_ADDR0(base, value) (LPI2C_WR_SAMR_ADDR0(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SAMR, field ADDR1[26:17] (RW)
 *
 * Compared against the received address to detect the Slave Address. In 10-bit
 * mode, the first address byte is compared to { 11110, ADDR1[10:9] } and the
 * second address byte is compared to ADDR1[8:1]. In 7-bit mode, the address is
 * compared to ADDR1[7:1].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SAMR_ADDR1 field. */
#define LPI2C_RD_SAMR_ADDR1(base) ((LPI2C_SAMR_REG(base) & LPI2C_SAMR_ADDR1_MASK) >> LPI2C_SAMR_ADDR1_SHIFT)
#define LPI2C_BRD_SAMR_ADDR1(base) (LPI2C_RD_SAMR_ADDR1(base))

/*! @brief Set the ADDR1 field to a new value. */
#define LPI2C_WR_SAMR_ADDR1(base, value) (LPI2C_RMW_SAMR(base, LPI2C_SAMR_ADDR1_MASK, LPI2C_SAMR_ADDR1(value)))
#define LPI2C_BWR_SAMR_ADDR1(base, value) (LPI2C_WR_SAMR_ADDR1(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SASR - Slave Address Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SASR - Slave Address Status Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SASR register
 */
/*@{*/
#define LPI2C_RD_SASR(base)      (LPI2C_SASR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SASR bitfields
 */

/*!
 * @name Register LPI2C_SASR, field RADDR[10:0] (RO)
 *
 * RADDR updates whenever the AMF is set and the AMF is cleared by reading this
 * register. In 7-bit mode, the address byte is store in RADDR[7:0]. In 10-bit
 * mode, the first address byte is { 11110, RADDR[10:9], RADDR[0] } and the second
 * address byte is RADDR[8:1]. The R/W bit is therefore always stored in RADDR[0].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SASR_RADDR field. */
#define LPI2C_RD_SASR_RADDR(base) ((LPI2C_SASR_REG(base) & LPI2C_SASR_RADDR_MASK) >> LPI2C_SASR_RADDR_SHIFT)
#define LPI2C_BRD_SASR_RADDR(base) (LPI2C_RD_SASR_RADDR(base))
/*@}*/

/*!
 * @name Register LPI2C_SASR, field ANV[14] (RO)
 *
 * Values:
 * - 0b0 - RADDR is valid.
 * - 0b1 - RADDR is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SASR_ANV field. */
#define LPI2C_RD_SASR_ANV(base) ((LPI2C_SASR_REG(base) & LPI2C_SASR_ANV_MASK) >> LPI2C_SASR_ANV_SHIFT)
#define LPI2C_BRD_SASR_ANV(base) (BITBAND_ACCESS32(&LPI2C_SASR_REG(base), LPI2C_SASR_ANV_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_STAR - Slave Transmit ACK Register
 ******************************************************************************/

/*!
 * @brief LPI2C_STAR - Slave Transmit ACK Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_STAR register
 */
/*@{*/
#define LPI2C_RD_STAR(base)      (LPI2C_STAR_REG(base))
#define LPI2C_WR_STAR(base, value) (LPI2C_STAR_REG(base) = (value))
#define LPI2C_RMW_STAR(base, mask, value) (LPI2C_WR_STAR(base, (LPI2C_RD_STAR(base) & ~(mask)) | (value)))
#define LPI2C_SET_STAR(base, value) (LPI2C_WR_STAR(base, LPI2C_RD_STAR(base) |  (value)))
#define LPI2C_CLR_STAR(base, value) (LPI2C_WR_STAR(base, LPI2C_RD_STAR(base) & ~(value)))
#define LPI2C_TOG_STAR(base, value) (LPI2C_WR_STAR(base, LPI2C_RD_STAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_STAR bitfields
 */

/*!
 * @name Register LPI2C_STAR, field TXNACK[0] (RW)
 *
 * When NACKSTALL is set, must be written once for each matching address byte
 * and each received word. Can also be written when LPI2C Slave is disabled or idle
 * to configure the default ACK/NACK.
 *
 * Values:
 * - 0b0 - Transmit ACK for received word.
 * - 0b1 - Transmit NACK for received word.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_STAR_TXNACK field. */
#define LPI2C_RD_STAR_TXNACK(base) ((LPI2C_STAR_REG(base) & LPI2C_STAR_TXNACK_MASK) >> LPI2C_STAR_TXNACK_SHIFT)
#define LPI2C_BRD_STAR_TXNACK(base) (BITBAND_ACCESS32(&LPI2C_STAR_REG(base), LPI2C_STAR_TXNACK_SHIFT))

/*! @brief Set the TXNACK field to a new value. */
#define LPI2C_WR_STAR_TXNACK(base, value) (LPI2C_RMW_STAR(base, LPI2C_STAR_TXNACK_MASK, LPI2C_STAR_TXNACK(value)))
#define LPI2C_BWR_STAR_TXNACK(base, value) (BITBAND_ACCESS32(&LPI2C_STAR_REG(base), LPI2C_STAR_TXNACK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_STDR - Slave Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_STDR - Slave Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_STDR register
 */
/*@{*/
#define LPI2C_RD_STDR(base)      (LPI2C_STDR_REG(base))
#define LPI2C_WR_STDR(base, value) (LPI2C_STDR_REG(base) = (value))
#define LPI2C_RMW_STDR(base, mask, value) (LPI2C_WR_STDR(base, (LPI2C_RD_STDR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_STDR bitfields
 */

/*!
 * @name Register LPI2C_STDR, field DATA[7:0] (WO)
 *
 * Writing this register will store I2C slave transmit data in the transmit
 * register.
 */
/*@{*/
/*! @brief Set the DATA field to a new value. */
#define LPI2C_WR_STDR_DATA(base, value) (LPI2C_RMW_STDR(base, LPI2C_STDR_DATA_MASK, LPI2C_STDR_DATA(value)))
#define LPI2C_BWR_STDR_DATA(base, value) (LPI2C_WR_STDR_DATA(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SRDR - Slave Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SRDR - Slave Receive Data Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SRDR register
 */
/*@{*/
#define LPI2C_RD_SRDR(base)      (LPI2C_SRDR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SRDR bitfields
 */

/*!
 * @name Register LPI2C_SRDR, field DATA[7:0] (RO)
 *
 * Reading this register returns the data received by the I2C slave.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_DATA field. */
#define LPI2C_RD_SRDR_DATA(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_DATA_MASK) >> LPI2C_SRDR_DATA_SHIFT)
#define LPI2C_BRD_SRDR_DATA(base) (LPI2C_RD_SRDR_DATA(base))
/*@}*/

/*!
 * @name Register LPI2C_SRDR, field RXEMPTY[14] (RO)
 *
 * Values:
 * - 0b0 - The Receive Data Register is not empty.
 * - 0b1 - The Receive Data Register is empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_RXEMPTY field. */
#define LPI2C_RD_SRDR_RXEMPTY(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_RXEMPTY_MASK) >> LPI2C_SRDR_RXEMPTY_SHIFT)
#define LPI2C_BRD_SRDR_RXEMPTY(base) (BITBAND_ACCESS32(&LPI2C_SRDR_REG(base), LPI2C_SRDR_RXEMPTY_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SRDR, field SOF[15] (RO)
 *
 * Values:
 * - 0b0 - Indicates this is not the first data word since a (repeated) START or
 *     STOP condition.
 * - 0b1 - Indicates this is the first data word since a (repeated) START or
 *     STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_SOF field. */
#define LPI2C_RD_SRDR_SOF(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_SOF_MASK) >> LPI2C_SRDR_SOF_SHIFT)
#define LPI2C_BRD_SRDR_SOF(base) (BITBAND_ACCESS32(&LPI2C_SRDR_REG(base), LPI2C_SRDR_SOF_SHIFT))
/*@}*/

/*
 * S32K144 LPIT
 *
 * Low Power Periodic Interrupt Timer (LPIT)
 *
 * Registers defined in this header file:
 * - LPIT_VERID - Version ID Register
 * - LPIT_PARAM - Parameter Register
 * - LPIT_MCR - Module Control Register
 * - LPIT_MSR - Module Status Register
 * - LPIT_MIER - Module Interrupt Enable Register
 * - LPIT_SETTEN - Set Timer Enable Register
 * - LPIT_CLRTEN - Clear Timer Enable Register
 * - LPIT_RSVD - Reserved Register
 * - LPIT_TVAL0 - Timer Value Register
 * - LPIT_CVAL0 - Current Timer Value
 * - LPIT_TCTRL0 - Timer Control Register
 * - LPIT_RFU0 - Reserved for Future Use
 * - LPIT_TVAL1 - Timer Value Register
 * - LPIT_CVAL1 - Current Timer Value
 * - LPIT_TCTRL1 - Timer Control Register
 * - LPIT_RFU1 - Reserved for Future Use
 * - LPIT_TVAL2 - Timer Value Register
 * - LPIT_CVAL2 - Current Timer Value
 * - LPIT_TCTRL2 - Timer Control Register
 * - LPIT_RFU2 - Reserved for Future Use
 * - LPIT_TVAL3 - Timer Value Register
 * - LPIT_CVAL3 - Current Timer Value
 * - LPIT_TCTRL3 - Timer Control Register
 * - LPIT_RFU3 - Reserved for Future Use
 */

#define LPIT_INSTANCE_COUNT (1U) /*!< Number of instances of the LPIT module. */
#define LPIT0_IDX (0U) /*!< Instance number for LPIT0. */

/*******************************************************************************
 * LPIT_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPIT_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire LPIT_VERID register
 */
/*@{*/
#define LPIT_RD_VERID(base)      (LPIT_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPIT_VERID bitfields
 */

/*!
 * @name Register LPIT_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 */
/*@{*/
/*! @brief Read current value of the LPIT_VERID_FEATURE field. */
#define LPIT_RD_VERID_FEATURE(base) ((LPIT_VERID_REG(base) & LPIT_VERID_FEATURE_MASK) >> LPIT_VERID_FEATURE_SHIFT)
#define LPIT_BRD_VERID_FEATURE(base) (LPIT_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPIT_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification
 */
/*@{*/
/*! @brief Read current value of the LPIT_VERID_MINOR field. */
#define LPIT_RD_VERID_MINOR(base) ((LPIT_VERID_REG(base) & LPIT_VERID_MINOR_MASK) >> LPIT_VERID_MINOR_SHIFT)
#define LPIT_BRD_VERID_MINOR(base) (LPIT_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register LPIT_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification
 */
/*@{*/
/*! @brief Read current value of the LPIT_VERID_MAJOR field. */
#define LPIT_RD_VERID_MAJOR(base) ((LPIT_VERID_REG(base) & LPIT_VERID_MAJOR_MASK) >> LPIT_VERID_MAJOR_SHIFT)
#define LPIT_BRD_VERID_MAJOR(base) (LPIT_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * LPIT_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPIT_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000404U
 *
 * This register provides details on the parameter settings that were used while
 * including this module in the device.
 */
/*!
 * @name Constants and macros for entire LPIT_PARAM register
 */
/*@{*/
#define LPIT_RD_PARAM(base)      (LPIT_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPIT_PARAM bitfields
 */

/*!
 * @name Register LPIT_PARAM, field CHANNEL[7:0] (RO)
 *
 * Number of timer channels implemented.
 */
/*@{*/
/*! @brief Read current value of the LPIT_PARAM_CHANNEL field. */
#define LPIT_RD_PARAM_CHANNEL(base) ((LPIT_PARAM_REG(base) & LPIT_PARAM_CHANNEL_MASK) >> LPIT_PARAM_CHANNEL_SHIFT)
#define LPIT_BRD_PARAM_CHANNEL(base) (LPIT_RD_PARAM_CHANNEL(base))
/*@}*/

/*!
 * @name Register LPIT_PARAM, field EXT_TRIG[15:8] (RO)
 *
 * Number of external triggers implemented.
 */
/*@{*/
/*! @brief Read current value of the LPIT_PARAM_EXT_TRIG field. */
#define LPIT_RD_PARAM_EXT_TRIG(base) ((LPIT_PARAM_REG(base) & LPIT_PARAM_EXT_TRIG_MASK) >> LPIT_PARAM_EXT_TRIG_SHIFT)
#define LPIT_BRD_PARAM_EXT_TRIG(base) (LPIT_RD_PARAM_EXT_TRIG(base))
/*@}*/

/*******************************************************************************
 * LPIT_MCR - Module Control Register
 ******************************************************************************/

/*!
 * @brief LPIT_MCR - Module Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_MCR register
 */
/*@{*/
#define LPIT_RD_MCR(base)        (LPIT_MCR_REG(base))
#define LPIT_WR_MCR(base, value) (LPIT_MCR_REG(base) = (value))
#define LPIT_RMW_MCR(base, mask, value) (LPIT_WR_MCR(base, (LPIT_RD_MCR(base) & ~(mask)) | (value)))
#define LPIT_SET_MCR(base, value) (LPIT_WR_MCR(base, LPIT_RD_MCR(base) |  (value)))
#define LPIT_CLR_MCR(base, value) (LPIT_WR_MCR(base, LPIT_RD_MCR(base) & ~(value)))
#define LPIT_TOG_MCR(base, value) (LPIT_WR_MCR(base, LPIT_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_MCR bitfields
 */

/*!
 * @name Register LPIT_MCR, field M_CEN[0] (RW)
 *
 * Enables the peripheral clock to the module timers. This bit must be asserted
 * when writing to timer registers. Both clocks (bus clock and peripheral clock)
 * must be enabled to allow for clock synchronization and update of register
 * bits. Writing to the SETTEN , CLRTEN, TCTRL, and TVAL while M_CEN = 0, will lead
 * to assertion of transfer error for that bus cycle. Writing to CVAL and Reserved
 * registers will always generate transfer error.
 *
 * Values:
 * - 0b0 - Protocol clock to timers is disabled
 * - 0b1 - Protocol clock to timers is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_M_CEN field. */
#define LPIT_RD_MCR_M_CEN(base) ((LPIT_MCR_REG(base) & LPIT_MCR_M_CEN_MASK) >> LPIT_MCR_M_CEN_SHIFT)
#define LPIT_BRD_MCR_M_CEN(base) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_M_CEN_SHIFT))

/*! @brief Set the M_CEN field to a new value. */
#define LPIT_WR_MCR_M_CEN(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_M_CEN_MASK, LPIT_MCR_M_CEN(value)))
#define LPIT_BWR_MCR_M_CEN(base, value) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_M_CEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MCR, field SW_RST[1] (RW)
 *
 * Resets all channels and registers, except the Module Control Register.
 * Remains set until cleared by software.
 *
 * Values:
 * - 0b0 - Timer channels and registers are not reset
 * - 0b1 - Timer channels and registers are reset
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_SW_RST field. */
#define LPIT_RD_MCR_SW_RST(base) ((LPIT_MCR_REG(base) & LPIT_MCR_SW_RST_MASK) >> LPIT_MCR_SW_RST_SHIFT)
#define LPIT_BRD_MCR_SW_RST(base) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_SW_RST_SHIFT))

/*! @brief Set the SW_RST field to a new value. */
#define LPIT_WR_MCR_SW_RST(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_SW_RST_MASK, LPIT_MCR_SW_RST(value)))
#define LPIT_BWR_MCR_SW_RST(base, value) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_SW_RST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MCR, field DOZE_EN[2] (RW)
 *
 * Allows the timer channels to be stopped or continue to run when the device
 * enters the DOZE mode
 *
 * Values:
 * - 0b0 - Timer channels are stopped in DOZE mode
 * - 0b1 - Timer channels continue to run in DOZE mode
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_DOZE_EN field. */
#define LPIT_RD_MCR_DOZE_EN(base) ((LPIT_MCR_REG(base) & LPIT_MCR_DOZE_EN_MASK) >> LPIT_MCR_DOZE_EN_SHIFT)
#define LPIT_BRD_MCR_DOZE_EN(base) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_DOZE_EN_SHIFT))

/*! @brief Set the DOZE_EN field to a new value. */
#define LPIT_WR_MCR_DOZE_EN(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_DOZE_EN_MASK, LPIT_MCR_DOZE_EN(value)))
#define LPIT_BWR_MCR_DOZE_EN(base, value) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_DOZE_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MCR, field DBG_EN[3] (RW)
 *
 * Allows the timer channels to be stopped when the device enters the Debug mode
 *
 * Values:
 * - 0b0 - Timer channels are stopped in Debug mode
 * - 0b1 - Timer channels continue to run in Debug mode
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_DBG_EN field. */
#define LPIT_RD_MCR_DBG_EN(base) ((LPIT_MCR_REG(base) & LPIT_MCR_DBG_EN_MASK) >> LPIT_MCR_DBG_EN_SHIFT)
#define LPIT_BRD_MCR_DBG_EN(base) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_DBG_EN_SHIFT))

/*! @brief Set the DBG_EN field to a new value. */
#define LPIT_WR_MCR_DBG_EN(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_DBG_EN_MASK, LPIT_MCR_DBG_EN(value)))
#define LPIT_BWR_MCR_DBG_EN(base, value) (BITBAND_ACCESS32(&LPIT_MCR_REG(base), LPIT_MCR_DBG_EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPIT_MSR - Module Status Register
 ******************************************************************************/

/*!
 * @brief LPIT_MSR - Module Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_MSR register
 */
/*@{*/
#define LPIT_RD_MSR(base)        (LPIT_MSR_REG(base))
#define LPIT_WR_MSR(base, value) (LPIT_MSR_REG(base) = (value))
#define LPIT_RMW_MSR(base, mask, value) (LPIT_WR_MSR(base, (LPIT_RD_MSR(base) & ~(mask)) | (value)))
#define LPIT_SET_MSR(base, value) (LPIT_WR_MSR(base, LPIT_RD_MSR(base) |  (value)))
#define LPIT_CLR_MSR(base, value) (LPIT_WR_MSR(base, LPIT_RD_MSR(base) & ~(value)))
#define LPIT_TOG_MSR(base, value) (LPIT_WR_MSR(base, LPIT_RD_MSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_MSR bitfields
 */

/*!
 * @name Register LPIT_MSR, field TIF0[0] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF0 field. */
#define LPIT_RD_MSR_TIF0(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF0_MASK) >> LPIT_MSR_TIF0_SHIFT)
#define LPIT_BRD_MSR_TIF0(base) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF0_SHIFT))

/*! @brief Set the TIF0 field to a new value. */
#define LPIT_WR_MSR_TIF0(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF2_MASK | LPIT_MSR_TIF3_MASK), LPIT_MSR_TIF0(value)))
#define LPIT_BWR_MSR_TIF0(base, value) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MSR, field TIF1[1] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF1 field. */
#define LPIT_RD_MSR_TIF1(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF1_MASK) >> LPIT_MSR_TIF1_SHIFT)
#define LPIT_BRD_MSR_TIF1(base) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF1_SHIFT))

/*! @brief Set the TIF1 field to a new value. */
#define LPIT_WR_MSR_TIF1(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF2_MASK | LPIT_MSR_TIF3_MASK), LPIT_MSR_TIF1(value)))
#define LPIT_BWR_MSR_TIF1(base, value) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MSR, field TIF2[2] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF2 field. */
#define LPIT_RD_MSR_TIF2(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF2_MASK) >> LPIT_MSR_TIF2_SHIFT)
#define LPIT_BRD_MSR_TIF2(base) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF2_SHIFT))

/*! @brief Set the TIF2 field to a new value. */
#define LPIT_WR_MSR_TIF2(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF2_MASK | LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF3_MASK), LPIT_MSR_TIF2(value)))
#define LPIT_BWR_MSR_TIF2(base, value) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MSR, field TIF3[3] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF3 field. */
#define LPIT_RD_MSR_TIF3(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF3_MASK) >> LPIT_MSR_TIF3_SHIFT)
#define LPIT_BRD_MSR_TIF3(base) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF3_SHIFT))

/*! @brief Set the TIF3 field to a new value. */
#define LPIT_WR_MSR_TIF3(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF3_MASK | LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF2_MASK), LPIT_MSR_TIF3(value)))
#define LPIT_BWR_MSR_TIF3(base, value) (BITBAND_ACCESS32(&LPIT_MSR_REG(base), LPIT_MSR_TIF3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPIT_MIER - Module Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPIT_MIER - Module Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_MIER register
 */
/*@{*/
#define LPIT_RD_MIER(base)       (LPIT_MIER_REG(base))
#define LPIT_WR_MIER(base, value) (LPIT_MIER_REG(base) = (value))
#define LPIT_RMW_MIER(base, mask, value) (LPIT_WR_MIER(base, (LPIT_RD_MIER(base) & ~(mask)) | (value)))
#define LPIT_SET_MIER(base, value) (LPIT_WR_MIER(base, LPIT_RD_MIER(base) |  (value)))
#define LPIT_CLR_MIER(base, value) (LPIT_WR_MIER(base, LPIT_RD_MIER(base) & ~(value)))
#define LPIT_TOG_MIER(base, value) (LPIT_WR_MIER(base, LPIT_RD_MIER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_MIER bitfields
 */

/*!
 * @name Register LPIT_MIER, field TIE0[0] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE0 field. */
#define LPIT_RD_MIER_TIE0(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE0_MASK) >> LPIT_MIER_TIE0_SHIFT)
#define LPIT_BRD_MIER_TIE0(base) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE0_SHIFT))

/*! @brief Set the TIE0 field to a new value. */
#define LPIT_WR_MIER_TIE0(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE0_MASK, LPIT_MIER_TIE0(value)))
#define LPIT_BWR_MIER_TIE0(base, value) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MIER, field TIE1[1] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE1 field. */
#define LPIT_RD_MIER_TIE1(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE1_MASK) >> LPIT_MIER_TIE1_SHIFT)
#define LPIT_BRD_MIER_TIE1(base) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE1_SHIFT))

/*! @brief Set the TIE1 field to a new value. */
#define LPIT_WR_MIER_TIE1(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE1_MASK, LPIT_MIER_TIE1(value)))
#define LPIT_BWR_MIER_TIE1(base, value) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MIER, field TIE2[2] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE2 field. */
#define LPIT_RD_MIER_TIE2(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE2_MASK) >> LPIT_MIER_TIE2_SHIFT)
#define LPIT_BRD_MIER_TIE2(base) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE2_SHIFT))

/*! @brief Set the TIE2 field to a new value. */
#define LPIT_WR_MIER_TIE2(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE2_MASK, LPIT_MIER_TIE2(value)))
#define LPIT_BWR_MIER_TIE2(base, value) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_MIER, field TIE3[3] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE3 field. */
#define LPIT_RD_MIER_TIE3(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE3_MASK) >> LPIT_MIER_TIE3_SHIFT)
#define LPIT_BRD_MIER_TIE3(base) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE3_SHIFT))

/*! @brief Set the TIE3 field to a new value. */
#define LPIT_WR_MIER_TIE3(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE3_MASK, LPIT_MIER_TIE3(value)))
#define LPIT_BWR_MIER_TIE3(base, value) (BITBAND_ACCESS32(&LPIT_MIER_REG(base), LPIT_MIER_TIE3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPIT_SETTEN - Set Timer Enable Register
 ******************************************************************************/

/*!
 * @brief LPIT_SETTEN - Set Timer Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register allows simulataneous enabling of timer channels. Timer channels
 * can be enabled either by writing '1' to T_EN in respective TCTRLn register or
 * setting the corresponding bit in this register. Writing a '0' to this
 * register has no effect. CLRTEN register should be used to disable timer channels
 * simultaneously.
 */
/*!
 * @name Constants and macros for entire LPIT_SETTEN register
 */
/*@{*/
#define LPIT_RD_SETTEN(base)     (LPIT_SETTEN_REG(base))
#define LPIT_WR_SETTEN(base, value) (LPIT_SETTEN_REG(base) = (value))
#define LPIT_RMW_SETTEN(base, mask, value) (LPIT_WR_SETTEN(base, (LPIT_RD_SETTEN(base) & ~(mask)) | (value)))
#define LPIT_SET_SETTEN(base, value) (LPIT_WR_SETTEN(base, LPIT_RD_SETTEN(base) |  (value)))
#define LPIT_CLR_SETTEN(base, value) (LPIT_WR_SETTEN(base, LPIT_RD_SETTEN(base) & ~(value)))
#define LPIT_TOG_SETTEN(base, value) (LPIT_WR_SETTEN(base, LPIT_RD_SETTEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_SETTEN bitfields
 */

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_0[0] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 0. This bit can be used
 * in addition to T_EN bit in TCTRL0 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL0 is set to 0 or '1'
 * is written to the CLR_T_EN_0 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No effect
 * - 0b1 - Enables the Timer Channel 0
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_0 field. */
#define LPIT_RD_SETTEN_SET_T_EN_0(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_0_MASK) >> LPIT_SETTEN_SET_T_EN_0_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_0(base) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_0_SHIFT))

/*! @brief Set the SET_T_EN_0 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_0(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_0_MASK, LPIT_SETTEN_SET_T_EN_0(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_0(base, value) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_1[1] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 1. This bit can be used
 * in addition to T_EN bit in TCTRL1 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL1 is set to '0' or '1'
 * is written to the CLR_T_EN_1 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No Effect
 * - 0b1 - Enables the Timer Channel 1
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_1 field. */
#define LPIT_RD_SETTEN_SET_T_EN_1(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_1_MASK) >> LPIT_SETTEN_SET_T_EN_1_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_1(base) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_1_SHIFT))

/*! @brief Set the SET_T_EN_1 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_1(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_1_MASK, LPIT_SETTEN_SET_T_EN_1(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_1(base, value) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_2[2] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 2. This bit can be used
 * in addition to T_EN bit in TCTRL2 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL2 is set to '0' or '1'
 * is written to the CLR_T_EN_2 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No Effect
 * - 0b1 - Enables the Timer Channel 2
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_2 field. */
#define LPIT_RD_SETTEN_SET_T_EN_2(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_2_MASK) >> LPIT_SETTEN_SET_T_EN_2_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_2(base) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_2_SHIFT))

/*! @brief Set the SET_T_EN_2 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_2(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_2_MASK, LPIT_SETTEN_SET_T_EN_2(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_2(base, value) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_3[3] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 3. This bit can be used
 * in addition to T_EN bit in TCTRL3 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL3 is set to '0' or '1'
 * is written to the CLR_T_EN_3 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No effect
 * - 0b1 - Enables the Timer Channel 3
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_3 field. */
#define LPIT_RD_SETTEN_SET_T_EN_3(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_3_MASK) >> LPIT_SETTEN_SET_T_EN_3_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_3(base) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_3_SHIFT))

/*! @brief Set the SET_T_EN_3 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_3(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_3_MASK, LPIT_SETTEN_SET_T_EN_3(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_3(base, value) (BITBAND_ACCESS32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPIT_CLRTEN - Clear Timer Enable Register
 ******************************************************************************/

/*!
 * @brief LPIT_CLRTEN - Clear Timer Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_CLRTEN register
 */
/*@{*/
#define LPIT_RD_CLRTEN(base)     (LPIT_CLRTEN_REG(base))
#define LPIT_WR_CLRTEN(base, value) (LPIT_CLRTEN_REG(base) = (value))
#define LPIT_RMW_CLRTEN(base, mask, value) (LPIT_WR_CLRTEN(base, (LPIT_RD_CLRTEN(base) & ~(mask)) | (value)))
#define LPIT_SET_CLRTEN(base, value) (LPIT_WR_CLRTEN(base, LPIT_RD_CLRTEN(base) |  (value)))
#define LPIT_CLR_CLRTEN(base, value) (LPIT_WR_CLRTEN(base, LPIT_RD_CLRTEN(base) & ~(value)))
#define LPIT_TOG_CLRTEN(base, value) (LPIT_WR_CLRTEN(base, LPIT_RD_CLRTEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_CLRTEN bitfields
 */

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_0[0] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 0. This bit can be
 * used in addition to T_EN bit in TCTRL0 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No action
 * - 0b1 - Clear T_EN bit for Timer Channel 0
 */
/*@{*/
/*! @brief Set the CLR_T_EN_0 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_0(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_0_MASK, LPIT_CLRTEN_CLR_T_EN_0(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_0(base, value) (BITBAND_ACCESS32(&LPIT_CLRTEN_REG(base), LPIT_CLRTEN_CLR_T_EN_0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_1[1] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 1. This bit can be
 * used in addition to T_EN bit in TCTRL1 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No Action
 * - 0b1 - Clear T_EN bit for Timer Channel 1
 */
/*@{*/
/*! @brief Set the CLR_T_EN_1 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_1(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_1_MASK, LPIT_CLRTEN_CLR_T_EN_1(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_1(base, value) (BITBAND_ACCESS32(&LPIT_CLRTEN_REG(base), LPIT_CLRTEN_CLR_T_EN_1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_2[2] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 2. This bit can be
 * used in addition to T_EN bit in TCTRL2 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No Action
 * - 0b1 - Clear T_EN bit for Timer Channel 2
 */
/*@{*/
/*! @brief Set the CLR_T_EN_2 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_2(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_2_MASK, LPIT_CLRTEN_CLR_T_EN_2(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_2(base, value) (BITBAND_ACCESS32(&LPIT_CLRTEN_REG(base), LPIT_CLRTEN_CLR_T_EN_2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_3[3] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 3. This bit can be
 * used in addition to T_EN bit in TCTRL3 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No Action
 * - 0b1 - Clear T_EN bit for Timer Channel 3
 */
/*@{*/
/*! @brief Set the CLR_T_EN_3 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_3(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_3_MASK, LPIT_CLRTEN_CLR_T_EN_3(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_3(base, value) (BITBAND_ACCESS32(&LPIT_CLRTEN_REG(base), LPIT_CLRTEN_CLR_T_EN_3_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPIT_RSVD - Reserved Register
 ******************************************************************************/

/*!
 * @brief LPIT_RSVD - Reserved Register (ROZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_RSVD register
 */
/*@{*/
#define LPIT_RD_RSVD(base)       (LPIT_RSVD_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TVAL0 - Timer Value Register
 ******************************************************************************/

/*!
 * @brief LPIT_TVAL0 - Timer Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * In compare modes, these registers select the timeout period for the timer
 * channels. In capture modes, these registers are loaded with the value of the
 * counter when the trigger asserts.
 */
/*!
 * @name Constants and macros for entire LPIT_TVAL0 register
 */
/*@{*/
#define LPIT_RD_TVAL0(base)      (LPIT_TVAL0_REG(base))
#define LPIT_WR_TVAL0(base, value) (LPIT_TVAL0_REG(base) = (value))
#define LPIT_RMW_TVAL0(base, mask, value) (LPIT_WR_TVAL0(base, (LPIT_RD_TVAL0(base) & ~(mask)) | (value)))
#define LPIT_SET_TVAL0(base, value) (LPIT_WR_TVAL0(base, LPIT_RD_TVAL0(base) |  (value)))
#define LPIT_CLR_TVAL0(base, value) (LPIT_WR_TVAL0(base, LPIT_RD_TVAL0(base) & ~(value)))
#define LPIT_TOG_TVAL0(base, value) (LPIT_WR_TVAL0(base, LPIT_RD_TVAL0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * LPIT_CVAL0 - Current Timer Value
 ******************************************************************************/

/*!
 * @brief LPIT_CVAL0 - Current Timer Value (RO)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * These registers indicate the current timer counter value.
 */
/*!
 * @name Constants and macros for entire LPIT_CVAL0 register
 */
/*@{*/
#define LPIT_RD_CVAL0(base)      (LPIT_CVAL0_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TCTRL0 - Timer Control Register
 ******************************************************************************/

/*!
 * @brief LPIT_TCTRL0 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer channel
 */
/*!
 * @name Constants and macros for entire LPIT_TCTRL0 register
 */
/*@{*/
#define LPIT_RD_TCTRL0(base)     (LPIT_TCTRL0_REG(base))
#define LPIT_WR_TCTRL0(base, value) (LPIT_TCTRL0_REG(base) = (value))
#define LPIT_RMW_TCTRL0(base, mask, value) (LPIT_WR_TCTRL0(base, (LPIT_RD_TCTRL0(base) & ~(mask)) | (value)))
#define LPIT_SET_TCTRL0(base, value) (LPIT_WR_TCTRL0(base, LPIT_RD_TCTRL0(base) |  (value)))
#define LPIT_CLR_TCTRL0(base, value) (LPIT_WR_TCTRL0(base, LPIT_RD_TCTRL0(base) & ~(value)))
#define LPIT_TOG_TCTRL0(base, value) (LPIT_WR_TCTRL0(base, LPIT_RD_TCTRL0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_TCTRL0 bitfields
 */

/*!
 * @name Register LPIT_TCTRL0, field T_EN[0] (RW)
 *
 * Enables or disables the Timer Channel
 *
 * Values:
 * - 0b0 - Timer Channel is disabled
 * - 0b1 - Timer Channel is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_T_EN field. */
#define LPIT_RD_TCTRL0_T_EN(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_T_EN_MASK) >> LPIT_TCTRL0_T_EN_SHIFT)
#define LPIT_BRD_TCTRL0_T_EN(base) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_T_EN_SHIFT))

/*! @brief Set the T_EN field to a new value. */
#define LPIT_WR_TCTRL0_T_EN(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_T_EN_MASK, LPIT_TCTRL0_T_EN(value)))
#define LPIT_BWR_TCTRL0_T_EN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_T_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL0, field CHAIN[1] (RW)
 *
 * When enabled, timer channel will decrement when channel N-1 trigger asserts.
 * Channel 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Channel Chaining is disabled. Channel Timer runs independently.
 * - 0b1 - Channel Chaining is enabled. Timer decrements on previous channel's
 *     timeout
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_CHAIN field. */
#define LPIT_RD_TCTRL0_CHAIN(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_CHAIN_MASK) >> LPIT_TCTRL0_CHAIN_SHIFT)
#define LPIT_BRD_TCTRL0_CHAIN(base) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_CHAIN_SHIFT))

/*! @brief Set the CHAIN field to a new value. */
#define LPIT_WR_TCTRL0_CHAIN(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_CHAIN_MASK, LPIT_TCTRL0_CHAIN(value)))
#define LPIT_BWR_TCTRL0_CHAIN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_CHAIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL0, field MODE[3:2] (RW)
 *
 * Configures the Channel Timer Mode of Operation. The mode bits control how the
 * timer decrements. See Functional Description for more details.
 *
 * Values:
 * - 0b00 - 32-bit Periodic Counter
 * - 0b01 - Dual 16-bit Periodic Counter
 * - 0b10 - 32-bit Trigger Accumulator
 * - 0b11 - 32-bit Trigger Input Capture
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_MODE field. */
#define LPIT_RD_TCTRL0_MODE(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_MODE_MASK) >> LPIT_TCTRL0_MODE_SHIFT)
#define LPIT_BRD_TCTRL0_MODE(base) (LPIT_RD_TCTRL0_MODE(base))

/*! @brief Set the MODE field to a new value. */
#define LPIT_WR_TCTRL0_MODE(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_MODE_MASK, LPIT_TCTRL0_MODE(value)))
#define LPIT_BWR_TCTRL0_MODE(base, value) (LPIT_WR_TCTRL0_MODE(base, value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL0, field TSOT[16] (RW)
 *
 * This bit controls when the timer starts decrementing.
 *
 * Values:
 * - 0b0 - Timer starts to decrement immediately based on restart condition
 *     (controlled by TSOI bit)
 * - 0b1 - Timer starts to decrement when rising edge on selected trigger is
 *     detected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_TSOT field. */
#define LPIT_RD_TCTRL0_TSOT(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_TSOT_MASK) >> LPIT_TCTRL0_TSOT_SHIFT)
#define LPIT_BRD_TCTRL0_TSOT(base) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TSOT_SHIFT))

/*! @brief Set the TSOT field to a new value. */
#define LPIT_WR_TCTRL0_TSOT(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_TSOT_MASK, LPIT_TCTRL0_TSOT(value)))
#define LPIT_BWR_TCTRL0_TSOT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TSOT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL0, field TSOI[17] (RW)
 *
 * This bit controls whether the channel timer will stop after it times out and
 * when it can restart (when TSOT = 0). If TSOT = 1, then the timer will stop on
 * timeout and will restart after a rising edge on the selected trigger is
 * detected. If TSOT = 0, then this bit controls when the timer restarts.
 *
 * Values:
 * - 0b0 - Timer does not stop after timeout
 * - 0b1 - Timer will stop after timeout and will restart after rising edge on
 *     the T_EN bit is detected (i.e. timer channel is disabled and then enabled)
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_TSOI field. */
#define LPIT_RD_TCTRL0_TSOI(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_TSOI_MASK) >> LPIT_TCTRL0_TSOI_SHIFT)
#define LPIT_BRD_TCTRL0_TSOI(base) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TSOI_SHIFT))

/*! @brief Set the TSOI field to a new value. */
#define LPIT_WR_TCTRL0_TSOI(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_TSOI_MASK, LPIT_TCTRL0_TSOI(value)))
#define LPIT_BWR_TCTRL0_TSOI(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TSOI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL0, field TROT[18] (RW)
 *
 * When set, the LPIT timer will reload when a rising edge is detected on the
 * selected trigger input. The trigger input is ignored if the LPIT is disabled
 * during debug mode or DOZE mode (DOZE_EN or DBGEN = 0)
 *
 * Values:
 * - 0b0 - Timer will not reload on selected trigger
 * - 0b1 - Timer will reload on selected trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_TROT field. */
#define LPIT_RD_TCTRL0_TROT(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_TROT_MASK) >> LPIT_TCTRL0_TROT_SHIFT)
#define LPIT_BRD_TCTRL0_TROT(base) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TROT_SHIFT))

/*! @brief Set the TROT field to a new value. */
#define LPIT_WR_TCTRL0_TROT(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_TROT_MASK, LPIT_TCTRL0_TROT(value)))
#define LPIT_BWR_TCTRL0_TROT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TROT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL0, field TRG_SRC[23] (RW)
 *
 * Selects between internal or external trigger sources. The final trigger is
 * selected by TRG_SEL depending on which trigger source out of internal triggers
 * or external triggers are selected by TRG_SRC. Refer to the chip configuration
 * section for available external trigger options. If a channel does not have an
 * associated external trigger then this bit for that channel should be set to 1.
 *
 * Values:
 * - 0b0 - Trigger source selected in external
 * - 0b1 - Trigger source selected is the internal trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_TRG_SRC field. */
#define LPIT_RD_TCTRL0_TRG_SRC(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_TRG_SRC_MASK) >> LPIT_TCTRL0_TRG_SRC_SHIFT)
#define LPIT_BRD_TCTRL0_TRG_SRC(base) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TRG_SRC_SHIFT))

/*! @brief Set the TRG_SRC field to a new value. */
#define LPIT_WR_TCTRL0_TRG_SRC(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_TRG_SRC_MASK, LPIT_TCTRL0_TRG_SRC(value)))
#define LPIT_BWR_TCTRL0_TRG_SRC(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL0_REG(base), LPIT_TCTRL0_TRG_SRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL0, field TRG_SEL[27:24] (RW)
 *
 * Selects the trigger to use for starting and/or reloading the LPIT timer. This
 * field should only be changed when the LPIT timer channel is disabled. The
 * TRG_SRC bit selects between internal and external trigger signals for each
 * channel. The TRG_SEL bits select one trigger from the set of internal or external
 * triggers selected by TRG_SRC.
 *
 * Values:
 * - 0b0000 - Timer channel 0 trigger source is selected
 * - 0b0001 - Timer channel 1 trigger source is selected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL0_TRG_SEL field. */
#define LPIT_RD_TCTRL0_TRG_SEL(base) ((LPIT_TCTRL0_REG(base) & LPIT_TCTRL0_TRG_SEL_MASK) >> LPIT_TCTRL0_TRG_SEL_SHIFT)
#define LPIT_BRD_TCTRL0_TRG_SEL(base) (LPIT_RD_TCTRL0_TRG_SEL(base))

/*! @brief Set the TRG_SEL field to a new value. */
#define LPIT_WR_TCTRL0_TRG_SEL(base, value) (LPIT_RMW_TCTRL0(base, LPIT_TCTRL0_TRG_SEL_MASK, LPIT_TCTRL0_TRG_SEL(value)))
#define LPIT_BWR_TCTRL0_TRG_SEL(base, value) (LPIT_WR_TCTRL0_TRG_SEL(base, value))
/*@}*/

/*******************************************************************************
 * LPIT_RFU0 - Reserved for Future Use
 ******************************************************************************/

/*!
 * @brief LPIT_RFU0 - Reserved for Future Use (ROZ)
 *
 * Reset value: 0x00000000U
 *
 * This register location is reserved for future use.
 */
/*!
 * @name Constants and macros for entire LPIT_RFU0 register
 */
/*@{*/
#define LPIT_RD_RFU0(base)       (LPIT_RFU0_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TVAL1 - Timer Value Register
 ******************************************************************************/

/*!
 * @brief LPIT_TVAL1 - Timer Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * In compare modes, these registers select the timeout period for the timer
 * channels. In capture modes, these registers are loaded with the value of the
 * counter when the trigger asserts.
 */
/*!
 * @name Constants and macros for entire LPIT_TVAL1 register
 */
/*@{*/
#define LPIT_RD_TVAL1(base)      (LPIT_TVAL1_REG(base))
#define LPIT_WR_TVAL1(base, value) (LPIT_TVAL1_REG(base) = (value))
#define LPIT_RMW_TVAL1(base, mask, value) (LPIT_WR_TVAL1(base, (LPIT_RD_TVAL1(base) & ~(mask)) | (value)))
#define LPIT_SET_TVAL1(base, value) (LPIT_WR_TVAL1(base, LPIT_RD_TVAL1(base) |  (value)))
#define LPIT_CLR_TVAL1(base, value) (LPIT_WR_TVAL1(base, LPIT_RD_TVAL1(base) & ~(value)))
#define LPIT_TOG_TVAL1(base, value) (LPIT_WR_TVAL1(base, LPIT_RD_TVAL1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * LPIT_CVAL1 - Current Timer Value
 ******************************************************************************/

/*!
 * @brief LPIT_CVAL1 - Current Timer Value (RO)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * These registers indicate the current timer counter value.
 */
/*!
 * @name Constants and macros for entire LPIT_CVAL1 register
 */
/*@{*/
#define LPIT_RD_CVAL1(base)      (LPIT_CVAL1_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TCTRL1 - Timer Control Register
 ******************************************************************************/

/*!
 * @brief LPIT_TCTRL1 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer channel
 */
/*!
 * @name Constants and macros for entire LPIT_TCTRL1 register
 */
/*@{*/
#define LPIT_RD_TCTRL1(base)     (LPIT_TCTRL1_REG(base))
#define LPIT_WR_TCTRL1(base, value) (LPIT_TCTRL1_REG(base) = (value))
#define LPIT_RMW_TCTRL1(base, mask, value) (LPIT_WR_TCTRL1(base, (LPIT_RD_TCTRL1(base) & ~(mask)) | (value)))
#define LPIT_SET_TCTRL1(base, value) (LPIT_WR_TCTRL1(base, LPIT_RD_TCTRL1(base) |  (value)))
#define LPIT_CLR_TCTRL1(base, value) (LPIT_WR_TCTRL1(base, LPIT_RD_TCTRL1(base) & ~(value)))
#define LPIT_TOG_TCTRL1(base, value) (LPIT_WR_TCTRL1(base, LPIT_RD_TCTRL1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_TCTRL1 bitfields
 */

/*!
 * @name Register LPIT_TCTRL1, field T_EN[0] (RW)
 *
 * Enables or disables the Timer Channel
 *
 * Values:
 * - 0b0 - Timer Channel is disabled
 * - 0b1 - Timer Channel is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_T_EN field. */
#define LPIT_RD_TCTRL1_T_EN(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_T_EN_MASK) >> LPIT_TCTRL1_T_EN_SHIFT)
#define LPIT_BRD_TCTRL1_T_EN(base) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_T_EN_SHIFT))

/*! @brief Set the T_EN field to a new value. */
#define LPIT_WR_TCTRL1_T_EN(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_T_EN_MASK, LPIT_TCTRL1_T_EN(value)))
#define LPIT_BWR_TCTRL1_T_EN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_T_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL1, field CHAIN[1] (RW)
 *
 * When enabled, timer channel will decrement when channel N-1 trigger asserts.
 * Channel 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Channel Chaining is disabled. Channel Timer runs independently.
 * - 0b1 - Channel Chaining is enabled. Timer decrements on previous channel's
 *     timeout
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_CHAIN field. */
#define LPIT_RD_TCTRL1_CHAIN(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_CHAIN_MASK) >> LPIT_TCTRL1_CHAIN_SHIFT)
#define LPIT_BRD_TCTRL1_CHAIN(base) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_CHAIN_SHIFT))

/*! @brief Set the CHAIN field to a new value. */
#define LPIT_WR_TCTRL1_CHAIN(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_CHAIN_MASK, LPIT_TCTRL1_CHAIN(value)))
#define LPIT_BWR_TCTRL1_CHAIN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_CHAIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL1, field MODE[3:2] (RW)
 *
 * Configures the Channel Timer Mode of Operation. The mode bits control how the
 * timer decrements. See Functional Description for more details.
 *
 * Values:
 * - 0b00 - 32-bit Periodic Counter
 * - 0b01 - Dual 16-bit Periodic Counter
 * - 0b10 - 32-bit Trigger Accumulator
 * - 0b11 - 32-bit Trigger Input Capture
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_MODE field. */
#define LPIT_RD_TCTRL1_MODE(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_MODE_MASK) >> LPIT_TCTRL1_MODE_SHIFT)
#define LPIT_BRD_TCTRL1_MODE(base) (LPIT_RD_TCTRL1_MODE(base))

/*! @brief Set the MODE field to a new value. */
#define LPIT_WR_TCTRL1_MODE(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_MODE_MASK, LPIT_TCTRL1_MODE(value)))
#define LPIT_BWR_TCTRL1_MODE(base, value) (LPIT_WR_TCTRL1_MODE(base, value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL1, field TSOT[16] (RW)
 *
 * This bit controls when the timer starts decrementing.
 *
 * Values:
 * - 0b0 - Timer starts to decrement immediately based on restart condition
 *     (controlled by TSOI bit)
 * - 0b1 - Timer starts to decrement when rising edge on selected trigger is
 *     detected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_TSOT field. */
#define LPIT_RD_TCTRL1_TSOT(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_TSOT_MASK) >> LPIT_TCTRL1_TSOT_SHIFT)
#define LPIT_BRD_TCTRL1_TSOT(base) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TSOT_SHIFT))

/*! @brief Set the TSOT field to a new value. */
#define LPIT_WR_TCTRL1_TSOT(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_TSOT_MASK, LPIT_TCTRL1_TSOT(value)))
#define LPIT_BWR_TCTRL1_TSOT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TSOT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL1, field TSOI[17] (RW)
 *
 * This bit controls whether the channel timer will stop after it times out and
 * when it can restart (when TSOT = 0). If TSOT = 1, then the timer will stop on
 * timeout and will restart after a rising edge on the selected trigger is
 * detected. If TSOT = 0, then this bit controls when the timer restarts.
 *
 * Values:
 * - 0b0 - Timer does not stop after timeout
 * - 0b1 - Timer will stop after timeout and will restart after rising edge on
 *     the T_EN bit is detected (i.e. timer channel is disabled and then enabled)
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_TSOI field. */
#define LPIT_RD_TCTRL1_TSOI(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_TSOI_MASK) >> LPIT_TCTRL1_TSOI_SHIFT)
#define LPIT_BRD_TCTRL1_TSOI(base) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TSOI_SHIFT))

/*! @brief Set the TSOI field to a new value. */
#define LPIT_WR_TCTRL1_TSOI(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_TSOI_MASK, LPIT_TCTRL1_TSOI(value)))
#define LPIT_BWR_TCTRL1_TSOI(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TSOI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL1, field TROT[18] (RW)
 *
 * When set, the LPIT timer will reload when a rising edge is detected on the
 * selected trigger input. The trigger input is ignored if the LPIT is disabled
 * during debug mode or DOZE mode (DOZE_EN or DBGEN = 0)
 *
 * Values:
 * - 0b0 - Timer will not reload on selected trigger
 * - 0b1 - Timer will reload on selected trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_TROT field. */
#define LPIT_RD_TCTRL1_TROT(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_TROT_MASK) >> LPIT_TCTRL1_TROT_SHIFT)
#define LPIT_BRD_TCTRL1_TROT(base) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TROT_SHIFT))

/*! @brief Set the TROT field to a new value. */
#define LPIT_WR_TCTRL1_TROT(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_TROT_MASK, LPIT_TCTRL1_TROT(value)))
#define LPIT_BWR_TCTRL1_TROT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TROT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL1, field TRG_SRC[23] (RW)
 *
 * Selects between internal or external trigger sources. The final trigger is
 * selected by TRG_SEL depending on which trigger source out of internal triggers
 * or external triggers are selected by TRG_SRC. Refer to the chip configuration
 * section for available external trigger options. If a channel does not have an
 * associated external trigger then this bit for that channel should be set to 1.
 *
 * Values:
 * - 0b0 - Trigger source selected in external
 * - 0b1 - Trigger source selected is the internal trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_TRG_SRC field. */
#define LPIT_RD_TCTRL1_TRG_SRC(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_TRG_SRC_MASK) >> LPIT_TCTRL1_TRG_SRC_SHIFT)
#define LPIT_BRD_TCTRL1_TRG_SRC(base) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TRG_SRC_SHIFT))

/*! @brief Set the TRG_SRC field to a new value. */
#define LPIT_WR_TCTRL1_TRG_SRC(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_TRG_SRC_MASK, LPIT_TCTRL1_TRG_SRC(value)))
#define LPIT_BWR_TCTRL1_TRG_SRC(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL1_REG(base), LPIT_TCTRL1_TRG_SRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL1, field TRG_SEL[27:24] (RW)
 *
 * Selects the trigger to use for starting and/or reloading the LPIT timer. This
 * field should only be changed when the LPIT timer channel is disabled. The
 * TRG_SRC bit selects between internal and external trigger signals for each
 * channel. The TRG_SEL bits select one trigger from the set of internal or external
 * triggers selected by TRG_SRC.
 *
 * Values:
 * - 0b0000 - Timer channel 0 trigger source is selected
 * - 0b0001 - Timer channel 1 trigger source is selected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL1_TRG_SEL field. */
#define LPIT_RD_TCTRL1_TRG_SEL(base) ((LPIT_TCTRL1_REG(base) & LPIT_TCTRL1_TRG_SEL_MASK) >> LPIT_TCTRL1_TRG_SEL_SHIFT)
#define LPIT_BRD_TCTRL1_TRG_SEL(base) (LPIT_RD_TCTRL1_TRG_SEL(base))

/*! @brief Set the TRG_SEL field to a new value. */
#define LPIT_WR_TCTRL1_TRG_SEL(base, value) (LPIT_RMW_TCTRL1(base, LPIT_TCTRL1_TRG_SEL_MASK, LPIT_TCTRL1_TRG_SEL(value)))
#define LPIT_BWR_TCTRL1_TRG_SEL(base, value) (LPIT_WR_TCTRL1_TRG_SEL(base, value))
/*@}*/

/*******************************************************************************
 * LPIT_RFU1 - Reserved for Future Use
 ******************************************************************************/

/*!
 * @brief LPIT_RFU1 - Reserved for Future Use (ROZ)
 *
 * Reset value: 0x00000000U
 *
 * This register location is reserved for future use.
 */
/*!
 * @name Constants and macros for entire LPIT_RFU1 register
 */
/*@{*/
#define LPIT_RD_RFU1(base)       (LPIT_RFU1_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TVAL2 - Timer Value Register
 ******************************************************************************/

/*!
 * @brief LPIT_TVAL2 - Timer Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * In compare modes, these registers select the timeout period for the timer
 * channels. In capture modes, these registers are loaded with the value of the
 * counter when the trigger asserts.
 */
/*!
 * @name Constants and macros for entire LPIT_TVAL2 register
 */
/*@{*/
#define LPIT_RD_TVAL2(base)      (LPIT_TVAL2_REG(base))
#define LPIT_WR_TVAL2(base, value) (LPIT_TVAL2_REG(base) = (value))
#define LPIT_RMW_TVAL2(base, mask, value) (LPIT_WR_TVAL2(base, (LPIT_RD_TVAL2(base) & ~(mask)) | (value)))
#define LPIT_SET_TVAL2(base, value) (LPIT_WR_TVAL2(base, LPIT_RD_TVAL2(base) |  (value)))
#define LPIT_CLR_TVAL2(base, value) (LPIT_WR_TVAL2(base, LPIT_RD_TVAL2(base) & ~(value)))
#define LPIT_TOG_TVAL2(base, value) (LPIT_WR_TVAL2(base, LPIT_RD_TVAL2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * LPIT_CVAL2 - Current Timer Value
 ******************************************************************************/

/*!
 * @brief LPIT_CVAL2 - Current Timer Value (RO)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * These registers indicate the current timer counter value.
 */
/*!
 * @name Constants and macros for entire LPIT_CVAL2 register
 */
/*@{*/
#define LPIT_RD_CVAL2(base)      (LPIT_CVAL2_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TCTRL2 - Timer Control Register
 ******************************************************************************/

/*!
 * @brief LPIT_TCTRL2 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer channel
 */
/*!
 * @name Constants and macros for entire LPIT_TCTRL2 register
 */
/*@{*/
#define LPIT_RD_TCTRL2(base)     (LPIT_TCTRL2_REG(base))
#define LPIT_WR_TCTRL2(base, value) (LPIT_TCTRL2_REG(base) = (value))
#define LPIT_RMW_TCTRL2(base, mask, value) (LPIT_WR_TCTRL2(base, (LPIT_RD_TCTRL2(base) & ~(mask)) | (value)))
#define LPIT_SET_TCTRL2(base, value) (LPIT_WR_TCTRL2(base, LPIT_RD_TCTRL2(base) |  (value)))
#define LPIT_CLR_TCTRL2(base, value) (LPIT_WR_TCTRL2(base, LPIT_RD_TCTRL2(base) & ~(value)))
#define LPIT_TOG_TCTRL2(base, value) (LPIT_WR_TCTRL2(base, LPIT_RD_TCTRL2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_TCTRL2 bitfields
 */

/*!
 * @name Register LPIT_TCTRL2, field T_EN[0] (RW)
 *
 * Enables or disables the Timer Channel
 *
 * Values:
 * - 0b0 - Timer Channel is disabled
 * - 0b1 - Timer Channel is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_T_EN field. */
#define LPIT_RD_TCTRL2_T_EN(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_T_EN_MASK) >> LPIT_TCTRL2_T_EN_SHIFT)
#define LPIT_BRD_TCTRL2_T_EN(base) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_T_EN_SHIFT))

/*! @brief Set the T_EN field to a new value. */
#define LPIT_WR_TCTRL2_T_EN(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_T_EN_MASK, LPIT_TCTRL2_T_EN(value)))
#define LPIT_BWR_TCTRL2_T_EN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_T_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL2, field CHAIN[1] (RW)
 *
 * When enabled, timer channel will decrement when channel N-1 trigger asserts.
 * Channel 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Channel Chaining is disabled. Channel Timer runs independently.
 * - 0b1 - Channel Chaining is enabled. Timer decrements on previous channel's
 *     timeout
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_CHAIN field. */
#define LPIT_RD_TCTRL2_CHAIN(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_CHAIN_MASK) >> LPIT_TCTRL2_CHAIN_SHIFT)
#define LPIT_BRD_TCTRL2_CHAIN(base) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_CHAIN_SHIFT))

/*! @brief Set the CHAIN field to a new value. */
#define LPIT_WR_TCTRL2_CHAIN(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_CHAIN_MASK, LPIT_TCTRL2_CHAIN(value)))
#define LPIT_BWR_TCTRL2_CHAIN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_CHAIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL2, field MODE[3:2] (RW)
 *
 * Configures the Channel Timer Mode of Operation. The mode bits control how the
 * timer decrements. See Functional Description for more details.
 *
 * Values:
 * - 0b00 - 32-bit Periodic Counter
 * - 0b01 - Dual 16-bit Periodic Counter
 * - 0b10 - 32-bit Trigger Accumulator
 * - 0b11 - 32-bit Trigger Input Capture
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_MODE field. */
#define LPIT_RD_TCTRL2_MODE(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_MODE_MASK) >> LPIT_TCTRL2_MODE_SHIFT)
#define LPIT_BRD_TCTRL2_MODE(base) (LPIT_RD_TCTRL2_MODE(base))

/*! @brief Set the MODE field to a new value. */
#define LPIT_WR_TCTRL2_MODE(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_MODE_MASK, LPIT_TCTRL2_MODE(value)))
#define LPIT_BWR_TCTRL2_MODE(base, value) (LPIT_WR_TCTRL2_MODE(base, value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL2, field TSOT[16] (RW)
 *
 * This bit controls when the timer starts decrementing.
 *
 * Values:
 * - 0b0 - Timer starts to decrement immediately based on restart condition
 *     (controlled by TSOI bit)
 * - 0b1 - Timer starts to decrement when rising edge on selected trigger is
 *     detected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_TSOT field. */
#define LPIT_RD_TCTRL2_TSOT(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_TSOT_MASK) >> LPIT_TCTRL2_TSOT_SHIFT)
#define LPIT_BRD_TCTRL2_TSOT(base) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TSOT_SHIFT))

/*! @brief Set the TSOT field to a new value. */
#define LPIT_WR_TCTRL2_TSOT(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_TSOT_MASK, LPIT_TCTRL2_TSOT(value)))
#define LPIT_BWR_TCTRL2_TSOT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TSOT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL2, field TSOI[17] (RW)
 *
 * This bit controls whether the channel timer will stop after it times out and
 * when it can restart (when TSOT = 0). If TSOT = 1, then the timer will stop on
 * timeout and will restart after a rising edge on the selected trigger is
 * detected. If TSOT = 0, then this bit controls when the timer restarts.
 *
 * Values:
 * - 0b0 - Timer does not stop after timeout
 * - 0b1 - Timer will stop after timeout and will restart after rising edge on
 *     the T_EN bit is detected (i.e. timer channel is disabled and then enabled)
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_TSOI field. */
#define LPIT_RD_TCTRL2_TSOI(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_TSOI_MASK) >> LPIT_TCTRL2_TSOI_SHIFT)
#define LPIT_BRD_TCTRL2_TSOI(base) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TSOI_SHIFT))

/*! @brief Set the TSOI field to a new value. */
#define LPIT_WR_TCTRL2_TSOI(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_TSOI_MASK, LPIT_TCTRL2_TSOI(value)))
#define LPIT_BWR_TCTRL2_TSOI(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TSOI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL2, field TROT[18] (RW)
 *
 * When set, the LPIT timer will reload when a rising edge is detected on the
 * selected trigger input. The trigger input is ignored if the LPIT is disabled
 * during debug mode or DOZE mode (DOZE_EN or DBGEN = 0)
 *
 * Values:
 * - 0b0 - Timer will not reload on selected trigger
 * - 0b1 - Timer will reload on selected trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_TROT field. */
#define LPIT_RD_TCTRL2_TROT(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_TROT_MASK) >> LPIT_TCTRL2_TROT_SHIFT)
#define LPIT_BRD_TCTRL2_TROT(base) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TROT_SHIFT))

/*! @brief Set the TROT field to a new value. */
#define LPIT_WR_TCTRL2_TROT(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_TROT_MASK, LPIT_TCTRL2_TROT(value)))
#define LPIT_BWR_TCTRL2_TROT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TROT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL2, field TRG_SRC[23] (RW)
 *
 * Selects between internal or external trigger sources. The final trigger is
 * selected by TRG_SEL depending on which trigger source out of internal triggers
 * or external triggers are selected by TRG_SRC. Refer to the chip configuration
 * section for available external trigger options. If a channel does not have an
 * associated external trigger then this bit for that channel should be set to 1.
 *
 * Values:
 * - 0b0 - Trigger source selected in external
 * - 0b1 - Trigger source selected is the internal trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_TRG_SRC field. */
#define LPIT_RD_TCTRL2_TRG_SRC(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_TRG_SRC_MASK) >> LPIT_TCTRL2_TRG_SRC_SHIFT)
#define LPIT_BRD_TCTRL2_TRG_SRC(base) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TRG_SRC_SHIFT))

/*! @brief Set the TRG_SRC field to a new value. */
#define LPIT_WR_TCTRL2_TRG_SRC(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_TRG_SRC_MASK, LPIT_TCTRL2_TRG_SRC(value)))
#define LPIT_BWR_TCTRL2_TRG_SRC(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL2_REG(base), LPIT_TCTRL2_TRG_SRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL2, field TRG_SEL[27:24] (RW)
 *
 * Selects the trigger to use for starting and/or reloading the LPIT timer. This
 * field should only be changed when the LPIT timer channel is disabled. The
 * TRG_SRC bit selects between internal and external trigger signals for each
 * channel. The TRG_SEL bits select one trigger from the set of internal or external
 * triggers selected by TRG_SRC.
 *
 * Values:
 * - 0b0000 - Timer channel 0 trigger source is selected
 * - 0b0001 - Timer channel 1 trigger source is selected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL2_TRG_SEL field. */
#define LPIT_RD_TCTRL2_TRG_SEL(base) ((LPIT_TCTRL2_REG(base) & LPIT_TCTRL2_TRG_SEL_MASK) >> LPIT_TCTRL2_TRG_SEL_SHIFT)
#define LPIT_BRD_TCTRL2_TRG_SEL(base) (LPIT_RD_TCTRL2_TRG_SEL(base))

/*! @brief Set the TRG_SEL field to a new value. */
#define LPIT_WR_TCTRL2_TRG_SEL(base, value) (LPIT_RMW_TCTRL2(base, LPIT_TCTRL2_TRG_SEL_MASK, LPIT_TCTRL2_TRG_SEL(value)))
#define LPIT_BWR_TCTRL2_TRG_SEL(base, value) (LPIT_WR_TCTRL2_TRG_SEL(base, value))
/*@}*/

/*******************************************************************************
 * LPIT_RFU2 - Reserved for Future Use
 ******************************************************************************/

/*!
 * @brief LPIT_RFU2 - Reserved for Future Use (ROZ)
 *
 * Reset value: 0x00000000U
 *
 * This register location is reserved for future use.
 */
/*!
 * @name Constants and macros for entire LPIT_RFU2 register
 */
/*@{*/
#define LPIT_RD_RFU2(base)       (LPIT_RFU2_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TVAL3 - Timer Value Register
 ******************************************************************************/

/*!
 * @brief LPIT_TVAL3 - Timer Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * In compare modes, these registers select the timeout period for the timer
 * channels. In capture modes, these registers are loaded with the value of the
 * counter when the trigger asserts.
 */
/*!
 * @name Constants and macros for entire LPIT_TVAL3 register
 */
/*@{*/
#define LPIT_RD_TVAL3(base)      (LPIT_TVAL3_REG(base))
#define LPIT_WR_TVAL3(base, value) (LPIT_TVAL3_REG(base) = (value))
#define LPIT_RMW_TVAL3(base, mask, value) (LPIT_WR_TVAL3(base, (LPIT_RD_TVAL3(base) & ~(mask)) | (value)))
#define LPIT_SET_TVAL3(base, value) (LPIT_WR_TVAL3(base, LPIT_RD_TVAL3(base) |  (value)))
#define LPIT_CLR_TVAL3(base, value) (LPIT_WR_TVAL3(base, LPIT_RD_TVAL3(base) & ~(value)))
#define LPIT_TOG_TVAL3(base, value) (LPIT_WR_TVAL3(base, LPIT_RD_TVAL3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * LPIT_CVAL3 - Current Timer Value
 ******************************************************************************/

/*!
 * @brief LPIT_CVAL3 - Current Timer Value (RO)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * These registers indicate the current timer counter value.
 */
/*!
 * @name Constants and macros for entire LPIT_CVAL3 register
 */
/*@{*/
#define LPIT_RD_CVAL3(base)      (LPIT_CVAL3_REG(base))
/*@}*/

/*******************************************************************************
 * LPIT_TCTRL3 - Timer Control Register
 ******************************************************************************/

/*!
 * @brief LPIT_TCTRL3 - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer channel
 */
/*!
 * @name Constants and macros for entire LPIT_TCTRL3 register
 */
/*@{*/
#define LPIT_RD_TCTRL3(base)     (LPIT_TCTRL3_REG(base))
#define LPIT_WR_TCTRL3(base, value) (LPIT_TCTRL3_REG(base) = (value))
#define LPIT_RMW_TCTRL3(base, mask, value) (LPIT_WR_TCTRL3(base, (LPIT_RD_TCTRL3(base) & ~(mask)) | (value)))
#define LPIT_SET_TCTRL3(base, value) (LPIT_WR_TCTRL3(base, LPIT_RD_TCTRL3(base) |  (value)))
#define LPIT_CLR_TCTRL3(base, value) (LPIT_WR_TCTRL3(base, LPIT_RD_TCTRL3(base) & ~(value)))
#define LPIT_TOG_TCTRL3(base, value) (LPIT_WR_TCTRL3(base, LPIT_RD_TCTRL3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_TCTRL3 bitfields
 */

/*!
 * @name Register LPIT_TCTRL3, field T_EN[0] (RW)
 *
 * Enables or disables the Timer Channel
 *
 * Values:
 * - 0b0 - Timer Channel is disabled
 * - 0b1 - Timer Channel is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_T_EN field. */
#define LPIT_RD_TCTRL3_T_EN(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_T_EN_MASK) >> LPIT_TCTRL3_T_EN_SHIFT)
#define LPIT_BRD_TCTRL3_T_EN(base) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_T_EN_SHIFT))

/*! @brief Set the T_EN field to a new value. */
#define LPIT_WR_TCTRL3_T_EN(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_T_EN_MASK, LPIT_TCTRL3_T_EN(value)))
#define LPIT_BWR_TCTRL3_T_EN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_T_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL3, field CHAIN[1] (RW)
 *
 * When enabled, timer channel will decrement when channel N-1 trigger asserts.
 * Channel 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Channel Chaining is disabled. Channel Timer runs independently.
 * - 0b1 - Channel Chaining is enabled. Timer decrements on previous channel's
 *     timeout
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_CHAIN field. */
#define LPIT_RD_TCTRL3_CHAIN(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_CHAIN_MASK) >> LPIT_TCTRL3_CHAIN_SHIFT)
#define LPIT_BRD_TCTRL3_CHAIN(base) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_CHAIN_SHIFT))

/*! @brief Set the CHAIN field to a new value. */
#define LPIT_WR_TCTRL3_CHAIN(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_CHAIN_MASK, LPIT_TCTRL3_CHAIN(value)))
#define LPIT_BWR_TCTRL3_CHAIN(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_CHAIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL3, field MODE[3:2] (RW)
 *
 * Configures the Channel Timer Mode of Operation. The mode bits control how the
 * timer decrements. See Functional Description for more details.
 *
 * Values:
 * - 0b00 - 32-bit Periodic Counter
 * - 0b01 - Dual 16-bit Periodic Counter
 * - 0b10 - 32-bit Trigger Accumulator
 * - 0b11 - 32-bit Trigger Input Capture
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_MODE field. */
#define LPIT_RD_TCTRL3_MODE(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_MODE_MASK) >> LPIT_TCTRL3_MODE_SHIFT)
#define LPIT_BRD_TCTRL3_MODE(base) (LPIT_RD_TCTRL3_MODE(base))

/*! @brief Set the MODE field to a new value. */
#define LPIT_WR_TCTRL3_MODE(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_MODE_MASK, LPIT_TCTRL3_MODE(value)))
#define LPIT_BWR_TCTRL3_MODE(base, value) (LPIT_WR_TCTRL3_MODE(base, value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL3, field TSOT[16] (RW)
 *
 * This bit controls when the timer starts decrementing.
 *
 * Values:
 * - 0b0 - Timer starts to decrement immediately based on restart condition
 *     (controlled by TSOI bit)
 * - 0b1 - Timer starts to decrement when rising edge on selected trigger is
 *     detected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_TSOT field. */
#define LPIT_RD_TCTRL3_TSOT(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_TSOT_MASK) >> LPIT_TCTRL3_TSOT_SHIFT)
#define LPIT_BRD_TCTRL3_TSOT(base) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TSOT_SHIFT))

/*! @brief Set the TSOT field to a new value. */
#define LPIT_WR_TCTRL3_TSOT(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_TSOT_MASK, LPIT_TCTRL3_TSOT(value)))
#define LPIT_BWR_TCTRL3_TSOT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TSOT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL3, field TSOI[17] (RW)
 *
 * This bit controls whether the channel timer will stop after it times out and
 * when it can restart (when TSOT = 0). If TSOT = 1, then the timer will stop on
 * timeout and will restart after a rising edge on the selected trigger is
 * detected. If TSOT = 0, then this bit controls when the timer restarts.
 *
 * Values:
 * - 0b0 - Timer does not stop after timeout
 * - 0b1 - Timer will stop after timeout and will restart after rising edge on
 *     the T_EN bit is detected (i.e. timer channel is disabled and then enabled)
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_TSOI field. */
#define LPIT_RD_TCTRL3_TSOI(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_TSOI_MASK) >> LPIT_TCTRL3_TSOI_SHIFT)
#define LPIT_BRD_TCTRL3_TSOI(base) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TSOI_SHIFT))

/*! @brief Set the TSOI field to a new value. */
#define LPIT_WR_TCTRL3_TSOI(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_TSOI_MASK, LPIT_TCTRL3_TSOI(value)))
#define LPIT_BWR_TCTRL3_TSOI(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TSOI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL3, field TROT[18] (RW)
 *
 * When set, the LPIT timer will reload when a rising edge is detected on the
 * selected trigger input. The trigger input is ignored if the LPIT is disabled
 * during debug mode or DOZE mode (DOZE_EN or DBGEN = 0)
 *
 * Values:
 * - 0b0 - Timer will not reload on selected trigger
 * - 0b1 - Timer will reload on selected trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_TROT field. */
#define LPIT_RD_TCTRL3_TROT(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_TROT_MASK) >> LPIT_TCTRL3_TROT_SHIFT)
#define LPIT_BRD_TCTRL3_TROT(base) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TROT_SHIFT))

/*! @brief Set the TROT field to a new value. */
#define LPIT_WR_TCTRL3_TROT(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_TROT_MASK, LPIT_TCTRL3_TROT(value)))
#define LPIT_BWR_TCTRL3_TROT(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TROT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL3, field TRG_SRC[23] (RW)
 *
 * Selects between internal or external trigger sources. The final trigger is
 * selected by TRG_SEL depending on which trigger source out of internal triggers
 * or external triggers are selected by TRG_SRC. Refer to the chip configuration
 * section for available external trigger options. If a channel does not have an
 * associated external trigger then this bit for that channel should be set to 1.
 *
 * Values:
 * - 0b0 - Trigger source selected in external
 * - 0b1 - Trigger source selected is the internal trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_TRG_SRC field. */
#define LPIT_RD_TCTRL3_TRG_SRC(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_TRG_SRC_MASK) >> LPIT_TCTRL3_TRG_SRC_SHIFT)
#define LPIT_BRD_TCTRL3_TRG_SRC(base) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TRG_SRC_SHIFT))

/*! @brief Set the TRG_SRC field to a new value. */
#define LPIT_WR_TCTRL3_TRG_SRC(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_TRG_SRC_MASK, LPIT_TCTRL3_TRG_SRC(value)))
#define LPIT_BWR_TCTRL3_TRG_SRC(base, value) (BITBAND_ACCESS32(&LPIT_TCTRL3_REG(base), LPIT_TCTRL3_TRG_SRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPIT_TCTRL3, field TRG_SEL[27:24] (RW)
 *
 * Selects the trigger to use for starting and/or reloading the LPIT timer. This
 * field should only be changed when the LPIT timer channel is disabled. The
 * TRG_SRC bit selects between internal and external trigger signals for each
 * channel. The TRG_SEL bits select one trigger from the set of internal or external
 * triggers selected by TRG_SRC.
 *
 * Values:
 * - 0b0000 - Timer channel 0 trigger source is selected
 * - 0b0001 - Timer channel 1 trigger source is selected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL3_TRG_SEL field. */
#define LPIT_RD_TCTRL3_TRG_SEL(base) ((LPIT_TCTRL3_REG(base) & LPIT_TCTRL3_TRG_SEL_MASK) >> LPIT_TCTRL3_TRG_SEL_SHIFT)
#define LPIT_BRD_TCTRL3_TRG_SEL(base) (LPIT_RD_TCTRL3_TRG_SEL(base))

/*! @brief Set the TRG_SEL field to a new value. */
#define LPIT_WR_TCTRL3_TRG_SEL(base, value) (LPIT_RMW_TCTRL3(base, LPIT_TCTRL3_TRG_SEL_MASK, LPIT_TCTRL3_TRG_SEL(value)))
#define LPIT_BWR_TCTRL3_TRG_SEL(base, value) (LPIT_WR_TCTRL3_TRG_SEL(base, value))
/*@}*/

/*******************************************************************************
 * LPIT_RFU3 - Reserved for Future Use
 ******************************************************************************/

/*!
 * @brief LPIT_RFU3 - Reserved for Future Use (ROZ)
 *
 * Reset value: 0x00000000U
 *
 * This register location is reserved for future use.
 */
/*!
 * @name Constants and macros for entire LPIT_RFU3 register
 */
/*@{*/
#define LPIT_RD_RFU3(base)       (LPIT_RFU3_REG(base))
/*@}*/

/*
 * S32K144 LPSPI
 *
 * The LPSPI Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - LPSPI_VERID - Version ID Register
 * - LPSPI_PARAM - Parameter Register
 * - LPSPI_CR - Control Register
 * - LPSPI_SR - Status Register
 * - LPSPI_IER - Interrupt Enable Register
 * - LPSPI_DER - DMA Enable Register
 * - LPSPI_CFGR0 - Configuration Register 0
 * - LPSPI_CFGR1 - Configuration Register 1
 * - LPSPI_DMR0 - Data Match Register 0
 * - LPSPI_DMR1 - Data Match Register 1
 * - LPSPI_CCR - Clock Configuration Register
 * - LPSPI_FCR - FIFO Control Register
 * - LPSPI_FSR - FIFO Status Register
 * - LPSPI_TCR - Transmit Command Register
 * - LPSPI_TDR - Transmit Data Register
 * - LPSPI_RSR - Receive Status Register
 * - LPSPI_RDR - Receive Data Register
 */

#define LPSPI_INSTANCE_COUNT (3U) /*!< Number of instances of the LPSPI module. */
#define LPSPI0_IDX (0U) /*!< Instance number for LPSPI0. */
#define LPSPI1_IDX (1U) /*!< Instance number for LPSPI1. */
#define LPSPI2_IDX (2U) /*!< Instance number for LPSPI2. */

/*******************************************************************************
 * LPSPI_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPSPI_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000004U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPSPI_VERID register
 */
/*@{*/
#define LPSPI_RD_VERID(base)     (LPSPI_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_VERID bitfields
 */

/*!
 * @name Register LPSPI_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000100 - Standard feature set supporting 32-bit shift register.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_VERID_FEATURE field. */
#define LPSPI_RD_VERID_FEATURE(base) ((LPSPI_VERID_REG(base) & LPSPI_VERID_FEATURE_MASK) >> LPSPI_VERID_FEATURE_SHIFT)
#define LPSPI_BRD_VERID_FEATURE(base) (LPSPI_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPSPI_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_VERID_MINOR field. */
#define LPSPI_RD_VERID_MINOR(base) ((LPSPI_VERID_REG(base) & LPSPI_VERID_MINOR_MASK) >> LPSPI_VERID_MINOR_SHIFT)
#define LPSPI_BRD_VERID_MINOR(base) (LPSPI_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register LPSPI_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_VERID_MAJOR field. */
#define LPSPI_RD_VERID_MAJOR(base) ((LPSPI_VERID_REG(base) & LPSPI_VERID_MAJOR_MASK) >> LPSPI_VERID_MAJOR_SHIFT)
#define LPSPI_BRD_VERID_MAJOR(base) (LPSPI_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * LPSPI_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPSPI_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000202U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPSPI_PARAM register
 */
/*@{*/
#define LPSPI_RD_PARAM(base)     (LPSPI_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_PARAM bitfields
 */

/*!
 * @name Register LPSPI_PARAM, field TXFIFO[7:0] (RO)
 *
 * The number of words in the transmit FIFO is 2**TXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_PARAM_TXFIFO field. */
#define LPSPI_RD_PARAM_TXFIFO(base) ((LPSPI_PARAM_REG(base) & LPSPI_PARAM_TXFIFO_MASK) >> LPSPI_PARAM_TXFIFO_SHIFT)
#define LPSPI_BRD_PARAM_TXFIFO(base) (LPSPI_RD_PARAM_TXFIFO(base))
/*@}*/

/*!
 * @name Register LPSPI_PARAM, field RXFIFO[15:8] (RO)
 *
 * The number of words in the receive FIFO is 2**RXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_PARAM_RXFIFO field. */
#define LPSPI_RD_PARAM_RXFIFO(base) ((LPSPI_PARAM_REG(base) & LPSPI_PARAM_RXFIFO_MASK) >> LPSPI_PARAM_RXFIFO_SHIFT)
#define LPSPI_BRD_PARAM_RXFIFO(base) (LPSPI_RD_PARAM_RXFIFO(base))
/*@}*/

/*******************************************************************************
 * LPSPI_CR - Control Register
 ******************************************************************************/

/*!
 * @brief LPSPI_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_CR register
 */
/*@{*/
#define LPSPI_RD_CR(base)        (LPSPI_CR_REG(base))
#define LPSPI_WR_CR(base, value) (LPSPI_CR_REG(base) = (value))
#define LPSPI_RMW_CR(base, mask, value) (LPSPI_WR_CR(base, (LPSPI_RD_CR(base) & ~(mask)) | (value)))
#define LPSPI_SET_CR(base, value) (LPSPI_WR_CR(base, LPSPI_RD_CR(base) |  (value)))
#define LPSPI_CLR_CR(base, value) (LPSPI_WR_CR(base, LPSPI_RD_CR(base) & ~(value)))
#define LPSPI_TOG_CR(base, value) (LPSPI_WR_CR(base, LPSPI_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CR bitfields
 */

/*!
 * @name Register LPSPI_CR, field MEN[0] (RW)
 *
 * Values:
 * - 0b0 - Module is disabled.
 * - 0b1 - Module is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_MEN field. */
#define LPSPI_RD_CR_MEN(base) ((LPSPI_CR_REG(base) & LPSPI_CR_MEN_MASK) >> LPSPI_CR_MEN_SHIFT)
#define LPSPI_BRD_CR_MEN(base) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_MEN_SHIFT))

/*! @brief Set the MEN field to a new value. */
#define LPSPI_WR_CR_MEN(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_MEN_MASK, LPSPI_CR_MEN(value)))
#define LPSPI_BWR_CR_MEN(base, value) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_MEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CR, field RST[1] (RW)
 *
 * Reset all internal logic and registers, except the Control Register. Remains
 * set until cleared by software.
 *
 * Values:
 * - 0b0 - Master logic is not reset.
 * - 0b1 - Master logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_RST field. */
#define LPSPI_RD_CR_RST(base) ((LPSPI_CR_REG(base) & LPSPI_CR_RST_MASK) >> LPSPI_CR_RST_SHIFT)
#define LPSPI_BRD_CR_RST(base) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_RST_SHIFT))

/*! @brief Set the RST field to a new value. */
#define LPSPI_WR_CR_RST(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_RST_MASK, LPSPI_CR_RST(value)))
#define LPSPI_BWR_CR_RST(base, value) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_RST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CR, field DOZEN[2] (RW)
 *
 * Enables or disables Doze mode
 *
 * Values:
 * - 0b0 - Module is enabled in Doze mode.
 * - 0b1 - Module is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_DOZEN field. */
#define LPSPI_RD_CR_DOZEN(base) ((LPSPI_CR_REG(base) & LPSPI_CR_DOZEN_MASK) >> LPSPI_CR_DOZEN_SHIFT)
#define LPSPI_BRD_CR_DOZEN(base) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_DOZEN_SHIFT))

/*! @brief Set the DOZEN field to a new value. */
#define LPSPI_WR_CR_DOZEN(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_DOZEN_MASK, LPSPI_CR_DOZEN(value)))
#define LPSPI_BWR_CR_DOZEN(base, value) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_DOZEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CR, field DBGEN[3] (RW)
 *
 * Values:
 * - 0b0 - Module is disabled in debug mode.
 * - 0b1 - Module is enabled in debug mode.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_DBGEN field. */
#define LPSPI_RD_CR_DBGEN(base) ((LPSPI_CR_REG(base) & LPSPI_CR_DBGEN_MASK) >> LPSPI_CR_DBGEN_SHIFT)
#define LPSPI_BRD_CR_DBGEN(base) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_DBGEN_SHIFT))

/*! @brief Set the DBGEN field to a new value. */
#define LPSPI_WR_CR_DBGEN(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_DBGEN_MASK, LPSPI_CR_DBGEN(value)))
#define LPSPI_BWR_CR_DBGEN(base, value) (BITBAND_ACCESS32(&LPSPI_CR_REG(base), LPSPI_CR_DBGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CR, field RTF[8] (WO)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Transmit FIFO is reset.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPSPI_WR_CR_RTF(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_RTF_MASK, LPSPI_CR_RTF(value)))
#define LPSPI_BWR_CR_RTF(base, value) (LPSPI_WR_CR_RTF(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CR, field RRF[9] (WO)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Receive FIFO is reset.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPSPI_WR_CR_RRF(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_RRF_MASK, LPSPI_CR_RRF(value)))
#define LPSPI_BWR_CR_RRF(base, value) (LPSPI_WR_CR_RRF(base, value))
/*@}*/

/*******************************************************************************
 * LPSPI_SR - Status Register
 ******************************************************************************/

/*!
 * @brief LPSPI_SR - Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire LPSPI_SR register
 */
/*@{*/
#define LPSPI_RD_SR(base)        (LPSPI_SR_REG(base))
#define LPSPI_WR_SR(base, value) (LPSPI_SR_REG(base) = (value))
#define LPSPI_RMW_SR(base, mask, value) (LPSPI_WR_SR(base, (LPSPI_RD_SR(base) & ~(mask)) | (value)))
#define LPSPI_SET_SR(base, value) (LPSPI_WR_SR(base, LPSPI_RD_SR(base) |  (value)))
#define LPSPI_CLR_SR(base, value) (LPSPI_WR_SR(base, LPSPI_RD_SR(base) & ~(value)))
#define LPSPI_TOG_SR(base, value) (LPSPI_WR_SR(base, LPSPI_RD_SR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_SR bitfields
 */

/*!
 * @name Register LPSPI_SR, field TDF[0] (RO)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER.
 *
 * Values:
 * - 0b0 - Transmit data not requested.
 * - 0b1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_TDF field. */
#define LPSPI_RD_SR_TDF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_TDF_MASK) >> LPSPI_SR_TDF_SHIFT)
#define LPSPI_BRD_SR_TDF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_TDF_SHIFT))
/*@}*/

/*!
 * @name Register LPSPI_SR, field RDF[1] (RO)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER.
 *
 * Values:
 * - 0b0 - Receive Data is not ready.
 * - 0b1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_RDF field. */
#define LPSPI_RD_SR_RDF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_RDF_MASK) >> LPSPI_SR_RDF_SHIFT)
#define LPSPI_BRD_SR_RDF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_RDF_SHIFT))
/*@}*/

/*!
 * @name Register LPSPI_SR, field WCF[8] (W1C)
 *
 * This flag will set when the last bit of a received word is sampled.
 *
 * Values:
 * - 0b0 - Transfer word not completed.
 * - 0b1 - Transfer word completed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_WCF field. */
#define LPSPI_RD_SR_WCF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_WCF_MASK) >> LPSPI_SR_WCF_SHIFT)
#define LPSPI_BRD_SR_WCF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_WCF_SHIFT))

/*! @brief Set the WCF field to a new value. */
#define LPSPI_WR_SR_WCF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_WCF(value)))
#define LPSPI_BWR_SR_WCF(base, value) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_WCF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_SR, field FCF[9] (W1C)
 *
 * This flag will set at the end of each frame transfer, when the PCS negates.
 *
 * Values:
 * - 0b0 - Frame transfer has not completed.
 * - 0b1 - Frame transfer has completed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_FCF field. */
#define LPSPI_RD_SR_FCF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_FCF_MASK) >> LPSPI_SR_FCF_SHIFT)
#define LPSPI_BRD_SR_FCF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_FCF_SHIFT))

/*! @brief Set the FCF field to a new value. */
#define LPSPI_WR_SR_FCF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_FCF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_FCF(value)))
#define LPSPI_BWR_SR_FCF(base, value) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_FCF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_SR, field TCF[10] (W1C)
 *
 * This flag will set in master mode when the LPSPI returns to idle state with
 * the transmit FIFO empty.
 *
 * Values:
 * - 0b0 - All transfers have not completed.
 * - 0b1 - All transfers have completed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_TCF field. */
#define LPSPI_RD_SR_TCF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_TCF_MASK) >> LPSPI_SR_TCF_SHIFT)
#define LPSPI_BRD_SR_TCF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_TCF_SHIFT))

/*! @brief Set the TCF field to a new value. */
#define LPSPI_WR_SR_TCF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_TCF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_TCF(value)))
#define LPSPI_BWR_SR_TCF(base, value) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_TCF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_SR, field TEF[11] (W1C)
 *
 * This flag will set when the Transmit FIFO underruns.
 *
 * Values:
 * - 0b0 - Transmit FIFO underrun has not occurred.
 * - 0b1 - Transmit FIFO underrun has occurred
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_TEF field. */
#define LPSPI_RD_SR_TEF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_TEF_MASK) >> LPSPI_SR_TEF_SHIFT)
#define LPSPI_BRD_SR_TEF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_TEF_SHIFT))

/*! @brief Set the TEF field to a new value. */
#define LPSPI_WR_SR_TEF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_TEF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_TEF(value)))
#define LPSPI_BWR_SR_TEF(base, value) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_TEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_SR, field REF[12] (W1C)
 *
 * This flag will set when the Receiver FIFO overflows.
 *
 * Values:
 * - 0b0 - Receive FIFO has not overflowed.
 * - 0b1 - Receive FIFO has overflowed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_REF field. */
#define LPSPI_RD_SR_REF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_REF_MASK) >> LPSPI_SR_REF_SHIFT)
#define LPSPI_BRD_SR_REF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_REF_SHIFT))

/*! @brief Set the REF field to a new value. */
#define LPSPI_WR_SR_REF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_REF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_REF(value)))
#define LPSPI_BWR_SR_REF(base, value) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_REF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_SR, field DMF[13] (W1C)
 *
 * Indicates that the received data has matched the MATCH0 and/or MATCH1 fields
 * as configured by MATCFG.
 *
 * Values:
 * - 0b0 - Have not received matching data.
 * - 0b1 - Have received matching data.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_DMF field. */
#define LPSPI_RD_SR_DMF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_DMF_MASK) >> LPSPI_SR_DMF_SHIFT)
#define LPSPI_BRD_SR_DMF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_DMF_SHIFT))

/*! @brief Set the DMF field to a new value. */
#define LPSPI_WR_SR_DMF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_DMF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK), LPSPI_SR_DMF(value)))
#define LPSPI_BWR_SR_DMF(base, value) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_DMF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_SR, field MBF[24] (RO)
 *
 * Values:
 * - 0b0 - LPSPI is idle.
 * - 0b1 - LPSPI is busy.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_MBF field. */
#define LPSPI_RD_SR_MBF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_MBF_MASK) >> LPSPI_SR_MBF_SHIFT)
#define LPSPI_BRD_SR_MBF(base) (BITBAND_ACCESS32(&LPSPI_SR_REG(base), LPSPI_SR_MBF_SHIFT))
/*@}*/

/*******************************************************************************
 * LPSPI_IER - Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPSPI_IER - Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_IER register
 */
/*@{*/
#define LPSPI_RD_IER(base)       (LPSPI_IER_REG(base))
#define LPSPI_WR_IER(base, value) (LPSPI_IER_REG(base) = (value))
#define LPSPI_RMW_IER(base, mask, value) (LPSPI_WR_IER(base, (LPSPI_RD_IER(base) & ~(mask)) | (value)))
#define LPSPI_SET_IER(base, value) (LPSPI_WR_IER(base, LPSPI_RD_IER(base) |  (value)))
#define LPSPI_CLR_IER(base, value) (LPSPI_WR_IER(base, LPSPI_RD_IER(base) & ~(value)))
#define LPSPI_TOG_IER(base, value) (LPSPI_WR_IER(base, LPSPI_RD_IER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_IER bitfields
 */

/*!
 * @name Register LPSPI_IER, field TDIE[0] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_TDIE field. */
#define LPSPI_RD_IER_TDIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_TDIE_MASK) >> LPSPI_IER_TDIE_SHIFT)
#define LPSPI_BRD_IER_TDIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_TDIE_SHIFT))

/*! @brief Set the TDIE field to a new value. */
#define LPSPI_WR_IER_TDIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_TDIE_MASK, LPSPI_IER_TDIE(value)))
#define LPSPI_BWR_IER_TDIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_TDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_IER, field RDIE[1] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_RDIE field. */
#define LPSPI_RD_IER_RDIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_RDIE_MASK) >> LPSPI_IER_RDIE_SHIFT)
#define LPSPI_BRD_IER_RDIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_RDIE_SHIFT))

/*! @brief Set the RDIE field to a new value. */
#define LPSPI_WR_IER_RDIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_RDIE_MASK, LPSPI_IER_RDIE(value)))
#define LPSPI_BWR_IER_RDIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_RDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_IER, field WCIE[8] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_WCIE field. */
#define LPSPI_RD_IER_WCIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_WCIE_MASK) >> LPSPI_IER_WCIE_SHIFT)
#define LPSPI_BRD_IER_WCIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_WCIE_SHIFT))

/*! @brief Set the WCIE field to a new value. */
#define LPSPI_WR_IER_WCIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_WCIE_MASK, LPSPI_IER_WCIE(value)))
#define LPSPI_BWR_IER_WCIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_WCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_IER, field FCIE[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_FCIE field. */
#define LPSPI_RD_IER_FCIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_FCIE_MASK) >> LPSPI_IER_FCIE_SHIFT)
#define LPSPI_BRD_IER_FCIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_FCIE_SHIFT))

/*! @brief Set the FCIE field to a new value. */
#define LPSPI_WR_IER_FCIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_FCIE_MASK, LPSPI_IER_FCIE(value)))
#define LPSPI_BWR_IER_FCIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_FCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_IER, field TCIE[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_TCIE field. */
#define LPSPI_RD_IER_TCIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_TCIE_MASK) >> LPSPI_IER_TCIE_SHIFT)
#define LPSPI_BRD_IER_TCIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_TCIE_SHIFT))

/*! @brief Set the TCIE field to a new value. */
#define LPSPI_WR_IER_TCIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_TCIE_MASK, LPSPI_IER_TCIE(value)))
#define LPSPI_BWR_IER_TCIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_TCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_IER, field TEIE[11] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_TEIE field. */
#define LPSPI_RD_IER_TEIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_TEIE_MASK) >> LPSPI_IER_TEIE_SHIFT)
#define LPSPI_BRD_IER_TEIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_TEIE_SHIFT))

/*! @brief Set the TEIE field to a new value. */
#define LPSPI_WR_IER_TEIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_TEIE_MASK, LPSPI_IER_TEIE(value)))
#define LPSPI_BWR_IER_TEIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_TEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_IER, field REIE[12] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_REIE field. */
#define LPSPI_RD_IER_REIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_REIE_MASK) >> LPSPI_IER_REIE_SHIFT)
#define LPSPI_BRD_IER_REIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_REIE_SHIFT))

/*! @brief Set the REIE field to a new value. */
#define LPSPI_WR_IER_REIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_REIE_MASK, LPSPI_IER_REIE(value)))
#define LPSPI_BWR_IER_REIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_REIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_IER, field DMIE[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_DMIE field. */
#define LPSPI_RD_IER_DMIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_DMIE_MASK) >> LPSPI_IER_DMIE_SHIFT)
#define LPSPI_BRD_IER_DMIE(base) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_DMIE_SHIFT))

/*! @brief Set the DMIE field to a new value. */
#define LPSPI_WR_IER_DMIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_DMIE_MASK, LPSPI_IER_DMIE(value)))
#define LPSPI_BWR_IER_DMIE(base, value) (BITBAND_ACCESS32(&LPSPI_IER_REG(base), LPSPI_IER_DMIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPSPI_DER - DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPSPI_DER - DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_DER register
 */
/*@{*/
#define LPSPI_RD_DER(base)       (LPSPI_DER_REG(base))
#define LPSPI_WR_DER(base, value) (LPSPI_DER_REG(base) = (value))
#define LPSPI_RMW_DER(base, mask, value) (LPSPI_WR_DER(base, (LPSPI_RD_DER(base) & ~(mask)) | (value)))
#define LPSPI_SET_DER(base, value) (LPSPI_WR_DER(base, LPSPI_RD_DER(base) |  (value)))
#define LPSPI_CLR_DER(base, value) (LPSPI_WR_DER(base, LPSPI_RD_DER(base) & ~(value)))
#define LPSPI_TOG_DER(base, value) (LPSPI_WR_DER(base, LPSPI_RD_DER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_DER bitfields
 */

/*!
 * @name Register LPSPI_DER, field TDDE[0] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPSPI_DER_TDDE field. */
#define LPSPI_RD_DER_TDDE(base) ((LPSPI_DER_REG(base) & LPSPI_DER_TDDE_MASK) >> LPSPI_DER_TDDE_SHIFT)
#define LPSPI_BRD_DER_TDDE(base) (BITBAND_ACCESS32(&LPSPI_DER_REG(base), LPSPI_DER_TDDE_SHIFT))

/*! @brief Set the TDDE field to a new value. */
#define LPSPI_WR_DER_TDDE(base, value) (LPSPI_RMW_DER(base, LPSPI_DER_TDDE_MASK, LPSPI_DER_TDDE(value)))
#define LPSPI_BWR_DER_TDDE(base, value) (BITBAND_ACCESS32(&LPSPI_DER_REG(base), LPSPI_DER_TDDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_DER, field RDDE[1] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_DER_RDDE field. */
#define LPSPI_RD_DER_RDDE(base) ((LPSPI_DER_REG(base) & LPSPI_DER_RDDE_MASK) >> LPSPI_DER_RDDE_SHIFT)
#define LPSPI_BRD_DER_RDDE(base) (BITBAND_ACCESS32(&LPSPI_DER_REG(base), LPSPI_DER_RDDE_SHIFT))

/*! @brief Set the RDDE field to a new value. */
#define LPSPI_WR_DER_RDDE(base, value) (LPSPI_RMW_DER(base, LPSPI_DER_RDDE_MASK, LPSPI_DER_RDDE(value)))
#define LPSPI_BWR_DER_RDDE(base, value) (BITBAND_ACCESS32(&LPSPI_DER_REG(base), LPSPI_DER_RDDE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPSPI_CFGR0 - Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPSPI_CFGR0 - Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_CFGR0 register
 */
/*@{*/
#define LPSPI_RD_CFGR0(base)     (LPSPI_CFGR0_REG(base))
#define LPSPI_WR_CFGR0(base, value) (LPSPI_CFGR0_REG(base) = (value))
#define LPSPI_RMW_CFGR0(base, mask, value) (LPSPI_WR_CFGR0(base, (LPSPI_RD_CFGR0(base) & ~(mask)) | (value)))
#define LPSPI_SET_CFGR0(base, value) (LPSPI_WR_CFGR0(base, LPSPI_RD_CFGR0(base) |  (value)))
#define LPSPI_CLR_CFGR0(base, value) (LPSPI_WR_CFGR0(base, LPSPI_RD_CFGR0(base) & ~(value)))
#define LPSPI_TOG_CFGR0(base, value) (LPSPI_WR_CFGR0(base, LPSPI_RD_CFGR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CFGR0 bitfields
 */

/*!
 * @name Register LPSPI_CFGR0, field HREN[0] (RW)
 *
 * When enabled in master mode, the LPSPI will only initiate a SPI bus transfer
 * if the host request input is asserted.
 *
 * Values:
 * - 0b0 - Host request is disabled.
 * - 0b1 - Host request is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_HREN field. */
#define LPSPI_RD_CFGR0_HREN(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_HREN_MASK) >> LPSPI_CFGR0_HREN_SHIFT)
#define LPSPI_BRD_CFGR0_HREN(base) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HREN_SHIFT))

/*! @brief Set the HREN field to a new value. */
#define LPSPI_WR_CFGR0_HREN(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_HREN_MASK, LPSPI_CFGR0_HREN(value)))
#define LPSPI_BWR_CFGR0_HREN(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field HRPOL[1] (RW)
 *
 * Configures the polarity of the host request pin.
 *
 * Values:
 * - 0b0 - Active low.
 * - 0b1 - Active high.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_HRPOL field. */
#define LPSPI_RD_CFGR0_HRPOL(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_HRPOL_MASK) >> LPSPI_CFGR0_HRPOL_SHIFT)
#define LPSPI_BRD_CFGR0_HRPOL(base) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HRPOL_SHIFT))

/*! @brief Set the HRPOL field to a new value. */
#define LPSPI_WR_CFGR0_HRPOL(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_HRPOL_MASK, LPSPI_CFGR0_HRPOL(value)))
#define LPSPI_BWR_CFGR0_HRPOL(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HRPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field HRSEL[2] (RW)
 *
 * Selects the source of the host request input. When the host request function
 * is enabled with the LPSPI_HREQ pin, the LPSPI_PCS[1] function is disabled.
 *
 * Values:
 * - 0b0 - Host request input is pin LPSPI_HREQ.
 * - 0b1 - Host request input is input trigger.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_HRSEL field. */
#define LPSPI_RD_CFGR0_HRSEL(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_HRSEL_MASK) >> LPSPI_CFGR0_HRSEL_SHIFT)
#define LPSPI_BRD_CFGR0_HRSEL(base) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HRSEL_SHIFT))

/*! @brief Set the HRSEL field to a new value. */
#define LPSPI_WR_CFGR0_HRSEL(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_HRSEL_MASK, LPSPI_CFGR0_HRSEL(value)))
#define LPSPI_BWR_CFGR0_HRSEL(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HRSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field CIRFIFO[8] (RW)
 *
 * When enabled, the transmit FIFO read pointer is saved to a temporary
 * register. The transmit FIFO will be emptied as normal, but once the LPSPI is idle and
 * the transmit FIFO is empty, then the read pointer value will be restored from
 * the temporary register. This will cause the contents of the transmit FIFO to
 * be cycled through repeatedly.
 *
 * Values:
 * - 0b0 - Circular FIFO is disabled.
 * - 0b1 - Circular FIFO is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_CIRFIFO field. */
#define LPSPI_RD_CFGR0_CIRFIFO(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_CIRFIFO_MASK) >> LPSPI_CFGR0_CIRFIFO_SHIFT)
#define LPSPI_BRD_CFGR0_CIRFIFO(base) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_CIRFIFO_SHIFT))

/*! @brief Set the CIRFIFO field to a new value. */
#define LPSPI_WR_CFGR0_CIRFIFO(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_CIRFIFO_MASK, LPSPI_CFGR0_CIRFIFO(value)))
#define LPSPI_BWR_CFGR0_CIRFIFO(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_CIRFIFO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field RDMO[9] (RW)
 *
 * When enabled, all received data that does not cause DMF to set is discarded.
 * Once DMF is set, the RDMO configuration is ignored. When disabling RDMO, clear
 * RDMO before clearing DMF to ensure no receive data is lost.
 *
 * Values:
 * - 0b0 - Received data is stored in the receive FIFO as normal.
 * - 0b1 - Received data is discarded unless the DMF is set.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_RDMO field. */
#define LPSPI_RD_CFGR0_RDMO(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_RDMO_MASK) >> LPSPI_CFGR0_RDMO_SHIFT)
#define LPSPI_BRD_CFGR0_RDMO(base) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_RDMO_SHIFT))

/*! @brief Set the RDMO field to a new value. */
#define LPSPI_WR_CFGR0_RDMO(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_RDMO_MASK, LPSPI_CFGR0_RDMO(value)))
#define LPSPI_BWR_CFGR0_RDMO(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_RDMO_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPSPI_CFGR1 - Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPSPI_CFGR1 - Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CFGR1 should only be written when the LPSPI is disabled.
 */
/*!
 * @name Constants and macros for entire LPSPI_CFGR1 register
 */
/*@{*/
#define LPSPI_RD_CFGR1(base)     (LPSPI_CFGR1_REG(base))
#define LPSPI_WR_CFGR1(base, value) (LPSPI_CFGR1_REG(base) = (value))
#define LPSPI_RMW_CFGR1(base, mask, value) (LPSPI_WR_CFGR1(base, (LPSPI_RD_CFGR1(base) & ~(mask)) | (value)))
#define LPSPI_SET_CFGR1(base, value) (LPSPI_WR_CFGR1(base, LPSPI_RD_CFGR1(base) |  (value)))
#define LPSPI_CLR_CFGR1(base, value) (LPSPI_WR_CFGR1(base, LPSPI_RD_CFGR1(base) & ~(value)))
#define LPSPI_TOG_CFGR1(base, value) (LPSPI_WR_CFGR1(base, LPSPI_RD_CFGR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CFGR1 bitfields
 */

/*!
 * @name Register LPSPI_CFGR1, field MASTER[0] (RW)
 *
 * Configures the LPSPI in master or slave mode. This bit directly controls the
 * direction of the LPSPI_SCK and LPCPI_PCS pins.
 *
 * Values:
 * - 0b0 - Slave mode.
 * - 0b1 - Master mode.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_MASTER field. */
#define LPSPI_RD_CFGR1_MASTER(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_MASTER_MASK) >> LPSPI_CFGR1_MASTER_SHIFT)
#define LPSPI_BRD_CFGR1_MASTER(base) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_MASTER_SHIFT))

/*! @brief Set the MASTER field to a new value. */
#define LPSPI_WR_CFGR1_MASTER(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_MASTER_MASK, LPSPI_CFGR1_MASTER(value)))
#define LPSPI_BWR_CFGR1_MASTER(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_MASTER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field SAMPLE[1] (RW)
 *
 * When set, the LPSPI master will sample the input data on a delayed LPSPI_SCK
 * edge. This improves the setup time when sampling data. The input data setup
 * time in master mode with delayed LPSPI_SCK edge is equal to the input data setup
 * time in slave mode. This bit is ignored in slave mode.
 *
 * Values:
 * - 0b0 - Input data sampled on SCK edge.
 * - 0b1 - Input data sampled on delayed SCK edge.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_SAMPLE field. */
#define LPSPI_RD_CFGR1_SAMPLE(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_SAMPLE_MASK) >> LPSPI_CFGR1_SAMPLE_SHIFT)
#define LPSPI_BRD_CFGR1_SAMPLE(base) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_SAMPLE_SHIFT))

/*! @brief Set the SAMPLE field to a new value. */
#define LPSPI_WR_CFGR1_SAMPLE(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_SAMPLE_MASK, LPSPI_CFGR1_SAMPLE(value)))
#define LPSPI_BWR_CFGR1_SAMPLE(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_SAMPLE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field AUTOPCS[2] (RW)
 *
 * The LPSPI slave normally requires the PCS to negate between frames for
 * correct operation. Setting this bit will cause the LPSPI to generate an internal PCS
 * signal at the end of each transfer word when CPHA=1. When this bit is set,
 * the SCK must remain idle for at least 4 LPSPI functional clock cycles (divided
 * by PRESCALE configuration) between each word to ensure correct operation. This
 * bit is ignored in master mode.
 *
 * Values:
 * - 0b0 - Automatic PCS generation disabled.
 * - 0b1 - Automatic PCS generation enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_AUTOPCS field. */
#define LPSPI_RD_CFGR1_AUTOPCS(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_AUTOPCS_MASK) >> LPSPI_CFGR1_AUTOPCS_SHIFT)
#define LPSPI_BRD_CFGR1_AUTOPCS(base) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_AUTOPCS_SHIFT))

/*! @brief Set the AUTOPCS field to a new value. */
#define LPSPI_WR_CFGR1_AUTOPCS(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_AUTOPCS_MASK, LPSPI_CFGR1_AUTOPCS(value)))
#define LPSPI_BWR_CFGR1_AUTOPCS(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_AUTOPCS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field NOSTALL[3] (RW)
 *
 * In master mode, the LPSPI will stall transfers when the transmit FIFO is
 * empty or receive FIFO is full ensuring that no transmit FIFO underrun or receive
 * FIFO overrun can occur. Setting this bit will disable this functionality.
 *
 * Values:
 * - 0b0 - Transfers will stall when transmit FIFO is empty or receive FIFO is
 *     full.
 * - 0b1 - Transfers will not stall, allowing transmit FIFO underrun or receive
 *     FIFO overrun to occur.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_NOSTALL field. */
#define LPSPI_RD_CFGR1_NOSTALL(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_NOSTALL_MASK) >> LPSPI_CFGR1_NOSTALL_SHIFT)
#define LPSPI_BRD_CFGR1_NOSTALL(base) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_NOSTALL_SHIFT))

/*! @brief Set the NOSTALL field to a new value. */
#define LPSPI_WR_CFGR1_NOSTALL(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_NOSTALL_MASK, LPSPI_CFGR1_NOSTALL(value)))
#define LPSPI_BWR_CFGR1_NOSTALL(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_NOSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field PCSPOL[11:8] (RW)
 *
 * Configures the polarity of each Peripheral Chip Select pin.
 *
 * Values:
 * - 0b0000 - The PCSx is active low.
 * - 0b0001 - The PCSx is active high.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_PCSPOL field. */
#define LPSPI_RD_CFGR1_PCSPOL(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_PCSPOL_MASK) >> LPSPI_CFGR1_PCSPOL_SHIFT)
#define LPSPI_BRD_CFGR1_PCSPOL(base) (LPSPI_RD_CFGR1_PCSPOL(base))

/*! @brief Set the PCSPOL field to a new value. */
#define LPSPI_WR_CFGR1_PCSPOL(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_PCSPOL_MASK, LPSPI_CFGR1_PCSPOL(value)))
#define LPSPI_BWR_CFGR1_PCSPOL(base, value) (LPSPI_WR_CFGR1_PCSPOL(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field MATCFG[18:16] (RW)
 *
 * Configures the condition that will cause the DMF to set.
 *
 * Values:
 * - 0b000 - Match disabled.
 * - 0b001 - Reserved
 * - 0b010 - Match enabled (1st data word equals MATCH0 OR MATCH1).
 * - 0b011 - Match enabled (any data word equals MATCH0 OR MATCH1).
 * - 0b100 - Match enabled (1st data word equals MATCH0 AND 2nd data word equals
 *     MATCH1).
 * - 0b101 - Match enabled (any data word equals MATCH0 AND next data word
 *     equals MATCH1)
 * - 0b110 - Match enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1)
 * - 0b111 - Match enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1).
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_MATCFG field. */
#define LPSPI_RD_CFGR1_MATCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_MATCFG_MASK) >> LPSPI_CFGR1_MATCFG_SHIFT)
#define LPSPI_BRD_CFGR1_MATCFG(base) (LPSPI_RD_CFGR1_MATCFG(base))

/*! @brief Set the MATCFG field to a new value. */
#define LPSPI_WR_CFGR1_MATCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_MATCFG_MASK, LPSPI_CFGR1_MATCFG(value)))
#define LPSPI_BWR_CFGR1_MATCFG(base, value) (LPSPI_WR_CFGR1_MATCFG(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field PINCFG[25:24] (RW)
 *
 * Configures which pins are used for input and output data during single bit
 * transfers.
 *
 * Values:
 * - 0b00 - SIN is used for input data and SOUT for output data.
 * - 0b01 - SOUT is used for both input and output data.
 * - 0b10 - SDI is used for both input and output data.
 * - 0b11 - SOUT is used for input data and SIN for output data.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_PINCFG field. */
#define LPSPI_RD_CFGR1_PINCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_PINCFG_MASK) >> LPSPI_CFGR1_PINCFG_SHIFT)
#define LPSPI_BRD_CFGR1_PINCFG(base) (LPSPI_RD_CFGR1_PINCFG(base))

/*! @brief Set the PINCFG field to a new value. */
#define LPSPI_WR_CFGR1_PINCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_PINCFG_MASK, LPSPI_CFGR1_PINCFG(value)))
#define LPSPI_BWR_CFGR1_PINCFG(base, value) (LPSPI_WR_CFGR1_PINCFG(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field OUTCFG[26] (RW)
 *
 * Configures if the output data is tristated between accesses (LPSPI_PCS is
 * negated).
 *
 * Values:
 * - 0b0 - Output data retains last value when chip select is negated.
 * - 0b1 - Output data is tristated when chip select is negated.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_OUTCFG field. */
#define LPSPI_RD_CFGR1_OUTCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_OUTCFG_MASK) >> LPSPI_CFGR1_OUTCFG_SHIFT)
#define LPSPI_BRD_CFGR1_OUTCFG(base) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_OUTCFG_SHIFT))

/*! @brief Set the OUTCFG field to a new value. */
#define LPSPI_WR_CFGR1_OUTCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_OUTCFG_MASK, LPSPI_CFGR1_OUTCFG(value)))
#define LPSPI_BWR_CFGR1_OUTCFG(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_OUTCFG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field PCSCFG[27] (RW)
 *
 * PCSCFG must be set if performing 4-bit transfers.
 *
 * Values:
 * - 0b0 - PCS[3:2] are enabled.
 * - 0b1 - PCS[3:2] are disabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_PCSCFG field. */
#define LPSPI_RD_CFGR1_PCSCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_PCSCFG_MASK) >> LPSPI_CFGR1_PCSCFG_SHIFT)
#define LPSPI_BRD_CFGR1_PCSCFG(base) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_PCSCFG_SHIFT))

/*! @brief Set the PCSCFG field to a new value. */
#define LPSPI_WR_CFGR1_PCSCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_PCSCFG_MASK, LPSPI_CFGR1_PCSCFG(value)))
#define LPSPI_BWR_CFGR1_PCSCFG(base, value) (BITBAND_ACCESS32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_PCSCFG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPSPI_DMR0 - Data Match Register 0
 ******************************************************************************/

/*!
 * @brief LPSPI_DMR0 - Data Match Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_DMR0 register
 */
/*@{*/
#define LPSPI_RD_DMR0(base)      (LPSPI_DMR0_REG(base))
#define LPSPI_WR_DMR0(base, value) (LPSPI_DMR0_REG(base) = (value))
#define LPSPI_RMW_DMR0(base, mask, value) (LPSPI_WR_DMR0(base, (LPSPI_RD_DMR0(base) & ~(mask)) | (value)))
#define LPSPI_SET_DMR0(base, value) (LPSPI_WR_DMR0(base, LPSPI_RD_DMR0(base) |  (value)))
#define LPSPI_CLR_DMR0(base, value) (LPSPI_WR_DMR0(base, LPSPI_RD_DMR0(base) & ~(value)))
#define LPSPI_TOG_DMR0(base, value) (LPSPI_WR_DMR0(base, LPSPI_RD_DMR0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * LPSPI_DMR1 - Data Match Register 1
 ******************************************************************************/

/*!
 * @brief LPSPI_DMR1 - Data Match Register 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_DMR1 register
 */
/*@{*/
#define LPSPI_RD_DMR1(base)      (LPSPI_DMR1_REG(base))
#define LPSPI_WR_DMR1(base, value) (LPSPI_DMR1_REG(base) = (value))
#define LPSPI_RMW_DMR1(base, mask, value) (LPSPI_WR_DMR1(base, (LPSPI_RD_DMR1(base) & ~(mask)) | (value)))
#define LPSPI_SET_DMR1(base, value) (LPSPI_WR_DMR1(base, LPSPI_RD_DMR1(base) |  (value)))
#define LPSPI_CLR_DMR1(base, value) (LPSPI_WR_DMR1(base, LPSPI_RD_DMR1(base) & ~(value)))
#define LPSPI_TOG_DMR1(base, value) (LPSPI_WR_DMR1(base, LPSPI_RD_DMR1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * LPSPI_CCR - Clock Configuration Register
 ******************************************************************************/

/*!
 * @brief LPSPI_CCR - Clock Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CCR is only used in master mode and cannot be changed when the LPSPI is
 * enabled.
 */
/*!
 * @name Constants and macros for entire LPSPI_CCR register
 */
/*@{*/
#define LPSPI_RD_CCR(base)       (LPSPI_CCR_REG(base))
#define LPSPI_WR_CCR(base, value) (LPSPI_CCR_REG(base) = (value))
#define LPSPI_RMW_CCR(base, mask, value) (LPSPI_WR_CCR(base, (LPSPI_RD_CCR(base) & ~(mask)) | (value)))
#define LPSPI_SET_CCR(base, value) (LPSPI_WR_CCR(base, LPSPI_RD_CCR(base) |  (value)))
#define LPSPI_CLR_CCR(base, value) (LPSPI_WR_CCR(base, LPSPI_RD_CCR(base) & ~(value)))
#define LPSPI_TOG_CCR(base, value) (LPSPI_WR_CCR(base, LPSPI_RD_CCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CCR bitfields
 */

/*!
 * @name Register LPSPI_CCR, field SCKDIV[7:0] (RW)
 *
 * Configures the divide ratio of the SCK pin in master mode, from the LPSPI
 * baud rate clock. The SCK period is equal to SCKDIV+2 cycles of the LPSPI baud
 * rate clock and the minimum period is 2 cycles. If the period is an odd number of
 * cycles, then the first half of the period will be one cycle longer than the
 * second half. The LPSPI baud rate clock is itself divided by the PRESCALE
 * setting, which can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_SCKDIV field. */
#define LPSPI_RD_CCR_SCKDIV(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_SCKDIV_MASK) >> LPSPI_CCR_SCKDIV_SHIFT)
#define LPSPI_BRD_CCR_SCKDIV(base) (LPSPI_RD_CCR_SCKDIV(base))

/*! @brief Set the SCKDIV field to a new value. */
#define LPSPI_WR_CCR_SCKDIV(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_SCKDIV_MASK, LPSPI_CCR_SCKDIV(value)))
#define LPSPI_BWR_CCR_SCKDIV(base, value) (LPSPI_WR_CCR_SCKDIV(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CCR, field DBT[15:8] (RW)
 *
 * Configures the delay in master mode from the PCS negation to the next PCS
 * assertion. The delay is equal to (DBT + 2) cycles of the LPSPI baud rate clock
 * and the minimum delay is 2 cycles. Note that half the delay occurs before PCS
 * assertion and the other half occurs after PCS negation, the full command word
 * can only update in the middle. The LPSPI baud rate clock is itself divided by
 * the PRESCALE setting, which can vary between transfers. Also configures the
 * delay in master mode from the last SCK edge of a transfer word and the first SCK
 * edge of the next transfer word in a continuous transfer. The delay is equal to
 * (DBT + 1) cycles of the LPSPI baud rate clock and the minimum delay is 1
 * cycle. The LPSPI baud rate clock is itself divided by the PRESCALE setting, which
 * can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_DBT field. */
#define LPSPI_RD_CCR_DBT(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_DBT_MASK) >> LPSPI_CCR_DBT_SHIFT)
#define LPSPI_BRD_CCR_DBT(base) (LPSPI_RD_CCR_DBT(base))

/*! @brief Set the DBT field to a new value. */
#define LPSPI_WR_CCR_DBT(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_DBT_MASK, LPSPI_CCR_DBT(value)))
#define LPSPI_BWR_CCR_DBT(base, value) (LPSPI_WR_CCR_DBT(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CCR, field PCSSCK[23:16] (RW)
 *
 * Configures the delay in master mode from the PCS assertion to the first SCK
 * edge. The delay is equal to (PCSSCK + 1) cycles of the LPSPI baud rate clock
 * and the minimum delay is 1 cycle. The LPSPI baud rate clock is itself divided by
 * the PRESCALE setting, which can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_PCSSCK field. */
#define LPSPI_RD_CCR_PCSSCK(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_PCSSCK_MASK) >> LPSPI_CCR_PCSSCK_SHIFT)
#define LPSPI_BRD_CCR_PCSSCK(base) (LPSPI_RD_CCR_PCSSCK(base))

/*! @brief Set the PCSSCK field to a new value. */
#define LPSPI_WR_CCR_PCSSCK(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_PCSSCK_MASK, LPSPI_CCR_PCSSCK(value)))
#define LPSPI_BWR_CCR_PCSSCK(base, value) (LPSPI_WR_CCR_PCSSCK(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CCR, field SCKPCS[31:24] (RW)
 *
 * Configures the delay in master mode from the last SCK edge to the PCS
 * negation. The delay is equal to (PCSSCK + 1) cycles of the LPSPI baud rate clock and
 * the minimum delay is 1 cycle. The LPSPI baud rate clock is itself divided by
 * the PRESCALE setting, which can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_SCKPCS field. */
#define LPSPI_RD_CCR_SCKPCS(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_SCKPCS_MASK) >> LPSPI_CCR_SCKPCS_SHIFT)
#define LPSPI_BRD_CCR_SCKPCS(base) (LPSPI_RD_CCR_SCKPCS(base))

/*! @brief Set the SCKPCS field to a new value. */
#define LPSPI_WR_CCR_SCKPCS(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_SCKPCS_MASK, LPSPI_CCR_SCKPCS(value)))
#define LPSPI_BWR_CCR_SCKPCS(base, value) (LPSPI_WR_CCR_SCKPCS(base, value))
/*@}*/

/*******************************************************************************
 * LPSPI_FCR - FIFO Control Register
 ******************************************************************************/

/*!
 * @brief LPSPI_FCR - FIFO Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_FCR register
 */
/*@{*/
#define LPSPI_RD_FCR(base)       (LPSPI_FCR_REG(base))
#define LPSPI_WR_FCR(base, value) (LPSPI_FCR_REG(base) = (value))
#define LPSPI_RMW_FCR(base, mask, value) (LPSPI_WR_FCR(base, (LPSPI_RD_FCR(base) & ~(mask)) | (value)))
#define LPSPI_SET_FCR(base, value) (LPSPI_WR_FCR(base, LPSPI_RD_FCR(base) |  (value)))
#define LPSPI_CLR_FCR(base, value) (LPSPI_WR_FCR(base, LPSPI_RD_FCR(base) & ~(value)))
#define LPSPI_TOG_FCR(base, value) (LPSPI_WR_FCR(base, LPSPI_RD_FCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_FCR bitfields
 */

/*!
 * @name Register LPSPI_FCR, field TXWATER[7:0] (RW)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER. Writing a value equal or greater than the
 * FIFO size will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FCR_TXWATER field. */
#define LPSPI_RD_FCR_TXWATER(base) ((LPSPI_FCR_REG(base) & LPSPI_FCR_TXWATER_MASK) >> LPSPI_FCR_TXWATER_SHIFT)
#define LPSPI_BRD_FCR_TXWATER(base) (LPSPI_RD_FCR_TXWATER(base))

/*! @brief Set the TXWATER field to a new value. */
#define LPSPI_WR_FCR_TXWATER(base, value) (LPSPI_RMW_FCR(base, LPSPI_FCR_TXWATER_MASK, LPSPI_FCR_TXWATER(value)))
#define LPSPI_BWR_FCR_TXWATER(base, value) (LPSPI_WR_FCR_TXWATER(base, value))
/*@}*/

/*!
 * @name Register LPSPI_FCR, field RXWATER[23:16] (RW)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER. Writing a value equal or greater than the FIFO size
 * will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FCR_RXWATER field. */
#define LPSPI_RD_FCR_RXWATER(base) ((LPSPI_FCR_REG(base) & LPSPI_FCR_RXWATER_MASK) >> LPSPI_FCR_RXWATER_SHIFT)
#define LPSPI_BRD_FCR_RXWATER(base) (LPSPI_RD_FCR_RXWATER(base))

/*! @brief Set the RXWATER field to a new value. */
#define LPSPI_WR_FCR_RXWATER(base, value) (LPSPI_RMW_FCR(base, LPSPI_FCR_RXWATER_MASK, LPSPI_FCR_RXWATER(value)))
#define LPSPI_BWR_FCR_RXWATER(base, value) (LPSPI_WR_FCR_RXWATER(base, value))
/*@}*/

/*******************************************************************************
 * LPSPI_FSR - FIFO Status Register
 ******************************************************************************/

/*!
 * @brief LPSPI_FSR - FIFO Status Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_FSR register
 */
/*@{*/
#define LPSPI_RD_FSR(base)       (LPSPI_FSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_FSR bitfields
 */

/*!
 * @name Register LPSPI_FSR, field TXCOUNT[7:0] (RO)
 *
 * Returns the number of words in the transmit FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FSR_TXCOUNT field. */
#define LPSPI_RD_FSR_TXCOUNT(base) ((LPSPI_FSR_REG(base) & LPSPI_FSR_TXCOUNT_MASK) >> LPSPI_FSR_TXCOUNT_SHIFT)
#define LPSPI_BRD_FSR_TXCOUNT(base) (LPSPI_RD_FSR_TXCOUNT(base))
/*@}*/

/*!
 * @name Register LPSPI_FSR, field RXCOUNT[23:16] (RO)
 *
 * Returns the number of words in the receive FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FSR_RXCOUNT field. */
#define LPSPI_RD_FSR_RXCOUNT(base) ((LPSPI_FSR_REG(base) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT)
#define LPSPI_BRD_FSR_RXCOUNT(base) (LPSPI_RD_FSR_RXCOUNT(base))
/*@}*/

/*******************************************************************************
 * LPSPI_TCR - Transmit Command Register
 ******************************************************************************/

/*!
 * @brief LPSPI_TCR - Transmit Command Register (RW)
 *
 * Reset value: 0x0000001FU
 *
 * Writes to either the Transmit Command Register or Transmit Data Register will
 * push the data into the transmit FIFO in the order they are written. Command
 * Register writes will be tagged and cause the command register to update once
 * that entry reaches the top of the FIFO. This allows changes to the command word
 * and the transmit data itself to be interleaved. Changing the command word will
 * cause all subsequent SPI bus transfer to be performed using the new command
 * word. In master mode, writing a new command word does not initiate a new
 * transfer, unless TXMSK is set. Transfers are initiated by transmit data in the
 * transmit FIFO, or a new command word with TXMSK set. Hardware will clear TXMSK when
 * the LPSPI_PCS negates. In master mode if the command word is changed before
 * an existing frame has completed, then the existing frame will terminate and the
 * command word will then update. The command word can be changed during a
 * continuous transfer, provided CONTC of the new command word is set and the command
 * word is written on a frame size boundary. In slave mode, the command word
 * should be changed only when the LPSPI is idle and there is no SPI bus transfer.
 * Reading the Transmit Command Register will return the current state of the
 * command register.
 */
/*!
 * @name Constants and macros for entire LPSPI_TCR register
 */
/*@{*/
#define LPSPI_RD_TCR(base)       (LPSPI_TCR_REG(base))
#define LPSPI_WR_TCR(base, value) (LPSPI_TCR_REG(base) = (value))
#define LPSPI_RMW_TCR(base, mask, value) (LPSPI_WR_TCR(base, (LPSPI_RD_TCR(base) & ~(mask)) | (value)))
#define LPSPI_SET_TCR(base, value) (LPSPI_WR_TCR(base, LPSPI_RD_TCR(base) |  (value)))
#define LPSPI_CLR_TCR(base, value) (LPSPI_WR_TCR(base, LPSPI_RD_TCR(base) & ~(value)))
#define LPSPI_TOG_TCR(base, value) (LPSPI_WR_TCR(base, LPSPI_RD_TCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_TCR bitfields
 */

/*!
 * @name Register LPSPI_TCR, field FRAMESZ[11:0] (RW)
 *
 * Configures the frame size in number of bits equal to (FRAMESZ + 1). The
 * minimum frame size is 8 bits. If the frame size is larger than 32 bits, data will
 * be loaded from the transmit FIFO and stored to the receive FIFO every 32 bits.
 * If the size of the transfer word is not divisible by 32, then the last load of
 * the transmit FIFO and store of the receive FIFO will contain the remainder
 * bits (e.g.: a 72-bit transfer will load/store 32-bits from the FIFO and then
 * another 32-bits from the FIFO and then the final 8-bits from the FIFO).
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_FRAMESZ field. */
#define LPSPI_RD_TCR_FRAMESZ(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_FRAMESZ_MASK) >> LPSPI_TCR_FRAMESZ_SHIFT)
#define LPSPI_BRD_TCR_FRAMESZ(base) (LPSPI_RD_TCR_FRAMESZ(base))

/*! @brief Set the FRAMESZ field to a new value. */
#define LPSPI_WR_TCR_FRAMESZ(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_FRAMESZ_MASK, LPSPI_TCR_FRAMESZ(value)))
#define LPSPI_BWR_TCR_FRAMESZ(base, value) (LPSPI_WR_TCR_FRAMESZ(base, value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field WIDTH[17:16] (RW)
 *
 * Either RXMSK or TXMSK must be set for 2-bit or 4-bit transfers.
 *
 * Values:
 * - 0b00 - Single bit transfer.
 * - 0b01 - Two bit transfer.
 * - 0b10 - Four bit transfer.
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_WIDTH field. */
#define LPSPI_RD_TCR_WIDTH(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_WIDTH_MASK) >> LPSPI_TCR_WIDTH_SHIFT)
#define LPSPI_BRD_TCR_WIDTH(base) (LPSPI_RD_TCR_WIDTH(base))

/*! @brief Set the WIDTH field to a new value. */
#define LPSPI_WR_TCR_WIDTH(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_WIDTH_MASK, LPSPI_TCR_WIDTH(value)))
#define LPSPI_BWR_TCR_WIDTH(base, value) (LPSPI_WR_TCR_WIDTH(base, value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field TXMSK[18] (RW)
 *
 * When set, transmit data is masked (no data is loaded from transmit FIFO and
 * output pin is tristated). In master mode, this bit will initiate a new transfer
 * which cannot be aborted by another command word and the bit will be cleared
 * by hardware at the end of the transfer.
 *
 * Values:
 * - 0b0 - Normal transfer.
 * - 0b1 - Mask transmit data.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_TXMSK field. */
#define LPSPI_RD_TCR_TXMSK(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_TXMSK_MASK) >> LPSPI_TCR_TXMSK_SHIFT)
#define LPSPI_BRD_TCR_TXMSK(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_TXMSK_SHIFT))

/*! @brief Set the TXMSK field to a new value. */
#define LPSPI_WR_TCR_TXMSK(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_TXMSK_MASK, LPSPI_TCR_TXMSK(value)))
#define LPSPI_BWR_TCR_TXMSK(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_TXMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field RXMSK[19] (RW)
 *
 * When set, receive data is masked (receive data is not stored in receive FIFO).
 *
 * Values:
 * - 0b0 - Normal transfer.
 * - 0b1 - Receive data is masked.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_RXMSK field. */
#define LPSPI_RD_TCR_RXMSK(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_RXMSK_MASK) >> LPSPI_TCR_RXMSK_SHIFT)
#define LPSPI_BRD_TCR_RXMSK(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_RXMSK_SHIFT))

/*! @brief Set the RXMSK field to a new value. */
#define LPSPI_WR_TCR_RXMSK(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_RXMSK_MASK, LPSPI_TCR_RXMSK(value)))
#define LPSPI_BWR_TCR_RXMSK(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_RXMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CONTC[20] (RW)
 *
 * In master mode, this bit allows the command word to be changed within a
 * continuous transfer. The initial command word must enable continuous transfer
 * (CONT=1), the continuing command must set this bit (CONTC=1) and the continuing
 * command word must be loaded on a frame size boundary. For example, if the
 * continuous transfer has a frame size of 64-bits, then a continuing command word must
 * be loaded on a 64-bit boundary.
 *
 * Values:
 * - 0b0 - Command word for start of new transfer.
 * - 0b1 - Command word for continuing transfer.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CONTC field. */
#define LPSPI_RD_TCR_CONTC(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CONTC_MASK) >> LPSPI_TCR_CONTC_SHIFT)
#define LPSPI_BRD_TCR_CONTC(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CONTC_SHIFT))

/*! @brief Set the CONTC field to a new value. */
#define LPSPI_WR_TCR_CONTC(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CONTC_MASK, LPSPI_TCR_CONTC(value)))
#define LPSPI_BWR_TCR_CONTC(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CONTC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CONT[21] (RW)
 *
 * In master mode, continuous transfer will keep the PCS asserted at the end of
 * the frame size, until a command word is received that starts a new frame. In
 * slave mode, when continuous transfer is enabled the LPSPI will only transmit
 * the first FRAMESZ bits, after which it will transmit received data assuming a
 * 32-bit shift register.
 *
 * Values:
 * - 0b0 - Continuous transfer disabled.
 * - 0b1 - Continuous transfer enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CONT field. */
#define LPSPI_RD_TCR_CONT(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CONT_MASK) >> LPSPI_TCR_CONT_SHIFT)
#define LPSPI_BRD_TCR_CONT(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CONT_SHIFT))

/*! @brief Set the CONT field to a new value. */
#define LPSPI_WR_TCR_CONT(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CONT_MASK, LPSPI_TCR_CONT(value)))
#define LPSPI_BWR_TCR_CONT(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CONT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field BYSW[22] (RW)
 *
 * Byte swap will swap the contents of [31:24] with [7:0] and [23:16] with
 * [15:8] for each transmit data word read from the FIFO and each received data word
 * stored to the FIFO (or compared with match registers).
 *
 * Values:
 * - 0b0 - Byte swap disabled.
 * - 0b1 - Byte swap enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_BYSW field. */
#define LPSPI_RD_TCR_BYSW(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_BYSW_MASK) >> LPSPI_TCR_BYSW_SHIFT)
#define LPSPI_BRD_TCR_BYSW(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_BYSW_SHIFT))

/*! @brief Set the BYSW field to a new value. */
#define LPSPI_WR_TCR_BYSW(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_BYSW_MASK, LPSPI_TCR_BYSW(value)))
#define LPSPI_BWR_TCR_BYSW(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_BYSW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field LSBF[23] (RW)
 *
 * Values:
 * - 0b0 - Data is transferred MSB first.
 * - 0b1 - Data is transferred LSB first.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_LSBF field. */
#define LPSPI_RD_TCR_LSBF(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_LSBF_MASK) >> LPSPI_TCR_LSBF_SHIFT)
#define LPSPI_BRD_TCR_LSBF(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_LSBF_SHIFT))

/*! @brief Set the LSBF field to a new value. */
#define LPSPI_WR_TCR_LSBF(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_LSBF_MASK, LPSPI_TCR_LSBF(value)))
#define LPSPI_BWR_TCR_LSBF(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_LSBF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field PCS[25:24] (RW)
 *
 * Configures the peripheral chip select used for the transfer. This field is
 * only updated between frames.
 *
 * Values:
 * - 0b00 - Transfer using LPSPI_PCS[0]
 * - 0b01 - Transfer using LPSPI_PCS[1]
 * - 0b10 - Transfer using LPSPI_PCS[2]
 * - 0b11 - Transfer using LPSPI_PCS[3]
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_PCS field. */
#define LPSPI_RD_TCR_PCS(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_PCS_MASK) >> LPSPI_TCR_PCS_SHIFT)
#define LPSPI_BRD_TCR_PCS(base) (LPSPI_RD_TCR_PCS(base))

/*! @brief Set the PCS field to a new value. */
#define LPSPI_WR_TCR_PCS(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_PCS_MASK, LPSPI_TCR_PCS(value)))
#define LPSPI_BWR_TCR_PCS(base, value) (LPSPI_WR_TCR_PCS(base, value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field PRESCALE[29:27] (RW)
 *
 * Prescaler applied to the clock configuration register for all SPI bus
 * transfers. This field is only updated between frames.
 *
 * Values:
 * - 0b000 - Divide by 1.
 * - 0b001 - Divide by 2.
 * - 0b010 - Divide by 4.
 * - 0b011 - Divide by 8.
 * - 0b100 - Divide by 16.
 * - 0b101 - Divide by 32.
 * - 0b110 - Divide by 64.
 * - 0b111 - Divide by 128.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_PRESCALE field. */
#define LPSPI_RD_TCR_PRESCALE(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_PRESCALE_MASK) >> LPSPI_TCR_PRESCALE_SHIFT)
#define LPSPI_BRD_TCR_PRESCALE(base) (LPSPI_RD_TCR_PRESCALE(base))

/*! @brief Set the PRESCALE field to a new value. */
#define LPSPI_WR_TCR_PRESCALE(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_PRESCALE_MASK, LPSPI_TCR_PRESCALE(value)))
#define LPSPI_BWR_TCR_PRESCALE(base, value) (LPSPI_WR_TCR_PRESCALE(base, value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CPHA[30] (RW)
 *
 * This field is only updated between frames.
 *
 * Values:
 * - 0b0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 0b1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CPHA field. */
#define LPSPI_RD_TCR_CPHA(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CPHA_MASK) >> LPSPI_TCR_CPHA_SHIFT)
#define LPSPI_BRD_TCR_CPHA(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CPHA_SHIFT))

/*! @brief Set the CPHA field to a new value. */
#define LPSPI_WR_TCR_CPHA(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CPHA_MASK, LPSPI_TCR_CPHA(value)))
#define LPSPI_BWR_TCR_CPHA(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CPHA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CPOL[31] (RW)
 *
 * This field is only updated between frames.
 *
 * Values:
 * - 0b0 - The inactive state value of SCK is low.
 * - 0b1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CPOL field. */
#define LPSPI_RD_TCR_CPOL(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CPOL_MASK) >> LPSPI_TCR_CPOL_SHIFT)
#define LPSPI_BRD_TCR_CPOL(base) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CPOL_SHIFT))

/*! @brief Set the CPOL field to a new value. */
#define LPSPI_WR_TCR_CPOL(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CPOL_MASK, LPSPI_TCR_CPOL(value)))
#define LPSPI_BWR_TCR_CPOL(base, value) (BITBAND_ACCESS32(&LPSPI_TCR_REG(base), LPSPI_TCR_CPOL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPSPI_TDR - Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPSPI_TDR - Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 *
 * Writes to either the Transmit Command Register or Transmit Data Register will
 * push the data into the transmit FIFO in the order it was written.
 */
/*!
 * @name Constants and macros for entire LPSPI_TDR register
 */
/*@{*/
#define LPSPI_WR_TDR(base, value) (LPSPI_TDR_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * LPSPI_RSR - Receive Status Register
 ******************************************************************************/

/*!
 * @brief LPSPI_RSR - Receive Status Register (RO)
 *
 * Reset value: 0x00000002U
 */
/*!
 * @name Constants and macros for entire LPSPI_RSR register
 */
/*@{*/
#define LPSPI_RD_RSR(base)       (LPSPI_RSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_RSR bitfields
 */

/*!
 * @name Register LPSPI_RSR, field SOF[0] (RO)
 *
 * Indicates that this is the first data word received after LPSPI_PCS assertion.
 *
 * Values:
 * - 0b0 - Subsequent data word received after LPSPI_PCS assertion.
 * - 0b1 - First data word received after LPSPI_PCS assertion.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_RSR_SOF field. */
#define LPSPI_RD_RSR_SOF(base) ((LPSPI_RSR_REG(base) & LPSPI_RSR_SOF_MASK) >> LPSPI_RSR_SOF_SHIFT)
#define LPSPI_BRD_RSR_SOF(base) (BITBAND_ACCESS32(&LPSPI_RSR_REG(base), LPSPI_RSR_SOF_SHIFT))
/*@}*/

/*!
 * @name Register LPSPI_RSR, field RXEMPTY[1] (RO)
 *
 * Values:
 * - 0b0 - RX FIFO is not empty.
 * - 0b1 - RX FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_RSR_RXEMPTY field. */
#define LPSPI_RD_RSR_RXEMPTY(base) ((LPSPI_RSR_REG(base) & LPSPI_RSR_RXEMPTY_MASK) >> LPSPI_RSR_RXEMPTY_SHIFT)
#define LPSPI_BRD_RSR_RXEMPTY(base) (BITBAND_ACCESS32(&LPSPI_RSR_REG(base), LPSPI_RSR_RXEMPTY_SHIFT))
/*@}*/

/*******************************************************************************
 * LPSPI_RDR - Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPSPI_RDR - Receive Data Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_RDR register
 */
/*@{*/
#define LPSPI_RD_RDR(base)       (LPSPI_RDR_REG(base))
/*@}*/

/*
 * S32K144 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) |  (value)))
#define LPTMR_CLR_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) & ~(value)))
#define LPTMR_TOG_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0b0 - LPTMR is disabled and internal logic is reset.
 * - 0b1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0b0 - Time Counter mode.
 * - 0b1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0b0 - CNR is reset whenever TCF is set.
 * - 0b1 - CNR is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 0b1 - Pulse Counter input source is active-low, and the CNR will increment
 *     on the falling-edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the chip configuration information about connections to these inputs.
 *
 * Values:
 * - 0b00 - Pulse counter input 0 is selected.
 * - 0b01 - Pulse counter input 1 is selected.
 * - 0b10 - Pulse counter input 2 is selected.
 * - 0b11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (LPTMR_RD_CSR_TPS(base))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (LPTMR_WR_CSR_TPS(base, value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0b0 - Timer interrupt disabled.
 * - 0b1 - Timer interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0b0 - The value of CNR is not equal to CMR and increments.
 * - 0b1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TDRE[8] (RW)
 *
 * When TDRE is set, the LPTMR DMA Request is generated whenever TCF is also set
 * and the TCF is cleared when the DMA Controller is done.
 *
 * Values:
 * - 0b0 - Timer DMA Request disabled.
 * - 0b1 - Timer DMA Request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TDRE field. */
#define LPTMR_RD_CSR_TDRE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TDRE_MASK) >> LPTMR_CSR_TDRE_SHIFT)
#define LPTMR_BRD_CSR_TDRE(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TDRE_SHIFT))

/*! @brief Set the TDRE field to a new value. */
#define LPTMR_WR_CSR_TDRE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TDRE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TDRE(value)))
#define LPTMR_BWR_CSR_TDRE(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TDRE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) |  (value)))
#define LPTMR_CLR_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) & ~(value)))
#define LPTMR_TOG_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 0b00 - Prescaler/glitch filter clock 0 selected.
 * - 0b01 - Prescaler/glitch filter clock 1 selected.
 * - 0b10 - Prescaler/glitch filter clock 2 selected.
 * - 0b11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (LPTMR_RD_PSR_PCS(base))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (LPTMR_WR_PSR_PCS(base, value))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Prescaler/glitch filter is enabled.
 * - 0b1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BITBAND_ACCESS32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BITBAND_ACCESS32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0b0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0b0001 - Prescaler divides the prescaler clock by 4; glitch filter
 *     recognizes change on input pin after 2 rising clock edges.
 * - 0b0010 - Prescaler divides the prescaler clock by 8; glitch filter
 *     recognizes change on input pin after 4 rising clock edges.
 * - 0b0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0b0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0b0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0b0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0b0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 0b1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 0b1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 0b1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 0b1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 0b1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 0b1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 0b1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 0b1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (LPTMR_RD_PSR_PRESCALE(base))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (LPTMR_WR_PSR_PRESCALE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) |  (value)))
#define LPTMR_CLR_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) & ~(value)))
#define LPTMR_TOG_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (LPTMR_RD_CMR_COMPARE(base))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (LPTMR_WR_CMR_COMPARE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RO)
 *
 * The CNR returns the current value of the LPTMR counter at the time this
 * register was last written.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (LPTMR_RD_CNR_COUNTER(base))
/*@}*/

/*
 * S32K144 LPUART
 *
 * Universal Asynchronous Receiver/Transmitter
 *
 * Registers defined in this header file:
 * - LPUART_VERID - Version ID Register
 * - LPUART_PARAM - Parameter Register
 * - LPUART_GLOBAL - LPUART Global Register
 * - LPUART_PINCFG - LPUART Pin Configuration Register
 * - LPUART_BAUD - LPUART Baud Rate Register
 * - LPUART_STAT - LPUART Status Register
 * - LPUART_CTRL - LPUART Control Register
 * - LPUART_DATA - LPUART Data Register
 * - LPUART_MATCH - LPUART Match Address Register
 * - LPUART_MODIR - LPUART Modem IrDA Register
 */

#define LPUART_INSTANCE_COUNT (4U) /*!< Number of instances of the LPUART module. */
#define LPUART0_IDX (0U) /*!< Instance number for LPUART0. */
#define LPUART1_IDX (1U) /*!< Instance number for LPUART1. */
#define LPUART2_IDX (2U) /*!< Instance number for LPUART2. */
#define LPUART3_IDX (3U) /*!< Instance number for LPUART3. */

/*******************************************************************************
 * LPUART_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPUART_VERID - Version ID Register (RO)
 *
 * Reset value: 0x04000003U
 */
/*!
 * @name Constants and macros for entire LPUART_VERID register
 */
/*@{*/
#define LPUART_RD_VERID(base)    (LPUART_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPUART_VERID bitfields
 */

/*!
 * @name Register LPUART_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000001 - Standard feature set.
 * - 0b0000000000000011 - Standard feature set with MODEM/IrDA support.
 */
/*@{*/
/*! @brief Read current value of the LPUART_VERID_FEATURE field. */
#define LPUART_RD_VERID_FEATURE(base) ((LPUART_VERID_REG(base) & LPUART_VERID_FEATURE_MASK) >> LPUART_VERID_FEATURE_SHIFT)
#define LPUART_BRD_VERID_FEATURE(base) (LPUART_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPUART_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LPUART_VERID_MINOR field. */
#define LPUART_RD_VERID_MINOR(base) ((LPUART_VERID_REG(base) & LPUART_VERID_MINOR_MASK) >> LPUART_VERID_MINOR_SHIFT)
#define LPUART_BRD_VERID_MINOR(base) (LPUART_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register LPUART_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LPUART_VERID_MAJOR field. */
#define LPUART_RD_VERID_MAJOR(base) ((LPUART_VERID_REG(base) & LPUART_VERID_MAJOR_MASK) >> LPUART_VERID_MAJOR_SHIFT)
#define LPUART_BRD_VERID_MAJOR(base) (LPUART_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * LPUART_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPUART_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_PARAM register
 */
/*@{*/
#define LPUART_RD_PARAM(base)    (LPUART_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPUART_PARAM bitfields
 */

/*!
 * @name Register LPUART_PARAM, field TXFIFO[7:0] (RO)
 *
 * The number of words in the transmit FIFO is 2^TXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPUART_PARAM_TXFIFO field. */
#define LPUART_RD_PARAM_TXFIFO(base) ((LPUART_PARAM_REG(base) & LPUART_PARAM_TXFIFO_MASK) >> LPUART_PARAM_TXFIFO_SHIFT)
#define LPUART_BRD_PARAM_TXFIFO(base) (LPUART_RD_PARAM_TXFIFO(base))
/*@}*/

/*!
 * @name Register LPUART_PARAM, field RXFIFO[15:8] (RO)
 *
 * The number of words in the receive FIFO is 2^RXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPUART_PARAM_RXFIFO field. */
#define LPUART_RD_PARAM_RXFIFO(base) ((LPUART_PARAM_REG(base) & LPUART_PARAM_RXFIFO_MASK) >> LPUART_PARAM_RXFIFO_SHIFT)
#define LPUART_BRD_PARAM_RXFIFO(base) (LPUART_RD_PARAM_RXFIFO(base))
/*@}*/

/*******************************************************************************
 * LPUART_GLOBAL - LPUART Global Register
 ******************************************************************************/

/*!
 * @brief LPUART_GLOBAL - LPUART Global Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_GLOBAL register
 */
/*@{*/
#define LPUART_RD_GLOBAL(base)   (LPUART_GLOBAL_REG(base))
#define LPUART_WR_GLOBAL(base, value) (LPUART_GLOBAL_REG(base) = (value))
#define LPUART_RMW_GLOBAL(base, mask, value) (LPUART_WR_GLOBAL(base, (LPUART_RD_GLOBAL(base) & ~(mask)) | (value)))
#define LPUART_SET_GLOBAL(base, value) (LPUART_WR_GLOBAL(base, LPUART_RD_GLOBAL(base) |  (value)))
#define LPUART_CLR_GLOBAL(base, value) (LPUART_WR_GLOBAL(base, LPUART_RD_GLOBAL(base) & ~(value)))
#define LPUART_TOG_GLOBAL(base, value) (LPUART_WR_GLOBAL(base, LPUART_RD_GLOBAL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_GLOBAL bitfields
 */

/*!
 * @name Register LPUART_GLOBAL, field RST[1] (RW)
 *
 * Reset all internal logic and registers, except the Global Register. Remains
 * set until cleared by software.
 *
 * Values:
 * - 0b0 - Module is not reset.
 * - 0b1 - Module is reset.
 */
/*@{*/
/*! @brief Read current value of the LPUART_GLOBAL_RST field. */
#define LPUART_RD_GLOBAL_RST(base) ((LPUART_GLOBAL_REG(base) & LPUART_GLOBAL_RST_MASK) >> LPUART_GLOBAL_RST_SHIFT)
#define LPUART_BRD_GLOBAL_RST(base) (BITBAND_ACCESS32(&LPUART_GLOBAL_REG(base), LPUART_GLOBAL_RST_SHIFT))

/*! @brief Set the RST field to a new value. */
#define LPUART_WR_GLOBAL_RST(base, value) (LPUART_RMW_GLOBAL(base, LPUART_GLOBAL_RST_MASK, LPUART_GLOBAL_RST(value)))
#define LPUART_BWR_GLOBAL_RST(base, value) (BITBAND_ACCESS32(&LPUART_GLOBAL_REG(base), LPUART_GLOBAL_RST_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPUART_PINCFG - LPUART Pin Configuration Register
 ******************************************************************************/

/*!
 * @brief LPUART_PINCFG - LPUART Pin Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_PINCFG register
 */
/*@{*/
#define LPUART_RD_PINCFG(base)   (LPUART_PINCFG_REG(base))
#define LPUART_WR_PINCFG(base, value) (LPUART_PINCFG_REG(base) = (value))
#define LPUART_RMW_PINCFG(base, mask, value) (LPUART_WR_PINCFG(base, (LPUART_RD_PINCFG(base) & ~(mask)) | (value)))
#define LPUART_SET_PINCFG(base, value) (LPUART_WR_PINCFG(base, LPUART_RD_PINCFG(base) |  (value)))
#define LPUART_CLR_PINCFG(base, value) (LPUART_WR_PINCFG(base, LPUART_RD_PINCFG(base) & ~(value)))
#define LPUART_TOG_PINCFG(base, value) (LPUART_WR_PINCFG(base, LPUART_RD_PINCFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_PINCFG bitfields
 */

/*!
 * @name Register LPUART_PINCFG, field TRGSEL[1:0] (RW)
 *
 * Configures the input trigger usage.
 *
 * Values:
 * - 0b00 - Input trigger is disabled.
 * - 0b01 - Input trigger is used instead of RXD pin input.
 * - 0b10 - Input trigger is used instead of CTS pin input.
 * - 0b11 - Input trigger is used to modulate the TXD pin output.
 */
/*@{*/
/*! @brief Read current value of the LPUART_PINCFG_TRGSEL field. */
#define LPUART_RD_PINCFG_TRGSEL(base) ((LPUART_PINCFG_REG(base) & LPUART_PINCFG_TRGSEL_MASK) >> LPUART_PINCFG_TRGSEL_SHIFT)
#define LPUART_BRD_PINCFG_TRGSEL(base) (LPUART_RD_PINCFG_TRGSEL(base))

/*! @brief Set the TRGSEL field to a new value. */
#define LPUART_WR_PINCFG_TRGSEL(base, value) (LPUART_RMW_PINCFG(base, LPUART_PINCFG_TRGSEL_MASK, LPUART_PINCFG_TRGSEL(value)))
#define LPUART_BWR_PINCFG_TRGSEL(base, value) (LPUART_WR_PINCFG_TRGSEL(base, value))
/*@}*/

/*******************************************************************************
 * LPUART_BAUD - LPUART Baud Rate Register
 ******************************************************************************/

/*!
 * @brief LPUART_BAUD - LPUART Baud Rate Register (RW)
 *
 * Reset value: 0x0F000004U
 */
/*!
 * @name Constants and macros for entire LPUART_BAUD register
 */
/*@{*/
#define LPUART_RD_BAUD(base)     (LPUART_BAUD_REG(base))
#define LPUART_WR_BAUD(base, value) (LPUART_BAUD_REG(base) = (value))
#define LPUART_RMW_BAUD(base, mask, value) (LPUART_WR_BAUD(base, (LPUART_RD_BAUD(base) & ~(mask)) | (value)))
#define LPUART_SET_BAUD(base, value) (LPUART_WR_BAUD(base, LPUART_RD_BAUD(base) |  (value)))
#define LPUART_CLR_BAUD(base, value) (LPUART_WR_BAUD(base, LPUART_RD_BAUD(base) & ~(value)))
#define LPUART_TOG_BAUD(base, value) (LPUART_WR_BAUD(base, LPUART_RD_BAUD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_BAUD bitfields
 */

/*!
 * @name Register LPUART_BAUD, field SBR[12:0] (RW)
 *
 * The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate
 * generator. When SBR is 1 - 8191, the baud rate equals "baud clock / ((OSR+1) * SBR)".
 * The 13-bit baud rate setting [SBR12:SBR0] must only be updated when the
 * transmitter and receiver are both disabled (LPUART_CTRL[RE] and LPUART_CTRL[TE] are
 * both 0).
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBR field. */
#define LPUART_RD_BAUD_SBR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBR_MASK) >> LPUART_BAUD_SBR_SHIFT)
#define LPUART_BRD_BAUD_SBR(base) (LPUART_RD_BAUD_SBR(base))

/*! @brief Set the SBR field to a new value. */
#define LPUART_WR_BAUD_SBR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBR_MASK, LPUART_BAUD_SBR(value)))
#define LPUART_BWR_BAUD_SBR(base, value) (LPUART_WR_BAUD_SBR(base, value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field SBNS[13] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - One stop bit.
 * - 0b1 - Two stop bits.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBNS field. */
#define LPUART_RD_BAUD_SBNS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBNS_MASK) >> LPUART_BAUD_SBNS_SHIFT)
#define LPUART_BRD_BAUD_SBNS(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBNS_SHIFT))

/*! @brief Set the SBNS field to a new value. */
#define LPUART_WR_BAUD_SBNS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBNS_MASK, LPUART_BAUD_SBNS(value)))
#define LPUART_BWR_BAUD_SBNS(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBNS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RXEDGIE[14] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests. Changing CTRL[LOOP] or CTRL[RSRC] when RXEDGIE is set can cause the RXEDGIF
 * to set.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RXEDGIE field. */
#define LPUART_RD_BAUD_RXEDGIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RXEDGIE_MASK) >> LPUART_BAUD_RXEDGIE_SHIFT)
#define LPUART_BRD_BAUD_RXEDGIE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RXEDGIE_SHIFT))

/*! @brief Set the RXEDGIE field to a new value. */
#define LPUART_WR_BAUD_RXEDGIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RXEDGIE_MASK, LPUART_BAUD_RXEDGIE(value)))
#define LPUART_BWR_BAUD_RXEDGIE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RXEDGIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field LBKDIE[15] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_LBKDIE field. */
#define LPUART_RD_BAUD_LBKDIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_LBKDIE_MASK) >> LPUART_BAUD_LBKDIE_SHIFT)
#define LPUART_BRD_BAUD_LBKDIE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_LBKDIE_SHIFT))

/*! @brief Set the LBKDIE field to a new value. */
#define LPUART_WR_BAUD_LBKDIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_LBKDIE_MASK, LPUART_BAUD_LBKDIE(value)))
#define LPUART_BWR_BAUD_LBKDIE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_LBKDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RESYNCDIS[16] (RW)
 *
 * When set, disables the resynchronization of the received data word when a
 * data one followed by data zero transition is detected. This bit should only be
 * changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Resynchronization during received data word is supported
 * - 0b1 - Resynchronization during received data word is disabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RESYNCDIS field. */
#define LPUART_RD_BAUD_RESYNCDIS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RESYNCDIS_MASK) >> LPUART_BAUD_RESYNCDIS_SHIFT)
#define LPUART_BRD_BAUD_RESYNCDIS(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RESYNCDIS_SHIFT))

/*! @brief Set the RESYNCDIS field to a new value. */
#define LPUART_WR_BAUD_RESYNCDIS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RESYNCDIS_MASK, LPUART_BAUD_RESYNCDIS(value)))
#define LPUART_BWR_BAUD_RESYNCDIS(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RESYNCDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field BOTHEDGE[17] (RW)
 *
 * Enables sampling of the received data on both edges of the baud rate clock,
 * effectively doubling the number of times the receiver samples the input data
 * for a given oversampling ratio. This bit must be set for oversampling ratios
 * between x4 and x7 and is optional for higher oversampling ratios. This bit should
 * only be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Receiver samples input data using the rising edge of the baud rate
 *     clock.
 * - 0b1 - Receiver samples input data using the rising and falling edge of the
 *     baud rate clock.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_BOTHEDGE field. */
#define LPUART_RD_BAUD_BOTHEDGE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_BOTHEDGE_MASK) >> LPUART_BAUD_BOTHEDGE_SHIFT)
#define LPUART_BRD_BAUD_BOTHEDGE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_BOTHEDGE_SHIFT))

/*! @brief Set the BOTHEDGE field to a new value. */
#define LPUART_WR_BAUD_BOTHEDGE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_BOTHEDGE_MASK, LPUART_BAUD_BOTHEDGE(value)))
#define LPUART_BWR_BAUD_BOTHEDGE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_BOTHEDGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MATCFG[19:18] (RW)
 *
 * Configures the match addressing mode used.
 *
 * Values:
 * - 0b00 - Address Match Wakeup
 * - 0b01 - Idle Match Wakeup
 * - 0b10 - Match On and Match Off
 * - 0b11 - Enables RWU on Data Match and Match On/Off for transmitter CTS input
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MATCFG field. */
#define LPUART_RD_BAUD_MATCFG(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MATCFG_MASK) >> LPUART_BAUD_MATCFG_SHIFT)
#define LPUART_BRD_BAUD_MATCFG(base) (LPUART_RD_BAUD_MATCFG(base))

/*! @brief Set the MATCFG field to a new value. */
#define LPUART_WR_BAUD_MATCFG(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MATCFG_MASK, LPUART_BAUD_MATCFG(value)))
#define LPUART_BWR_BAUD_MATCFG(base, value) (LPUART_WR_BAUD_MATCFG(base, value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RDMAE[21] (RW)
 *
 * RDMAE configures the receiver data register full flag, LPUART_STAT[RDRF], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RDMAE field. */
#define LPUART_RD_BAUD_RDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RDMAE_MASK) >> LPUART_BAUD_RDMAE_SHIFT)
#define LPUART_BRD_BAUD_RDMAE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RDMAE_SHIFT))

/*! @brief Set the RDMAE field to a new value. */
#define LPUART_WR_BAUD_RDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RDMAE_MASK, LPUART_BAUD_RDMAE(value)))
#define LPUART_BWR_BAUD_RDMAE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RDMAE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field TDMAE[23] (RW)
 *
 * TDMAE configures the transmit data register empty flag, LPUART_STAT[TDRE], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_TDMAE field. */
#define LPUART_RD_BAUD_TDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_TDMAE_MASK) >> LPUART_BAUD_TDMAE_SHIFT)
#define LPUART_BRD_BAUD_TDMAE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_TDMAE_SHIFT))

/*! @brief Set the TDMAE field to a new value. */
#define LPUART_WR_BAUD_TDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_TDMAE_MASK, LPUART_BAUD_TDMAE(value)))
#define LPUART_BWR_BAUD_TDMAE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_TDMAE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field OSR[28:24] (RW)
 *
 * This field configures the oversampling ratio for the receiver between 4x
 * (00011) and 32x (11111). Writing an invalid oversampling ratio will default to an
 * oversampling ratio of 16 (01111). This field should only be changed when the
 * transmitter and receiver are both disabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_OSR field. */
#define LPUART_RD_BAUD_OSR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_OSR_MASK) >> LPUART_BAUD_OSR_SHIFT)
#define LPUART_BRD_BAUD_OSR(base) (LPUART_RD_BAUD_OSR(base))

/*! @brief Set the OSR field to a new value. */
#define LPUART_WR_BAUD_OSR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_OSR_MASK, LPUART_BAUD_OSR(value)))
#define LPUART_BWR_BAUD_OSR(base, value) (LPUART_WR_BAUD_OSR(base, value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field M10[29] (RW)
 *
 * The M10 bit causes a tenth bit to be part of the serial transmission. This
 * bit should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit or 9-bit data characters.
 * - 0b1 - Receiver and transmitter use 10-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_M10 field. */
#define LPUART_RD_BAUD_M10(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_M10_MASK) >> LPUART_BAUD_M10_SHIFT)
#define LPUART_BRD_BAUD_M10(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_M10_SHIFT))

/*! @brief Set the M10 field to a new value. */
#define LPUART_WR_BAUD_M10(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_M10_MASK, LPUART_BAUD_M10(value)))
#define LPUART_BWR_BAUD_M10(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_M10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN2[30] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA2].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN2 field. */
#define LPUART_RD_BAUD_MAEN2(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN2_MASK) >> LPUART_BAUD_MAEN2_SHIFT)
#define LPUART_BRD_BAUD_MAEN2(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN2_SHIFT))

/*! @brief Set the MAEN2 field to a new value. */
#define LPUART_WR_BAUD_MAEN2(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN2_MASK, LPUART_BAUD_MAEN2(value)))
#define LPUART_BWR_BAUD_MAEN2(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN1[31] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA1].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN1 field. */
#define LPUART_RD_BAUD_MAEN1(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN1_MASK) >> LPUART_BAUD_MAEN1_SHIFT)
#define LPUART_BRD_BAUD_MAEN1(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN1_SHIFT))

/*! @brief Set the MAEN1 field to a new value. */
#define LPUART_WR_BAUD_MAEN1(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN1_MASK, LPUART_BAUD_MAEN1(value)))
#define LPUART_BWR_BAUD_MAEN1(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN1_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPUART_STAT - LPUART Status Register
 ******************************************************************************/

/*!
 * @brief LPUART_STAT - LPUART Status Register (RW)
 *
 * Reset value: 0x00C00000U
 */
/*!
 * @name Constants and macros for entire LPUART_STAT register
 */
/*@{*/
#define LPUART_RD_STAT(base)     (LPUART_STAT_REG(base))
#define LPUART_WR_STAT(base, value) (LPUART_STAT_REG(base) = (value))
#define LPUART_RMW_STAT(base, mask, value) (LPUART_WR_STAT(base, (LPUART_RD_STAT(base) & ~(mask)) | (value)))
#define LPUART_SET_STAT(base, value) (LPUART_WR_STAT(base, LPUART_RD_STAT(base) |  (value)))
#define LPUART_CLR_STAT(base, value) (LPUART_WR_STAT(base, LPUART_RD_STAT(base) & ~(value)))
#define LPUART_TOG_STAT(base, value) (LPUART_WR_STAT(base, LPUART_RD_STAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_STAT bitfields
 */

/*!
 * @name Register LPUART_STAT, field MA2F[14] (W1C)
 *
 * MA2F is set whenever the next character to be read from LPUART_DATA matches
 * MA2. To clear MA2F, write a logic one to the MA2F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA2
 * - 0b1 - Received data is equal to MA2
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA2F field. */
#define LPUART_RD_STAT_MA2F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA2F_MASK) >> LPUART_STAT_MA2F_SHIFT)
#define LPUART_BRD_STAT_MA2F(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA2F_SHIFT))

/*! @brief Set the MA2F field to a new value. */
#define LPUART_WR_STAT_MA2F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA2F(value)))
#define LPUART_BWR_STAT_MA2F(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA2F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MA1F[15] (W1C)
 *
 * MA1F is set whenever the next character to be read from LPUART_DATA matches
 * MA1. To clear MA1F, write a logic one to the MA1F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA1
 * - 0b1 - Received data is equal to MA1
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA1F field. */
#define LPUART_RD_STAT_MA1F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA1F_MASK) >> LPUART_STAT_MA1F_SHIFT)
#define LPUART_BRD_STAT_MA1F(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA1F_SHIFT))

/*! @brief Set the MA1F field to a new value. */
#define LPUART_WR_STAT_MA1F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA1F(value)))
#define LPUART_BWR_STAT_MA1F(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field PF[16] (W1C)
 *
 * PF is set whenever the next character to be read from LPUART_DATA was
 * received when parity is enabled (PE = 1) and the parity bit in the received character
 * does not agree with the expected parity value. To clear PF, write a logic one
 * to the PF.
 *
 * Values:
 * - 0b0 - No parity error.
 * - 0b1 - Parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_PF field. */
#define LPUART_RD_STAT_PF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_PF_MASK) >> LPUART_STAT_PF_SHIFT)
#define LPUART_BRD_STAT_PF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_PF_SHIFT))

/*! @brief Set the PF field to a new value. */
#define LPUART_WR_STAT_PF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_PF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_PF(value)))
#define LPUART_BWR_STAT_PF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_PF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field FE[17] (W1C)
 *
 * FE is set whenever the next character to be read from LPUART_DATA was
 * received with logic 0 detected where a stop bit was expected. To clear NF, write
 * logic one to the NF.
 *
 * Values:
 * - 0b0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 0b1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_FE field. */
#define LPUART_RD_STAT_FE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_FE_MASK) >> LPUART_STAT_FE_SHIFT)
#define LPUART_BRD_STAT_FE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_FE_SHIFT))

/*! @brief Set the FE field to a new value. */
#define LPUART_WR_STAT_FE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_FE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_FE(value)))
#define LPUART_BWR_STAT_FE(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_FE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field NF[18] (W1C)
 *
 * The advanced sampling technique used in the receiver takes three samples in
 * each of the received bits. If any of these samples disagrees with the rest of
 * the samples within any bit time in the frame then noise is detected for that
 * character. NF is set whenever the next character to be read from LPUART_DATA was
 * received with noise detected within the character. To clear NF, write logic
 * one to the NF.
 *
 * Values:
 * - 0b0 - No noise detected.
 * - 0b1 - Noise detected in the received character in LPUART_DATA.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_NF field. */
#define LPUART_RD_STAT_NF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_NF_MASK) >> LPUART_STAT_NF_SHIFT)
#define LPUART_BRD_STAT_NF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_NF_SHIFT))

/*! @brief Set the NF field to a new value. */
#define LPUART_WR_STAT_NF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_NF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_NF(value)))
#define LPUART_BWR_STAT_NF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_NF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field OR[19] (W1C)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the LPUART data registers is not
 * affected. If LBKDE is enabled and a LIN Break is detected, the OR field asserts
 * if LBKDIF is not cleared before the next data character is received. While
 * the OR flag is set, no additional data is stored in the data buffer even if
 * sufficient room exists. To clear OR, write logic 1 to the OR flag.
 *
 * Values:
 * - 0b0 - No overrun.
 * - 0b1 - Receive overrun (new LPUART data lost).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_OR field. */
#define LPUART_RD_STAT_OR(base) ((LPUART_STAT_REG(base) & LPUART_STAT_OR_MASK) >> LPUART_STAT_OR_SHIFT)
#define LPUART_BRD_STAT_OR(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_OR_SHIFT))

/*! @brief Set the OR field to a new value. */
#define LPUART_WR_STAT_OR(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_OR_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_OR(value)))
#define LPUART_BWR_STAT_OR(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_OR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field IDLE[20] (W1C)
 *
 * IDLE is set when the LPUART receive line becomes idle for a full character
 * time after a period of activity. When ILT is cleared, the receiver starts
 * counting idle bit times after the start bit. If the receive character is all 1s,
 * these bit times and the stop bits time count toward the full character time of
 * logic high, 10 to 13 bit times, needed for the receiver to detect an idle line.
 * When ILT is set, the receiver doesn't start counting idle bit times until
 * after the stop bits. The stop bits and any logic high bit times at the end of the
 * previous character do not count toward the full character time of logic high
 * needed for the receiver to detect an idle line. To clear IDLE, write logic 1 to
 * the IDLE flag. After IDLE has been cleared, it cannot become set again until
 * after a new character has been stored in the receive buffer or a LIN break
 * character has set the LBKDIF flag . IDLE is set only once even if the receive
 * line remains idle for an extended period.
 *
 * Values:
 * - 0b0 - No idle line detected.
 * - 0b1 - Idle line was detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_IDLE field. */
#define LPUART_RD_STAT_IDLE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_IDLE_MASK) >> LPUART_STAT_IDLE_SHIFT)
#define LPUART_BRD_STAT_IDLE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_IDLE_SHIFT))

/*! @brief Set the IDLE field to a new value. */
#define LPUART_WR_STAT_IDLE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_IDLE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_IDLE(value)))
#define LPUART_BWR_STAT_IDLE(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_IDLE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RDRF[21] (RO)
 *
 * RDRF is set when the receive buffer (LPUART_DATA) is full. To clear RDRF,
 * read the LPUART_DATA register. A character that is in the process of being
 * received does not cause a change in RDRF until the entire character is received.
 * Even if RDRF is set, the character will continue to be received until an overrun
 * condition occurs once the entire character is received.
 *
 * Values:
 * - 0b0 - Receive data buffer empty.
 * - 0b1 - Receive data buffer full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RDRF field. */
#define LPUART_RD_STAT_RDRF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RDRF_MASK) >> LPUART_STAT_RDRF_SHIFT)
#define LPUART_BRD_STAT_RDRF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RDRF_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TC[22] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). TC is cleared by writing to
 * LPUART_DATA to transmit new data, queuing a preamble by clearing and then
 * setting LPUART_CTRL[TE], queuing a break character by writing 1 to
 * LPUART_CTRL[SBK].
 *
 * Values:
 * - 0b0 - Transmitter active (sending data, a preamble, or a break).
 * - 0b1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TC field. */
#define LPUART_RD_STAT_TC(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TC_MASK) >> LPUART_STAT_TC_SHIFT)
#define LPUART_BRD_STAT_TC(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_TC_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TDRE[23] (RO)
 *
 * TDRE will set when the transmit data register (LPUART_DATA) is empty. To
 * clear TDRE, write to the LPUART data register (LPUART_DATA). TDRE is not affected
 * by a character that is in the process of being transmitted, it is updated at
 * the start of each transmitted character.
 *
 * Values:
 * - 0b0 - Transmit data buffer full.
 * - 0b1 - Transmit data buffer empty.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TDRE field. */
#define LPUART_RD_STAT_TDRE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TDRE_MASK) >> LPUART_STAT_TDRE_SHIFT)
#define LPUART_BRD_STAT_TDRE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_TDRE_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RAF[24] (RO)
 *
 * RAF is set when the receiver detects the beginning of a valid start bit, and
 * RAF is cleared automatically when the receiver detects an idle line.
 *
 * Values:
 * - 0b0 - LPUART receiver idle waiting for a start bit.
 * - 0b1 - LPUART receiver active (LPUART_RX input not idle).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RAF field. */
#define LPUART_RD_STAT_RAF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RAF_MASK) >> LPUART_STAT_RAF_SHIFT)
#define LPUART_BRD_STAT_RAF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RAF_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDE[25] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * receive data is not stored in the receive data buffer.
 *
 * Values:
 * - 0b0 - Break character is detected at length 10 bit times (if M = 0, SBNS =
 *     0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1
 *     or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is detected at length of 11 bit times (if M = 0, SBNS
 *     = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS
 *     = 1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDE field. */
#define LPUART_RD_STAT_LBKDE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDE_MASK) >> LPUART_STAT_LBKDE_SHIFT)
#define LPUART_BRD_STAT_LBKDE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDE_SHIFT))

/*! @brief Set the LBKDE field to a new value. */
#define LPUART_WR_STAT_LBKDE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_LBKDE(value)))
#define LPUART_BWR_STAT_LBKDE(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field BRK13[26] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit. This bit should only be
 * changed when the transmitter is disabled.
 *
 * Values:
 * - 0b0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_BRK13 field. */
#define LPUART_RD_STAT_BRK13(base) ((LPUART_STAT_REG(base) & LPUART_STAT_BRK13_MASK) >> LPUART_STAT_BRK13_SHIFT)
#define LPUART_BRD_STAT_BRK13(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_BRK13_SHIFT))

/*! @brief Set the BRK13 field to a new value. */
#define LPUART_WR_STAT_BRK13(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_BRK13_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_BRK13(value)))
#define LPUART_BWR_STAT_BRK13(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_BRK13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RWUID[27] (RW)
 *
 * For RWU on idle character, RWUID controls whether the idle character that
 * wakes up the receiver sets the IDLE bit. For address match wakeup, RWUID controls
 * if the IDLE bit is set when the address does not match. This bit should only
 * be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character. During address match wakeup, the
 *     IDLE bit does not get set when an address does not match.
 * - 0b1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character. During address match wakeup, the IDLE bit
 *     does get set when an address does not match.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RWUID field. */
#define LPUART_RD_STAT_RWUID(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RWUID_MASK) >> LPUART_STAT_RWUID_SHIFT)
#define LPUART_BRD_STAT_RWUID(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RWUID_SHIFT))

/*! @brief Set the RWUID field to a new value. */
#define LPUART_WR_STAT_RWUID(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RWUID_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RWUID(value)))
#define LPUART_BWR_STAT_RWUID(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RWUID_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the LPUART_RX input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0b0 - Receive data not inverted.
 * - 0b1 - Receive data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXINV field. */
#define LPUART_RD_STAT_RXINV(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXINV_MASK) >> LPUART_STAT_RXINV_SHIFT)
#define LPUART_BRD_STAT_RXINV(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXINV_SHIFT))

/*! @brief Set the RXINV field to a new value. */
#define LPUART_WR_STAT_RXINV(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXINV_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXINV(value)))
#define LPUART_BWR_STAT_RXINV(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MSBF[29] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 0b1 - MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit depending on the setting of CTRL[M], CTRL[PE] and
 *     BAUD[M10]. Further, the first bit received after the start bit is
 *     identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and
 *     CTRL[PE].
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MSBF field. */
#define LPUART_RD_STAT_MSBF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MSBF_MASK) >> LPUART_STAT_MSBF_SHIFT)
#define LPUART_BRD_STAT_MSBF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MSBF_SHIFT))

/*! @brief Set the MSBF field to a new value. */
#define LPUART_WR_STAT_MSBF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MSBF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MSBF(value)))
#define LPUART_BWR_STAT_MSBF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MSBF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXEDGIF[30] (W1C)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the LPUART_RX pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No active edge on the receive pin has occurred.
 * - 0b1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXEDGIF field. */
#define LPUART_RD_STAT_RXEDGIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXEDGIF_MASK) >> LPUART_STAT_RXEDGIF_SHIFT)
#define LPUART_BRD_STAT_RXEDGIF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXEDGIF_SHIFT))

/*! @brief Set the RXEDGIF field to a new value. */
#define LPUART_WR_STAT_RXEDGIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXEDGIF(value)))
#define LPUART_BWR_STAT_RXEDGIF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXEDGIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDIF[31] (W1C)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No LIN break character has been detected.
 * - 0b1 - LIN break character has been detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDIF field. */
#define LPUART_RD_STAT_LBKDIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDIF_MASK) >> LPUART_STAT_LBKDIF_SHIFT)
#define LPUART_BRD_STAT_LBKDIF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDIF_SHIFT))

/*! @brief Set the LBKDIF field to a new value. */
#define LPUART_WR_STAT_LBKDIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK), LPUART_STAT_LBKDIF(value)))
#define LPUART_BWR_STAT_LBKDIF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPUART_CTRL - LPUART Control Register
 ******************************************************************************/

/*!
 * @brief LPUART_CTRL - LPUART Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This read/write register controls various optional features of the LPUART
 * system. This register should only be altered when the transmitter and receiver
 * are both disabled.
 */
/*!
 * @name Constants and macros for entire LPUART_CTRL register
 */
/*@{*/
#define LPUART_RD_CTRL(base)     (LPUART_CTRL_REG(base))
#define LPUART_WR_CTRL(base, value) (LPUART_CTRL_REG(base) = (value))
#define LPUART_RMW_CTRL(base, mask, value) (LPUART_WR_CTRL(base, (LPUART_RD_CTRL(base) & ~(mask)) | (value)))
#define LPUART_SET_CTRL(base, value) (LPUART_WR_CTRL(base, LPUART_RD_CTRL(base) |  (value)))
#define LPUART_CLR_CTRL(base, value) (LPUART_WR_CTRL(base, LPUART_RD_CTRL(base) & ~(value)))
#define LPUART_TOG_CTRL(base, value) (LPUART_WR_CTRL(base, LPUART_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_CTRL bitfields
 */

/*!
 * @name Register LPUART_CTRL, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0b0 - Even parity.
 * - 0b1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PT field. */
#define LPUART_RD_CTRL_PT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PT_MASK) >> LPUART_CTRL_PT_SHIFT)
#define LPUART_BRD_CTRL_PT(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PT_SHIFT))

/*! @brief Set the PT field to a new value. */
#define LPUART_WR_CTRL_PT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PT_MASK, LPUART_CTRL_PT(value)))
#define LPUART_BWR_CTRL_PT(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * bit immediately before the stop bit is treated as the parity bit.
 *
 * Values:
 * - 0b0 - No hardware parity generation or checking.
 * - 0b1 - Parity enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PE field. */
#define LPUART_RD_CTRL_PE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PE_MASK) >> LPUART_CTRL_PE_SHIFT)
#define LPUART_BRD_CTRL_PE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PE_SHIFT))

/*! @brief Set the PE field to a new value. */
#define LPUART_WR_CTRL_PE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PE_MASK, LPUART_CTRL_PE(value)))
#define LPUART_BWR_CTRL_PE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the LPUART is programmed with ILT = 1, a
 * logic 0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count.
 *
 * Values:
 * - 0b0 - Idle character bit count starts after start bit.
 * - 0b1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILT field. */
#define LPUART_RD_CTRL_ILT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILT_MASK) >> LPUART_CTRL_ILT_SHIFT)
#define LPUART_BRD_CTRL_ILT(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILT_SHIFT))

/*! @brief Set the ILT field to a new value. */
#define LPUART_WR_CTRL_ILT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILT_MASK, LPUART_CTRL_ILT(value)))
#define LPUART_BWR_CTRL_ILT(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field WAKE[3] (RW)
 *
 * Determines which condition wakes the LPUART when RWU=1: Address mark in the
 * most significant bit position of a received data character, or An idle
 * condition on the receive pin input signal.
 *
 * Values:
 * - 0b0 - Configures RWU for idle-line wakeup.
 * - 0b1 - Configures RWU with address-mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_WAKE field. */
#define LPUART_RD_CTRL_WAKE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_WAKE_MASK) >> LPUART_CTRL_WAKE_SHIFT)
#define LPUART_BRD_CTRL_WAKE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_WAKE_SHIFT))

/*! @brief Set the WAKE field to a new value. */
#define LPUART_WR_CTRL_WAKE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_WAKE_MASK, LPUART_CTRL_WAKE(value)))
#define LPUART_BWR_CTRL_WAKE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_WAKE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field M[4] (RW)
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit data characters.
 * - 0b1 - Receiver and transmitter use 9-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_M field. */
#define LPUART_RD_CTRL_M(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_M_MASK) >> LPUART_CTRL_M_SHIFT)
#define LPUART_BRD_CTRL_M(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_M_SHIFT))

/*! @brief Set the M field to a new value. */
#define LPUART_WR_CTRL_M(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_M_MASK, LPUART_CTRL_M(value)))
#define LPUART_BWR_CTRL_M(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_M_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0b0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back
 *     mode and the LPUART does not use the LPUART_RX pin.
 * - 0b1 - Single-wire LPUART mode where the LPUART_TX pin is connected to the
 *     transmitter output and receiver input.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RSRC field. */
#define LPUART_RD_CTRL_RSRC(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RSRC_MASK) >> LPUART_CTRL_RSRC_SHIFT)
#define LPUART_BRD_CTRL_RSRC(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RSRC_SHIFT))

/*! @brief Set the RSRC field to a new value. */
#define LPUART_WR_CTRL_RSRC(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RSRC_MASK, LPUART_CTRL_RSRC(value)))
#define LPUART_BWR_CTRL_RSRC(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field DOZEEN[6] (RW)
 *
 * Values:
 * - 0b0 - LPUART is enabled in Doze mode.
 * - 0b1 - LPUART is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_DOZEEN field. */
#define LPUART_RD_CTRL_DOZEEN(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_DOZEEN_MASK) >> LPUART_CTRL_DOZEEN_SHIFT)
#define LPUART_BRD_CTRL_DOZEEN(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_DOZEEN_SHIFT))

/*! @brief Set the DOZEEN field to a new value. */
#define LPUART_WR_CTRL_DOZEEN(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_DOZEEN_MASK, LPUART_CTRL_DOZEEN(value)))
#define LPUART_BWR_CTRL_DOZEEN(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_DOZEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the LPUART_RX pin is disconnected from the LPUART and the
 * transmitter output is internally connected to the receiver input. The
 * transmitter and the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0b0 - Normal operation - LPUART_RX and LPUART_TX use separate pins.
 * - 0b1 - Loop mode or single-wire mode where transmitter outputs are
 *     internally connected to receiver input (see RSRC bit).
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_LOOPS field. */
#define LPUART_RD_CTRL_LOOPS(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_LOOPS_MASK) >> LPUART_CTRL_LOOPS_SHIFT)
#define LPUART_BRD_CTRL_LOOPS(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_LOOPS_SHIFT))

/*! @brief Set the LOOPS field to a new value. */
#define LPUART_WR_CTRL_LOOPS(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_LOOPS_MASK, LPUART_CTRL_LOOPS(value)))
#define LPUART_BWR_CTRL_LOOPS(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_LOOPS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field IDLECFG[10:8] (RW)
 *
 * Configures the number of idle characters that must be received before the
 * IDLE flag is set.
 *
 * Values:
 * - 0b000 - 1 idle character
 * - 0b001 - 2 idle characters
 * - 0b010 - 4 idle characters
 * - 0b011 - 8 idle characters
 * - 0b100 - 16 idle characters
 * - 0b101 - 32 idle characters
 * - 0b110 - 64 idle characters
 * - 0b111 - 128 idle characters
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_IDLECFG field. */
#define LPUART_RD_CTRL_IDLECFG(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_IDLECFG_MASK) >> LPUART_CTRL_IDLECFG_SHIFT)
#define LPUART_BRD_CTRL_IDLECFG(base) (LPUART_RD_CTRL_IDLECFG(base))

/*! @brief Set the IDLECFG field to a new value. */
#define LPUART_WR_CTRL_IDLECFG(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_IDLECFG_MASK, LPUART_CTRL_IDLECFG(value)))
#define LPUART_BWR_CTRL_IDLECFG(base, value) (LPUART_WR_CTRL_IDLECFG(base, value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA2IE[14] (RW)
 *
 * Values:
 * - 0b0 - MA2F interrupt disabled
 * - 0b1 - MA2F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA2IE field. */
#define LPUART_RD_CTRL_MA2IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA2IE_MASK) >> LPUART_CTRL_MA2IE_SHIFT)
#define LPUART_BRD_CTRL_MA2IE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA2IE_SHIFT))

/*! @brief Set the MA2IE field to a new value. */
#define LPUART_WR_CTRL_MA2IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA2IE_MASK, LPUART_CTRL_MA2IE(value)))
#define LPUART_BWR_CTRL_MA2IE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA2IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA1IE[15] (RW)
 *
 * Values:
 * - 0b0 - MA1F interrupt disabled
 * - 0b1 - MA1F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA1IE field. */
#define LPUART_RD_CTRL_MA1IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA1IE_MASK) >> LPUART_CTRL_MA1IE_SHIFT)
#define LPUART_BRD_CTRL_MA1IE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA1IE_SHIFT))

/*! @brief Set the MA1IE field to a new value. */
#define LPUART_WR_CTRL_MA1IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA1IE_MASK, LPUART_CTRL_MA1IE(value)))
#define LPUART_BWR_CTRL_MA1IE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA1IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field SBK[16] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 to 13, or 13 to 16 if
 * LPUART_STATBRK13] is set, bit times of logic 0 are queued as long as SBK is set. Depending
 * on the timing of the set and clear of SBK relative to the information
 * currently being transmitted, a second break character may be queued before software
 * clears SBK.
 *
 * Values:
 * - 0b0 - Normal transmitter operation.
 * - 0b1 - Queue break character(s) to be sent.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_SBK field. */
#define LPUART_RD_CTRL_SBK(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_SBK_MASK) >> LPUART_CTRL_SBK_SHIFT)
#define LPUART_BRD_CTRL_SBK(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_SBK_SHIFT))

/*! @brief Set the SBK field to a new value. */
#define LPUART_WR_CTRL_SBK(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_SBK_MASK, LPUART_CTRL_SBK(value)))
#define LPUART_BWR_CTRL_SBK(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_SBK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RWU[17] (RW)
 *
 * This field can be set to place the LPUART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * CTRL[WAKE] is clear or an address match when CTRL[WAKE] is set with STAT[RWUID] is
 * clear. RWU must be set only with CTRL[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by STAT[RAF]. If the flag is
 * set to wake up an IDLE event and the channel is already idle, it is possible
 * that the LPUART will discard data. This is because the data must be received or
 * a LIN break detected after an IDLE is detected before IDLE is allowed to be
 * reasserted.
 *
 * Values:
 * - 0b0 - Normal receiver operation.
 * - 0b1 - LPUART receiver in standby waiting for wakeup condition.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RWU field. */
#define LPUART_RD_CTRL_RWU(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RWU_MASK) >> LPUART_CTRL_RWU_SHIFT)
#define LPUART_BRD_CTRL_RWU(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RWU_SHIFT))

/*! @brief Set the RWU field to a new value. */
#define LPUART_WR_CTRL_RWU(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RWU_MASK, LPUART_CTRL_RWU(value)))
#define LPUART_BWR_CTRL_RWU(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RWU_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RE[18] (RW)
 *
 * Enables the LPUART receiver. When RE is written to 0, this register bit will
 * read as 1 until the receiver finishes receiving the current character (if any).
 *
 * Values:
 * - 0b0 - Receiver disabled.
 * - 0b1 - Receiver enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RE field. */
#define LPUART_RD_CTRL_RE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RE_MASK) >> LPUART_CTRL_RE_SHIFT)
#define LPUART_BRD_CTRL_RE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RE_SHIFT))

/*! @brief Set the RE field to a new value. */
#define LPUART_WR_CTRL_RE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RE_MASK, LPUART_CTRL_RE(value)))
#define LPUART_BWR_CTRL_RE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TE[19] (RW)
 *
 * Enables the LPUART transmitter. TE can also be used to queue an idle preamble
 * by clearing and then setting TE. When TE is cleared, this register bit will
 * read as 1 until the transmitter has completed the current character and the
 * LPUART_TX pin is tristated.
 *
 * Values:
 * - 0b0 - Transmitter disabled.
 * - 0b1 - Transmitter enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TE field. */
#define LPUART_RD_CTRL_TE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TE_MASK) >> LPUART_CTRL_TE_SHIFT)
#define LPUART_BRD_CTRL_TE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TE_SHIFT))

/*! @brief Set the TE field to a new value. */
#define LPUART_WR_CTRL_TE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TE_MASK, LPUART_CTRL_TE(value)))
#define LPUART_BWR_CTRL_TE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILIE[20] (RW)
 *
 * ILIE enables the idle line flag, STAT[IDLE], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from IDLE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILIE field. */
#define LPUART_RD_CTRL_ILIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILIE_MASK) >> LPUART_CTRL_ILIE_SHIFT)
#define LPUART_BRD_CTRL_ILIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILIE_SHIFT))

/*! @brief Set the ILIE field to a new value. */
#define LPUART_WR_CTRL_ILIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILIE_MASK, LPUART_CTRL_ILIE(value)))
#define LPUART_BWR_CTRL_ILIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RIE[21] (RW)
 *
 * Enables STAT[RDRF] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from RDRF disabled; use polling.
 * - 0b1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RIE field. */
#define LPUART_RD_CTRL_RIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RIE_MASK) >> LPUART_CTRL_RIE_SHIFT)
#define LPUART_BRD_CTRL_RIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RIE_SHIFT))

/*! @brief Set the RIE field to a new value. */
#define LPUART_WR_CTRL_RIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RIE_MASK, LPUART_CTRL_RIE(value)))
#define LPUART_BWR_CTRL_RIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TCIE[22] (RW)
 *
 * TCIE enables the transmission complete flag, TC, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TC disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TCIE field. */
#define LPUART_RD_CTRL_TCIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TCIE_MASK) >> LPUART_CTRL_TCIE_SHIFT)
#define LPUART_BRD_CTRL_TCIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TCIE_SHIFT))

/*! @brief Set the TCIE field to a new value. */
#define LPUART_WR_CTRL_TCIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TCIE_MASK, LPUART_CTRL_TCIE(value)))
#define LPUART_BWR_CTRL_TCIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TIE[23] (RW)
 *
 * Enables STAT[TDRE] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TDRE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TIE field. */
#define LPUART_RD_CTRL_TIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TIE_MASK) >> LPUART_CTRL_TIE_SHIFT)
#define LPUART_BRD_CTRL_TIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define LPUART_WR_CTRL_TIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TIE_MASK, LPUART_CTRL_TIE(value)))
#define LPUART_BWR_CTRL_TIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PEIE[24] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - PF interrupts disabled; use polling).
 * - 0b1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PEIE field. */
#define LPUART_RD_CTRL_PEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PEIE_MASK) >> LPUART_CTRL_PEIE_SHIFT)
#define LPUART_BRD_CTRL_PEIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PEIE_SHIFT))

/*! @brief Set the PEIE field to a new value. */
#define LPUART_WR_CTRL_PEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PEIE_MASK, LPUART_CTRL_PEIE(value)))
#define LPUART_BWR_CTRL_PEIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field FEIE[25] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - FE interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_FEIE field. */
#define LPUART_RD_CTRL_FEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_FEIE_MASK) >> LPUART_CTRL_FEIE_SHIFT)
#define LPUART_BRD_CTRL_FEIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define LPUART_WR_CTRL_FEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_FEIE_MASK, LPUART_CTRL_FEIE(value)))
#define LPUART_BWR_CTRL_FEIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field NEIE[26] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0b0 - NF interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_NEIE field. */
#define LPUART_RD_CTRL_NEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_NEIE_MASK) >> LPUART_CTRL_NEIE_SHIFT)
#define LPUART_BRD_CTRL_NEIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_NEIE_SHIFT))

/*! @brief Set the NEIE field to a new value. */
#define LPUART_WR_CTRL_NEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_NEIE_MASK, LPUART_CTRL_NEIE(value)))
#define LPUART_BWR_CTRL_NEIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_NEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ORIE[27] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - OR interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ORIE field. */
#define LPUART_RD_CTRL_ORIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ORIE_MASK) >> LPUART_CTRL_ORIE_SHIFT)
#define LPUART_BRD_CTRL_ORIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ORIE_SHIFT))

/*! @brief Set the ORIE field to a new value. */
#define LPUART_WR_CTRL_ORIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ORIE_MASK, LPUART_CTRL_ORIE(value)))
#define LPUART_BWR_CTRL_ORIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ORIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the LPUART_TX output for all cases: data bits, start and stop
 * bits, break, and idle.
 *
 * Values:
 * - 0b0 - Transmit data not inverted.
 * - 0b1 - Transmit data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXINV field. */
#define LPUART_RD_CTRL_TXINV(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXINV_MASK) >> LPUART_CTRL_TXINV_SHIFT)
#define LPUART_BRD_CTRL_TXINV(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXINV_SHIFT))

/*! @brief Set the TXINV field to a new value. */
#define LPUART_WR_CTRL_TXINV(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXINV_MASK, LPUART_CTRL_TXINV(value)))
#define LPUART_BWR_CTRL_TXINV(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXDIR[29] (RW)
 *
 * When the LPUART is configured for single-wire half-duplex operation (LOOPS =
 * RSRC = 1), this bit determines the direction of data at the LPUART_TX pin.
 * When clearing TXDIR, the transmitter will finish receiving the current character
 * (if any) before the receiver starts receiving data from the LPUART_TX pin.
 *
 * Values:
 * - 0b0 - LPUART_TX pin is an input in single-wire mode.
 * - 0b1 - LPUART_TX pin is an output in single-wire mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXDIR field. */
#define LPUART_RD_CTRL_TXDIR(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXDIR_MASK) >> LPUART_CTRL_TXDIR_SHIFT)
#define LPUART_BRD_CTRL_TXDIR(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXDIR_SHIFT))

/*! @brief Set the TXDIR field to a new value. */
#define LPUART_WR_CTRL_TXDIR(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXDIR_MASK, LPUART_CTRL_TXDIR(value)))
#define LPUART_BWR_CTRL_TXDIR(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXDIR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R9T8[30] (RW)
 *
 * R9 is the tenth data bit received when the LPUART is configured for 10-bit
 * data formats. When reading 10-bit data, read R9 before reading LPUART_DATA T8 is
 * the ninth data bit received when the LPUART is configured for 9-bit or 10-bit
 * data formats. When writing 9-bit or 10-bit data, write T8 before writing
 * LPUART_DATA. If T8 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written each
 * time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R9T8 field. */
#define LPUART_RD_CTRL_R9T8(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R9T8_MASK) >> LPUART_CTRL_R9T8_SHIFT)
#define LPUART_BRD_CTRL_R9T8(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R9T8_SHIFT))

/*! @brief Set the R9T8 field to a new value. */
#define LPUART_WR_CTRL_R9T8(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R9T8_MASK, LPUART_CTRL_R9T8(value)))
#define LPUART_BWR_CTRL_R9T8(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R9T8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R8T9[31] (RW)
 *
 * R8 is the ninth data bit received when the LPUART is configured for 9-bit or
 * 10-bit data formats. When reading 9-bit or 10-bit data, read R8 before reading
 * LPUART_DATA. T9 is the tenth data bit received when the LPUART is configured
 * for 10-bit data formats. When writing 10-bit data, write T9 before writing
 * LPUART_DATA. If T9 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written
 * each time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R8T9 field. */
#define LPUART_RD_CTRL_R8T9(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R8T9_MASK) >> LPUART_CTRL_R8T9_SHIFT)
#define LPUART_BRD_CTRL_R8T9(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R8T9_SHIFT))

/*! @brief Set the R8T9 field to a new value. */
#define LPUART_WR_CTRL_R8T9(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R8T9_MASK, LPUART_CTRL_R8T9(value)))
#define LPUART_BWR_CTRL_R8T9(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R8T9_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPUART_DATA - LPUART Data Register
 ******************************************************************************/

/*!
 * @brief LPUART_DATA - LPUART Data Register (RW)
 *
 * Reset value: 0x00001000U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for some of the LPUART status flags.
 */
/*!
 * @name Constants and macros for entire LPUART_DATA register
 */
/*@{*/
#define LPUART_RD_DATA(base)     (LPUART_DATA_REG(base))
#define LPUART_WR_DATA(base, value) (LPUART_DATA_REG(base) = (value))
#define LPUART_RMW_DATA(base, mask, value) (LPUART_WR_DATA(base, (LPUART_RD_DATA(base) & ~(mask)) | (value)))
#define LPUART_SET_DATA(base, value) (LPUART_WR_DATA(base, LPUART_RD_DATA(base) |  (value)))
#define LPUART_CLR_DATA(base, value) (LPUART_WR_DATA(base, LPUART_RD_DATA(base) & ~(value)))
#define LPUART_TOG_DATA(base, value) (LPUART_WR_DATA(base, LPUART_RD_DATA(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_DATA bitfields
 */

/*!
 * @name Register LPUART_DATA, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R0T0 field. */
#define LPUART_RD_DATA_R0T0(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R0T0_MASK) >> LPUART_DATA_R0T0_SHIFT)
#define LPUART_BRD_DATA_R0T0(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R0T0_SHIFT))

/*! @brief Set the R0T0 field to a new value. */
#define LPUART_WR_DATA_R0T0(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R0T0_MASK, LPUART_DATA_R0T0(value)))
#define LPUART_BWR_DATA_R0T0(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R0T0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R1T1 field. */
#define LPUART_RD_DATA_R1T1(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R1T1_MASK) >> LPUART_DATA_R1T1_SHIFT)
#define LPUART_BRD_DATA_R1T1(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R1T1_SHIFT))

/*! @brief Set the R1T1 field to a new value. */
#define LPUART_WR_DATA_R1T1(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R1T1_MASK, LPUART_DATA_R1T1(value)))
#define LPUART_BWR_DATA_R1T1(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R1T1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R2T2 field. */
#define LPUART_RD_DATA_R2T2(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R2T2_MASK) >> LPUART_DATA_R2T2_SHIFT)
#define LPUART_BRD_DATA_R2T2(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R2T2_SHIFT))

/*! @brief Set the R2T2 field to a new value. */
#define LPUART_WR_DATA_R2T2(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R2T2_MASK, LPUART_DATA_R2T2(value)))
#define LPUART_BWR_DATA_R2T2(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R2T2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R3T3 field. */
#define LPUART_RD_DATA_R3T3(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R3T3_MASK) >> LPUART_DATA_R3T3_SHIFT)
#define LPUART_BRD_DATA_R3T3(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R3T3_SHIFT))

/*! @brief Set the R3T3 field to a new value. */
#define LPUART_WR_DATA_R3T3(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R3T3_MASK, LPUART_DATA_R3T3(value)))
#define LPUART_BWR_DATA_R3T3(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R3T3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R4T4 field. */
#define LPUART_RD_DATA_R4T4(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R4T4_MASK) >> LPUART_DATA_R4T4_SHIFT)
#define LPUART_BRD_DATA_R4T4(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R4T4_SHIFT))

/*! @brief Set the R4T4 field to a new value. */
#define LPUART_WR_DATA_R4T4(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R4T4_MASK, LPUART_DATA_R4T4(value)))
#define LPUART_BWR_DATA_R4T4(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R4T4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R5T5 field. */
#define LPUART_RD_DATA_R5T5(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R5T5_MASK) >> LPUART_DATA_R5T5_SHIFT)
#define LPUART_BRD_DATA_R5T5(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R5T5_SHIFT))

/*! @brief Set the R5T5 field to a new value. */
#define LPUART_WR_DATA_R5T5(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R5T5_MASK, LPUART_DATA_R5T5(value)))
#define LPUART_BWR_DATA_R5T5(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R5T5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R6T6 field. */
#define LPUART_RD_DATA_R6T6(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R6T6_MASK) >> LPUART_DATA_R6T6_SHIFT)
#define LPUART_BRD_DATA_R6T6(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R6T6_SHIFT))

/*! @brief Set the R6T6 field to a new value. */
#define LPUART_WR_DATA_R6T6(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R6T6_MASK, LPUART_DATA_R6T6(value)))
#define LPUART_BWR_DATA_R6T6(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R6T6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R7T7 field. */
#define LPUART_RD_DATA_R7T7(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R7T7_MASK) >> LPUART_DATA_R7T7_SHIFT)
#define LPUART_BRD_DATA_R7T7(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R7T7_SHIFT))

/*! @brief Set the R7T7 field to a new value. */
#define LPUART_WR_DATA_R7T7(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R7T7_MASK, LPUART_DATA_R7T7(value)))
#define LPUART_BWR_DATA_R7T7(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R7T7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R8T8[8] (RW)
 *
 * Read receive data buffer 8 or write transmit data buffer 8.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R8T8 field. */
#define LPUART_RD_DATA_R8T8(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R8T8_MASK) >> LPUART_DATA_R8T8_SHIFT)
#define LPUART_BRD_DATA_R8T8(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R8T8_SHIFT))

/*! @brief Set the R8T8 field to a new value. */
#define LPUART_WR_DATA_R8T8(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R8T8_MASK, LPUART_DATA_R8T8(value)))
#define LPUART_BWR_DATA_R8T8(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R8T8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R9T9[9] (RW)
 *
 * Read receive data buffer 9 or write transmit data buffer 9.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R9T9 field. */
#define LPUART_RD_DATA_R9T9(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R9T9_MASK) >> LPUART_DATA_R9T9_SHIFT)
#define LPUART_BRD_DATA_R9T9(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R9T9_SHIFT))

/*! @brief Set the R9T9 field to a new value. */
#define LPUART_WR_DATA_R9T9(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R9T9_MASK, LPUART_DATA_R9T9(value)))
#define LPUART_BWR_DATA_R9T9(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R9T9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field IDLINE[11] (RO)
 *
 * Indicates the receiver line was idle before receiving the character in
 * DATA[9:0]. Unlike the IDLE flag, this bit can set for the first character received
 * when the receiver is first enabled.
 *
 * Values:
 * - 0b0 - Receiver was not idle before receiving this character.
 * - 0b1 - Receiver was idle before receiving this character.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_IDLINE field. */
#define LPUART_RD_DATA_IDLINE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_IDLINE_MASK) >> LPUART_DATA_IDLINE_SHIFT)
#define LPUART_BRD_DATA_IDLINE(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_IDLINE_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_DATA, field RXEMPT[12] (RO)
 *
 * Asserts when there is no data in the receive buffer. This field does not take
 * into account data that is in the receive shift register.
 *
 * Values:
 * - 0b0 - Receive buffer contains valid data.
 * - 0b1 - Receive buffer is empty, data returned on read is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_RXEMPT field. */
#define LPUART_RD_DATA_RXEMPT(base) ((LPUART_DATA_REG(base) & LPUART_DATA_RXEMPT_MASK) >> LPUART_DATA_RXEMPT_SHIFT)
#define LPUART_BRD_DATA_RXEMPT(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_RXEMPT_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_DATA, field FRETSC[13] (RW)
 *
 * For reads, indicates the current received dataword contained in DATA[R9:R0]
 * was received with a frame error. For writes, indicates a break or idle
 * character is to be transmitted instead of the contents in DATA[T9:T0]. T9 is used to
 * indicate a break character when 0 and a idle character when 1, he contents of
 * DATA[T8:T0] should be zero.
 *
 * Values:
 * - 0b0 - The dataword was received without a frame error on read, transmit a
 *     normal character on write.
 * - 0b1 - The dataword was received with a frame error, transmit an idle or
 *     break character on transmit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_FRETSC field. */
#define LPUART_RD_DATA_FRETSC(base) ((LPUART_DATA_REG(base) & LPUART_DATA_FRETSC_MASK) >> LPUART_DATA_FRETSC_SHIFT)
#define LPUART_BRD_DATA_FRETSC(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_FRETSC_SHIFT))

/*! @brief Set the FRETSC field to a new value. */
#define LPUART_WR_DATA_FRETSC(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_FRETSC_MASK, LPUART_DATA_FRETSC(value)))
#define LPUART_BWR_DATA_FRETSC(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_FRETSC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field PARITYE[14] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with a
 * parity error.
 *
 * Values:
 * - 0b0 - The dataword was received without a parity error.
 * - 0b1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_PARITYE field. */
#define LPUART_RD_DATA_PARITYE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_PARITYE_MASK) >> LPUART_DATA_PARITYE_SHIFT)
#define LPUART_BRD_DATA_PARITYE(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_PARITYE_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_DATA, field NOISY[15] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with
 * noise.
 *
 * Values:
 * - 0b0 - The dataword was received without noise.
 * - 0b1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_NOISY field. */
#define LPUART_RD_DATA_NOISY(base) ((LPUART_DATA_REG(base) & LPUART_DATA_NOISY_MASK) >> LPUART_DATA_NOISY_SHIFT)
#define LPUART_BRD_DATA_NOISY(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_NOISY_SHIFT))
/*@}*/

/*******************************************************************************
 * LPUART_MATCH - LPUART Match Address Register
 ******************************************************************************/

/*!
 * @brief LPUART_MATCH - LPUART Match Address Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_MATCH register
 */
/*@{*/
#define LPUART_RD_MATCH(base)    (LPUART_MATCH_REG(base))
#define LPUART_WR_MATCH(base, value) (LPUART_MATCH_REG(base) = (value))
#define LPUART_RMW_MATCH(base, mask, value) (LPUART_WR_MATCH(base, (LPUART_RD_MATCH(base) & ~(mask)) | (value)))
#define LPUART_SET_MATCH(base, value) (LPUART_WR_MATCH(base, LPUART_RD_MATCH(base) |  (value)))
#define LPUART_CLR_MATCH(base, value) (LPUART_WR_MATCH(base, LPUART_RD_MATCH(base) & ~(value)))
#define LPUART_TOG_MATCH(base, value) (LPUART_WR_MATCH(base, LPUART_RD_MATCH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MATCH bitfields
 */

/*!
 * @name Register LPUART_MATCH, field MA1[9:0] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA1 field. */
#define LPUART_RD_MATCH_MA1(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA1_MASK) >> LPUART_MATCH_MA1_SHIFT)
#define LPUART_BRD_MATCH_MA1(base) (LPUART_RD_MATCH_MA1(base))

/*! @brief Set the MA1 field to a new value. */
#define LPUART_WR_MATCH_MA1(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA1_MASK, LPUART_MATCH_MA1(value)))
#define LPUART_BWR_MATCH_MA1(base, value) (LPUART_WR_MATCH_MA1(base, value))
/*@}*/

/*!
 * @name Register LPUART_MATCH, field MA2[25:16] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA2 field. */
#define LPUART_RD_MATCH_MA2(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA2_MASK) >> LPUART_MATCH_MA2_SHIFT)
#define LPUART_BRD_MATCH_MA2(base) (LPUART_RD_MATCH_MA2(base))

/*! @brief Set the MA2 field to a new value. */
#define LPUART_WR_MATCH_MA2(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA2_MASK, LPUART_MATCH_MA2(value)))
#define LPUART_BWR_MATCH_MA2(base, value) (LPUART_WR_MATCH_MA2(base, value))
/*@}*/

/*******************************************************************************
 * LPUART_MODIR - LPUART Modem IrDA Register
 ******************************************************************************/

/*!
 * @brief LPUART_MODIR - LPUART Modem IrDA Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MODEM register controls options for setting the modem configuration.
 */
/*!
 * @name Constants and macros for entire LPUART_MODIR register
 */
/*@{*/
#define LPUART_RD_MODIR(base)    (LPUART_MODIR_REG(base))
#define LPUART_WR_MODIR(base, value) (LPUART_MODIR_REG(base) = (value))
#define LPUART_RMW_MODIR(base, mask, value) (LPUART_WR_MODIR(base, (LPUART_RD_MODIR(base) & ~(mask)) | (value)))
#define LPUART_SET_MODIR(base, value) (LPUART_WR_MODIR(base, LPUART_RD_MODIR(base) |  (value)))
#define LPUART_CLR_MODIR(base, value) (LPUART_WR_MODIR(base, LPUART_RD_MODIR(base) & ~(value)))
#define LPUART_TOG_MODIR(base, value) (LPUART_WR_MODIR(base, LPUART_RD_MODIR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MODIR bitfields
 */

/*!
 * @name Register LPUART_MODIR, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0b0 - CTS has no effect on the transmitter.
 * - 0b1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as
 *     a character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSE field. */
#define LPUART_RD_MODIR_TXCTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSE_MASK) >> LPUART_MODIR_TXCTSE_SHIFT)
#define LPUART_BRD_MODIR_TXCTSE(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSE_SHIFT))

/*! @brief Set the TXCTSE field to a new value. */
#define LPUART_WR_MODIR_TXCTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSE_MASK, LPUART_MODIR_TXCTSE(value)))
#define LPUART_BWR_MODIR_TXCTSE(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0b0 - The transmitter has no effect on RTS.
 * - 0b1 - When a character is placed into an empty transmitter data buffer ,
 *     RTS asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSE field. */
#define LPUART_RD_MODIR_TXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSE_MASK) >> LPUART_MODIR_TXRTSE_SHIFT)
#define LPUART_BRD_MODIR_TXRTSE(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSE_SHIFT))

/*! @brief Set the TXRTSE field to a new value. */
#define LPUART_WR_MODIR_TXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSE_MASK, LPUART_MODIR_TXRTSE(value)))
#define LPUART_BWR_MODIR_TXRTSE(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0b0 - Transmitter RTS is active low.
 * - 0b1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSPOL field. */
#define LPUART_RD_MODIR_TXRTSPOL(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSPOL_MASK) >> LPUART_MODIR_TXRTSPOL_SHIFT)
#define LPUART_BRD_MODIR_TXRTSPOL(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSPOL_SHIFT))

/*! @brief Set the TXRTSPOL field to a new value. */
#define LPUART_WR_MODIR_TXRTSPOL(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSPOL_MASK, LPUART_MODIR_TXRTSPOL(value)))
#define LPUART_BWR_MODIR_TXRTSPOL(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0b0 - The receiver has no effect on RTS.
 * - 0b1 - RTS is deasserted if the receiver data register is full or a start
 *     bit has been detected that would cause the receiver data register to become
 *     full. RTS is asserted if the receiver data register is not full and has
 *     not detected a start bit that would cause the receiver data register to
 *     become full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_RXRTSE field. */
#define LPUART_RD_MODIR_RXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_RXRTSE_MASK) >> LPUART_MODIR_RXRTSE_SHIFT)
#define LPUART_BRD_MODIR_RXRTSE(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_RXRTSE_SHIFT))

/*! @brief Set the RXRTSE field to a new value. */
#define LPUART_WR_MODIR_RXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_RXRTSE_MASK, LPUART_MODIR_RXRTSE(value)))
#define LPUART_BWR_MODIR_RXRTSE(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_RXRTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSC[4] (RW)
 *
 * Configures if the CTS state is checked at the start of each character or only
 * when the transmitter is idle.
 *
 * Values:
 * - 0b0 - CTS input is sampled at the start of each character.
 * - 0b1 - CTS input is sampled when the transmitter is idle.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSC field. */
#define LPUART_RD_MODIR_TXCTSC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSC_MASK) >> LPUART_MODIR_TXCTSC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSC(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSC_SHIFT))

/*! @brief Set the TXCTSC field to a new value. */
#define LPUART_WR_MODIR_TXCTSC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSC_MASK, LPUART_MODIR_TXCTSC(value)))
#define LPUART_BWR_MODIR_TXCTSC(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSSRC[5] (RW)
 *
 * Configures the source of the CTS input.
 *
 * Values:
 * - 0b0 - CTS input is the LPUART_CTS pin.
 * - 0b1 - CTS input is the inverted Receiver Match result.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSSRC field. */
#define LPUART_RD_MODIR_TXCTSSRC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSSRC_MASK) >> LPUART_MODIR_TXCTSSRC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSSRC(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSSRC_SHIFT))

/*! @brief Set the TXCTSSRC field to a new value. */
#define LPUART_WR_MODIR_TXCTSSRC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSSRC_MASK, LPUART_MODIR_TXCTSSRC(value)))
#define LPUART_BWR_MODIR_TXCTSSRC(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TNP[17:16] (RW)
 *
 * Enables whether the LPUART transmits a 1/OSR, 2/OSR, 3/OSR or 4/OSR narrow
 * pulse.
 *
 * Values:
 * - 0b00 - 1/OSR.
 * - 0b01 - 2/OSR.
 * - 0b10 - 3/OSR.
 * - 0b11 - 4/OSR.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TNP field. */
#define LPUART_RD_MODIR_TNP(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TNP_MASK) >> LPUART_MODIR_TNP_SHIFT)
#define LPUART_BRD_MODIR_TNP(base) (LPUART_RD_MODIR_TNP(base))

/*! @brief Set the TNP field to a new value. */
#define LPUART_WR_MODIR_TNP(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TNP_MASK, LPUART_MODIR_TNP(value)))
#define LPUART_BWR_MODIR_TNP(base, value) (LPUART_WR_MODIR_TNP(base, value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field IREN[18] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0b0 - IR disabled.
 * - 0b1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_IREN field. */
#define LPUART_RD_MODIR_IREN(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_IREN_MASK) >> LPUART_MODIR_IREN_SHIFT)
#define LPUART_BRD_MODIR_IREN(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_IREN_SHIFT))

/*! @brief Set the IREN field to a new value. */
#define LPUART_WR_MODIR_IREN(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_IREN_MASK, LPUART_MODIR_IREN(value)))
#define LPUART_BWR_MODIR_IREN(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_IREN_SHIFT) = (value))
/*@}*/

/*
 * S32K144 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - MCM_CPCR - Core Platform Control Register
 * - MCM_ISCR - Interrupt Status and Control Register
 * - MCM_FADR - Store Buffer Fault address register
 * - MCM_FATR - Store Buffer Fault Attributes register
 * - MCM_FDR - Store Buffer Fault Data Register
 * - MCM_PID - Process ID register
 * - MCM_CPO - Compute Operation Control Register
 * - MCM_LMDR - Local Memory Descriptor Register
 * - MCM_LMPECR - LMEM Parity & ECC Control Register
 * - MCM_LMPEIR - LMEM Parity & ECC Interrupt Register
 * - MCM_LMFAR - LMEM Fault Address Register
 * - MCM_LMFATR - LMEM Fault Attribute Register
 * - MCM_LMFDHR - LMEM Fault Data High Register
 * - MCM_LMFDLR - LMEM Fault Data Low Register
 */

#define MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define MCM_IDX (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x0007U
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define MCM_RD_PLASC(base)       (MCM_PLASC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus slave connection to AXBS input port n is absent
 * - 0b00000001 - A bus slave connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define MCM_RD_PLASC_ASC(base) ((MCM_PLASC_REG(base) & MCM_PLASC_ASC_MASK) >> MCM_PLASC_ASC_SHIFT)
#define MCM_BRD_PLASC_ASC(base) (MCM_RD_PLASC_ASC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x0007U
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define MCM_RD_PLAMC(base)       (MCM_PLAMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus master connection to AXBS input port n is absent
 * - 0b00000001 - A bus master connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define MCM_RD_PLAMC_AMC(base) ((MCM_PLAMC_REG(base) & MCM_PLAMC_AMC_MASK) >> MCM_PLAMC_AMC_SHIFT)
#define MCM_BRD_PLAMC_AMC(base) (MCM_RD_PLAMC_AMC(base))
/*@}*/

/*******************************************************************************
 * MCM_CPCR - Core Platform Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPCR - Core Platform Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Control Register defines the arbitration and protection schemes for the two
 * system RAM arrays. Bits 23-0 are undefined after reset.
 */
/*!
 * @name Constants and macros for entire MCM_CPCR register
 */
/*@{*/
#define MCM_RD_CPCR(base)        (MCM_CPCR_REG(base))
#define MCM_WR_CPCR(base, value) (MCM_CPCR_REG(base) = (value))
#define MCM_RMW_CPCR(base, mask, value) (MCM_WR_CPCR(base, (MCM_RD_CPCR(base) & ~(mask)) | (value)))
#define MCM_SET_CPCR(base, value) (MCM_WR_CPCR(base, MCM_RD_CPCR(base) |  (value)))
#define MCM_CLR_CPCR(base, value) (MCM_WR_CPCR(base, MCM_RD_CPCR(base) & ~(value)))
#define MCM_TOG_CPCR(base, value) (MCM_WR_CPCR(base, MCM_RD_CPCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPCR bitfields
 */

/*!
 * @name Register MCM_CPCR, field CBRR[9] (RW)
 *
 * Configures the crossbar slave ports to fixed-priority or round-robin
 * arbitration.
 *
 * Values:
 * - 0b0 - Fixed-priority arbitration
 * - 0b1 - Round-robin arbitration
 */
/*@{*/
/*! @brief Read current value of the MCM_CPCR_CBRR field. */
#define MCM_RD_CPCR_CBRR(base) ((MCM_CPCR_REG(base) & MCM_CPCR_CBRR_MASK) >> MCM_CPCR_CBRR_SHIFT)
#define MCM_BRD_CPCR_CBRR(base) (MCM_RD_CPCR_CBRR(base))

/*! @brief Set the CBRR field to a new value. */
#define MCM_WR_CPCR_CBRR(base, value) (MCM_RMW_CPCR(base, MCM_CPCR_CBRR_MASK, MCM_CPCR_CBRR(value)))
#define MCM_BWR_CPCR_CBRR(base, value) (MCM_WR_CPCR_CBRR(base, value))
/*@}*/

/*!
 * @name Register MCM_CPCR, field SRAMUAP[25:24] (RW)
 *
 * Defines the arbitration scheme and priority for the processor and SRAM
 * backdoor accesses to the SRAM_U array.
 *
 * Values:
 * - 0b00 - Round robin
 * - 0b01 - Special round robin (favors SRAM backdoor accesses over the
 *     processor)
 * - 0b10 - Fixed priority. Processor has highest, backdoor has lowest
 * - 0b11 - Fixed priority. Backdoor has highest, processor has lowest
 */
/*@{*/
/*! @brief Read current value of the MCM_CPCR_SRAMUAP field. */
#define MCM_RD_CPCR_SRAMUAP(base) ((MCM_CPCR_REG(base) & MCM_CPCR_SRAMUAP_MASK) >> MCM_CPCR_SRAMUAP_SHIFT)
#define MCM_BRD_CPCR_SRAMUAP(base) (MCM_RD_CPCR_SRAMUAP(base))

/*! @brief Set the SRAMUAP field to a new value. */
#define MCM_WR_CPCR_SRAMUAP(base, value) (MCM_RMW_CPCR(base, MCM_CPCR_SRAMUAP_MASK, MCM_CPCR_SRAMUAP(value)))
#define MCM_BWR_CPCR_SRAMUAP(base, value) (MCM_WR_CPCR_SRAMUAP(base, value))
/*@}*/

/*!
 * @name Register MCM_CPCR, field SRAMUWP[26] (RW)
 *
 * When this bit is set, writes to SRAM_U array generates a bus error.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPCR_SRAMUWP field. */
#define MCM_RD_CPCR_SRAMUWP(base) ((MCM_CPCR_REG(base) & MCM_CPCR_SRAMUWP_MASK) >> MCM_CPCR_SRAMUWP_SHIFT)
#define MCM_BRD_CPCR_SRAMUWP(base) (MCM_RD_CPCR_SRAMUWP(base))

/*! @brief Set the SRAMUWP field to a new value. */
#define MCM_WR_CPCR_SRAMUWP(base, value) (MCM_RMW_CPCR(base, MCM_CPCR_SRAMUWP_MASK, MCM_CPCR_SRAMUWP(value)))
#define MCM_BWR_CPCR_SRAMUWP(base, value) (MCM_WR_CPCR_SRAMUWP(base, value))
/*@}*/

/*!
 * @name Register MCM_CPCR, field SRAMLAP[29:28] (RW)
 *
 * Defines the arbitration scheme and priority for the processor and SRAM
 * backdoor accesses to the SRAM_L array.
 *
 * Values:
 * - 0b00 - Round robin
 * - 0b01 - Special round robin (favors SRAM backdoor accesses over the
 *     processor)
 * - 0b10 - Fixed priority. Processor has highest, backdoor has lowest
 * - 0b11 - Fixed priority. Backdoor has highest, processor has lowest
 */
/*@{*/
/*! @brief Read current value of the MCM_CPCR_SRAMLAP field. */
#define MCM_RD_CPCR_SRAMLAP(base) ((MCM_CPCR_REG(base) & MCM_CPCR_SRAMLAP_MASK) >> MCM_CPCR_SRAMLAP_SHIFT)
#define MCM_BRD_CPCR_SRAMLAP(base) (MCM_RD_CPCR_SRAMLAP(base))

/*! @brief Set the SRAMLAP field to a new value. */
#define MCM_WR_CPCR_SRAMLAP(base, value) (MCM_RMW_CPCR(base, MCM_CPCR_SRAMLAP_MASK, MCM_CPCR_SRAMLAP(value)))
#define MCM_BWR_CPCR_SRAMLAP(base, value) (MCM_WR_CPCR_SRAMLAP(base, value))
/*@}*/

/*!
 * @name Register MCM_CPCR, field SRAMLWP[30] (RW)
 *
 * When this bit is set, writes to SRAM_L array generates a bus error.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPCR_SRAMLWP field. */
#define MCM_RD_CPCR_SRAMLWP(base) ((MCM_CPCR_REG(base) & MCM_CPCR_SRAMLWP_MASK) >> MCM_CPCR_SRAMLWP_SHIFT)
#define MCM_BRD_CPCR_SRAMLWP(base) (MCM_RD_CPCR_SRAMLWP(base))

/*! @brief Set the SRAMLWP field to a new value. */
#define MCM_WR_CPCR_SRAMLWP(base, value) (MCM_RMW_CPCR(base, MCM_CPCR_SRAMLWP_MASK, MCM_CPCR_SRAMLWP(value)))
#define MCM_BWR_CPCR_SRAMLWP(base, value) (MCM_WR_CPCR_SRAMLWP(base, value))
/*@}*/

/*******************************************************************************
 * MCM_ISCR - Interrupt Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCM_ISCR - Interrupt Status and Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCM_ISCR register defines the configuration and reports status for a
 * number of core-related interrupt exception conditions. It includes the enable and
 * status bits associated with the core's floating-point exceptions, and bus
 * errors associated with the core's cache write buffer. The individual event
 * indicators are first qualified with their exception enables and then logically summed
 * to form an interrupt request sent to the core's NVIC. Bits 15-8 are read-only
 * indicator flags based on the processor's FPSCR register. Attempted writes to
 * these bits are ignored. Once set, the flags remain asserted until software
 * clears the corresponding FPSCR bit.
 */
/*!
 * @name Constants and macros for entire MCM_ISCR register
 */
/*@{*/
#define MCM_RD_ISCR(base)        (MCM_ISCR_REG(base))
#define MCM_WR_ISCR(base, value) (MCM_ISCR_REG(base) = (value))
#define MCM_RMW_ISCR(base, mask, value) (MCM_WR_ISCR(base, (MCM_RD_ISCR(base) & ~(mask)) | (value)))
#define MCM_SET_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) |  (value)))
#define MCM_CLR_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) & ~(value)))
#define MCM_TOG_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_ISCR bitfields
 */

/*!
 * @name Register MCM_ISCR, field CWBER[4] (W1C)
 *
 * Signals a data transfer from the core's cache write buffer was terminated
 * with a bus error. This bit only sets when the corresponding enable bit (CWBEE) is
 * set. The corresponding core fault address, attributes and write data are
 * typically retrieved from the FADR, FATR, and FDR registers during the interrupt
 * service routine before clearing the CWBER flag.
 *
 * Values:
 * - 0b0 - No error
 * - 0b1 - Error occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_CWBER field. */
#define MCM_RD_ISCR_CWBER(base) ((MCM_ISCR_REG(base) & MCM_ISCR_CWBER_MASK) >> MCM_ISCR_CWBER_SHIFT)
#define MCM_BRD_ISCR_CWBER(base) (MCM_RD_ISCR_CWBER(base))

/*! @brief Set the CWBER field to a new value. */
#define MCM_WR_ISCR_CWBER(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_CWBER_MASK, MCM_ISCR_CWBER(value)))
#define MCM_BWR_ISCR_CWBER(base, value) (MCM_WR_ISCR_CWBER(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIOC[8] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IOC] bit and signals an
 * illegal operation has been detected in the processor's FPU. Once set, this bit
 * remains set until software clears the FPSCR[IOC] bit.
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIOC field. */
#define MCM_RD_ISCR_FIOC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIOC_MASK) >> MCM_ISCR_FIOC_SHIFT)
#define MCM_BRD_ISCR_FIOC(base) (MCM_RD_ISCR_FIOC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZC[9] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[DZC] bit and signals a
 * divide by zero has been detected in the processor's FPU. Once set, this bit remains
 * set until software clears the FPSCR[DZC] bit.
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FDZC field. */
#define MCM_RD_ISCR_FDZC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FDZC_MASK) >> MCM_ISCR_FDZC_SHIFT)
#define MCM_BRD_ISCR_FDZC(base) (MCM_RD_ISCR_FDZC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFC[10] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[OFC] bit and signals an
 * overflow has been detected in the processor's FPU. Once set, this bit remains set
 * until software clears the FPSCR[OFC] bit.
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FOFC field. */
#define MCM_RD_ISCR_FOFC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FOFC_MASK) >> MCM_ISCR_FOFC_SHIFT)
#define MCM_BRD_ISCR_FOFC(base) (MCM_RD_ISCR_FOFC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFC[11] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[UFC] bit and signals an
 * underflow has been detected in the processor's FPU. Once set, this bit remains set
 * until software clears the FPSCR[UFC] bit.
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FUFC field. */
#define MCM_RD_ISCR_FUFC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FUFC_MASK) >> MCM_ISCR_FUFC_SHIFT)
#define MCM_BRD_ISCR_FUFC(base) (MCM_RD_ISCR_FUFC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXC[12] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IXC] bit and signals an
 * inexact number has been detected in the processor's FPU. Once set, this bit
 * remains set until software clears the FPSCR[IXC] bit.
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIXC field. */
#define MCM_RD_ISCR_FIXC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIXC_MASK) >> MCM_ISCR_FIXC_SHIFT)
#define MCM_BRD_ISCR_FIXC(base) (MCM_RD_ISCR_FIXC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDC[15] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IDC] bit and signals input
 * denormalized number has been detected in the processor's FPU. Once set, this
 * bit remains set until software clears the FPSCR[IDC] bit.
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIDC field. */
#define MCM_RD_ISCR_FIDC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIDC_MASK) >> MCM_ISCR_FIDC_SHIFT)
#define MCM_BRD_ISCR_FIDC(base) (MCM_RD_ISCR_FIDC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field CWBEE[20] (RW)
 *
 * Enables the generation of an interrupt in response to a bus error termination
 * reported on a system bus transfer initiated from the cache's write buffer.
 *
 * Values:
 * - 0b0 - Disable error interrupt
 * - 0b1 - Enable error interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_CWBEE field. */
#define MCM_RD_ISCR_CWBEE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_CWBEE_MASK) >> MCM_ISCR_CWBEE_SHIFT)
#define MCM_BRD_ISCR_CWBEE(base) (MCM_RD_ISCR_CWBEE(base))

/*! @brief Set the CWBEE field to a new value. */
#define MCM_WR_ISCR_CWBEE(base, value) (MCM_RMW_ISCR(base, (MCM_ISCR_CWBEE_MASK | MCM_ISCR_CWBER_MASK), MCM_ISCR_CWBEE(value)))
#define MCM_BWR_ISCR_CWBEE(base, value) (MCM_WR_ISCR_CWBEE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIOCE[24] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIOCE field. */
#define MCM_RD_ISCR_FIOCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIOCE_MASK) >> MCM_ISCR_FIOCE_SHIFT)
#define MCM_BRD_ISCR_FIOCE(base) (MCM_RD_ISCR_FIOCE(base))

/*! @brief Set the FIOCE field to a new value. */
#define MCM_WR_ISCR_FIOCE(base, value) (MCM_RMW_ISCR(base, (MCM_ISCR_FIOCE_MASK | MCM_ISCR_CWBER_MASK), MCM_ISCR_FIOCE(value)))
#define MCM_BWR_ISCR_FIOCE(base, value) (MCM_WR_ISCR_FIOCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZCE[25] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FDZCE field. */
#define MCM_RD_ISCR_FDZCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FDZCE_MASK) >> MCM_ISCR_FDZCE_SHIFT)
#define MCM_BRD_ISCR_FDZCE(base) (MCM_RD_ISCR_FDZCE(base))

/*! @brief Set the FDZCE field to a new value. */
#define MCM_WR_ISCR_FDZCE(base, value) (MCM_RMW_ISCR(base, (MCM_ISCR_FDZCE_MASK | MCM_ISCR_CWBER_MASK), MCM_ISCR_FDZCE(value)))
#define MCM_BWR_ISCR_FDZCE(base, value) (MCM_WR_ISCR_FDZCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFCE[26] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FOFCE field. */
#define MCM_RD_ISCR_FOFCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FOFCE_MASK) >> MCM_ISCR_FOFCE_SHIFT)
#define MCM_BRD_ISCR_FOFCE(base) (MCM_RD_ISCR_FOFCE(base))

/*! @brief Set the FOFCE field to a new value. */
#define MCM_WR_ISCR_FOFCE(base, value) (MCM_RMW_ISCR(base, (MCM_ISCR_FOFCE_MASK | MCM_ISCR_CWBER_MASK), MCM_ISCR_FOFCE(value)))
#define MCM_BWR_ISCR_FOFCE(base, value) (MCM_WR_ISCR_FOFCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFCE[27] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FUFCE field. */
#define MCM_RD_ISCR_FUFCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FUFCE_MASK) >> MCM_ISCR_FUFCE_SHIFT)
#define MCM_BRD_ISCR_FUFCE(base) (MCM_RD_ISCR_FUFCE(base))

/*! @brief Set the FUFCE field to a new value. */
#define MCM_WR_ISCR_FUFCE(base, value) (MCM_RMW_ISCR(base, (MCM_ISCR_FUFCE_MASK | MCM_ISCR_CWBER_MASK), MCM_ISCR_FUFCE(value)))
#define MCM_BWR_ISCR_FUFCE(base, value) (MCM_WR_ISCR_FUFCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXCE[28] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIXCE field. */
#define MCM_RD_ISCR_FIXCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIXCE_MASK) >> MCM_ISCR_FIXCE_SHIFT)
#define MCM_BRD_ISCR_FIXCE(base) (MCM_RD_ISCR_FIXCE(base))

/*! @brief Set the FIXCE field to a new value. */
#define MCM_WR_ISCR_FIXCE(base, value) (MCM_RMW_ISCR(base, (MCM_ISCR_FIXCE_MASK | MCM_ISCR_CWBER_MASK), MCM_ISCR_FIXCE(value)))
#define MCM_BWR_ISCR_FIXCE(base, value) (MCM_WR_ISCR_FIXCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDCE[31] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIDCE field. */
#define MCM_RD_ISCR_FIDCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIDCE_MASK) >> MCM_ISCR_FIDCE_SHIFT)
#define MCM_BRD_ISCR_FIDCE(base) (MCM_RD_ISCR_FIDCE(base))

/*! @brief Set the FIDCE field to a new value. */
#define MCM_WR_ISCR_FIDCE(base, value) (MCM_RMW_ISCR(base, (MCM_ISCR_FIDCE_MASK | MCM_ISCR_CWBER_MASK), MCM_ISCR_FIDCE(value)))
#define MCM_BWR_ISCR_FIDCE(base, value) (MCM_WR_ISCR_FIDCE(base, value))
/*@}*/

/*******************************************************************************
 * MCM_FADR - Store Buffer Fault address register
 ******************************************************************************/

/*!
 * @brief MCM_FADR - Store Buffer Fault address register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When a properly-enabled cache write buffer error interrupt event is detected,
 * the faulting address is captured in the MCM_FADR register. The MCM logic
 * supports capturing a single cache write buffer bus error event; if a subsequent
 * error is detected before the captured error information has been read from the
 * corresponding registers and the MCM_ISCR[CWBER] indicator cleared, the
 * MCM_FATR[BEOVR] flag is set. However, no additional information is captured. The bits
 * in this register are set by hardware and signaled by the assertion of
 * MCM_ISCR[CWBER]. Attempted writes have no effect.
 */
/*!
 * @name Constants and macros for entire MCM_FADR register
 */
/*@{*/
#define MCM_RD_FADR(base)        (MCM_FADR_REG(base))
/*@}*/

/*******************************************************************************
 * MCM_FATR - Store Buffer Fault Attributes register
 ******************************************************************************/

/*!
 * @brief MCM_FATR - Store Buffer Fault Attributes register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When a properly-enabled cache write buffer error interrupt event is detected,
 * the faulting attributes are captured in the MCM_FATR register. The bits in
 * this register are set by hardware and signaled by the assertion of
 * MCM_ISCR[CWBER]. Attempted writes have no effect.
 */
/*!
 * @name Constants and macros for entire MCM_FATR register
 */
/*@{*/
#define MCM_RD_FATR(base)        (MCM_FATR_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_FATR bitfields
 */

/*!
 * @name Register MCM_FATR, field BEDA[0] (RO)
 *
 * Indicates the type of cache write buffer access when the error was detected.
 * This attribute is always a logical one signaling a data reference.
 *
 * Values:
 * - 0b0 - Instruction
 * - 0b1 - Data
 */
/*@{*/
/*! @brief Read current value of the MCM_FATR_BEDA field. */
#define MCM_RD_FATR_BEDA(base) ((MCM_FATR_REG(base) & MCM_FATR_BEDA_MASK) >> MCM_FATR_BEDA_SHIFT)
#define MCM_BRD_FATR_BEDA(base) (MCM_RD_FATR_BEDA(base))
/*@}*/

/*!
 * @name Register MCM_FATR, field BEMD[1] (RO)
 *
 * Indicates the privilege level of the cache write buffer access when the error
 * was detected.
 *
 * Values:
 * - 0b0 - User mode
 * - 0b1 - Supervisor/privileged mode
 */
/*@{*/
/*! @brief Read current value of the MCM_FATR_BEMD field. */
#define MCM_RD_FATR_BEMD(base) ((MCM_FATR_REG(base) & MCM_FATR_BEMD_MASK) >> MCM_FATR_BEMD_SHIFT)
#define MCM_BRD_FATR_BEMD(base) (MCM_RD_FATR_BEMD(base))
/*@}*/

/*!
 * @name Register MCM_FATR, field BESZ[5:4] (RO)
 *
 * Indicates the size of the cache write buffer access when the error was
 * detected.
 *
 * Values:
 * - 0b00 - 8-bit access
 * - 0b01 - 16-bit access
 * - 0b10 - 32-bit access
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the MCM_FATR_BESZ field. */
#define MCM_RD_FATR_BESZ(base) ((MCM_FATR_REG(base) & MCM_FATR_BESZ_MASK) >> MCM_FATR_BESZ_SHIFT)
#define MCM_BRD_FATR_BESZ(base) (MCM_RD_FATR_BESZ(base))
/*@}*/

/*!
 * @name Register MCM_FATR, field BEWT[7] (RO)
 *
 * Indicates the type of system bus access when the error was detected. Since
 * this logic is monitoring data transfers from the cache write buffer, this bit is
 * always a logical one, signaling a write operation.
 *
 * Values:
 * - 0b0 - Read access
 * - 0b1 - Write access
 */
/*@{*/
/*! @brief Read current value of the MCM_FATR_BEWT field. */
#define MCM_RD_FATR_BEWT(base) ((MCM_FATR_REG(base) & MCM_FATR_BEWT_MASK) >> MCM_FATR_BEWT_SHIFT)
#define MCM_BRD_FATR_BEWT(base) (MCM_RD_FATR_BEWT(base))
/*@}*/

/*!
 * @name Register MCM_FATR, field BEMN[11:8] (RO)
 *
 * Crossbar switch bus master number of the captured cache write buffer bus
 * error. For this device, this value is always 0x1.
 */
/*@{*/
/*! @brief Read current value of the MCM_FATR_BEMN field. */
#define MCM_RD_FATR_BEMN(base) ((MCM_FATR_REG(base) & MCM_FATR_BEMN_MASK) >> MCM_FATR_BEMN_SHIFT)
#define MCM_BRD_FATR_BEMN(base) (MCM_RD_FATR_BEMN(base))
/*@}*/

/*!
 * @name Register MCM_FATR, field BEOVR[31] (RO)
 *
 * Indicates if another cache write buffer bus error is detected before system
 * software has retrieved all the error information from the original event. The
 * window of time is defined from the detection of the original cache write buffer
 * error termination until the MCM_ISCR[CWBER] is written with a 1 to clear it
 * and rearm the capture logic. This bit is set by the hardware and cleared
 * whenever software writes a 1 to the CWBER bit.
 *
 * Values:
 * - 0b0 - No bus error overrun
 * - 0b1 - Bus error overrun occurred. The FADR and FDR registers and the other
 *     FATR bits are not updated to reflect this new bus error.
 */
/*@{*/
/*! @brief Read current value of the MCM_FATR_BEOVR field. */
#define MCM_RD_FATR_BEOVR(base) ((MCM_FATR_REG(base) & MCM_FATR_BEOVR_MASK) >> MCM_FATR_BEOVR_SHIFT)
#define MCM_BRD_FATR_BEOVR(base) (MCM_RD_FATR_BEOVR(base))
/*@}*/

/*******************************************************************************
 * MCM_FDR - Store Buffer Fault Data Register
 ******************************************************************************/

/*!
 * @brief MCM_FDR - Store Buffer Fault Data Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When a properly-enabled cache write buffer error interrupt event is detected,
 * the faulting data is captured in the MCM_FDR register. The bits in this
 * register are set by hardware and signaled by the assertion of MCM_ISCR[CWBER]. For
 * byte and halfword writes, only the accessed byte lanes contain valid data; the
 * contents of the other bytes are undefined. Attempted writes have no effect.
 */
/*!
 * @name Constants and macros for entire MCM_FDR register
 */
/*@{*/
#define MCM_RD_FDR(base)         (MCM_FDR_REG(base))
/*@}*/

/*******************************************************************************
 * MCM_PID - Process ID register
 ******************************************************************************/

/*!
 * @brief MCM_PID - Process ID register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register drives the M0_PID and M1_PID values in the Memory Protection
 * Unit(MPU). System software loads this register before passing control to a given
 * user mode process. If the PID of the process does not match the value in this
 * register, a bus error occurs. See the MPU chapter for more details.
 */
/*!
 * @name Constants and macros for entire MCM_PID register
 */
/*@{*/
#define MCM_RD_PID(base)         (MCM_PID_REG(base))
#define MCM_WR_PID(base, value)  (MCM_PID_REG(base) = (value))
#define MCM_RMW_PID(base, mask, value) (MCM_WR_PID(base, (MCM_RD_PID(base) & ~(mask)) | (value)))
#define MCM_SET_PID(base, value) (MCM_WR_PID(base, MCM_RD_PID(base) |  (value)))
#define MCM_CLR_PID(base, value) (MCM_WR_PID(base, MCM_RD_PID(base) & ~(value)))
#define MCM_TOG_PID(base, value) (MCM_WR_PID(base, MCM_RD_PID(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_PID bitfields
 */

/*!
 * @name Register MCM_PID, field PID[7:0] (RW)
 *
 * Drives the M0_PID and M1_PID values in the MPU.
 */
/*@{*/
/*! @brief Read current value of the MCM_PID_PID field. */
#define MCM_RD_PID_PID(base) ((MCM_PID_REG(base) & MCM_PID_PID_MASK) >> MCM_PID_PID_SHIFT)
#define MCM_BRD_PID_PID(base) (MCM_RD_PID_PID(base))

/*! @brief Set the PID field to a new value. */
#define MCM_WR_PID_PID(base, value) (MCM_RMW_PID(base, MCM_PID_PID_MASK, MCM_PID_PID(value)))
#define MCM_BWR_PID_PID(base, value) (MCM_WR_PID_PID(base, value))
/*@}*/

/*******************************************************************************
 * MCM_CPO - Compute Operation Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPO - Compute Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Operation.
 */
/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define MCM_RD_CPO(base)         (MCM_CPO_REG(base))
#define MCM_WR_CPO(base, value)  (MCM_CPO_REG(base) = (value))
#define MCM_RMW_CPO(base, mask, value) (MCM_WR_CPO(base, (MCM_RD_CPO(base) & ~(mask)) | (value)))
#define MCM_SET_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) |  (value)))
#define MCM_CLR_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) & ~(value)))
#define MCM_TOG_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This bit is auto-cleared by vector fetching if CPOWOI = 1.
 *
 * Values:
 * - 0b0 - Request is cleared.
 * - 0b1 - Request Compute Operation.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define MCM_RD_CPO_CPOREQ(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOREQ_MASK) >> MCM_CPO_CPOREQ_SHIFT)
#define MCM_BRD_CPO_CPOREQ(base) (MCM_RD_CPO_CPOREQ(base))

/*! @brief Set the CPOREQ field to a new value. */
#define MCM_WR_CPO_CPOREQ(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOREQ_MASK, MCM_CPO_CPOREQ(value)))
#define MCM_BWR_CPO_CPOREQ(base, value) (MCM_WR_CPO_CPOREQ(base, value))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0b0 - Compute operation entry has not completed or compute operation exit
 *     has completed.
 * - 0b1 - Compute operation entry has completed or compute operation exit has
 *     not completed.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define MCM_RD_CPO_CPOACK(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOACK_MASK) >> MCM_CPO_CPOACK_SHIFT)
#define MCM_BRD_CPO_CPOACK(base) (MCM_RD_CPO_CPOACK(base))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOWOI[2] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - When set, the CPOREQ is cleared on any interrupt or exception vector
 *     fetch.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOWOI field. */
#define MCM_RD_CPO_CPOWOI(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOWOI_MASK) >> MCM_CPO_CPOWOI_SHIFT)
#define MCM_BRD_CPO_CPOWOI(base) (MCM_RD_CPO_CPOWOI(base))

/*! @brief Set the CPOWOI field to a new value. */
#define MCM_WR_CPO_CPOWOI(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOWOI_MASK, MCM_CPO_CPOWOI(value)))
#define MCM_BWR_CPO_CPOWOI(base, value) (MCM_WR_CPO_CPOWOI(base, value))
/*@}*/

/*******************************************************************************
 * MCM_LMDR - Local Memory Descriptor Register
 ******************************************************************************/

/*!
 * @brief MCM_LMDR - Local Memory Descriptor Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The LMDRn registers mapping to the LMEMs is as follows: LMDR0:SRAM_L,
 * LMDR1:SRAM_U, LMDR2:PC CACHE.should this info be added to somewhere ? (??TBD??
 * current content and reset value footnotesfrom "MSCM OCMEM Configuration Register
 * Descriptions"). This section of the programming model is an array of 32-bit
 * generic on-chip memory descriptor registers that provide static information on the
 * attached memories as well as configurable controls (where appropriate).
 * (??TBD?? current content from "MSCM OCMEM Configuration Register Descriptions").
 * Privileged 32-bit reads from a processor core or the debugger return the
 * appropriate processor information. Reads from any other bus master return all zeroes.
 * Privileged writes from a processor core or the debugger to writeable registers
 * update the appropriate fields. Privileged writes from other bus masters are
 * ignored. Attempted user mode accesses or any access with a size other than 32
 * bits are terminated with an error.
 */
/*!
 * @name Constants and macros for entire MCM_LMDR register
 */
/*@{*/
#define MCM_RD_LMDR(base, index) (MCM_LMDR_REG(base, index))
#define MCM_WR_LMDR(base, index, value) (MCM_LMDR_REG(base, index) = (value))
#define MCM_RMW_LMDR(base, index, mask, value) (MCM_WR_LMDR(base, index, (MCM_RD_LMDR(base, index) & ~(mask)) | (value)))
#define MCM_SET_LMDR(base, index, value) (MCM_WR_LMDR(base, index, MCM_RD_LMDR(base, index) |  (value)))
#define MCM_CLR_LMDR(base, index, value) (MCM_WR_LMDR(base, index, MCM_RD_LMDR(base, index) & ~(value)))
#define MCM_TOG_LMDR(base, index, value) (MCM_WR_LMDR(base, index, MCM_RD_LMDR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_LMDR bitfields
 */

/*!
 * @name Register MCM_LMDR, field CF0[3:0] (RW)
 *
 * CF0[3] - PFE = Parity Fault Enable CF0[2] - RESERVED CF0[1] - EERC = ECC
 * Enable Read Check CF0[0] - EEWG = ECC Enable Write Generation
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_CF0 field. */
#define MCM_RD_LMDR_CF0(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_CF0_MASK) >> MCM_LMDR_CF0_SHIFT)
#define MCM_BRD_LMDR_CF0(base, index) (MCM_RD_LMDR_CF0(base, index))

/*! @brief Set the CF0 field to a new value. */
#define MCM_WR_LMDR_CF0(base, index, value) (MCM_RMW_LMDR(base, index, MCM_LMDR_CF0_MASK, MCM_LMDR_CF0(value)))
#define MCM_BWR_LMDR_CF0(base, index, value) (MCM_WR_LMDR_CF0(base, index, value))
/*@}*/

/*!
 * @name Register MCM_LMDR, field CF1[7:4] (RW)
 *
 * CF1[3] - PCPFE = PC Parity Fault Enable CF1[2] - PSPFE = PS Parity Fault
 * Enable CF1[1] - PCPME = PC Parity Miss Enable CF1[0] - PSPME = PS Parity Miss
 * Enable
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_CF1 field. */
#define MCM_RD_LMDR_CF1(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_CF1_MASK) >> MCM_LMDR_CF1_SHIFT)
#define MCM_BRD_LMDR_CF1(base, index) (MCM_RD_LMDR_CF1(base, index))

/*! @brief Set the CF1 field to a new value. */
#define MCM_WR_LMDR_CF1(base, index, value) (MCM_RMW_LMDR(base, index, MCM_LMDR_CF1_MASK, MCM_LMDR_CF1(value)))
#define MCM_BWR_LMDR_CF1(base, index, value) (MCM_WR_LMDR_CF1(base, index, value))
/*@}*/

/*!
 * @name Register MCM_LMDR, field MT[15:13] (RO)
 *
 * This field defines the type of the local memory.
 *
 * Values:
 * - 0b000 - SRAM_L
 * - 0b001 - SRAM_U
 * - 0b010 - PC Cache
 * - 0b011 - PS Cache
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_MT field. */
#define MCM_RD_LMDR_MT(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_MT_MASK) >> MCM_LMDR_MT_SHIFT)
#define MCM_BRD_LMDR_MT(base, index) (MCM_RD_LMDR_MT(base, index))
/*@}*/

/*!
 * @name Register MCM_LMDR, field RO[16] (RO)
 *
 * (??TBD?? current content from "MSCM OCMEM Configuration Register
 * Descriptions"). Read-Only. This register bit provides a mechanism to "lock" the
 * configuration state defined by LMDRn[7:0]. Once asserted, attempted writes to the
 * LMDRn[7:0] register are ignored until the next reset clears the flag.
 *
 * Values:
 * - 0b0 - (??TBD?? current content from "MSCM OCMEM Configuration Register
 *     Descriptions"). Writes to the LMDRn[7:0] are allowed.
 * - 0b1 - (??TBD?? current content from "MSCM OCMEM Configuration Register
 *     Descriptions"). Writes to the LMDRn[7:0] are ignored.
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_RO field. */
#define MCM_RD_LMDR_RO(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_RO_MASK) >> MCM_LMDR_RO_SHIFT)
#define MCM_BRD_LMDR_RO(base, index) (MCM_RD_LMDR_RO(base, index))
/*@}*/

/*!
 * @name Register MCM_LMDR, field DPW[19:17] (RO)
 *
 * LMEM Data Path Width. This read-only field defines the width of the local
 * memory.
 *
 * Values:
 * - 0b010 - LMEMn 32-bits wide
 * - 0b011 - LMEMn 64-bits wide
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_DPW field. */
#define MCM_RD_LMDR_DPW(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_DPW_MASK) >> MCM_LMDR_DPW_SHIFT)
#define MCM_BRD_LMDR_DPW(base, index) (MCM_RD_LMDR_DPW(base, index))
/*@}*/

/*!
 * @name Register MCM_LMDR, field WY[23:20] (RO)
 *
 * Values:
 * - 0b0000 - No Cache
 * - 0b0010 - 2-Way Set Associative
 * - 0b0100 - 4-Way Set Associative
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_WY field. */
#define MCM_RD_LMDR_WY(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_WY_MASK) >> MCM_LMDR_WY_SHIFT)
#define MCM_BRD_LMDR_WY(base, index) (MCM_RD_LMDR_WY(base, index))
/*@}*/

/*!
 * @name Register MCM_LMDR, field LMSZ[27:24] (RO)
 *
 * (??TBD?? current content from "MSCM OCMEM Configuration Register
 * Descriptions"). LMEM Size. This read-only field provides an encoded value of the local
 * memory size. The capacity of the memory is expressed as Size [bytes] = 2(9+SZ)
 * where SZ is non-zero; a SZ = 0 indicates the memory is not present.
 *
 * Values:
 * - 0b0000 - no LMEMn (0 KB)
 * - 0b0001 - 1 KB LMEMn
 * - 0b0010 - 2 KB LMEMn
 * - 0b0011 - 4 KB LMEMn
 * - 0b0100 - 8 KB LMEMn
 * - 0b0101 - 16 KB LMEMn
 * - 0b0110 - 32 KB LMEMn
 * - 0b0111 - 64 KB LMEMn
 * - 0b1000 - 128 KB LMEMn
 * - 0b1001 - 256 KB LMEMn
 * - 0b1010 - 512 KB LMEMn
 * - 0b1011 - 1024 KB LMEMn
 * - 0b1100 - 2048 KB LMEMn
 * - 0b1101 - 4096 KB LMEMn
 * - 0b1110 - 8192 KB LMEMn
 * - 0b1111 - 16384 KB LMEMn
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_LMSZ field. */
#define MCM_RD_LMDR_LMSZ(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_LMSZ_MASK) >> MCM_LMDR_LMSZ_SHIFT)
#define MCM_BRD_LMDR_LMSZ(base, index) (MCM_RD_LMDR_LMSZ(base, index))
/*@}*/

/*!
 * @name Register MCM_LMDR, field LMSZH[28] (RO)
 *
 * (??TBD?? current content from "MSCM OCMEM Configuration Register
 * Descriptions"). LMEM Size "Hole". For local memories that are not fully populated, that
 * is, include a memory "hole" in the upper 25% of the address range, this bit is
 * used.
 *
 * Values:
 * - 0b0 - LMEMn is a power-of-2 capacity.
 * - 0b1 - LMEMn is not a power-of-2, with a capacity is 0.75 * LMSZ.
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_LMSZH field. */
#define MCM_RD_LMDR_LMSZH(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_LMSZH_MASK) >> MCM_LMDR_LMSZH_SHIFT)
#define MCM_BRD_LMDR_LMSZH(base, index) (MCM_RD_LMDR_LMSZH(base, index))
/*@}*/

/*!
 * @name Register MCM_LMDR, field V[31] (RO)
 *
 * Local memory Valid bit. This read-only field defines the validity (presence)
 * of the local memory.
 *
 * Values:
 * - 0b0 - (??TBD?? current content from "MSCM OCMEM Configuration Register
 *     Descriptions"). LMEMn is not present.
 * - 0b1 - (??TBD?? current content from "MSCM OCMEM Configuration Register
 *     Descriptions"). LMEMn is present.
 */
/*@{*/
/*! @brief Read current value of the MCM_LMDR_V field. */
#define MCM_RD_LMDR_V(base, index) ((MCM_LMDR_REG(base, index) & MCM_LMDR_V_MASK) >> MCM_LMDR_V_SHIFT)
#define MCM_BRD_LMDR_V(base, index) (MCM_RD_LMDR_V(base, index))
/*@}*/

/*******************************************************************************
 * MCM_LMPECR - LMEM Parity & ECC Control Register
 ******************************************************************************/

/*!
 * @brief MCM_LMPECR - LMEM Parity & ECC Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * description and reset value ??TBD??
 */
/*!
 * @name Constants and macros for entire MCM_LMPECR register
 */
/*@{*/
#define MCM_RD_LMPECR(base)      (MCM_LMPECR_REG(base))
#define MCM_WR_LMPECR(base, value) (MCM_LMPECR_REG(base) = (value))
#define MCM_RMW_LMPECR(base, mask, value) (MCM_WR_LMPECR(base, (MCM_RD_LMPECR(base) & ~(mask)) | (value)))
#define MCM_SET_LMPECR(base, value) (MCM_WR_LMPECR(base, MCM_RD_LMPECR(base) |  (value)))
#define MCM_CLR_LMPECR(base, value) (MCM_WR_LMPECR(base, MCM_RD_LMPECR(base) & ~(value)))
#define MCM_TOG_LMPECR(base, value) (MCM_WR_LMPECR(base, MCM_RD_LMPECR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_LMPECR bitfields
 */

/*!
 * @name Register MCM_LMPECR, field ERNCR[0] (RW)
 *
 * Values:
 * - 0b0 - reporting enabled
 * - 0b1 - reporting disabled
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPECR_ERNCR field. */
#define MCM_RD_LMPECR_ERNCR(base) ((MCM_LMPECR_REG(base) & MCM_LMPECR_ERNCR_MASK) >> MCM_LMPECR_ERNCR_SHIFT)
#define MCM_BRD_LMPECR_ERNCR(base) (MCM_RD_LMPECR_ERNCR(base))

/*! @brief Set the ERNCR field to a new value. */
#define MCM_WR_LMPECR_ERNCR(base, value) (MCM_RMW_LMPECR(base, MCM_LMPECR_ERNCR_MASK, MCM_LMPECR_ERNCR(value)))
#define MCM_BWR_LMPECR_ERNCR(base, value) (MCM_WR_LMPECR_ERNCR(base, value))
/*@}*/

/*!
 * @name Register MCM_LMPECR, field ER1BR[8] (RW)
 *
 * Values:
 * - 0b0 - reporting enabled
 * - 0b1 - reporting disabled
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPECR_ER1BR field. */
#define MCM_RD_LMPECR_ER1BR(base) ((MCM_LMPECR_REG(base) & MCM_LMPECR_ER1BR_MASK) >> MCM_LMPECR_ER1BR_SHIFT)
#define MCM_BRD_LMPECR_ER1BR(base) (MCM_RD_LMPECR_ER1BR(base))

/*! @brief Set the ER1BR field to a new value. */
#define MCM_WR_LMPECR_ER1BR(base, value) (MCM_RMW_LMPECR(base, MCM_LMPECR_ER1BR_MASK, MCM_LMPECR_ER1BR(value)))
#define MCM_BWR_LMPECR_ER1BR(base, value) (MCM_WR_LMPECR_ER1BR(base, value))
/*@}*/

/*!
 * @name Register MCM_LMPECR, field ERPR[16] (RW)
 *
 * Values:
 * - 0b0 - reporting enabled
 * - 0b1 - reporting disabled
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPECR_ERPR field. */
#define MCM_RD_LMPECR_ERPR(base) ((MCM_LMPECR_REG(base) & MCM_LMPECR_ERPR_MASK) >> MCM_LMPECR_ERPR_SHIFT)
#define MCM_BRD_LMPECR_ERPR(base) (MCM_RD_LMPECR_ERPR(base))

/*! @brief Set the ERPR field to a new value. */
#define MCM_WR_LMPECR_ERPR(base, value) (MCM_RMW_LMPECR(base, MCM_LMPECR_ERPR_MASK, MCM_LMPECR_ERPR(value)))
#define MCM_BWR_LMPECR_ERPR(base, value) (MCM_WR_LMPECR_ERPR(base, value))
/*@}*/

/*!
 * @name Register MCM_LMPECR, field ECPR[20] (RW)
 *
 * Values:
 * - 0b0 - reporting enabled
 * - 0b1 - reporting disabled
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPECR_ECPR field. */
#define MCM_RD_LMPECR_ECPR(base) ((MCM_LMPECR_REG(base) & MCM_LMPECR_ECPR_MASK) >> MCM_LMPECR_ECPR_SHIFT)
#define MCM_BRD_LMPECR_ECPR(base) (MCM_RD_LMPECR_ECPR(base))

/*! @brief Set the ECPR field to a new value. */
#define MCM_WR_LMPECR_ECPR(base, value) (MCM_RMW_LMPECR(base, MCM_LMPECR_ECPR_MASK, MCM_LMPECR_ECPR(value)))
#define MCM_BWR_LMPECR_ECPR(base, value) (MCM_WR_LMPECR_ECPR(base, value))
/*@}*/

/*******************************************************************************
 * MCM_LMPEIR - LMEM Parity & ECC Interrupt Register
 ******************************************************************************/

/*!
 * @brief MCM_LMPEIR - LMEM Parity & ECC Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * description and reset value ??TBD?? Write 1 to the error bit in
 * MCM_LMPEIR[23:0] can clear the interrupt flag.
 */
/*!
 * @name Constants and macros for entire MCM_LMPEIR register
 */
/*@{*/
#define MCM_RD_LMPEIR(base)      (MCM_LMPEIR_REG(base))
#define MCM_WR_LMPEIR(base, value) (MCM_LMPEIR_REG(base) = (value))
#define MCM_RMW_LMPEIR(base, mask, value) (MCM_WR_LMPEIR(base, (MCM_RD_LMPEIR(base) & ~(mask)) | (value)))
#define MCM_SET_LMPEIR(base, value) (MCM_WR_LMPEIR(base, MCM_RD_LMPEIR(base) |  (value)))
#define MCM_CLR_LMPEIR(base, value) (MCM_WR_LMPEIR(base, MCM_RD_LMPEIR(base) & ~(value)))
#define MCM_TOG_LMPEIR(base, value) (MCM_WR_LMPEIR(base, MCM_RD_LMPEIR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_LMPEIR bitfields
 */

/*!
 * @name Register MCM_LMPEIR, field ENC[7:0] (RW)
 *
 * PEIR[7:2] - Reserved PEIR[1] - Noncorrectable Error detected on SRAM_U
 * PEIR[0] - Noncorrectable Error detected on SRAM_L
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPEIR_ENC field. */
#define MCM_RD_LMPEIR_ENC(base) ((MCM_LMPEIR_REG(base) & MCM_LMPEIR_ENC_MASK) >> MCM_LMPEIR_ENC_SHIFT)
#define MCM_BRD_LMPEIR_ENC(base) (MCM_RD_LMPEIR_ENC(base))

/*! @brief Set the ENC field to a new value. */
#define MCM_WR_LMPEIR_ENC(base, value) (MCM_RMW_LMPEIR(base, MCM_LMPEIR_ENC_MASK, MCM_LMPEIR_ENC(value)))
#define MCM_BWR_LMPEIR_ENC(base, value) (MCM_WR_LMPEIR_ENC(base, value))
/*@}*/

/*!
 * @name Register MCM_LMPEIR, field E1B[15:8] (RW)
 *
 * PEIR[15:10] - Reserved PEIR[9] - 1-bit Error detected on SRAM_U PEIR[8] -
 * 1-bit Error detected on SRAM_L
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPEIR_E1B field. */
#define MCM_RD_LMPEIR_E1B(base) ((MCM_LMPEIR_REG(base) & MCM_LMPEIR_E1B_MASK) >> MCM_LMPEIR_E1B_SHIFT)
#define MCM_BRD_LMPEIR_E1B(base) (MCM_RD_LMPEIR_E1B(base))

/*! @brief Set the E1B field to a new value. */
#define MCM_WR_LMPEIR_E1B(base, value) (MCM_RMW_LMPEIR(base, MCM_LMPEIR_E1B_MASK, MCM_LMPEIR_E1B(value)))
#define MCM_BWR_LMPEIR_E1B(base, value) (MCM_WR_LMPEIR_E1B(base, value))
/*@}*/

/*!
 * @name Register MCM_LMPEIR, field PE[23:16] (RW)
 *
 * [21] - PC Data Parity Error [20] - PC Tag Parity Error [19] - RESERVED [18] -
 * RESERVED
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPEIR_PE field. */
#define MCM_RD_LMPEIR_PE(base) ((MCM_LMPEIR_REG(base) & MCM_LMPEIR_PE_MASK) >> MCM_LMPEIR_PE_SHIFT)
#define MCM_BRD_LMPEIR_PE(base) (MCM_RD_LMPEIR_PE(base))

/*! @brief Set the PE field to a new value. */
#define MCM_WR_LMPEIR_PE(base, value) (MCM_RMW_LMPEIR(base, MCM_LMPEIR_PE_MASK, MCM_LMPEIR_PE(value)))
#define MCM_BWR_LMPEIR_PE(base, value) (MCM_WR_LMPEIR_PE(base, value))
/*@}*/

/*!
 * @name Register MCM_LMPEIR, field PEELOC[28:24] (RW)
 *
 * 5'h00 - a non-correctable ECC event from SRAM_L 5'h01 - a non-correctable ECC
 * event from SRAM_U 5'h08 - a 1-bit correctable ECC event from SRAM_L 5'h09 - a
 * 1-bit correctable ECC event from SRAM_U 5'h14 - a PC Tag Parity Error 5'h15 -
 * a PC Data Parity Error
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPEIR_PEELOC field. */
#define MCM_RD_LMPEIR_PEELOC(base) ((MCM_LMPEIR_REG(base) & MCM_LMPEIR_PEELOC_MASK) >> MCM_LMPEIR_PEELOC_SHIFT)
#define MCM_BRD_LMPEIR_PEELOC(base) (MCM_RD_LMPEIR_PEELOC(base))

/*! @brief Set the PEELOC field to a new value. */
#define MCM_WR_LMPEIR_PEELOC(base, value) (MCM_RMW_LMPEIR(base, MCM_LMPEIR_PEELOC_MASK, MCM_LMPEIR_PEELOC(value)))
#define MCM_BWR_LMPEIR_PEELOC(base, value) (MCM_WR_LMPEIR_PEELOC(base, value))
/*@}*/

/*!
 * @name Register MCM_LMPEIR, field V[31] (RO)
 */
/*@{*/
/*! @brief Read current value of the MCM_LMPEIR_V field. */
#define MCM_RD_LMPEIR_V(base) ((MCM_LMPEIR_REG(base) & MCM_LMPEIR_V_MASK) >> MCM_LMPEIR_V_SHIFT)
#define MCM_BRD_LMPEIR_V(base) (MCM_RD_LMPEIR_V(base))
/*@}*/

/*******************************************************************************
 * MCM_LMFAR - LMEM Fault Address Register
 ******************************************************************************/

/*!
 * @brief MCM_LMFAR - LMEM Fault Address Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * descciption and reset value ??TBD??
 */
/*!
 * @name Constants and macros for entire MCM_LMFAR register
 */
/*@{*/
#define MCM_RD_LMFAR(base)       (MCM_LMFAR_REG(base))
/*@}*/

/*******************************************************************************
 * MCM_LMFATR - LMEM Fault Attribute Register
 ******************************************************************************/

/*!
 * @brief MCM_LMFATR - LMEM Fault Attribute Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * description and reset value ??TBD??
 */
/*!
 * @name Constants and macros for entire MCM_LMFATR register
 */
/*@{*/
#define MCM_RD_LMFATR(base)      (MCM_LMFATR_REG(base))
#define MCM_WR_LMFATR(base, value) (MCM_LMFATR_REG(base) = (value))
#define MCM_RMW_LMFATR(base, mask, value) (MCM_WR_LMFATR(base, (MCM_RD_LMFATR(base) & ~(mask)) | (value)))
#define MCM_SET_LMFATR(base, value) (MCM_WR_LMFATR(base, MCM_RD_LMFATR(base) |  (value)))
#define MCM_CLR_LMFATR(base, value) (MCM_WR_LMFATR(base, MCM_RD_LMFATR(base) & ~(value)))
#define MCM_TOG_LMFATR(base, value) (MCM_WR_LMFATR(base, MCM_RD_LMFATR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_LMFATR bitfields
 */

/*!
 * @name Register MCM_LMFATR, field PEFPRT[3:0] (RW)
 *
 * FATR[3] is Cacheable: 0=Non-cacheable, 1=Cacheable FATR[2] is Bufferable:
 * 0=Non-bufferable, 1=Bufferable FATR[1] is Mode: 0=User mode, 1=Supervisor mode
 * FATR[0] is Type: 0=I-Fetch, 1=Data
 */
/*@{*/
/*! @brief Read current value of the MCM_LMFATR_PEFPRT field. */
#define MCM_RD_LMFATR_PEFPRT(base) ((MCM_LMFATR_REG(base) & MCM_LMFATR_PEFPRT_MASK) >> MCM_LMFATR_PEFPRT_SHIFT)
#define MCM_BRD_LMFATR_PEFPRT(base) (MCM_RD_LMFATR_PEFPRT(base))

/*! @brief Set the PEFPRT field to a new value. */
#define MCM_WR_LMFATR_PEFPRT(base, value) (MCM_RMW_LMFATR(base, MCM_LMFATR_PEFPRT_MASK, MCM_LMFATR_PEFPRT(value)))
#define MCM_BWR_LMFATR_PEFPRT(base, value) (MCM_WR_LMFATR_PEFPRT(base, value))
/*@}*/

/*!
 * @name Register MCM_LMFATR, field PEFSIZE[6:4] (RW)
 *
 * 3'b000 = 8-bit access 3'b001 = 16-bit access 3'b010 = 32-bit access 3'b011 =
 * 64-bit access 3'b1xx = Reserved
 */
/*@{*/
/*! @brief Read current value of the MCM_LMFATR_PEFSIZE field. */
#define MCM_RD_LMFATR_PEFSIZE(base) ((MCM_LMFATR_REG(base) & MCM_LMFATR_PEFSIZE_MASK) >> MCM_LMFATR_PEFSIZE_SHIFT)
#define MCM_BRD_LMFATR_PEFSIZE(base) (MCM_RD_LMFATR_PEFSIZE(base))

/*! @brief Set the PEFSIZE field to a new value. */
#define MCM_WR_LMFATR_PEFSIZE(base, value) (MCM_RMW_LMFATR(base, MCM_LMFATR_PEFSIZE_MASK, MCM_LMFATR_PEFSIZE(value)))
#define MCM_BWR_LMFATR_PEFSIZE(base, value) (MCM_WR_LMFATR_PEFSIZE(base, value))
/*@}*/

/*!
 * @name Register MCM_LMFATR, field PEFW[7] (RO)
 */
/*@{*/
/*! @brief Read current value of the MCM_LMFATR_PEFW field. */
#define MCM_RD_LMFATR_PEFW(base) ((MCM_LMFATR_REG(base) & MCM_LMFATR_PEFW_MASK) >> MCM_LMFATR_PEFW_SHIFT)
#define MCM_BRD_LMFATR_PEFW(base) (MCM_RD_LMFATR_PEFW(base))
/*@}*/

/*!
 * @name Register MCM_LMFATR, field PEFMST[15:8] (RO)
 */
/*@{*/
/*! @brief Read current value of the MCM_LMFATR_PEFMST field. */
#define MCM_RD_LMFATR_PEFMST(base) ((MCM_LMFATR_REG(base) & MCM_LMFATR_PEFMST_MASK) >> MCM_LMFATR_PEFMST_SHIFT)
#define MCM_BRD_LMFATR_PEFMST(base) (MCM_RD_LMFATR_PEFMST(base))
/*@}*/

/*!
 * @name Register MCM_LMFATR, field OVR[31] (RO)
 */
/*@{*/
/*! @brief Read current value of the MCM_LMFATR_OVR field. */
#define MCM_RD_LMFATR_OVR(base) ((MCM_LMFATR_REG(base) & MCM_LMFATR_OVR_MASK) >> MCM_LMFATR_OVR_SHIFT)
#define MCM_BRD_LMFATR_OVR(base) (MCM_RD_LMFATR_OVR(base))
/*@}*/

/*******************************************************************************
 * MCM_LMFDHR - LMEM Fault Data High Register
 ******************************************************************************/

/*!
 * @brief MCM_LMFDHR - LMEM Fault Data High Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * description and reset value ??TBD??
 */
/*!
 * @name Constants and macros for entire MCM_LMFDHR register
 */
/*@{*/
#define MCM_RD_LMFDHR(base)      (MCM_LMFDHR_REG(base))
/*@}*/

/*******************************************************************************
 * MCM_LMFDLR - LMEM Fault Data Low Register
 ******************************************************************************/

/*!
 * @brief MCM_LMFDLR - LMEM Fault Data Low Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * description and reset value ??TBD??
 */
/*!
 * @name Constants and macros for entire MCM_LMFDLR register
 */
/*@{*/
#define MCM_RD_LMFDLR(base)      (MCM_LMFDLR_REG(base))
/*@}*/

/*
 * S32K144 MPU
 *
 * Memory protection unit
 *
 * Registers defined in this header file:
 * - MPU_CESR - Control/Error Status Register
 * - MPU_EAR0 - Error Address Register, slave port n
 * - MPU_EDR0 - Error Detail Register, slave port n
 * - MPU_EAR1 - Error Address Register, slave port n
 * - MPU_EDR1 - Error Detail Register, slave port n
 * - MPU_EAR2 - Error Address Register, slave port n
 * - MPU_EDR2 - Error Detail Register, slave port n
 * - MPU_EAR3 - Error Address Register, slave port n
 * - MPU_EDR3 - Error Detail Register, slave port n
 * - MPU_EAR4 - Error Address Register, slave port n
 * - MPU_EDR4 - Error Detail Register, slave port n
 * - MPU_EAR5 - Error Address Register, slave port n
 * - MPU_EDR5 - Error Detail Register, slave port n
 * - MPU_EAR6 - Error Address Register, slave port n
 * - MPU_EDR6 - Error Detail Register, slave port n
 * - MPU_EAR7 - Error Address Register, slave port n
 * - MPU_EDR7 - Error Detail Register, slave port n
 * - MPU_RGD0_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD0_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD0_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD0_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGD1_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD1_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD1_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD1_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGD2_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD2_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD2_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD2_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGD3_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD3_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD3_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD3_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGD4_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD4_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD4_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD4_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGD5_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD5_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD5_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD5_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGD6_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD6_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD6_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD6_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGD7_WORD0 - Region Descriptor n, Word 0
 * - MPU_RGD7_WORD1 - Region Descriptor n, Word 1
 * - MPU_RGD7_WORD2 - Region Descriptor n, Word 2
 * - MPU_RGD7_WORD3 - Region Descriptor n, Word 3
 * - MPU_RGDAAC0 - Region Descriptor Alternate Access Control n
 * - MPU_RGDAAC1 - Region Descriptor Alternate Access Control n
 * - MPU_RGDAAC2 - Region Descriptor Alternate Access Control n
 * - MPU_RGDAAC3 - Region Descriptor Alternate Access Control n
 * - MPU_RGDAAC4 - Region Descriptor Alternate Access Control n
 * - MPU_RGDAAC5 - Region Descriptor Alternate Access Control n
 * - MPU_RGDAAC6 - Region Descriptor Alternate Access Control n
 * - MPU_RGDAAC7 - Region Descriptor Alternate Access Control n
 */

#define MPU_INSTANCE_COUNT (1U) /*!< Number of instances of the MPU module. */
#define MPU_IDX (0U) /*!< Instance number for MPU. */

/*******************************************************************************
 * MPU_CESR - Control/Error Status Register
 ******************************************************************************/

/*!
 * @brief MPU_CESR - Control/Error Status Register (RW)
 *
 * Reset value: 0x00814001U
 */
/*!
 * @name Constants and macros for entire MPU_CESR register
 */
/*@{*/
#define MPU_RD_CESR(base)        (MPU_CESR_REG(base))
#define MPU_WR_CESR(base, value) (MPU_CESR_REG(base) = (value))
#define MPU_RMW_CESR(base, mask, value) (MPU_WR_CESR(base, (MPU_RD_CESR(base) & ~(mask)) | (value)))
#define MPU_SET_CESR(base, value) (MPU_WR_CESR(base, MPU_RD_CESR(base) |  (value)))
#define MPU_CLR_CESR(base, value) (MPU_WR_CESR(base, MPU_RD_CESR(base) & ~(value)))
#define MPU_TOG_CESR(base, value) (MPU_WR_CESR(base, MPU_RD_CESR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_CESR bitfields
 */

/*!
 * @name Register MPU_CESR, field VLD[0] (RW)
 *
 * Global enable/disable for the MPU.
 *
 * Values:
 * - 0b0 - MPU is disabled. All accesses from all bus masters are allowed.
 * - 0b1 - MPU is enabled
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_VLD field. */
#define MPU_RD_CESR_VLD(base) ((MPU_CESR_REG(base) & MPU_CESR_VLD_MASK) >> MPU_CESR_VLD_SHIFT)
#define MPU_BRD_CESR_VLD(base) (BITBAND_ACCESS32(&MPU_CESR_REG(base), MPU_CESR_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_CESR_VLD(base, value) (MPU_RMW_CESR(base, (MPU_CESR_VLD_MASK | MPU_CESR_SPERR_MASK), MPU_CESR_VLD(value)))
#define MPU_BWR_CESR_VLD(base, value) (BITBAND_ACCESS32(&MPU_CESR_REG(base), MPU_CESR_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_CESR, field NRGD[11:8] (RO)
 *
 * Indicates the number of region descriptors implemented in the MPU.
 *
 * Values:
 * - 0b0000 - 8 region descriptors
 * - 0b0001 - 12 region descriptors
 * - 0b0010 - 16 region descriptors
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_NRGD field. */
#define MPU_RD_CESR_NRGD(base) ((MPU_CESR_REG(base) & MPU_CESR_NRGD_MASK) >> MPU_CESR_NRGD_SHIFT)
#define MPU_BRD_CESR_NRGD(base) (MPU_RD_CESR_NRGD(base))
/*@}*/

/*!
 * @name Register MPU_CESR, field NSP[15:12] (RO)
 *
 * Specifies the number of slave ports connected to the MPU.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_NSP field. */
#define MPU_RD_CESR_NSP(base) ((MPU_CESR_REG(base) & MPU_CESR_NSP_MASK) >> MPU_CESR_NSP_SHIFT)
#define MPU_BRD_CESR_NSP(base) (MPU_RD_CESR_NSP(base))
/*@}*/

/*!
 * @name Register MPU_CESR, field HRL[19:16] (RO)
 *
 * Specifies the MPU's hardware and definition revision level. It can be read by
 * software to determine the functional definition of the module.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_HRL field. */
#define MPU_RD_CESR_HRL(base) ((MPU_CESR_REG(base) & MPU_CESR_HRL_MASK) >> MPU_CESR_HRL_SHIFT)
#define MPU_BRD_CESR_HRL(base) (MPU_RD_CESR_HRL(base))
/*@}*/

/*!
 * @name Register MPU_CESR, field SPERR[31:24] (W1C)
 *
 * Indicates a captured error in EARn and EDRn. This bit is set when the
 * hardware detects an error and records the faulting address and attributes. It is
 * cleared by writing one to it. If another error is captured at the exact same cycle
 * as the write, the flag remains set. A find-first-one instruction or
 * equivalent can detect the presence of a captured error. The following shows the
 * correspondence between the bit number and slave port number: Bit 31 corresponds to
 * slave port 0. Bit 30 corresponds to slave port 1. Bit 29 corresponds to slave
 * port 2. Bit 28 corresponds to slave port 3. Bit 27 corresponds to slave port 4.
 * Bit 26 corresponds to slave port 5. Bit 25 corresponds to slave port 6. Bit 24
 * corresponds to slave port 7.
 *
 * Values:
 * - 0b00000000 - No error has occurred for slave port n.
 * - 0b00000001 - An error has occurred for slave port n.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_SPERR field. */
#define MPU_RD_CESR_SPERR(base) ((MPU_CESR_REG(base) & MPU_CESR_SPERR_MASK) >> MPU_CESR_SPERR_SHIFT)
#define MPU_BRD_CESR_SPERR(base) (MPU_RD_CESR_SPERR(base))

/*! @brief Set the SPERR field to a new value. */
#define MPU_WR_CESR_SPERR(base, value) (MPU_RMW_CESR(base, MPU_CESR_SPERR_MASK, MPU_CESR_SPERR(value)))
#define MPU_BWR_CESR_SPERR(base, value) (MPU_WR_CESR_SPERR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_EAR0 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR0 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR0 register
 */
/*@{*/
#define MPU_RD_EAR0(base)        (MPU_EAR0_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR0 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR0 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR0 register
 */
/*@{*/
#define MPU_RD_EDR0(base)        (MPU_EDR0_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR0 bitfields
 */

/*!
 * @name Register MPU_EDR0, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR0_ERW field. */
#define MPU_RD_EDR0_ERW(base) ((MPU_EDR0_REG(base) & MPU_EDR0_ERW_MASK) >> MPU_EDR0_ERW_SHIFT)
#define MPU_BRD_EDR0_ERW(base) (BITBAND_ACCESS32(&MPU_EDR0_REG(base), MPU_EDR0_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR0, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR0_EATTR field. */
#define MPU_RD_EDR0_EATTR(base) ((MPU_EDR0_REG(base) & MPU_EDR0_EATTR_MASK) >> MPU_EDR0_EATTR_SHIFT)
#define MPU_BRD_EDR0_EATTR(base) (MPU_RD_EDR0_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR0, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR0_EMN field. */
#define MPU_RD_EDR0_EMN(base) ((MPU_EDR0_REG(base) & MPU_EDR0_EMN_MASK) >> MPU_EDR0_EMN_SHIFT)
#define MPU_BRD_EDR0_EMN(base) (MPU_RD_EDR0_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR0, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR0_EPID field. */
#define MPU_RD_EDR0_EPID(base) ((MPU_EDR0_REG(base) & MPU_EDR0_EPID_MASK) >> MPU_EDR0_EPID_SHIFT)
#define MPU_BRD_EDR0_EPID(base) (MPU_RD_EDR0_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR0, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR0_EACD field. */
#define MPU_RD_EDR0_EACD(base) ((MPU_EDR0_REG(base) & MPU_EDR0_EACD_MASK) >> MPU_EDR0_EACD_SHIFT)
#define MPU_BRD_EDR0_EACD(base) (MPU_RD_EDR0_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_EAR1 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR1 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR1 register
 */
/*@{*/
#define MPU_RD_EAR1(base)        (MPU_EAR1_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR1 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR1 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR1 register
 */
/*@{*/
#define MPU_RD_EDR1(base)        (MPU_EDR1_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR1 bitfields
 */

/*!
 * @name Register MPU_EDR1, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR1_ERW field. */
#define MPU_RD_EDR1_ERW(base) ((MPU_EDR1_REG(base) & MPU_EDR1_ERW_MASK) >> MPU_EDR1_ERW_SHIFT)
#define MPU_BRD_EDR1_ERW(base) (BITBAND_ACCESS32(&MPU_EDR1_REG(base), MPU_EDR1_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR1, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR1_EATTR field. */
#define MPU_RD_EDR1_EATTR(base) ((MPU_EDR1_REG(base) & MPU_EDR1_EATTR_MASK) >> MPU_EDR1_EATTR_SHIFT)
#define MPU_BRD_EDR1_EATTR(base) (MPU_RD_EDR1_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR1, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR1_EMN field. */
#define MPU_RD_EDR1_EMN(base) ((MPU_EDR1_REG(base) & MPU_EDR1_EMN_MASK) >> MPU_EDR1_EMN_SHIFT)
#define MPU_BRD_EDR1_EMN(base) (MPU_RD_EDR1_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR1, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR1_EPID field. */
#define MPU_RD_EDR1_EPID(base) ((MPU_EDR1_REG(base) & MPU_EDR1_EPID_MASK) >> MPU_EDR1_EPID_SHIFT)
#define MPU_BRD_EDR1_EPID(base) (MPU_RD_EDR1_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR1, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR1_EACD field. */
#define MPU_RD_EDR1_EACD(base) ((MPU_EDR1_REG(base) & MPU_EDR1_EACD_MASK) >> MPU_EDR1_EACD_SHIFT)
#define MPU_BRD_EDR1_EACD(base) (MPU_RD_EDR1_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_EAR2 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR2 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR2 register
 */
/*@{*/
#define MPU_RD_EAR2(base)        (MPU_EAR2_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR2 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR2 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR2 register
 */
/*@{*/
#define MPU_RD_EDR2(base)        (MPU_EDR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR2 bitfields
 */

/*!
 * @name Register MPU_EDR2, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR2_ERW field. */
#define MPU_RD_EDR2_ERW(base) ((MPU_EDR2_REG(base) & MPU_EDR2_ERW_MASK) >> MPU_EDR2_ERW_SHIFT)
#define MPU_BRD_EDR2_ERW(base) (BITBAND_ACCESS32(&MPU_EDR2_REG(base), MPU_EDR2_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR2, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR2_EATTR field. */
#define MPU_RD_EDR2_EATTR(base) ((MPU_EDR2_REG(base) & MPU_EDR2_EATTR_MASK) >> MPU_EDR2_EATTR_SHIFT)
#define MPU_BRD_EDR2_EATTR(base) (MPU_RD_EDR2_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR2, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR2_EMN field. */
#define MPU_RD_EDR2_EMN(base) ((MPU_EDR2_REG(base) & MPU_EDR2_EMN_MASK) >> MPU_EDR2_EMN_SHIFT)
#define MPU_BRD_EDR2_EMN(base) (MPU_RD_EDR2_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR2, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR2_EPID field. */
#define MPU_RD_EDR2_EPID(base) ((MPU_EDR2_REG(base) & MPU_EDR2_EPID_MASK) >> MPU_EDR2_EPID_SHIFT)
#define MPU_BRD_EDR2_EPID(base) (MPU_RD_EDR2_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR2, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR2_EACD field. */
#define MPU_RD_EDR2_EACD(base) ((MPU_EDR2_REG(base) & MPU_EDR2_EACD_MASK) >> MPU_EDR2_EACD_SHIFT)
#define MPU_BRD_EDR2_EACD(base) (MPU_RD_EDR2_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_EAR3 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR3 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR3 register
 */
/*@{*/
#define MPU_RD_EAR3(base)        (MPU_EAR3_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR3 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR3 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR3 register
 */
/*@{*/
#define MPU_RD_EDR3(base)        (MPU_EDR3_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR3 bitfields
 */

/*!
 * @name Register MPU_EDR3, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR3_ERW field. */
#define MPU_RD_EDR3_ERW(base) ((MPU_EDR3_REG(base) & MPU_EDR3_ERW_MASK) >> MPU_EDR3_ERW_SHIFT)
#define MPU_BRD_EDR3_ERW(base) (BITBAND_ACCESS32(&MPU_EDR3_REG(base), MPU_EDR3_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR3, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR3_EATTR field. */
#define MPU_RD_EDR3_EATTR(base) ((MPU_EDR3_REG(base) & MPU_EDR3_EATTR_MASK) >> MPU_EDR3_EATTR_SHIFT)
#define MPU_BRD_EDR3_EATTR(base) (MPU_RD_EDR3_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR3, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR3_EMN field. */
#define MPU_RD_EDR3_EMN(base) ((MPU_EDR3_REG(base) & MPU_EDR3_EMN_MASK) >> MPU_EDR3_EMN_SHIFT)
#define MPU_BRD_EDR3_EMN(base) (MPU_RD_EDR3_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR3, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR3_EPID field. */
#define MPU_RD_EDR3_EPID(base) ((MPU_EDR3_REG(base) & MPU_EDR3_EPID_MASK) >> MPU_EDR3_EPID_SHIFT)
#define MPU_BRD_EDR3_EPID(base) (MPU_RD_EDR3_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR3, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR3_EACD field. */
#define MPU_RD_EDR3_EACD(base) ((MPU_EDR3_REG(base) & MPU_EDR3_EACD_MASK) >> MPU_EDR3_EACD_SHIFT)
#define MPU_BRD_EDR3_EACD(base) (MPU_RD_EDR3_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_EAR4 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR4 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR4 register
 */
/*@{*/
#define MPU_RD_EAR4(base)        (MPU_EAR4_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR4 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR4 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR4 register
 */
/*@{*/
#define MPU_RD_EDR4(base)        (MPU_EDR4_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR4 bitfields
 */

/*!
 * @name Register MPU_EDR4, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR4_ERW field. */
#define MPU_RD_EDR4_ERW(base) ((MPU_EDR4_REG(base) & MPU_EDR4_ERW_MASK) >> MPU_EDR4_ERW_SHIFT)
#define MPU_BRD_EDR4_ERW(base) (BITBAND_ACCESS32(&MPU_EDR4_REG(base), MPU_EDR4_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR4, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR4_EATTR field. */
#define MPU_RD_EDR4_EATTR(base) ((MPU_EDR4_REG(base) & MPU_EDR4_EATTR_MASK) >> MPU_EDR4_EATTR_SHIFT)
#define MPU_BRD_EDR4_EATTR(base) (MPU_RD_EDR4_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR4, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR4_EMN field. */
#define MPU_RD_EDR4_EMN(base) ((MPU_EDR4_REG(base) & MPU_EDR4_EMN_MASK) >> MPU_EDR4_EMN_SHIFT)
#define MPU_BRD_EDR4_EMN(base) (MPU_RD_EDR4_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR4, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR4_EPID field. */
#define MPU_RD_EDR4_EPID(base) ((MPU_EDR4_REG(base) & MPU_EDR4_EPID_MASK) >> MPU_EDR4_EPID_SHIFT)
#define MPU_BRD_EDR4_EPID(base) (MPU_RD_EDR4_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR4, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR4_EACD field. */
#define MPU_RD_EDR4_EACD(base) ((MPU_EDR4_REG(base) & MPU_EDR4_EACD_MASK) >> MPU_EDR4_EACD_SHIFT)
#define MPU_BRD_EDR4_EACD(base) (MPU_RD_EDR4_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_EAR5 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR5 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR5 register
 */
/*@{*/
#define MPU_RD_EAR5(base)        (MPU_EAR5_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR5 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR5 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR5 register
 */
/*@{*/
#define MPU_RD_EDR5(base)        (MPU_EDR5_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR5 bitfields
 */

/*!
 * @name Register MPU_EDR5, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR5_ERW field. */
#define MPU_RD_EDR5_ERW(base) ((MPU_EDR5_REG(base) & MPU_EDR5_ERW_MASK) >> MPU_EDR5_ERW_SHIFT)
#define MPU_BRD_EDR5_ERW(base) (BITBAND_ACCESS32(&MPU_EDR5_REG(base), MPU_EDR5_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR5, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR5_EATTR field. */
#define MPU_RD_EDR5_EATTR(base) ((MPU_EDR5_REG(base) & MPU_EDR5_EATTR_MASK) >> MPU_EDR5_EATTR_SHIFT)
#define MPU_BRD_EDR5_EATTR(base) (MPU_RD_EDR5_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR5, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR5_EMN field. */
#define MPU_RD_EDR5_EMN(base) ((MPU_EDR5_REG(base) & MPU_EDR5_EMN_MASK) >> MPU_EDR5_EMN_SHIFT)
#define MPU_BRD_EDR5_EMN(base) (MPU_RD_EDR5_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR5, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR5_EPID field. */
#define MPU_RD_EDR5_EPID(base) ((MPU_EDR5_REG(base) & MPU_EDR5_EPID_MASK) >> MPU_EDR5_EPID_SHIFT)
#define MPU_BRD_EDR5_EPID(base) (MPU_RD_EDR5_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR5, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR5_EACD field. */
#define MPU_RD_EDR5_EACD(base) ((MPU_EDR5_REG(base) & MPU_EDR5_EACD_MASK) >> MPU_EDR5_EACD_SHIFT)
#define MPU_BRD_EDR5_EACD(base) (MPU_RD_EDR5_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_EAR6 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR6 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR6 register
 */
/*@{*/
#define MPU_RD_EAR6(base)        (MPU_EAR6_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR6 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR6 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR6 register
 */
/*@{*/
#define MPU_RD_EDR6(base)        (MPU_EDR6_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR6 bitfields
 */

/*!
 * @name Register MPU_EDR6, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR6_ERW field. */
#define MPU_RD_EDR6_ERW(base) ((MPU_EDR6_REG(base) & MPU_EDR6_ERW_MASK) >> MPU_EDR6_ERW_SHIFT)
#define MPU_BRD_EDR6_ERW(base) (BITBAND_ACCESS32(&MPU_EDR6_REG(base), MPU_EDR6_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR6, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR6_EATTR field. */
#define MPU_RD_EDR6_EATTR(base) ((MPU_EDR6_REG(base) & MPU_EDR6_EATTR_MASK) >> MPU_EDR6_EATTR_SHIFT)
#define MPU_BRD_EDR6_EATTR(base) (MPU_RD_EDR6_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR6, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR6_EMN field. */
#define MPU_RD_EDR6_EMN(base) ((MPU_EDR6_REG(base) & MPU_EDR6_EMN_MASK) >> MPU_EDR6_EMN_SHIFT)
#define MPU_BRD_EDR6_EMN(base) (MPU_RD_EDR6_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR6, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR6_EPID field. */
#define MPU_RD_EDR6_EPID(base) ((MPU_EDR6_REG(base) & MPU_EDR6_EPID_MASK) >> MPU_EDR6_EPID_SHIFT)
#define MPU_BRD_EDR6_EPID(base) (MPU_RD_EDR6_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR6, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR6_EACD field. */
#define MPU_RD_EDR6_EACD(base) ((MPU_EDR6_REG(base) & MPU_EDR6_EACD_MASK) >> MPU_EDR6_EACD_SHIFT)
#define MPU_BRD_EDR6_EACD(base) (MPU_RD_EDR6_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_EAR7 - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR7 - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR7 register
 */
/*@{*/
#define MPU_RD_EAR7(base)        (MPU_EAR7_REG(base))
/*@}*/

/*******************************************************************************
 * MPU_EDR7 - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR7 - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR7 register
 */
/*@{*/
#define MPU_RD_EDR7(base)        (MPU_EDR7_REG(base))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR7 bitfields
 */

/*!
 * @name Register MPU_EDR7, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR7_ERW field. */
#define MPU_RD_EDR7_ERW(base) ((MPU_EDR7_REG(base) & MPU_EDR7_ERW_MASK) >> MPU_EDR7_ERW_SHIFT)
#define MPU_BRD_EDR7_ERW(base) (BITBAND_ACCESS32(&MPU_EDR7_REG(base), MPU_EDR7_ERW_SHIFT))
/*@}*/

/*!
 * @name Register MPU_EDR7, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR7_EATTR field. */
#define MPU_RD_EDR7_EATTR(base) ((MPU_EDR7_REG(base) & MPU_EDR7_EATTR_MASK) >> MPU_EDR7_EATTR_SHIFT)
#define MPU_BRD_EDR7_EATTR(base) (MPU_RD_EDR7_EATTR(base))
/*@}*/

/*!
 * @name Register MPU_EDR7, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR7_EMN field. */
#define MPU_RD_EDR7_EMN(base) ((MPU_EDR7_REG(base) & MPU_EDR7_EMN_MASK) >> MPU_EDR7_EMN_SHIFT)
#define MPU_BRD_EDR7_EMN(base) (MPU_RD_EDR7_EMN(base))
/*@}*/

/*!
 * @name Register MPU_EDR7, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR7_EPID field. */
#define MPU_RD_EDR7_EPID(base) ((MPU_EDR7_REG(base) & MPU_EDR7_EPID_MASK) >> MPU_EDR7_EPID_SHIFT)
#define MPU_BRD_EDR7_EPID(base) (MPU_RD_EDR7_EPID(base))
/*@}*/

/*!
 * @name Register MPU_EDR7, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR7_EACD field. */
#define MPU_RD_EDR7_EACD(base) ((MPU_EDR7_REG(base) & MPU_EDR7_EACD_MASK) >> MPU_EDR7_EACD_SHIFT)
#define MPU_BRD_EDR7_EACD(base) (MPU_RD_EDR7_EACD(base))
/*@}*/

/*******************************************************************************
 * MPU_RGD0_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD0_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD0_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD0_WORD0(base)  (MPU_RGD0_WORD0_REG(base))
#define MPU_WR_RGD0_WORD0(base, value) (MPU_RGD0_WORD0_REG(base) = (value))
#define MPU_RMW_RGD0_WORD0(base, mask, value) (MPU_WR_RGD0_WORD0(base, (MPU_RD_RGD0_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD0_WORD0(base, value) (MPU_WR_RGD0_WORD0(base, MPU_RD_RGD0_WORD0(base) |  (value)))
#define MPU_CLR_RGD0_WORD0(base, value) (MPU_WR_RGD0_WORD0(base, MPU_RD_RGD0_WORD0(base) & ~(value)))
#define MPU_TOG_RGD0_WORD0(base, value) (MPU_WR_RGD0_WORD0(base, MPU_RD_RGD0_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD0_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD0_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD0_SRTADDR field. */
#define MPU_RD_RGD0_WORD0_SRTADDR(base) ((MPU_RGD0_WORD0_REG(base) & MPU_RGD0_WORD0_SRTADDR_MASK) >> MPU_RGD0_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD0_WORD0_SRTADDR(base) (MPU_RD_RGD0_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD0_WORD0_SRTADDR(base, value) (MPU_RMW_RGD0_WORD0(base, MPU_RGD0_WORD0_SRTADDR_MASK, MPU_RGD0_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD0_WORD0_SRTADDR(base, value) (MPU_WR_RGD0_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD0_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD0_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD0_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD0_WORD1(base)  (MPU_RGD0_WORD1_REG(base))
#define MPU_WR_RGD0_WORD1(base, value) (MPU_RGD0_WORD1_REG(base) = (value))
#define MPU_RMW_RGD0_WORD1(base, mask, value) (MPU_WR_RGD0_WORD1(base, (MPU_RD_RGD0_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD0_WORD1(base, value) (MPU_WR_RGD0_WORD1(base, MPU_RD_RGD0_WORD1(base) |  (value)))
#define MPU_CLR_RGD0_WORD1(base, value) (MPU_WR_RGD0_WORD1(base, MPU_RD_RGD0_WORD1(base) & ~(value)))
#define MPU_TOG_RGD0_WORD1(base, value) (MPU_WR_RGD0_WORD1(base, MPU_RD_RGD0_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD0_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD0_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD1_ENDADDR field. */
#define MPU_RD_RGD0_WORD1_ENDADDR(base) ((MPU_RGD0_WORD1_REG(base) & MPU_RGD0_WORD1_ENDADDR_MASK) >> MPU_RGD0_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD0_WORD1_ENDADDR(base) (MPU_RD_RGD0_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD0_WORD1_ENDADDR(base, value) (MPU_RMW_RGD0_WORD1(base, MPU_RGD0_WORD1_ENDADDR_MASK, MPU_RGD0_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD0_WORD1_ENDADDR(base, value) (MPU_WR_RGD0_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD0_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD0_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD0_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD0_WORD2(base)  (MPU_RGD0_WORD2_REG(base))
#define MPU_WR_RGD0_WORD2(base, value) (MPU_RGD0_WORD2_REG(base) = (value))
#define MPU_RMW_RGD0_WORD2(base, mask, value) (MPU_WR_RGD0_WORD2(base, (MPU_RD_RGD0_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD0_WORD2(base, value) (MPU_WR_RGD0_WORD2(base, MPU_RD_RGD0_WORD2(base) |  (value)))
#define MPU_CLR_RGD0_WORD2(base, value) (MPU_WR_RGD0_WORD2(base, MPU_RD_RGD0_WORD2(base) & ~(value)))
#define MPU_TOG_RGD0_WORD2(base, value) (MPU_WR_RGD0_WORD2(base, MPU_RD_RGD0_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD0_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD0_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M0UM field. */
#define MPU_RD_RGD0_WORD2_M0UM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M0UM_MASK) >> MPU_RGD0_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M0UM(base) (MPU_RD_RGD0_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD0_WORD2_M0UM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M0UM_MASK, MPU_RGD0_WORD2_M0UM(value)))
#define MPU_BWR_RGD0_WORD2_M0UM(base, value) (MPU_WR_RGD0_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M0SM field. */
#define MPU_RD_RGD0_WORD2_M0SM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M0SM_MASK) >> MPU_RGD0_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M0SM(base) (MPU_RD_RGD0_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD0_WORD2_M0SM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M0SM_MASK, MPU_RGD0_WORD2_M0SM(value)))
#define MPU_BWR_RGD0_WORD2_M0SM(base, value) (MPU_WR_RGD0_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M0PE field. */
#define MPU_RD_RGD0_WORD2_M0PE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M0PE_MASK) >> MPU_RGD0_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD0_WORD2_M0PE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M0PE_MASK, MPU_RGD0_WORD2_M0PE(value)))
#define MPU_BWR_RGD0_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M1UM field. */
#define MPU_RD_RGD0_WORD2_M1UM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M1UM_MASK) >> MPU_RGD0_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M1UM(base) (MPU_RD_RGD0_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD0_WORD2_M1UM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M1UM_MASK, MPU_RGD0_WORD2_M1UM(value)))
#define MPU_BWR_RGD0_WORD2_M1UM(base, value) (MPU_WR_RGD0_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M1SM field. */
#define MPU_RD_RGD0_WORD2_M1SM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M1SM_MASK) >> MPU_RGD0_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M1SM(base) (MPU_RD_RGD0_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD0_WORD2_M1SM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M1SM_MASK, MPU_RGD0_WORD2_M1SM(value)))
#define MPU_BWR_RGD0_WORD2_M1SM(base, value) (MPU_WR_RGD0_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M1PE field. */
#define MPU_RD_RGD0_WORD2_M1PE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M1PE_MASK) >> MPU_RGD0_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD0_WORD2_M1PE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M1PE_MASK, MPU_RGD0_WORD2_M1PE(value)))
#define MPU_BWR_RGD0_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M2UM field. */
#define MPU_RD_RGD0_WORD2_M2UM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M2UM_MASK) >> MPU_RGD0_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M2UM(base) (MPU_RD_RGD0_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD0_WORD2_M2UM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M2UM_MASK, MPU_RGD0_WORD2_M2UM(value)))
#define MPU_BWR_RGD0_WORD2_M2UM(base, value) (MPU_WR_RGD0_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M2SM field. */
#define MPU_RD_RGD0_WORD2_M2SM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M2SM_MASK) >> MPU_RGD0_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M2SM(base) (MPU_RD_RGD0_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD0_WORD2_M2SM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M2SM_MASK, MPU_RGD0_WORD2_M2SM(value)))
#define MPU_BWR_RGD0_WORD2_M2SM(base, value) (MPU_WR_RGD0_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M2PE field. */
#define MPU_RD_RGD0_WORD2_M2PE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M2PE_MASK) >> MPU_RGD0_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD0_WORD2_M2PE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M2PE_MASK, MPU_RGD0_WORD2_M2PE(value)))
#define MPU_BWR_RGD0_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M3UM field. */
#define MPU_RD_RGD0_WORD2_M3UM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M3UM_MASK) >> MPU_RGD0_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M3UM(base) (MPU_RD_RGD0_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD0_WORD2_M3UM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M3UM_MASK, MPU_RGD0_WORD2_M3UM(value)))
#define MPU_BWR_RGD0_WORD2_M3UM(base, value) (MPU_WR_RGD0_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M3SM field. */
#define MPU_RD_RGD0_WORD2_M3SM(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M3SM_MASK) >> MPU_RGD0_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD0_WORD2_M3SM(base) (MPU_RD_RGD0_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD0_WORD2_M3SM(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M3SM_MASK, MPU_RGD0_WORD2_M3SM(value)))
#define MPU_BWR_RGD0_WORD2_M3SM(base, value) (MPU_WR_RGD0_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M3PE field. */
#define MPU_RD_RGD0_WORD2_M3PE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M3PE_MASK) >> MPU_RGD0_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD0_WORD2_M3PE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M3PE_MASK, MPU_RGD0_WORD2_M3PE(value)))
#define MPU_BWR_RGD0_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M4WE field. */
#define MPU_RD_RGD0_WORD2_M4WE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M4WE_MASK) >> MPU_RGD0_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD0_WORD2_M4WE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M4WE_MASK, MPU_RGD0_WORD2_M4WE(value)))
#define MPU_BWR_RGD0_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M4RE field. */
#define MPU_RD_RGD0_WORD2_M4RE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M4RE_MASK) >> MPU_RGD0_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD0_WORD2_M4RE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M4RE_MASK, MPU_RGD0_WORD2_M4RE(value)))
#define MPU_BWR_RGD0_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M5WE field. */
#define MPU_RD_RGD0_WORD2_M5WE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M5WE_MASK) >> MPU_RGD0_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD0_WORD2_M5WE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M5WE_MASK, MPU_RGD0_WORD2_M5WE(value)))
#define MPU_BWR_RGD0_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M5RE field. */
#define MPU_RD_RGD0_WORD2_M5RE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M5RE_MASK) >> MPU_RGD0_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD0_WORD2_M5RE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M5RE_MASK, MPU_RGD0_WORD2_M5RE(value)))
#define MPU_BWR_RGD0_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M6WE field. */
#define MPU_RD_RGD0_WORD2_M6WE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M6WE_MASK) >> MPU_RGD0_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD0_WORD2_M6WE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M6WE_MASK, MPU_RGD0_WORD2_M6WE(value)))
#define MPU_BWR_RGD0_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M6RE field. */
#define MPU_RD_RGD0_WORD2_M6RE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M6RE_MASK) >> MPU_RGD0_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD0_WORD2_M6RE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M6RE_MASK, MPU_RGD0_WORD2_M6RE(value)))
#define MPU_BWR_RGD0_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M7WE field. */
#define MPU_RD_RGD0_WORD2_M7WE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M7WE_MASK) >> MPU_RGD0_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD0_WORD2_M7WE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M7WE_MASK, MPU_RGD0_WORD2_M7WE(value)))
#define MPU_BWR_RGD0_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD2_M7RE field. */
#define MPU_RD_RGD0_WORD2_M7RE(base) ((MPU_RGD0_WORD2_REG(base) & MPU_RGD0_WORD2_M7RE_MASK) >> MPU_RGD0_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD0_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD0_WORD2_M7RE(base, value) (MPU_RMW_RGD0_WORD2(base, MPU_RGD0_WORD2_M7RE_MASK, MPU_RGD0_WORD2_M7RE(value)))
#define MPU_BWR_RGD0_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD2_REG(base), MPU_RGD0_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD0_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD0_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD0_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD0_WORD3(base)  (MPU_RGD0_WORD3_REG(base))
#define MPU_WR_RGD0_WORD3(base, value) (MPU_RGD0_WORD3_REG(base) = (value))
#define MPU_RMW_RGD0_WORD3(base, mask, value) (MPU_WR_RGD0_WORD3(base, (MPU_RD_RGD0_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD0_WORD3(base, value) (MPU_WR_RGD0_WORD3(base, MPU_RD_RGD0_WORD3(base) |  (value)))
#define MPU_CLR_RGD0_WORD3(base, value) (MPU_WR_RGD0_WORD3(base, MPU_RD_RGD0_WORD3(base) & ~(value)))
#define MPU_TOG_RGD0_WORD3(base, value) (MPU_WR_RGD0_WORD3(base, MPU_RD_RGD0_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD0_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD0_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD3_VLD field. */
#define MPU_RD_RGD0_WORD3_VLD(base) ((MPU_RGD0_WORD3_REG(base) & MPU_RGD0_WORD3_VLD_MASK) >> MPU_RGD0_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD0_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD0_WORD3_REG(base), MPU_RGD0_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD0_WORD3_VLD(base, value) (MPU_RMW_RGD0_WORD3(base, MPU_RGD0_WORD3_VLD_MASK, MPU_RGD0_WORD3_VLD(value)))
#define MPU_BWR_RGD0_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD0_WORD3_REG(base), MPU_RGD0_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD3_PIDMASK field. */
#define MPU_RD_RGD0_WORD3_PIDMASK(base) ((MPU_RGD0_WORD3_REG(base) & MPU_RGD0_WORD3_PIDMASK_MASK) >> MPU_RGD0_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD0_WORD3_PIDMASK(base) (MPU_RD_RGD0_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD0_WORD3_PIDMASK(base, value) (MPU_RMW_RGD0_WORD3(base, MPU_RGD0_WORD3_PIDMASK_MASK, MPU_RGD0_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD0_WORD3_PIDMASK(base, value) (MPU_WR_RGD0_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD0_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD0_WORD3_PID field. */
#define MPU_RD_RGD0_WORD3_PID(base) ((MPU_RGD0_WORD3_REG(base) & MPU_RGD0_WORD3_PID_MASK) >> MPU_RGD0_WORD3_PID_SHIFT)
#define MPU_BRD_RGD0_WORD3_PID(base) (MPU_RD_RGD0_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD0_WORD3_PID(base, value) (MPU_RMW_RGD0_WORD3(base, MPU_RGD0_WORD3_PID_MASK, MPU_RGD0_WORD3_PID(value)))
#define MPU_BWR_RGD0_WORD3_PID(base, value) (MPU_WR_RGD0_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD1_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD1_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD1_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD1_WORD0(base)  (MPU_RGD1_WORD0_REG(base))
#define MPU_WR_RGD1_WORD0(base, value) (MPU_RGD1_WORD0_REG(base) = (value))
#define MPU_RMW_RGD1_WORD0(base, mask, value) (MPU_WR_RGD1_WORD0(base, (MPU_RD_RGD1_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD1_WORD0(base, value) (MPU_WR_RGD1_WORD0(base, MPU_RD_RGD1_WORD0(base) |  (value)))
#define MPU_CLR_RGD1_WORD0(base, value) (MPU_WR_RGD1_WORD0(base, MPU_RD_RGD1_WORD0(base) & ~(value)))
#define MPU_TOG_RGD1_WORD0(base, value) (MPU_WR_RGD1_WORD0(base, MPU_RD_RGD1_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD1_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD1_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD0_SRTADDR field. */
#define MPU_RD_RGD1_WORD0_SRTADDR(base) ((MPU_RGD1_WORD0_REG(base) & MPU_RGD1_WORD0_SRTADDR_MASK) >> MPU_RGD1_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD1_WORD0_SRTADDR(base) (MPU_RD_RGD1_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD1_WORD0_SRTADDR(base, value) (MPU_RMW_RGD1_WORD0(base, MPU_RGD1_WORD0_SRTADDR_MASK, MPU_RGD1_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD1_WORD0_SRTADDR(base, value) (MPU_WR_RGD1_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD1_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD1_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD1_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD1_WORD1(base)  (MPU_RGD1_WORD1_REG(base))
#define MPU_WR_RGD1_WORD1(base, value) (MPU_RGD1_WORD1_REG(base) = (value))
#define MPU_RMW_RGD1_WORD1(base, mask, value) (MPU_WR_RGD1_WORD1(base, (MPU_RD_RGD1_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD1_WORD1(base, value) (MPU_WR_RGD1_WORD1(base, MPU_RD_RGD1_WORD1(base) |  (value)))
#define MPU_CLR_RGD1_WORD1(base, value) (MPU_WR_RGD1_WORD1(base, MPU_RD_RGD1_WORD1(base) & ~(value)))
#define MPU_TOG_RGD1_WORD1(base, value) (MPU_WR_RGD1_WORD1(base, MPU_RD_RGD1_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD1_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD1_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD1_ENDADDR field. */
#define MPU_RD_RGD1_WORD1_ENDADDR(base) ((MPU_RGD1_WORD1_REG(base) & MPU_RGD1_WORD1_ENDADDR_MASK) >> MPU_RGD1_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD1_WORD1_ENDADDR(base) (MPU_RD_RGD1_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD1_WORD1_ENDADDR(base, value) (MPU_RMW_RGD1_WORD1(base, MPU_RGD1_WORD1_ENDADDR_MASK, MPU_RGD1_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD1_WORD1_ENDADDR(base, value) (MPU_WR_RGD1_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD1_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD1_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD1_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD1_WORD2(base)  (MPU_RGD1_WORD2_REG(base))
#define MPU_WR_RGD1_WORD2(base, value) (MPU_RGD1_WORD2_REG(base) = (value))
#define MPU_RMW_RGD1_WORD2(base, mask, value) (MPU_WR_RGD1_WORD2(base, (MPU_RD_RGD1_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD1_WORD2(base, value) (MPU_WR_RGD1_WORD2(base, MPU_RD_RGD1_WORD2(base) |  (value)))
#define MPU_CLR_RGD1_WORD2(base, value) (MPU_WR_RGD1_WORD2(base, MPU_RD_RGD1_WORD2(base) & ~(value)))
#define MPU_TOG_RGD1_WORD2(base, value) (MPU_WR_RGD1_WORD2(base, MPU_RD_RGD1_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD1_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD1_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M0UM field. */
#define MPU_RD_RGD1_WORD2_M0UM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M0UM_MASK) >> MPU_RGD1_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M0UM(base) (MPU_RD_RGD1_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD1_WORD2_M0UM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M0UM_MASK, MPU_RGD1_WORD2_M0UM(value)))
#define MPU_BWR_RGD1_WORD2_M0UM(base, value) (MPU_WR_RGD1_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M0SM field. */
#define MPU_RD_RGD1_WORD2_M0SM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M0SM_MASK) >> MPU_RGD1_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M0SM(base) (MPU_RD_RGD1_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD1_WORD2_M0SM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M0SM_MASK, MPU_RGD1_WORD2_M0SM(value)))
#define MPU_BWR_RGD1_WORD2_M0SM(base, value) (MPU_WR_RGD1_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M0PE field. */
#define MPU_RD_RGD1_WORD2_M0PE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M0PE_MASK) >> MPU_RGD1_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD1_WORD2_M0PE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M0PE_MASK, MPU_RGD1_WORD2_M0PE(value)))
#define MPU_BWR_RGD1_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M1UM field. */
#define MPU_RD_RGD1_WORD2_M1UM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M1UM_MASK) >> MPU_RGD1_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M1UM(base) (MPU_RD_RGD1_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD1_WORD2_M1UM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M1UM_MASK, MPU_RGD1_WORD2_M1UM(value)))
#define MPU_BWR_RGD1_WORD2_M1UM(base, value) (MPU_WR_RGD1_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M1SM field. */
#define MPU_RD_RGD1_WORD2_M1SM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M1SM_MASK) >> MPU_RGD1_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M1SM(base) (MPU_RD_RGD1_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD1_WORD2_M1SM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M1SM_MASK, MPU_RGD1_WORD2_M1SM(value)))
#define MPU_BWR_RGD1_WORD2_M1SM(base, value) (MPU_WR_RGD1_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M1PE field. */
#define MPU_RD_RGD1_WORD2_M1PE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M1PE_MASK) >> MPU_RGD1_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD1_WORD2_M1PE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M1PE_MASK, MPU_RGD1_WORD2_M1PE(value)))
#define MPU_BWR_RGD1_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M2UM field. */
#define MPU_RD_RGD1_WORD2_M2UM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M2UM_MASK) >> MPU_RGD1_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M2UM(base) (MPU_RD_RGD1_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD1_WORD2_M2UM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M2UM_MASK, MPU_RGD1_WORD2_M2UM(value)))
#define MPU_BWR_RGD1_WORD2_M2UM(base, value) (MPU_WR_RGD1_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M2SM field. */
#define MPU_RD_RGD1_WORD2_M2SM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M2SM_MASK) >> MPU_RGD1_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M2SM(base) (MPU_RD_RGD1_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD1_WORD2_M2SM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M2SM_MASK, MPU_RGD1_WORD2_M2SM(value)))
#define MPU_BWR_RGD1_WORD2_M2SM(base, value) (MPU_WR_RGD1_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M2PE field. */
#define MPU_RD_RGD1_WORD2_M2PE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M2PE_MASK) >> MPU_RGD1_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD1_WORD2_M2PE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M2PE_MASK, MPU_RGD1_WORD2_M2PE(value)))
#define MPU_BWR_RGD1_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M3UM field. */
#define MPU_RD_RGD1_WORD2_M3UM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M3UM_MASK) >> MPU_RGD1_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M3UM(base) (MPU_RD_RGD1_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD1_WORD2_M3UM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M3UM_MASK, MPU_RGD1_WORD2_M3UM(value)))
#define MPU_BWR_RGD1_WORD2_M3UM(base, value) (MPU_WR_RGD1_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M3SM field. */
#define MPU_RD_RGD1_WORD2_M3SM(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M3SM_MASK) >> MPU_RGD1_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD1_WORD2_M3SM(base) (MPU_RD_RGD1_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD1_WORD2_M3SM(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M3SM_MASK, MPU_RGD1_WORD2_M3SM(value)))
#define MPU_BWR_RGD1_WORD2_M3SM(base, value) (MPU_WR_RGD1_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M3PE field. */
#define MPU_RD_RGD1_WORD2_M3PE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M3PE_MASK) >> MPU_RGD1_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD1_WORD2_M3PE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M3PE_MASK, MPU_RGD1_WORD2_M3PE(value)))
#define MPU_BWR_RGD1_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M4WE field. */
#define MPU_RD_RGD1_WORD2_M4WE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M4WE_MASK) >> MPU_RGD1_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD1_WORD2_M4WE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M4WE_MASK, MPU_RGD1_WORD2_M4WE(value)))
#define MPU_BWR_RGD1_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M4RE field. */
#define MPU_RD_RGD1_WORD2_M4RE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M4RE_MASK) >> MPU_RGD1_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD1_WORD2_M4RE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M4RE_MASK, MPU_RGD1_WORD2_M4RE(value)))
#define MPU_BWR_RGD1_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M5WE field. */
#define MPU_RD_RGD1_WORD2_M5WE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M5WE_MASK) >> MPU_RGD1_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD1_WORD2_M5WE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M5WE_MASK, MPU_RGD1_WORD2_M5WE(value)))
#define MPU_BWR_RGD1_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M5RE field. */
#define MPU_RD_RGD1_WORD2_M5RE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M5RE_MASK) >> MPU_RGD1_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD1_WORD2_M5RE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M5RE_MASK, MPU_RGD1_WORD2_M5RE(value)))
#define MPU_BWR_RGD1_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M6WE field. */
#define MPU_RD_RGD1_WORD2_M6WE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M6WE_MASK) >> MPU_RGD1_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD1_WORD2_M6WE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M6WE_MASK, MPU_RGD1_WORD2_M6WE(value)))
#define MPU_BWR_RGD1_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M6RE field. */
#define MPU_RD_RGD1_WORD2_M6RE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M6RE_MASK) >> MPU_RGD1_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD1_WORD2_M6RE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M6RE_MASK, MPU_RGD1_WORD2_M6RE(value)))
#define MPU_BWR_RGD1_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M7WE field. */
#define MPU_RD_RGD1_WORD2_M7WE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M7WE_MASK) >> MPU_RGD1_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD1_WORD2_M7WE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M7WE_MASK, MPU_RGD1_WORD2_M7WE(value)))
#define MPU_BWR_RGD1_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD2_M7RE field. */
#define MPU_RD_RGD1_WORD2_M7RE(base) ((MPU_RGD1_WORD2_REG(base) & MPU_RGD1_WORD2_M7RE_MASK) >> MPU_RGD1_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD1_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD1_WORD2_M7RE(base, value) (MPU_RMW_RGD1_WORD2(base, MPU_RGD1_WORD2_M7RE_MASK, MPU_RGD1_WORD2_M7RE(value)))
#define MPU_BWR_RGD1_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD2_REG(base), MPU_RGD1_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD1_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD1_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD1_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD1_WORD3(base)  (MPU_RGD1_WORD3_REG(base))
#define MPU_WR_RGD1_WORD3(base, value) (MPU_RGD1_WORD3_REG(base) = (value))
#define MPU_RMW_RGD1_WORD3(base, mask, value) (MPU_WR_RGD1_WORD3(base, (MPU_RD_RGD1_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD1_WORD3(base, value) (MPU_WR_RGD1_WORD3(base, MPU_RD_RGD1_WORD3(base) |  (value)))
#define MPU_CLR_RGD1_WORD3(base, value) (MPU_WR_RGD1_WORD3(base, MPU_RD_RGD1_WORD3(base) & ~(value)))
#define MPU_TOG_RGD1_WORD3(base, value) (MPU_WR_RGD1_WORD3(base, MPU_RD_RGD1_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD1_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD1_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD3_VLD field. */
#define MPU_RD_RGD1_WORD3_VLD(base) ((MPU_RGD1_WORD3_REG(base) & MPU_RGD1_WORD3_VLD_MASK) >> MPU_RGD1_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD1_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD1_WORD3_REG(base), MPU_RGD1_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD1_WORD3_VLD(base, value) (MPU_RMW_RGD1_WORD3(base, MPU_RGD1_WORD3_VLD_MASK, MPU_RGD1_WORD3_VLD(value)))
#define MPU_BWR_RGD1_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD1_WORD3_REG(base), MPU_RGD1_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD3_PIDMASK field. */
#define MPU_RD_RGD1_WORD3_PIDMASK(base) ((MPU_RGD1_WORD3_REG(base) & MPU_RGD1_WORD3_PIDMASK_MASK) >> MPU_RGD1_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD1_WORD3_PIDMASK(base) (MPU_RD_RGD1_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD1_WORD3_PIDMASK(base, value) (MPU_RMW_RGD1_WORD3(base, MPU_RGD1_WORD3_PIDMASK_MASK, MPU_RGD1_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD1_WORD3_PIDMASK(base, value) (MPU_WR_RGD1_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD1_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD1_WORD3_PID field. */
#define MPU_RD_RGD1_WORD3_PID(base) ((MPU_RGD1_WORD3_REG(base) & MPU_RGD1_WORD3_PID_MASK) >> MPU_RGD1_WORD3_PID_SHIFT)
#define MPU_BRD_RGD1_WORD3_PID(base) (MPU_RD_RGD1_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD1_WORD3_PID(base, value) (MPU_RMW_RGD1_WORD3(base, MPU_RGD1_WORD3_PID_MASK, MPU_RGD1_WORD3_PID(value)))
#define MPU_BWR_RGD1_WORD3_PID(base, value) (MPU_WR_RGD1_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD2_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD2_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD2_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD2_WORD0(base)  (MPU_RGD2_WORD0_REG(base))
#define MPU_WR_RGD2_WORD0(base, value) (MPU_RGD2_WORD0_REG(base) = (value))
#define MPU_RMW_RGD2_WORD0(base, mask, value) (MPU_WR_RGD2_WORD0(base, (MPU_RD_RGD2_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD2_WORD0(base, value) (MPU_WR_RGD2_WORD0(base, MPU_RD_RGD2_WORD0(base) |  (value)))
#define MPU_CLR_RGD2_WORD0(base, value) (MPU_WR_RGD2_WORD0(base, MPU_RD_RGD2_WORD0(base) & ~(value)))
#define MPU_TOG_RGD2_WORD0(base, value) (MPU_WR_RGD2_WORD0(base, MPU_RD_RGD2_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD2_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD2_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD0_SRTADDR field. */
#define MPU_RD_RGD2_WORD0_SRTADDR(base) ((MPU_RGD2_WORD0_REG(base) & MPU_RGD2_WORD0_SRTADDR_MASK) >> MPU_RGD2_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD2_WORD0_SRTADDR(base) (MPU_RD_RGD2_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD2_WORD0_SRTADDR(base, value) (MPU_RMW_RGD2_WORD0(base, MPU_RGD2_WORD0_SRTADDR_MASK, MPU_RGD2_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD2_WORD0_SRTADDR(base, value) (MPU_WR_RGD2_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD2_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD2_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD2_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD2_WORD1(base)  (MPU_RGD2_WORD1_REG(base))
#define MPU_WR_RGD2_WORD1(base, value) (MPU_RGD2_WORD1_REG(base) = (value))
#define MPU_RMW_RGD2_WORD1(base, mask, value) (MPU_WR_RGD2_WORD1(base, (MPU_RD_RGD2_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD2_WORD1(base, value) (MPU_WR_RGD2_WORD1(base, MPU_RD_RGD2_WORD1(base) |  (value)))
#define MPU_CLR_RGD2_WORD1(base, value) (MPU_WR_RGD2_WORD1(base, MPU_RD_RGD2_WORD1(base) & ~(value)))
#define MPU_TOG_RGD2_WORD1(base, value) (MPU_WR_RGD2_WORD1(base, MPU_RD_RGD2_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD2_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD2_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD1_ENDADDR field. */
#define MPU_RD_RGD2_WORD1_ENDADDR(base) ((MPU_RGD2_WORD1_REG(base) & MPU_RGD2_WORD1_ENDADDR_MASK) >> MPU_RGD2_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD2_WORD1_ENDADDR(base) (MPU_RD_RGD2_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD2_WORD1_ENDADDR(base, value) (MPU_RMW_RGD2_WORD1(base, MPU_RGD2_WORD1_ENDADDR_MASK, MPU_RGD2_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD2_WORD1_ENDADDR(base, value) (MPU_WR_RGD2_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD2_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD2_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD2_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD2_WORD2(base)  (MPU_RGD2_WORD2_REG(base))
#define MPU_WR_RGD2_WORD2(base, value) (MPU_RGD2_WORD2_REG(base) = (value))
#define MPU_RMW_RGD2_WORD2(base, mask, value) (MPU_WR_RGD2_WORD2(base, (MPU_RD_RGD2_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD2_WORD2(base, value) (MPU_WR_RGD2_WORD2(base, MPU_RD_RGD2_WORD2(base) |  (value)))
#define MPU_CLR_RGD2_WORD2(base, value) (MPU_WR_RGD2_WORD2(base, MPU_RD_RGD2_WORD2(base) & ~(value)))
#define MPU_TOG_RGD2_WORD2(base, value) (MPU_WR_RGD2_WORD2(base, MPU_RD_RGD2_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD2_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD2_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M0UM field. */
#define MPU_RD_RGD2_WORD2_M0UM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M0UM_MASK) >> MPU_RGD2_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M0UM(base) (MPU_RD_RGD2_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD2_WORD2_M0UM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M0UM_MASK, MPU_RGD2_WORD2_M0UM(value)))
#define MPU_BWR_RGD2_WORD2_M0UM(base, value) (MPU_WR_RGD2_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M0SM field. */
#define MPU_RD_RGD2_WORD2_M0SM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M0SM_MASK) >> MPU_RGD2_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M0SM(base) (MPU_RD_RGD2_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD2_WORD2_M0SM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M0SM_MASK, MPU_RGD2_WORD2_M0SM(value)))
#define MPU_BWR_RGD2_WORD2_M0SM(base, value) (MPU_WR_RGD2_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M0PE field. */
#define MPU_RD_RGD2_WORD2_M0PE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M0PE_MASK) >> MPU_RGD2_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD2_WORD2_M0PE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M0PE_MASK, MPU_RGD2_WORD2_M0PE(value)))
#define MPU_BWR_RGD2_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M1UM field. */
#define MPU_RD_RGD2_WORD2_M1UM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M1UM_MASK) >> MPU_RGD2_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M1UM(base) (MPU_RD_RGD2_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD2_WORD2_M1UM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M1UM_MASK, MPU_RGD2_WORD2_M1UM(value)))
#define MPU_BWR_RGD2_WORD2_M1UM(base, value) (MPU_WR_RGD2_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M1SM field. */
#define MPU_RD_RGD2_WORD2_M1SM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M1SM_MASK) >> MPU_RGD2_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M1SM(base) (MPU_RD_RGD2_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD2_WORD2_M1SM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M1SM_MASK, MPU_RGD2_WORD2_M1SM(value)))
#define MPU_BWR_RGD2_WORD2_M1SM(base, value) (MPU_WR_RGD2_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M1PE field. */
#define MPU_RD_RGD2_WORD2_M1PE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M1PE_MASK) >> MPU_RGD2_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD2_WORD2_M1PE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M1PE_MASK, MPU_RGD2_WORD2_M1PE(value)))
#define MPU_BWR_RGD2_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M2UM field. */
#define MPU_RD_RGD2_WORD2_M2UM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M2UM_MASK) >> MPU_RGD2_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M2UM(base) (MPU_RD_RGD2_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD2_WORD2_M2UM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M2UM_MASK, MPU_RGD2_WORD2_M2UM(value)))
#define MPU_BWR_RGD2_WORD2_M2UM(base, value) (MPU_WR_RGD2_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M2SM field. */
#define MPU_RD_RGD2_WORD2_M2SM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M2SM_MASK) >> MPU_RGD2_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M2SM(base) (MPU_RD_RGD2_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD2_WORD2_M2SM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M2SM_MASK, MPU_RGD2_WORD2_M2SM(value)))
#define MPU_BWR_RGD2_WORD2_M2SM(base, value) (MPU_WR_RGD2_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M2PE field. */
#define MPU_RD_RGD2_WORD2_M2PE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M2PE_MASK) >> MPU_RGD2_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD2_WORD2_M2PE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M2PE_MASK, MPU_RGD2_WORD2_M2PE(value)))
#define MPU_BWR_RGD2_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M3UM field. */
#define MPU_RD_RGD2_WORD2_M3UM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M3UM_MASK) >> MPU_RGD2_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M3UM(base) (MPU_RD_RGD2_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD2_WORD2_M3UM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M3UM_MASK, MPU_RGD2_WORD2_M3UM(value)))
#define MPU_BWR_RGD2_WORD2_M3UM(base, value) (MPU_WR_RGD2_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M3SM field. */
#define MPU_RD_RGD2_WORD2_M3SM(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M3SM_MASK) >> MPU_RGD2_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD2_WORD2_M3SM(base) (MPU_RD_RGD2_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD2_WORD2_M3SM(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M3SM_MASK, MPU_RGD2_WORD2_M3SM(value)))
#define MPU_BWR_RGD2_WORD2_M3SM(base, value) (MPU_WR_RGD2_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M3PE field. */
#define MPU_RD_RGD2_WORD2_M3PE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M3PE_MASK) >> MPU_RGD2_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD2_WORD2_M3PE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M3PE_MASK, MPU_RGD2_WORD2_M3PE(value)))
#define MPU_BWR_RGD2_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M4WE field. */
#define MPU_RD_RGD2_WORD2_M4WE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M4WE_MASK) >> MPU_RGD2_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD2_WORD2_M4WE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M4WE_MASK, MPU_RGD2_WORD2_M4WE(value)))
#define MPU_BWR_RGD2_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M4RE field. */
#define MPU_RD_RGD2_WORD2_M4RE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M4RE_MASK) >> MPU_RGD2_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD2_WORD2_M4RE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M4RE_MASK, MPU_RGD2_WORD2_M4RE(value)))
#define MPU_BWR_RGD2_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M5WE field. */
#define MPU_RD_RGD2_WORD2_M5WE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M5WE_MASK) >> MPU_RGD2_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD2_WORD2_M5WE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M5WE_MASK, MPU_RGD2_WORD2_M5WE(value)))
#define MPU_BWR_RGD2_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M5RE field. */
#define MPU_RD_RGD2_WORD2_M5RE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M5RE_MASK) >> MPU_RGD2_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD2_WORD2_M5RE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M5RE_MASK, MPU_RGD2_WORD2_M5RE(value)))
#define MPU_BWR_RGD2_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M6WE field. */
#define MPU_RD_RGD2_WORD2_M6WE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M6WE_MASK) >> MPU_RGD2_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD2_WORD2_M6WE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M6WE_MASK, MPU_RGD2_WORD2_M6WE(value)))
#define MPU_BWR_RGD2_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M6RE field. */
#define MPU_RD_RGD2_WORD2_M6RE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M6RE_MASK) >> MPU_RGD2_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD2_WORD2_M6RE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M6RE_MASK, MPU_RGD2_WORD2_M6RE(value)))
#define MPU_BWR_RGD2_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M7WE field. */
#define MPU_RD_RGD2_WORD2_M7WE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M7WE_MASK) >> MPU_RGD2_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD2_WORD2_M7WE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M7WE_MASK, MPU_RGD2_WORD2_M7WE(value)))
#define MPU_BWR_RGD2_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD2_M7RE field. */
#define MPU_RD_RGD2_WORD2_M7RE(base) ((MPU_RGD2_WORD2_REG(base) & MPU_RGD2_WORD2_M7RE_MASK) >> MPU_RGD2_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD2_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD2_WORD2_M7RE(base, value) (MPU_RMW_RGD2_WORD2(base, MPU_RGD2_WORD2_M7RE_MASK, MPU_RGD2_WORD2_M7RE(value)))
#define MPU_BWR_RGD2_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD2_REG(base), MPU_RGD2_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD2_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD2_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD2_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD2_WORD3(base)  (MPU_RGD2_WORD3_REG(base))
#define MPU_WR_RGD2_WORD3(base, value) (MPU_RGD2_WORD3_REG(base) = (value))
#define MPU_RMW_RGD2_WORD3(base, mask, value) (MPU_WR_RGD2_WORD3(base, (MPU_RD_RGD2_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD2_WORD3(base, value) (MPU_WR_RGD2_WORD3(base, MPU_RD_RGD2_WORD3(base) |  (value)))
#define MPU_CLR_RGD2_WORD3(base, value) (MPU_WR_RGD2_WORD3(base, MPU_RD_RGD2_WORD3(base) & ~(value)))
#define MPU_TOG_RGD2_WORD3(base, value) (MPU_WR_RGD2_WORD3(base, MPU_RD_RGD2_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD2_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD2_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD3_VLD field. */
#define MPU_RD_RGD2_WORD3_VLD(base) ((MPU_RGD2_WORD3_REG(base) & MPU_RGD2_WORD3_VLD_MASK) >> MPU_RGD2_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD2_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD2_WORD3_REG(base), MPU_RGD2_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD2_WORD3_VLD(base, value) (MPU_RMW_RGD2_WORD3(base, MPU_RGD2_WORD3_VLD_MASK, MPU_RGD2_WORD3_VLD(value)))
#define MPU_BWR_RGD2_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD2_WORD3_REG(base), MPU_RGD2_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD3_PIDMASK field. */
#define MPU_RD_RGD2_WORD3_PIDMASK(base) ((MPU_RGD2_WORD3_REG(base) & MPU_RGD2_WORD3_PIDMASK_MASK) >> MPU_RGD2_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD2_WORD3_PIDMASK(base) (MPU_RD_RGD2_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD2_WORD3_PIDMASK(base, value) (MPU_RMW_RGD2_WORD3(base, MPU_RGD2_WORD3_PIDMASK_MASK, MPU_RGD2_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD2_WORD3_PIDMASK(base, value) (MPU_WR_RGD2_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD2_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD2_WORD3_PID field. */
#define MPU_RD_RGD2_WORD3_PID(base) ((MPU_RGD2_WORD3_REG(base) & MPU_RGD2_WORD3_PID_MASK) >> MPU_RGD2_WORD3_PID_SHIFT)
#define MPU_BRD_RGD2_WORD3_PID(base) (MPU_RD_RGD2_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD2_WORD3_PID(base, value) (MPU_RMW_RGD2_WORD3(base, MPU_RGD2_WORD3_PID_MASK, MPU_RGD2_WORD3_PID(value)))
#define MPU_BWR_RGD2_WORD3_PID(base, value) (MPU_WR_RGD2_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD3_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD3_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD3_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD3_WORD0(base)  (MPU_RGD3_WORD0_REG(base))
#define MPU_WR_RGD3_WORD0(base, value) (MPU_RGD3_WORD0_REG(base) = (value))
#define MPU_RMW_RGD3_WORD0(base, mask, value) (MPU_WR_RGD3_WORD0(base, (MPU_RD_RGD3_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD3_WORD0(base, value) (MPU_WR_RGD3_WORD0(base, MPU_RD_RGD3_WORD0(base) |  (value)))
#define MPU_CLR_RGD3_WORD0(base, value) (MPU_WR_RGD3_WORD0(base, MPU_RD_RGD3_WORD0(base) & ~(value)))
#define MPU_TOG_RGD3_WORD0(base, value) (MPU_WR_RGD3_WORD0(base, MPU_RD_RGD3_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD3_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD3_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD0_SRTADDR field. */
#define MPU_RD_RGD3_WORD0_SRTADDR(base) ((MPU_RGD3_WORD0_REG(base) & MPU_RGD3_WORD0_SRTADDR_MASK) >> MPU_RGD3_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD3_WORD0_SRTADDR(base) (MPU_RD_RGD3_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD3_WORD0_SRTADDR(base, value) (MPU_RMW_RGD3_WORD0(base, MPU_RGD3_WORD0_SRTADDR_MASK, MPU_RGD3_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD3_WORD0_SRTADDR(base, value) (MPU_WR_RGD3_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD3_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD3_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD3_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD3_WORD1(base)  (MPU_RGD3_WORD1_REG(base))
#define MPU_WR_RGD3_WORD1(base, value) (MPU_RGD3_WORD1_REG(base) = (value))
#define MPU_RMW_RGD3_WORD1(base, mask, value) (MPU_WR_RGD3_WORD1(base, (MPU_RD_RGD3_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD3_WORD1(base, value) (MPU_WR_RGD3_WORD1(base, MPU_RD_RGD3_WORD1(base) |  (value)))
#define MPU_CLR_RGD3_WORD1(base, value) (MPU_WR_RGD3_WORD1(base, MPU_RD_RGD3_WORD1(base) & ~(value)))
#define MPU_TOG_RGD3_WORD1(base, value) (MPU_WR_RGD3_WORD1(base, MPU_RD_RGD3_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD3_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD3_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD1_ENDADDR field. */
#define MPU_RD_RGD3_WORD1_ENDADDR(base) ((MPU_RGD3_WORD1_REG(base) & MPU_RGD3_WORD1_ENDADDR_MASK) >> MPU_RGD3_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD3_WORD1_ENDADDR(base) (MPU_RD_RGD3_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD3_WORD1_ENDADDR(base, value) (MPU_RMW_RGD3_WORD1(base, MPU_RGD3_WORD1_ENDADDR_MASK, MPU_RGD3_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD3_WORD1_ENDADDR(base, value) (MPU_WR_RGD3_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD3_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD3_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD3_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD3_WORD2(base)  (MPU_RGD3_WORD2_REG(base))
#define MPU_WR_RGD3_WORD2(base, value) (MPU_RGD3_WORD2_REG(base) = (value))
#define MPU_RMW_RGD3_WORD2(base, mask, value) (MPU_WR_RGD3_WORD2(base, (MPU_RD_RGD3_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD3_WORD2(base, value) (MPU_WR_RGD3_WORD2(base, MPU_RD_RGD3_WORD2(base) |  (value)))
#define MPU_CLR_RGD3_WORD2(base, value) (MPU_WR_RGD3_WORD2(base, MPU_RD_RGD3_WORD2(base) & ~(value)))
#define MPU_TOG_RGD3_WORD2(base, value) (MPU_WR_RGD3_WORD2(base, MPU_RD_RGD3_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD3_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD3_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M0UM field. */
#define MPU_RD_RGD3_WORD2_M0UM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M0UM_MASK) >> MPU_RGD3_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M0UM(base) (MPU_RD_RGD3_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD3_WORD2_M0UM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M0UM_MASK, MPU_RGD3_WORD2_M0UM(value)))
#define MPU_BWR_RGD3_WORD2_M0UM(base, value) (MPU_WR_RGD3_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M0SM field. */
#define MPU_RD_RGD3_WORD2_M0SM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M0SM_MASK) >> MPU_RGD3_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M0SM(base) (MPU_RD_RGD3_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD3_WORD2_M0SM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M0SM_MASK, MPU_RGD3_WORD2_M0SM(value)))
#define MPU_BWR_RGD3_WORD2_M0SM(base, value) (MPU_WR_RGD3_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M0PE field. */
#define MPU_RD_RGD3_WORD2_M0PE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M0PE_MASK) >> MPU_RGD3_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD3_WORD2_M0PE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M0PE_MASK, MPU_RGD3_WORD2_M0PE(value)))
#define MPU_BWR_RGD3_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M1UM field. */
#define MPU_RD_RGD3_WORD2_M1UM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M1UM_MASK) >> MPU_RGD3_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M1UM(base) (MPU_RD_RGD3_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD3_WORD2_M1UM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M1UM_MASK, MPU_RGD3_WORD2_M1UM(value)))
#define MPU_BWR_RGD3_WORD2_M1UM(base, value) (MPU_WR_RGD3_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M1SM field. */
#define MPU_RD_RGD3_WORD2_M1SM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M1SM_MASK) >> MPU_RGD3_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M1SM(base) (MPU_RD_RGD3_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD3_WORD2_M1SM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M1SM_MASK, MPU_RGD3_WORD2_M1SM(value)))
#define MPU_BWR_RGD3_WORD2_M1SM(base, value) (MPU_WR_RGD3_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M1PE field. */
#define MPU_RD_RGD3_WORD2_M1PE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M1PE_MASK) >> MPU_RGD3_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD3_WORD2_M1PE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M1PE_MASK, MPU_RGD3_WORD2_M1PE(value)))
#define MPU_BWR_RGD3_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M2UM field. */
#define MPU_RD_RGD3_WORD2_M2UM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M2UM_MASK) >> MPU_RGD3_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M2UM(base) (MPU_RD_RGD3_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD3_WORD2_M2UM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M2UM_MASK, MPU_RGD3_WORD2_M2UM(value)))
#define MPU_BWR_RGD3_WORD2_M2UM(base, value) (MPU_WR_RGD3_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M2SM field. */
#define MPU_RD_RGD3_WORD2_M2SM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M2SM_MASK) >> MPU_RGD3_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M2SM(base) (MPU_RD_RGD3_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD3_WORD2_M2SM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M2SM_MASK, MPU_RGD3_WORD2_M2SM(value)))
#define MPU_BWR_RGD3_WORD2_M2SM(base, value) (MPU_WR_RGD3_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M2PE field. */
#define MPU_RD_RGD3_WORD2_M2PE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M2PE_MASK) >> MPU_RGD3_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD3_WORD2_M2PE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M2PE_MASK, MPU_RGD3_WORD2_M2PE(value)))
#define MPU_BWR_RGD3_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M3UM field. */
#define MPU_RD_RGD3_WORD2_M3UM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M3UM_MASK) >> MPU_RGD3_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M3UM(base) (MPU_RD_RGD3_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD3_WORD2_M3UM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M3UM_MASK, MPU_RGD3_WORD2_M3UM(value)))
#define MPU_BWR_RGD3_WORD2_M3UM(base, value) (MPU_WR_RGD3_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M3SM field. */
#define MPU_RD_RGD3_WORD2_M3SM(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M3SM_MASK) >> MPU_RGD3_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD3_WORD2_M3SM(base) (MPU_RD_RGD3_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD3_WORD2_M3SM(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M3SM_MASK, MPU_RGD3_WORD2_M3SM(value)))
#define MPU_BWR_RGD3_WORD2_M3SM(base, value) (MPU_WR_RGD3_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M3PE field. */
#define MPU_RD_RGD3_WORD2_M3PE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M3PE_MASK) >> MPU_RGD3_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD3_WORD2_M3PE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M3PE_MASK, MPU_RGD3_WORD2_M3PE(value)))
#define MPU_BWR_RGD3_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M4WE field. */
#define MPU_RD_RGD3_WORD2_M4WE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M4WE_MASK) >> MPU_RGD3_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD3_WORD2_M4WE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M4WE_MASK, MPU_RGD3_WORD2_M4WE(value)))
#define MPU_BWR_RGD3_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M4RE field. */
#define MPU_RD_RGD3_WORD2_M4RE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M4RE_MASK) >> MPU_RGD3_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD3_WORD2_M4RE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M4RE_MASK, MPU_RGD3_WORD2_M4RE(value)))
#define MPU_BWR_RGD3_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M5WE field. */
#define MPU_RD_RGD3_WORD2_M5WE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M5WE_MASK) >> MPU_RGD3_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD3_WORD2_M5WE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M5WE_MASK, MPU_RGD3_WORD2_M5WE(value)))
#define MPU_BWR_RGD3_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M5RE field. */
#define MPU_RD_RGD3_WORD2_M5RE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M5RE_MASK) >> MPU_RGD3_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD3_WORD2_M5RE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M5RE_MASK, MPU_RGD3_WORD2_M5RE(value)))
#define MPU_BWR_RGD3_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M6WE field. */
#define MPU_RD_RGD3_WORD2_M6WE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M6WE_MASK) >> MPU_RGD3_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD3_WORD2_M6WE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M6WE_MASK, MPU_RGD3_WORD2_M6WE(value)))
#define MPU_BWR_RGD3_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M6RE field. */
#define MPU_RD_RGD3_WORD2_M6RE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M6RE_MASK) >> MPU_RGD3_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD3_WORD2_M6RE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M6RE_MASK, MPU_RGD3_WORD2_M6RE(value)))
#define MPU_BWR_RGD3_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M7WE field. */
#define MPU_RD_RGD3_WORD2_M7WE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M7WE_MASK) >> MPU_RGD3_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD3_WORD2_M7WE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M7WE_MASK, MPU_RGD3_WORD2_M7WE(value)))
#define MPU_BWR_RGD3_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD2_M7RE field. */
#define MPU_RD_RGD3_WORD2_M7RE(base) ((MPU_RGD3_WORD2_REG(base) & MPU_RGD3_WORD2_M7RE_MASK) >> MPU_RGD3_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD3_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD3_WORD2_M7RE(base, value) (MPU_RMW_RGD3_WORD2(base, MPU_RGD3_WORD2_M7RE_MASK, MPU_RGD3_WORD2_M7RE(value)))
#define MPU_BWR_RGD3_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD2_REG(base), MPU_RGD3_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD3_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD3_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD3_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD3_WORD3(base)  (MPU_RGD3_WORD3_REG(base))
#define MPU_WR_RGD3_WORD3(base, value) (MPU_RGD3_WORD3_REG(base) = (value))
#define MPU_RMW_RGD3_WORD3(base, mask, value) (MPU_WR_RGD3_WORD3(base, (MPU_RD_RGD3_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD3_WORD3(base, value) (MPU_WR_RGD3_WORD3(base, MPU_RD_RGD3_WORD3(base) |  (value)))
#define MPU_CLR_RGD3_WORD3(base, value) (MPU_WR_RGD3_WORD3(base, MPU_RD_RGD3_WORD3(base) & ~(value)))
#define MPU_TOG_RGD3_WORD3(base, value) (MPU_WR_RGD3_WORD3(base, MPU_RD_RGD3_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD3_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD3_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD3_VLD field. */
#define MPU_RD_RGD3_WORD3_VLD(base) ((MPU_RGD3_WORD3_REG(base) & MPU_RGD3_WORD3_VLD_MASK) >> MPU_RGD3_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD3_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD3_WORD3_REG(base), MPU_RGD3_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD3_WORD3_VLD(base, value) (MPU_RMW_RGD3_WORD3(base, MPU_RGD3_WORD3_VLD_MASK, MPU_RGD3_WORD3_VLD(value)))
#define MPU_BWR_RGD3_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD3_WORD3_REG(base), MPU_RGD3_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD3_PIDMASK field. */
#define MPU_RD_RGD3_WORD3_PIDMASK(base) ((MPU_RGD3_WORD3_REG(base) & MPU_RGD3_WORD3_PIDMASK_MASK) >> MPU_RGD3_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD3_WORD3_PIDMASK(base) (MPU_RD_RGD3_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD3_WORD3_PIDMASK(base, value) (MPU_RMW_RGD3_WORD3(base, MPU_RGD3_WORD3_PIDMASK_MASK, MPU_RGD3_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD3_WORD3_PIDMASK(base, value) (MPU_WR_RGD3_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD3_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD3_WORD3_PID field. */
#define MPU_RD_RGD3_WORD3_PID(base) ((MPU_RGD3_WORD3_REG(base) & MPU_RGD3_WORD3_PID_MASK) >> MPU_RGD3_WORD3_PID_SHIFT)
#define MPU_BRD_RGD3_WORD3_PID(base) (MPU_RD_RGD3_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD3_WORD3_PID(base, value) (MPU_RMW_RGD3_WORD3(base, MPU_RGD3_WORD3_PID_MASK, MPU_RGD3_WORD3_PID(value)))
#define MPU_BWR_RGD3_WORD3_PID(base, value) (MPU_WR_RGD3_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD4_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD4_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD4_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD4_WORD0(base)  (MPU_RGD4_WORD0_REG(base))
#define MPU_WR_RGD4_WORD0(base, value) (MPU_RGD4_WORD0_REG(base) = (value))
#define MPU_RMW_RGD4_WORD0(base, mask, value) (MPU_WR_RGD4_WORD0(base, (MPU_RD_RGD4_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD4_WORD0(base, value) (MPU_WR_RGD4_WORD0(base, MPU_RD_RGD4_WORD0(base) |  (value)))
#define MPU_CLR_RGD4_WORD0(base, value) (MPU_WR_RGD4_WORD0(base, MPU_RD_RGD4_WORD0(base) & ~(value)))
#define MPU_TOG_RGD4_WORD0(base, value) (MPU_WR_RGD4_WORD0(base, MPU_RD_RGD4_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD4_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD4_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD0_SRTADDR field. */
#define MPU_RD_RGD4_WORD0_SRTADDR(base) ((MPU_RGD4_WORD0_REG(base) & MPU_RGD4_WORD0_SRTADDR_MASK) >> MPU_RGD4_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD4_WORD0_SRTADDR(base) (MPU_RD_RGD4_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD4_WORD0_SRTADDR(base, value) (MPU_RMW_RGD4_WORD0(base, MPU_RGD4_WORD0_SRTADDR_MASK, MPU_RGD4_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD4_WORD0_SRTADDR(base, value) (MPU_WR_RGD4_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD4_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD4_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD4_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD4_WORD1(base)  (MPU_RGD4_WORD1_REG(base))
#define MPU_WR_RGD4_WORD1(base, value) (MPU_RGD4_WORD1_REG(base) = (value))
#define MPU_RMW_RGD4_WORD1(base, mask, value) (MPU_WR_RGD4_WORD1(base, (MPU_RD_RGD4_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD4_WORD1(base, value) (MPU_WR_RGD4_WORD1(base, MPU_RD_RGD4_WORD1(base) |  (value)))
#define MPU_CLR_RGD4_WORD1(base, value) (MPU_WR_RGD4_WORD1(base, MPU_RD_RGD4_WORD1(base) & ~(value)))
#define MPU_TOG_RGD4_WORD1(base, value) (MPU_WR_RGD4_WORD1(base, MPU_RD_RGD4_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD4_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD4_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD1_ENDADDR field. */
#define MPU_RD_RGD4_WORD1_ENDADDR(base) ((MPU_RGD4_WORD1_REG(base) & MPU_RGD4_WORD1_ENDADDR_MASK) >> MPU_RGD4_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD4_WORD1_ENDADDR(base) (MPU_RD_RGD4_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD4_WORD1_ENDADDR(base, value) (MPU_RMW_RGD4_WORD1(base, MPU_RGD4_WORD1_ENDADDR_MASK, MPU_RGD4_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD4_WORD1_ENDADDR(base, value) (MPU_WR_RGD4_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD4_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD4_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD4_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD4_WORD2(base)  (MPU_RGD4_WORD2_REG(base))
#define MPU_WR_RGD4_WORD2(base, value) (MPU_RGD4_WORD2_REG(base) = (value))
#define MPU_RMW_RGD4_WORD2(base, mask, value) (MPU_WR_RGD4_WORD2(base, (MPU_RD_RGD4_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD4_WORD2(base, value) (MPU_WR_RGD4_WORD2(base, MPU_RD_RGD4_WORD2(base) |  (value)))
#define MPU_CLR_RGD4_WORD2(base, value) (MPU_WR_RGD4_WORD2(base, MPU_RD_RGD4_WORD2(base) & ~(value)))
#define MPU_TOG_RGD4_WORD2(base, value) (MPU_WR_RGD4_WORD2(base, MPU_RD_RGD4_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD4_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD4_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M0UM field. */
#define MPU_RD_RGD4_WORD2_M0UM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M0UM_MASK) >> MPU_RGD4_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M0UM(base) (MPU_RD_RGD4_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD4_WORD2_M0UM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M0UM_MASK, MPU_RGD4_WORD2_M0UM(value)))
#define MPU_BWR_RGD4_WORD2_M0UM(base, value) (MPU_WR_RGD4_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M0SM field. */
#define MPU_RD_RGD4_WORD2_M0SM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M0SM_MASK) >> MPU_RGD4_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M0SM(base) (MPU_RD_RGD4_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD4_WORD2_M0SM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M0SM_MASK, MPU_RGD4_WORD2_M0SM(value)))
#define MPU_BWR_RGD4_WORD2_M0SM(base, value) (MPU_WR_RGD4_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M0PE field. */
#define MPU_RD_RGD4_WORD2_M0PE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M0PE_MASK) >> MPU_RGD4_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD4_WORD2_M0PE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M0PE_MASK, MPU_RGD4_WORD2_M0PE(value)))
#define MPU_BWR_RGD4_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M1UM field. */
#define MPU_RD_RGD4_WORD2_M1UM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M1UM_MASK) >> MPU_RGD4_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M1UM(base) (MPU_RD_RGD4_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD4_WORD2_M1UM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M1UM_MASK, MPU_RGD4_WORD2_M1UM(value)))
#define MPU_BWR_RGD4_WORD2_M1UM(base, value) (MPU_WR_RGD4_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M1SM field. */
#define MPU_RD_RGD4_WORD2_M1SM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M1SM_MASK) >> MPU_RGD4_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M1SM(base) (MPU_RD_RGD4_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD4_WORD2_M1SM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M1SM_MASK, MPU_RGD4_WORD2_M1SM(value)))
#define MPU_BWR_RGD4_WORD2_M1SM(base, value) (MPU_WR_RGD4_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M1PE field. */
#define MPU_RD_RGD4_WORD2_M1PE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M1PE_MASK) >> MPU_RGD4_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD4_WORD2_M1PE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M1PE_MASK, MPU_RGD4_WORD2_M1PE(value)))
#define MPU_BWR_RGD4_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M2UM field. */
#define MPU_RD_RGD4_WORD2_M2UM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M2UM_MASK) >> MPU_RGD4_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M2UM(base) (MPU_RD_RGD4_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD4_WORD2_M2UM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M2UM_MASK, MPU_RGD4_WORD2_M2UM(value)))
#define MPU_BWR_RGD4_WORD2_M2UM(base, value) (MPU_WR_RGD4_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M2SM field. */
#define MPU_RD_RGD4_WORD2_M2SM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M2SM_MASK) >> MPU_RGD4_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M2SM(base) (MPU_RD_RGD4_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD4_WORD2_M2SM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M2SM_MASK, MPU_RGD4_WORD2_M2SM(value)))
#define MPU_BWR_RGD4_WORD2_M2SM(base, value) (MPU_WR_RGD4_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M2PE field. */
#define MPU_RD_RGD4_WORD2_M2PE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M2PE_MASK) >> MPU_RGD4_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD4_WORD2_M2PE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M2PE_MASK, MPU_RGD4_WORD2_M2PE(value)))
#define MPU_BWR_RGD4_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M3UM field. */
#define MPU_RD_RGD4_WORD2_M3UM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M3UM_MASK) >> MPU_RGD4_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M3UM(base) (MPU_RD_RGD4_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD4_WORD2_M3UM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M3UM_MASK, MPU_RGD4_WORD2_M3UM(value)))
#define MPU_BWR_RGD4_WORD2_M3UM(base, value) (MPU_WR_RGD4_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M3SM field. */
#define MPU_RD_RGD4_WORD2_M3SM(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M3SM_MASK) >> MPU_RGD4_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD4_WORD2_M3SM(base) (MPU_RD_RGD4_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD4_WORD2_M3SM(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M3SM_MASK, MPU_RGD4_WORD2_M3SM(value)))
#define MPU_BWR_RGD4_WORD2_M3SM(base, value) (MPU_WR_RGD4_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M3PE field. */
#define MPU_RD_RGD4_WORD2_M3PE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M3PE_MASK) >> MPU_RGD4_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD4_WORD2_M3PE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M3PE_MASK, MPU_RGD4_WORD2_M3PE(value)))
#define MPU_BWR_RGD4_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M4WE field. */
#define MPU_RD_RGD4_WORD2_M4WE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M4WE_MASK) >> MPU_RGD4_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD4_WORD2_M4WE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M4WE_MASK, MPU_RGD4_WORD2_M4WE(value)))
#define MPU_BWR_RGD4_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M4RE field. */
#define MPU_RD_RGD4_WORD2_M4RE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M4RE_MASK) >> MPU_RGD4_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD4_WORD2_M4RE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M4RE_MASK, MPU_RGD4_WORD2_M4RE(value)))
#define MPU_BWR_RGD4_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M5WE field. */
#define MPU_RD_RGD4_WORD2_M5WE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M5WE_MASK) >> MPU_RGD4_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD4_WORD2_M5WE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M5WE_MASK, MPU_RGD4_WORD2_M5WE(value)))
#define MPU_BWR_RGD4_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M5RE field. */
#define MPU_RD_RGD4_WORD2_M5RE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M5RE_MASK) >> MPU_RGD4_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD4_WORD2_M5RE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M5RE_MASK, MPU_RGD4_WORD2_M5RE(value)))
#define MPU_BWR_RGD4_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M6WE field. */
#define MPU_RD_RGD4_WORD2_M6WE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M6WE_MASK) >> MPU_RGD4_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD4_WORD2_M6WE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M6WE_MASK, MPU_RGD4_WORD2_M6WE(value)))
#define MPU_BWR_RGD4_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M6RE field. */
#define MPU_RD_RGD4_WORD2_M6RE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M6RE_MASK) >> MPU_RGD4_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD4_WORD2_M6RE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M6RE_MASK, MPU_RGD4_WORD2_M6RE(value)))
#define MPU_BWR_RGD4_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M7WE field. */
#define MPU_RD_RGD4_WORD2_M7WE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M7WE_MASK) >> MPU_RGD4_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD4_WORD2_M7WE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M7WE_MASK, MPU_RGD4_WORD2_M7WE(value)))
#define MPU_BWR_RGD4_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD2_M7RE field. */
#define MPU_RD_RGD4_WORD2_M7RE(base) ((MPU_RGD4_WORD2_REG(base) & MPU_RGD4_WORD2_M7RE_MASK) >> MPU_RGD4_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD4_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD4_WORD2_M7RE(base, value) (MPU_RMW_RGD4_WORD2(base, MPU_RGD4_WORD2_M7RE_MASK, MPU_RGD4_WORD2_M7RE(value)))
#define MPU_BWR_RGD4_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD2_REG(base), MPU_RGD4_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD4_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD4_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD4_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD4_WORD3(base)  (MPU_RGD4_WORD3_REG(base))
#define MPU_WR_RGD4_WORD3(base, value) (MPU_RGD4_WORD3_REG(base) = (value))
#define MPU_RMW_RGD4_WORD3(base, mask, value) (MPU_WR_RGD4_WORD3(base, (MPU_RD_RGD4_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD4_WORD3(base, value) (MPU_WR_RGD4_WORD3(base, MPU_RD_RGD4_WORD3(base) |  (value)))
#define MPU_CLR_RGD4_WORD3(base, value) (MPU_WR_RGD4_WORD3(base, MPU_RD_RGD4_WORD3(base) & ~(value)))
#define MPU_TOG_RGD4_WORD3(base, value) (MPU_WR_RGD4_WORD3(base, MPU_RD_RGD4_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD4_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD4_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD3_VLD field. */
#define MPU_RD_RGD4_WORD3_VLD(base) ((MPU_RGD4_WORD3_REG(base) & MPU_RGD4_WORD3_VLD_MASK) >> MPU_RGD4_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD4_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD4_WORD3_REG(base), MPU_RGD4_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD4_WORD3_VLD(base, value) (MPU_RMW_RGD4_WORD3(base, MPU_RGD4_WORD3_VLD_MASK, MPU_RGD4_WORD3_VLD(value)))
#define MPU_BWR_RGD4_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD4_WORD3_REG(base), MPU_RGD4_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD3_PIDMASK field. */
#define MPU_RD_RGD4_WORD3_PIDMASK(base) ((MPU_RGD4_WORD3_REG(base) & MPU_RGD4_WORD3_PIDMASK_MASK) >> MPU_RGD4_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD4_WORD3_PIDMASK(base) (MPU_RD_RGD4_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD4_WORD3_PIDMASK(base, value) (MPU_RMW_RGD4_WORD3(base, MPU_RGD4_WORD3_PIDMASK_MASK, MPU_RGD4_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD4_WORD3_PIDMASK(base, value) (MPU_WR_RGD4_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD4_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD4_WORD3_PID field. */
#define MPU_RD_RGD4_WORD3_PID(base) ((MPU_RGD4_WORD3_REG(base) & MPU_RGD4_WORD3_PID_MASK) >> MPU_RGD4_WORD3_PID_SHIFT)
#define MPU_BRD_RGD4_WORD3_PID(base) (MPU_RD_RGD4_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD4_WORD3_PID(base, value) (MPU_RMW_RGD4_WORD3(base, MPU_RGD4_WORD3_PID_MASK, MPU_RGD4_WORD3_PID(value)))
#define MPU_BWR_RGD4_WORD3_PID(base, value) (MPU_WR_RGD4_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD5_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD5_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD5_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD5_WORD0(base)  (MPU_RGD5_WORD0_REG(base))
#define MPU_WR_RGD5_WORD0(base, value) (MPU_RGD5_WORD0_REG(base) = (value))
#define MPU_RMW_RGD5_WORD0(base, mask, value) (MPU_WR_RGD5_WORD0(base, (MPU_RD_RGD5_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD5_WORD0(base, value) (MPU_WR_RGD5_WORD0(base, MPU_RD_RGD5_WORD0(base) |  (value)))
#define MPU_CLR_RGD5_WORD0(base, value) (MPU_WR_RGD5_WORD0(base, MPU_RD_RGD5_WORD0(base) & ~(value)))
#define MPU_TOG_RGD5_WORD0(base, value) (MPU_WR_RGD5_WORD0(base, MPU_RD_RGD5_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD5_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD5_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD0_SRTADDR field. */
#define MPU_RD_RGD5_WORD0_SRTADDR(base) ((MPU_RGD5_WORD0_REG(base) & MPU_RGD5_WORD0_SRTADDR_MASK) >> MPU_RGD5_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD5_WORD0_SRTADDR(base) (MPU_RD_RGD5_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD5_WORD0_SRTADDR(base, value) (MPU_RMW_RGD5_WORD0(base, MPU_RGD5_WORD0_SRTADDR_MASK, MPU_RGD5_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD5_WORD0_SRTADDR(base, value) (MPU_WR_RGD5_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD5_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD5_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD5_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD5_WORD1(base)  (MPU_RGD5_WORD1_REG(base))
#define MPU_WR_RGD5_WORD1(base, value) (MPU_RGD5_WORD1_REG(base) = (value))
#define MPU_RMW_RGD5_WORD1(base, mask, value) (MPU_WR_RGD5_WORD1(base, (MPU_RD_RGD5_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD5_WORD1(base, value) (MPU_WR_RGD5_WORD1(base, MPU_RD_RGD5_WORD1(base) |  (value)))
#define MPU_CLR_RGD5_WORD1(base, value) (MPU_WR_RGD5_WORD1(base, MPU_RD_RGD5_WORD1(base) & ~(value)))
#define MPU_TOG_RGD5_WORD1(base, value) (MPU_WR_RGD5_WORD1(base, MPU_RD_RGD5_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD5_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD5_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD1_ENDADDR field. */
#define MPU_RD_RGD5_WORD1_ENDADDR(base) ((MPU_RGD5_WORD1_REG(base) & MPU_RGD5_WORD1_ENDADDR_MASK) >> MPU_RGD5_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD5_WORD1_ENDADDR(base) (MPU_RD_RGD5_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD5_WORD1_ENDADDR(base, value) (MPU_RMW_RGD5_WORD1(base, MPU_RGD5_WORD1_ENDADDR_MASK, MPU_RGD5_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD5_WORD1_ENDADDR(base, value) (MPU_WR_RGD5_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD5_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD5_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD5_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD5_WORD2(base)  (MPU_RGD5_WORD2_REG(base))
#define MPU_WR_RGD5_WORD2(base, value) (MPU_RGD5_WORD2_REG(base) = (value))
#define MPU_RMW_RGD5_WORD2(base, mask, value) (MPU_WR_RGD5_WORD2(base, (MPU_RD_RGD5_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD5_WORD2(base, value) (MPU_WR_RGD5_WORD2(base, MPU_RD_RGD5_WORD2(base) |  (value)))
#define MPU_CLR_RGD5_WORD2(base, value) (MPU_WR_RGD5_WORD2(base, MPU_RD_RGD5_WORD2(base) & ~(value)))
#define MPU_TOG_RGD5_WORD2(base, value) (MPU_WR_RGD5_WORD2(base, MPU_RD_RGD5_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD5_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD5_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M0UM field. */
#define MPU_RD_RGD5_WORD2_M0UM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M0UM_MASK) >> MPU_RGD5_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M0UM(base) (MPU_RD_RGD5_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD5_WORD2_M0UM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M0UM_MASK, MPU_RGD5_WORD2_M0UM(value)))
#define MPU_BWR_RGD5_WORD2_M0UM(base, value) (MPU_WR_RGD5_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M0SM field. */
#define MPU_RD_RGD5_WORD2_M0SM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M0SM_MASK) >> MPU_RGD5_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M0SM(base) (MPU_RD_RGD5_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD5_WORD2_M0SM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M0SM_MASK, MPU_RGD5_WORD2_M0SM(value)))
#define MPU_BWR_RGD5_WORD2_M0SM(base, value) (MPU_WR_RGD5_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M0PE field. */
#define MPU_RD_RGD5_WORD2_M0PE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M0PE_MASK) >> MPU_RGD5_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD5_WORD2_M0PE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M0PE_MASK, MPU_RGD5_WORD2_M0PE(value)))
#define MPU_BWR_RGD5_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M1UM field. */
#define MPU_RD_RGD5_WORD2_M1UM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M1UM_MASK) >> MPU_RGD5_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M1UM(base) (MPU_RD_RGD5_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD5_WORD2_M1UM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M1UM_MASK, MPU_RGD5_WORD2_M1UM(value)))
#define MPU_BWR_RGD5_WORD2_M1UM(base, value) (MPU_WR_RGD5_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M1SM field. */
#define MPU_RD_RGD5_WORD2_M1SM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M1SM_MASK) >> MPU_RGD5_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M1SM(base) (MPU_RD_RGD5_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD5_WORD2_M1SM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M1SM_MASK, MPU_RGD5_WORD2_M1SM(value)))
#define MPU_BWR_RGD5_WORD2_M1SM(base, value) (MPU_WR_RGD5_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M1PE field. */
#define MPU_RD_RGD5_WORD2_M1PE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M1PE_MASK) >> MPU_RGD5_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD5_WORD2_M1PE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M1PE_MASK, MPU_RGD5_WORD2_M1PE(value)))
#define MPU_BWR_RGD5_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M2UM field. */
#define MPU_RD_RGD5_WORD2_M2UM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M2UM_MASK) >> MPU_RGD5_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M2UM(base) (MPU_RD_RGD5_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD5_WORD2_M2UM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M2UM_MASK, MPU_RGD5_WORD2_M2UM(value)))
#define MPU_BWR_RGD5_WORD2_M2UM(base, value) (MPU_WR_RGD5_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M2SM field. */
#define MPU_RD_RGD5_WORD2_M2SM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M2SM_MASK) >> MPU_RGD5_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M2SM(base) (MPU_RD_RGD5_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD5_WORD2_M2SM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M2SM_MASK, MPU_RGD5_WORD2_M2SM(value)))
#define MPU_BWR_RGD5_WORD2_M2SM(base, value) (MPU_WR_RGD5_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M2PE field. */
#define MPU_RD_RGD5_WORD2_M2PE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M2PE_MASK) >> MPU_RGD5_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD5_WORD2_M2PE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M2PE_MASK, MPU_RGD5_WORD2_M2PE(value)))
#define MPU_BWR_RGD5_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M3UM field. */
#define MPU_RD_RGD5_WORD2_M3UM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M3UM_MASK) >> MPU_RGD5_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M3UM(base) (MPU_RD_RGD5_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD5_WORD2_M3UM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M3UM_MASK, MPU_RGD5_WORD2_M3UM(value)))
#define MPU_BWR_RGD5_WORD2_M3UM(base, value) (MPU_WR_RGD5_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M3SM field. */
#define MPU_RD_RGD5_WORD2_M3SM(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M3SM_MASK) >> MPU_RGD5_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD5_WORD2_M3SM(base) (MPU_RD_RGD5_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD5_WORD2_M3SM(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M3SM_MASK, MPU_RGD5_WORD2_M3SM(value)))
#define MPU_BWR_RGD5_WORD2_M3SM(base, value) (MPU_WR_RGD5_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M3PE field. */
#define MPU_RD_RGD5_WORD2_M3PE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M3PE_MASK) >> MPU_RGD5_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD5_WORD2_M3PE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M3PE_MASK, MPU_RGD5_WORD2_M3PE(value)))
#define MPU_BWR_RGD5_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M4WE field. */
#define MPU_RD_RGD5_WORD2_M4WE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M4WE_MASK) >> MPU_RGD5_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD5_WORD2_M4WE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M4WE_MASK, MPU_RGD5_WORD2_M4WE(value)))
#define MPU_BWR_RGD5_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M4RE field. */
#define MPU_RD_RGD5_WORD2_M4RE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M4RE_MASK) >> MPU_RGD5_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD5_WORD2_M4RE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M4RE_MASK, MPU_RGD5_WORD2_M4RE(value)))
#define MPU_BWR_RGD5_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M5WE field. */
#define MPU_RD_RGD5_WORD2_M5WE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M5WE_MASK) >> MPU_RGD5_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD5_WORD2_M5WE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M5WE_MASK, MPU_RGD5_WORD2_M5WE(value)))
#define MPU_BWR_RGD5_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M5RE field. */
#define MPU_RD_RGD5_WORD2_M5RE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M5RE_MASK) >> MPU_RGD5_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD5_WORD2_M5RE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M5RE_MASK, MPU_RGD5_WORD2_M5RE(value)))
#define MPU_BWR_RGD5_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M6WE field. */
#define MPU_RD_RGD5_WORD2_M6WE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M6WE_MASK) >> MPU_RGD5_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD5_WORD2_M6WE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M6WE_MASK, MPU_RGD5_WORD2_M6WE(value)))
#define MPU_BWR_RGD5_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M6RE field. */
#define MPU_RD_RGD5_WORD2_M6RE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M6RE_MASK) >> MPU_RGD5_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD5_WORD2_M6RE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M6RE_MASK, MPU_RGD5_WORD2_M6RE(value)))
#define MPU_BWR_RGD5_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M7WE field. */
#define MPU_RD_RGD5_WORD2_M7WE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M7WE_MASK) >> MPU_RGD5_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD5_WORD2_M7WE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M7WE_MASK, MPU_RGD5_WORD2_M7WE(value)))
#define MPU_BWR_RGD5_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD2_M7RE field. */
#define MPU_RD_RGD5_WORD2_M7RE(base) ((MPU_RGD5_WORD2_REG(base) & MPU_RGD5_WORD2_M7RE_MASK) >> MPU_RGD5_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD5_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD5_WORD2_M7RE(base, value) (MPU_RMW_RGD5_WORD2(base, MPU_RGD5_WORD2_M7RE_MASK, MPU_RGD5_WORD2_M7RE(value)))
#define MPU_BWR_RGD5_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD2_REG(base), MPU_RGD5_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD5_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD5_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD5_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD5_WORD3(base)  (MPU_RGD5_WORD3_REG(base))
#define MPU_WR_RGD5_WORD3(base, value) (MPU_RGD5_WORD3_REG(base) = (value))
#define MPU_RMW_RGD5_WORD3(base, mask, value) (MPU_WR_RGD5_WORD3(base, (MPU_RD_RGD5_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD5_WORD3(base, value) (MPU_WR_RGD5_WORD3(base, MPU_RD_RGD5_WORD3(base) |  (value)))
#define MPU_CLR_RGD5_WORD3(base, value) (MPU_WR_RGD5_WORD3(base, MPU_RD_RGD5_WORD3(base) & ~(value)))
#define MPU_TOG_RGD5_WORD3(base, value) (MPU_WR_RGD5_WORD3(base, MPU_RD_RGD5_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD5_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD5_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD3_VLD field. */
#define MPU_RD_RGD5_WORD3_VLD(base) ((MPU_RGD5_WORD3_REG(base) & MPU_RGD5_WORD3_VLD_MASK) >> MPU_RGD5_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD5_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD5_WORD3_REG(base), MPU_RGD5_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD5_WORD3_VLD(base, value) (MPU_RMW_RGD5_WORD3(base, MPU_RGD5_WORD3_VLD_MASK, MPU_RGD5_WORD3_VLD(value)))
#define MPU_BWR_RGD5_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD5_WORD3_REG(base), MPU_RGD5_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD3_PIDMASK field. */
#define MPU_RD_RGD5_WORD3_PIDMASK(base) ((MPU_RGD5_WORD3_REG(base) & MPU_RGD5_WORD3_PIDMASK_MASK) >> MPU_RGD5_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD5_WORD3_PIDMASK(base) (MPU_RD_RGD5_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD5_WORD3_PIDMASK(base, value) (MPU_RMW_RGD5_WORD3(base, MPU_RGD5_WORD3_PIDMASK_MASK, MPU_RGD5_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD5_WORD3_PIDMASK(base, value) (MPU_WR_RGD5_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD5_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD5_WORD3_PID field. */
#define MPU_RD_RGD5_WORD3_PID(base) ((MPU_RGD5_WORD3_REG(base) & MPU_RGD5_WORD3_PID_MASK) >> MPU_RGD5_WORD3_PID_SHIFT)
#define MPU_BRD_RGD5_WORD3_PID(base) (MPU_RD_RGD5_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD5_WORD3_PID(base, value) (MPU_RMW_RGD5_WORD3(base, MPU_RGD5_WORD3_PID_MASK, MPU_RGD5_WORD3_PID(value)))
#define MPU_BWR_RGD5_WORD3_PID(base, value) (MPU_WR_RGD5_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD6_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD6_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD6_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD6_WORD0(base)  (MPU_RGD6_WORD0_REG(base))
#define MPU_WR_RGD6_WORD0(base, value) (MPU_RGD6_WORD0_REG(base) = (value))
#define MPU_RMW_RGD6_WORD0(base, mask, value) (MPU_WR_RGD6_WORD0(base, (MPU_RD_RGD6_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD6_WORD0(base, value) (MPU_WR_RGD6_WORD0(base, MPU_RD_RGD6_WORD0(base) |  (value)))
#define MPU_CLR_RGD6_WORD0(base, value) (MPU_WR_RGD6_WORD0(base, MPU_RD_RGD6_WORD0(base) & ~(value)))
#define MPU_TOG_RGD6_WORD0(base, value) (MPU_WR_RGD6_WORD0(base, MPU_RD_RGD6_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD6_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD6_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD0_SRTADDR field. */
#define MPU_RD_RGD6_WORD0_SRTADDR(base) ((MPU_RGD6_WORD0_REG(base) & MPU_RGD6_WORD0_SRTADDR_MASK) >> MPU_RGD6_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD6_WORD0_SRTADDR(base) (MPU_RD_RGD6_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD6_WORD0_SRTADDR(base, value) (MPU_RMW_RGD6_WORD0(base, MPU_RGD6_WORD0_SRTADDR_MASK, MPU_RGD6_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD6_WORD0_SRTADDR(base, value) (MPU_WR_RGD6_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD6_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD6_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD6_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD6_WORD1(base)  (MPU_RGD6_WORD1_REG(base))
#define MPU_WR_RGD6_WORD1(base, value) (MPU_RGD6_WORD1_REG(base) = (value))
#define MPU_RMW_RGD6_WORD1(base, mask, value) (MPU_WR_RGD6_WORD1(base, (MPU_RD_RGD6_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD6_WORD1(base, value) (MPU_WR_RGD6_WORD1(base, MPU_RD_RGD6_WORD1(base) |  (value)))
#define MPU_CLR_RGD6_WORD1(base, value) (MPU_WR_RGD6_WORD1(base, MPU_RD_RGD6_WORD1(base) & ~(value)))
#define MPU_TOG_RGD6_WORD1(base, value) (MPU_WR_RGD6_WORD1(base, MPU_RD_RGD6_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD6_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD6_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD1_ENDADDR field. */
#define MPU_RD_RGD6_WORD1_ENDADDR(base) ((MPU_RGD6_WORD1_REG(base) & MPU_RGD6_WORD1_ENDADDR_MASK) >> MPU_RGD6_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD6_WORD1_ENDADDR(base) (MPU_RD_RGD6_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD6_WORD1_ENDADDR(base, value) (MPU_RMW_RGD6_WORD1(base, MPU_RGD6_WORD1_ENDADDR_MASK, MPU_RGD6_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD6_WORD1_ENDADDR(base, value) (MPU_WR_RGD6_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD6_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD6_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD6_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD6_WORD2(base)  (MPU_RGD6_WORD2_REG(base))
#define MPU_WR_RGD6_WORD2(base, value) (MPU_RGD6_WORD2_REG(base) = (value))
#define MPU_RMW_RGD6_WORD2(base, mask, value) (MPU_WR_RGD6_WORD2(base, (MPU_RD_RGD6_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD6_WORD2(base, value) (MPU_WR_RGD6_WORD2(base, MPU_RD_RGD6_WORD2(base) |  (value)))
#define MPU_CLR_RGD6_WORD2(base, value) (MPU_WR_RGD6_WORD2(base, MPU_RD_RGD6_WORD2(base) & ~(value)))
#define MPU_TOG_RGD6_WORD2(base, value) (MPU_WR_RGD6_WORD2(base, MPU_RD_RGD6_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD6_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD6_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M0UM field. */
#define MPU_RD_RGD6_WORD2_M0UM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M0UM_MASK) >> MPU_RGD6_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M0UM(base) (MPU_RD_RGD6_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD6_WORD2_M0UM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M0UM_MASK, MPU_RGD6_WORD2_M0UM(value)))
#define MPU_BWR_RGD6_WORD2_M0UM(base, value) (MPU_WR_RGD6_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M0SM field. */
#define MPU_RD_RGD6_WORD2_M0SM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M0SM_MASK) >> MPU_RGD6_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M0SM(base) (MPU_RD_RGD6_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD6_WORD2_M0SM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M0SM_MASK, MPU_RGD6_WORD2_M0SM(value)))
#define MPU_BWR_RGD6_WORD2_M0SM(base, value) (MPU_WR_RGD6_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M0PE field. */
#define MPU_RD_RGD6_WORD2_M0PE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M0PE_MASK) >> MPU_RGD6_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD6_WORD2_M0PE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M0PE_MASK, MPU_RGD6_WORD2_M0PE(value)))
#define MPU_BWR_RGD6_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M1UM field. */
#define MPU_RD_RGD6_WORD2_M1UM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M1UM_MASK) >> MPU_RGD6_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M1UM(base) (MPU_RD_RGD6_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD6_WORD2_M1UM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M1UM_MASK, MPU_RGD6_WORD2_M1UM(value)))
#define MPU_BWR_RGD6_WORD2_M1UM(base, value) (MPU_WR_RGD6_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M1SM field. */
#define MPU_RD_RGD6_WORD2_M1SM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M1SM_MASK) >> MPU_RGD6_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M1SM(base) (MPU_RD_RGD6_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD6_WORD2_M1SM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M1SM_MASK, MPU_RGD6_WORD2_M1SM(value)))
#define MPU_BWR_RGD6_WORD2_M1SM(base, value) (MPU_WR_RGD6_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M1PE field. */
#define MPU_RD_RGD6_WORD2_M1PE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M1PE_MASK) >> MPU_RGD6_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD6_WORD2_M1PE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M1PE_MASK, MPU_RGD6_WORD2_M1PE(value)))
#define MPU_BWR_RGD6_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M2UM field. */
#define MPU_RD_RGD6_WORD2_M2UM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M2UM_MASK) >> MPU_RGD6_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M2UM(base) (MPU_RD_RGD6_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD6_WORD2_M2UM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M2UM_MASK, MPU_RGD6_WORD2_M2UM(value)))
#define MPU_BWR_RGD6_WORD2_M2UM(base, value) (MPU_WR_RGD6_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M2SM field. */
#define MPU_RD_RGD6_WORD2_M2SM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M2SM_MASK) >> MPU_RGD6_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M2SM(base) (MPU_RD_RGD6_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD6_WORD2_M2SM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M2SM_MASK, MPU_RGD6_WORD2_M2SM(value)))
#define MPU_BWR_RGD6_WORD2_M2SM(base, value) (MPU_WR_RGD6_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M2PE field. */
#define MPU_RD_RGD6_WORD2_M2PE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M2PE_MASK) >> MPU_RGD6_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD6_WORD2_M2PE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M2PE_MASK, MPU_RGD6_WORD2_M2PE(value)))
#define MPU_BWR_RGD6_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M3UM field. */
#define MPU_RD_RGD6_WORD2_M3UM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M3UM_MASK) >> MPU_RGD6_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M3UM(base) (MPU_RD_RGD6_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD6_WORD2_M3UM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M3UM_MASK, MPU_RGD6_WORD2_M3UM(value)))
#define MPU_BWR_RGD6_WORD2_M3UM(base, value) (MPU_WR_RGD6_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M3SM field. */
#define MPU_RD_RGD6_WORD2_M3SM(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M3SM_MASK) >> MPU_RGD6_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD6_WORD2_M3SM(base) (MPU_RD_RGD6_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD6_WORD2_M3SM(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M3SM_MASK, MPU_RGD6_WORD2_M3SM(value)))
#define MPU_BWR_RGD6_WORD2_M3SM(base, value) (MPU_WR_RGD6_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M3PE field. */
#define MPU_RD_RGD6_WORD2_M3PE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M3PE_MASK) >> MPU_RGD6_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD6_WORD2_M3PE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M3PE_MASK, MPU_RGD6_WORD2_M3PE(value)))
#define MPU_BWR_RGD6_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M4WE field. */
#define MPU_RD_RGD6_WORD2_M4WE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M4WE_MASK) >> MPU_RGD6_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD6_WORD2_M4WE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M4WE_MASK, MPU_RGD6_WORD2_M4WE(value)))
#define MPU_BWR_RGD6_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M4RE field. */
#define MPU_RD_RGD6_WORD2_M4RE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M4RE_MASK) >> MPU_RGD6_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD6_WORD2_M4RE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M4RE_MASK, MPU_RGD6_WORD2_M4RE(value)))
#define MPU_BWR_RGD6_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M5WE field. */
#define MPU_RD_RGD6_WORD2_M5WE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M5WE_MASK) >> MPU_RGD6_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD6_WORD2_M5WE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M5WE_MASK, MPU_RGD6_WORD2_M5WE(value)))
#define MPU_BWR_RGD6_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M5RE field. */
#define MPU_RD_RGD6_WORD2_M5RE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M5RE_MASK) >> MPU_RGD6_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD6_WORD2_M5RE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M5RE_MASK, MPU_RGD6_WORD2_M5RE(value)))
#define MPU_BWR_RGD6_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M6WE field. */
#define MPU_RD_RGD6_WORD2_M6WE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M6WE_MASK) >> MPU_RGD6_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD6_WORD2_M6WE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M6WE_MASK, MPU_RGD6_WORD2_M6WE(value)))
#define MPU_BWR_RGD6_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M6RE field. */
#define MPU_RD_RGD6_WORD2_M6RE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M6RE_MASK) >> MPU_RGD6_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD6_WORD2_M6RE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M6RE_MASK, MPU_RGD6_WORD2_M6RE(value)))
#define MPU_BWR_RGD6_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M7WE field. */
#define MPU_RD_RGD6_WORD2_M7WE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M7WE_MASK) >> MPU_RGD6_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD6_WORD2_M7WE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M7WE_MASK, MPU_RGD6_WORD2_M7WE(value)))
#define MPU_BWR_RGD6_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD2_M7RE field. */
#define MPU_RD_RGD6_WORD2_M7RE(base) ((MPU_RGD6_WORD2_REG(base) & MPU_RGD6_WORD2_M7RE_MASK) >> MPU_RGD6_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD6_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD6_WORD2_M7RE(base, value) (MPU_RMW_RGD6_WORD2(base, MPU_RGD6_WORD2_M7RE_MASK, MPU_RGD6_WORD2_M7RE(value)))
#define MPU_BWR_RGD6_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD2_REG(base), MPU_RGD6_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD6_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD6_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD6_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD6_WORD3(base)  (MPU_RGD6_WORD3_REG(base))
#define MPU_WR_RGD6_WORD3(base, value) (MPU_RGD6_WORD3_REG(base) = (value))
#define MPU_RMW_RGD6_WORD3(base, mask, value) (MPU_WR_RGD6_WORD3(base, (MPU_RD_RGD6_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD6_WORD3(base, value) (MPU_WR_RGD6_WORD3(base, MPU_RD_RGD6_WORD3(base) |  (value)))
#define MPU_CLR_RGD6_WORD3(base, value) (MPU_WR_RGD6_WORD3(base, MPU_RD_RGD6_WORD3(base) & ~(value)))
#define MPU_TOG_RGD6_WORD3(base, value) (MPU_WR_RGD6_WORD3(base, MPU_RD_RGD6_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD6_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD6_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD3_VLD field. */
#define MPU_RD_RGD6_WORD3_VLD(base) ((MPU_RGD6_WORD3_REG(base) & MPU_RGD6_WORD3_VLD_MASK) >> MPU_RGD6_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD6_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD6_WORD3_REG(base), MPU_RGD6_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD6_WORD3_VLD(base, value) (MPU_RMW_RGD6_WORD3(base, MPU_RGD6_WORD3_VLD_MASK, MPU_RGD6_WORD3_VLD(value)))
#define MPU_BWR_RGD6_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD6_WORD3_REG(base), MPU_RGD6_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD3_PIDMASK field. */
#define MPU_RD_RGD6_WORD3_PIDMASK(base) ((MPU_RGD6_WORD3_REG(base) & MPU_RGD6_WORD3_PIDMASK_MASK) >> MPU_RGD6_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD6_WORD3_PIDMASK(base) (MPU_RD_RGD6_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD6_WORD3_PIDMASK(base, value) (MPU_RMW_RGD6_WORD3(base, MPU_RGD6_WORD3_PIDMASK_MASK, MPU_RGD6_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD6_WORD3_PIDMASK(base, value) (MPU_WR_RGD6_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD6_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD6_WORD3_PID field. */
#define MPU_RD_RGD6_WORD3_PID(base) ((MPU_RGD6_WORD3_REG(base) & MPU_RGD6_WORD3_PID_MASK) >> MPU_RGD6_WORD3_PID_SHIFT)
#define MPU_BRD_RGD6_WORD3_PID(base) (MPU_RD_RGD6_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD6_WORD3_PID(base, value) (MPU_RMW_RGD6_WORD3(base, MPU_RGD6_WORD3_PID_MASK, MPU_RGD6_WORD3_PID(value)))
#define MPU_BWR_RGD6_WORD3_PID(base, value) (MPU_WR_RGD6_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD7_WORD0 - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_RGD7_WORD0 - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD7_WORD0 register
 */
/*@{*/
#define MPU_RD_RGD7_WORD0(base)  (MPU_RGD7_WORD0_REG(base))
#define MPU_WR_RGD7_WORD0(base, value) (MPU_RGD7_WORD0_REG(base) = (value))
#define MPU_RMW_RGD7_WORD0(base, mask, value) (MPU_WR_RGD7_WORD0(base, (MPU_RD_RGD7_WORD0(base) & ~(mask)) | (value)))
#define MPU_SET_RGD7_WORD0(base, value) (MPU_WR_RGD7_WORD0(base, MPU_RD_RGD7_WORD0(base) |  (value)))
#define MPU_CLR_RGD7_WORD0(base, value) (MPU_WR_RGD7_WORD0(base, MPU_RD_RGD7_WORD0(base) & ~(value)))
#define MPU_TOG_RGD7_WORD0(base, value) (MPU_WR_RGD7_WORD0(base, MPU_RD_RGD7_WORD0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD7_WORD0 bitfields
 */

/*!
 * @name Register MPU_RGD7_WORD0, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD0_SRTADDR field. */
#define MPU_RD_RGD7_WORD0_SRTADDR(base) ((MPU_RGD7_WORD0_REG(base) & MPU_RGD7_WORD0_SRTADDR_MASK) >> MPU_RGD7_WORD0_SRTADDR_SHIFT)
#define MPU_BRD_RGD7_WORD0_SRTADDR(base) (MPU_RD_RGD7_WORD0_SRTADDR(base))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_RGD7_WORD0_SRTADDR(base, value) (MPU_RMW_RGD7_WORD0(base, MPU_RGD7_WORD0_SRTADDR_MASK, MPU_RGD7_WORD0_SRTADDR(value)))
#define MPU_BWR_RGD7_WORD0_SRTADDR(base, value) (MPU_WR_RGD7_WORD0_SRTADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD7_WORD1 - Region Descriptor n, Word 1
 ******************************************************************************/

/*!
 * @brief MPU_RGD7_WORD1 - Region Descriptor n, Word 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * The second word of the region descriptor defines the 31-modulo-32 byte end
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_RGD7_WORD1 register
 */
/*@{*/
#define MPU_RD_RGD7_WORD1(base)  (MPU_RGD7_WORD1_REG(base))
#define MPU_WR_RGD7_WORD1(base, value) (MPU_RGD7_WORD1_REG(base) = (value))
#define MPU_RMW_RGD7_WORD1(base, mask, value) (MPU_WR_RGD7_WORD1(base, (MPU_RD_RGD7_WORD1(base) & ~(mask)) | (value)))
#define MPU_SET_RGD7_WORD1(base, value) (MPU_WR_RGD7_WORD1(base, MPU_RD_RGD7_WORD1(base) |  (value)))
#define MPU_CLR_RGD7_WORD1(base, value) (MPU_WR_RGD7_WORD1(base, MPU_RD_RGD7_WORD1(base) & ~(value)))
#define MPU_TOG_RGD7_WORD1(base, value) (MPU_WR_RGD7_WORD1(base, MPU_RD_RGD7_WORD1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD7_WORD1 bitfields
 */

/*!
 * @name Register MPU_RGD7_WORD1, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD1_ENDADDR field. */
#define MPU_RD_RGD7_WORD1_ENDADDR(base) ((MPU_RGD7_WORD1_REG(base) & MPU_RGD7_WORD1_ENDADDR_MASK) >> MPU_RGD7_WORD1_ENDADDR_SHIFT)
#define MPU_BRD_RGD7_WORD1_ENDADDR(base) (MPU_RD_RGD7_WORD1_ENDADDR(base))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_RGD7_WORD1_ENDADDR(base, value) (MPU_RMW_RGD7_WORD1(base, MPU_RGD7_WORD1_ENDADDR_MASK, MPU_RGD7_WORD1_ENDADDR(value)))
#define MPU_BWR_RGD7_WORD1_ENDADDR(base, value) (MPU_WR_RGD7_WORD1_ENDADDR(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGD7_WORD2 - Region Descriptor n, Word 2
 ******************************************************************************/

/*!
 * @brief MPU_RGD7_WORD2 - Region Descriptor n, Word 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The third word of the region descriptor defines the access control rights of
 * the memory region. The access control privileges depend on two broad
 * classifications of bus masters: Bus masters 0-3 have a 5-bit field defining separate
 * privilege rights for user and supervisor mode accesses, as well as the optional
 * inclusion of a process identification field within the definition. Bus masters
 * 4-7 are limited to separate read and write permissions. For the privilege
 * rights of bus masters 0-3, there are three flags associated with this function:
 * Read (r) refers to accessing the referenced memory address using an operand
 * (data) fetch Write (w) refers to updating the referenced memory address using a
 * store (data) instruction Execute (x) refers to reading the referenced memory
 * address using an instruction fetch Writes to RGDn_WORD2 clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]). If only updating the access controls, write
 * to RGDAACn instead because stores to these locations do not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD7_WORD2 register
 */
/*@{*/
#define MPU_RD_RGD7_WORD2(base)  (MPU_RGD7_WORD2_REG(base))
#define MPU_WR_RGD7_WORD2(base, value) (MPU_RGD7_WORD2_REG(base) = (value))
#define MPU_RMW_RGD7_WORD2(base, mask, value) (MPU_WR_RGD7_WORD2(base, (MPU_RD_RGD7_WORD2(base) & ~(mask)) | (value)))
#define MPU_SET_RGD7_WORD2(base, value) (MPU_WR_RGD7_WORD2(base, MPU_RD_RGD7_WORD2(base) |  (value)))
#define MPU_CLR_RGD7_WORD2(base, value) (MPU_WR_RGD7_WORD2(base, MPU_RD_RGD7_WORD2(base) & ~(value)))
#define MPU_TOG_RGD7_WORD2(base, value) (MPU_WR_RGD7_WORD2(base, MPU_RD_RGD7_WORD2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD7_WORD2 bitfields
 */

/*!
 * @name Register MPU_RGD7_WORD2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M0UM field. */
#define MPU_RD_RGD7_WORD2_M0UM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M0UM_MASK) >> MPU_RGD7_WORD2_M0UM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M0UM(base) (MPU_RD_RGD7_WORD2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGD7_WORD2_M0UM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M0UM_MASK, MPU_RGD7_WORD2_M0UM(value)))
#define MPU_BWR_RGD7_WORD2_M0UM(base, value) (MPU_WR_RGD7_WORD2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M0SM field. */
#define MPU_RD_RGD7_WORD2_M0SM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M0SM_MASK) >> MPU_RGD7_WORD2_M0SM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M0SM(base) (MPU_RD_RGD7_WORD2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGD7_WORD2_M0SM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M0SM_MASK, MPU_RGD7_WORD2_M0SM(value)))
#define MPU_BWR_RGD7_WORD2_M0SM(base, value) (MPU_WR_RGD7_WORD2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M0PE field. */
#define MPU_RD_RGD7_WORD2_M0PE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M0PE_MASK) >> MPU_RGD7_WORD2_M0PE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGD7_WORD2_M0PE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M0PE_MASK, MPU_RGD7_WORD2_M0PE(value)))
#define MPU_BWR_RGD7_WORD2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M1UM field. */
#define MPU_RD_RGD7_WORD2_M1UM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M1UM_MASK) >> MPU_RGD7_WORD2_M1UM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M1UM(base) (MPU_RD_RGD7_WORD2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGD7_WORD2_M1UM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M1UM_MASK, MPU_RGD7_WORD2_M1UM(value)))
#define MPU_BWR_RGD7_WORD2_M1UM(base, value) (MPU_WR_RGD7_WORD2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M1SM field. */
#define MPU_RD_RGD7_WORD2_M1SM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M1SM_MASK) >> MPU_RGD7_WORD2_M1SM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M1SM(base) (MPU_RD_RGD7_WORD2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGD7_WORD2_M1SM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M1SM_MASK, MPU_RGD7_WORD2_M1SM(value)))
#define MPU_BWR_RGD7_WORD2_M1SM(base, value) (MPU_WR_RGD7_WORD2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M1PE field. */
#define MPU_RD_RGD7_WORD2_M1PE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M1PE_MASK) >> MPU_RGD7_WORD2_M1PE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGD7_WORD2_M1PE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M1PE_MASK, MPU_RGD7_WORD2_M1PE(value)))
#define MPU_BWR_RGD7_WORD2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M2UM field. */
#define MPU_RD_RGD7_WORD2_M2UM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M2UM_MASK) >> MPU_RGD7_WORD2_M2UM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M2UM(base) (MPU_RD_RGD7_WORD2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGD7_WORD2_M2UM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M2UM_MASK, MPU_RGD7_WORD2_M2UM(value)))
#define MPU_BWR_RGD7_WORD2_M2UM(base, value) (MPU_WR_RGD7_WORD2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M2SM field. */
#define MPU_RD_RGD7_WORD2_M2SM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M2SM_MASK) >> MPU_RGD7_WORD2_M2SM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M2SM(base) (MPU_RD_RGD7_WORD2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGD7_WORD2_M2SM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M2SM_MASK, MPU_RGD7_WORD2_M2SM(value)))
#define MPU_BWR_RGD7_WORD2_M2SM(base, value) (MPU_WR_RGD7_WORD2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M2PE field. */
#define MPU_RD_RGD7_WORD2_M2PE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M2PE_MASK) >> MPU_RGD7_WORD2_M2PE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGD7_WORD2_M2PE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M2PE_MASK, MPU_RGD7_WORD2_M2PE(value)))
#define MPU_BWR_RGD7_WORD2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M3UM field. */
#define MPU_RD_RGD7_WORD2_M3UM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M3UM_MASK) >> MPU_RGD7_WORD2_M3UM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M3UM(base) (MPU_RD_RGD7_WORD2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGD7_WORD2_M3UM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M3UM_MASK, MPU_RGD7_WORD2_M3UM(value)))
#define MPU_BWR_RGD7_WORD2_M3UM(base, value) (MPU_WR_RGD7_WORD2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M3SM field. */
#define MPU_RD_RGD7_WORD2_M3SM(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M3SM_MASK) >> MPU_RGD7_WORD2_M3SM_SHIFT)
#define MPU_BRD_RGD7_WORD2_M3SM(base) (MPU_RD_RGD7_WORD2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGD7_WORD2_M3SM(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M3SM_MASK, MPU_RGD7_WORD2_M3SM(value)))
#define MPU_BWR_RGD7_WORD2_M3SM(base, value) (MPU_WR_RGD7_WORD2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M3PE field. */
#define MPU_RD_RGD7_WORD2_M3PE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M3PE_MASK) >> MPU_RGD7_WORD2_M3PE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGD7_WORD2_M3PE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M3PE_MASK, MPU_RGD7_WORD2_M3PE(value)))
#define MPU_BWR_RGD7_WORD2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M4WE field. */
#define MPU_RD_RGD7_WORD2_M4WE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M4WE_MASK) >> MPU_RGD7_WORD2_M4WE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGD7_WORD2_M4WE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M4WE_MASK, MPU_RGD7_WORD2_M4WE(value)))
#define MPU_BWR_RGD7_WORD2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M4RE field. */
#define MPU_RD_RGD7_WORD2_M4RE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M4RE_MASK) >> MPU_RGD7_WORD2_M4RE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGD7_WORD2_M4RE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M4RE_MASK, MPU_RGD7_WORD2_M4RE(value)))
#define MPU_BWR_RGD7_WORD2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M5WE field. */
#define MPU_RD_RGD7_WORD2_M5WE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M5WE_MASK) >> MPU_RGD7_WORD2_M5WE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGD7_WORD2_M5WE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M5WE_MASK, MPU_RGD7_WORD2_M5WE(value)))
#define MPU_BWR_RGD7_WORD2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M5RE field. */
#define MPU_RD_RGD7_WORD2_M5RE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M5RE_MASK) >> MPU_RGD7_WORD2_M5RE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGD7_WORD2_M5RE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M5RE_MASK, MPU_RGD7_WORD2_M5RE(value)))
#define MPU_BWR_RGD7_WORD2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M6WE field. */
#define MPU_RD_RGD7_WORD2_M6WE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M6WE_MASK) >> MPU_RGD7_WORD2_M6WE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGD7_WORD2_M6WE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M6WE_MASK, MPU_RGD7_WORD2_M6WE(value)))
#define MPU_BWR_RGD7_WORD2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M6RE field. */
#define MPU_RD_RGD7_WORD2_M6RE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M6RE_MASK) >> MPU_RGD7_WORD2_M6RE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGD7_WORD2_M6RE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M6RE_MASK, MPU_RGD7_WORD2_M6RE(value)))
#define MPU_BWR_RGD7_WORD2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M7WE field. */
#define MPU_RD_RGD7_WORD2_M7WE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M7WE_MASK) >> MPU_RGD7_WORD2_M7WE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGD7_WORD2_M7WE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M7WE_MASK, MPU_RGD7_WORD2_M7WE(value)))
#define MPU_BWR_RGD7_WORD2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD2_M7RE field. */
#define MPU_RD_RGD7_WORD2_M7RE(base) ((MPU_RGD7_WORD2_REG(base) & MPU_RGD7_WORD2_M7RE_MASK) >> MPU_RGD7_WORD2_M7RE_SHIFT)
#define MPU_BRD_RGD7_WORD2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGD7_WORD2_M7RE(base, value) (MPU_RMW_RGD7_WORD2(base, MPU_RGD7_WORD2_M7RE_MASK, MPU_RGD7_WORD2_M7RE(value)))
#define MPU_BWR_RGD7_WORD2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD2_REG(base), MPU_RGD7_WORD2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGD7_WORD3 - Region Descriptor n, Word 3
 ******************************************************************************/

/*!
 * @brief MPU_RGD7_WORD3 - Region Descriptor n, Word 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The fourth word of the region descriptor contains the optional process
 * identifier and mask, plus the region descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGD7_WORD3 register
 */
/*@{*/
#define MPU_RD_RGD7_WORD3(base)  (MPU_RGD7_WORD3_REG(base))
#define MPU_WR_RGD7_WORD3(base, value) (MPU_RGD7_WORD3_REG(base) = (value))
#define MPU_RMW_RGD7_WORD3(base, mask, value) (MPU_WR_RGD7_WORD3(base, (MPU_RD_RGD7_WORD3(base) & ~(mask)) | (value)))
#define MPU_SET_RGD7_WORD3(base, value) (MPU_WR_RGD7_WORD3(base, MPU_RD_RGD7_WORD3(base) |  (value)))
#define MPU_CLR_RGD7_WORD3(base, value) (MPU_WR_RGD7_WORD3(base, MPU_RD_RGD7_WORD3(base) & ~(value)))
#define MPU_TOG_RGD7_WORD3(base, value) (MPU_WR_RGD7_WORD3(base, MPU_RD_RGD7_WORD3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGD7_WORD3 bitfields
 */

/*!
 * @name Register MPU_RGD7_WORD3, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD3_VLD field. */
#define MPU_RD_RGD7_WORD3_VLD(base) ((MPU_RGD7_WORD3_REG(base) & MPU_RGD7_WORD3_VLD_MASK) >> MPU_RGD7_WORD3_VLD_SHIFT)
#define MPU_BRD_RGD7_WORD3_VLD(base) (BITBAND_ACCESS32(&MPU_RGD7_WORD3_REG(base), MPU_RGD7_WORD3_VLD_SHIFT))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_RGD7_WORD3_VLD(base, value) (MPU_RMW_RGD7_WORD3(base, MPU_RGD7_WORD3_VLD_MASK, MPU_RGD7_WORD3_VLD(value)))
#define MPU_BWR_RGD7_WORD3_VLD(base, value) (BITBAND_ACCESS32(&MPU_RGD7_WORD3_REG(base), MPU_RGD7_WORD3_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD3, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD3_PIDMASK field. */
#define MPU_RD_RGD7_WORD3_PIDMASK(base) ((MPU_RGD7_WORD3_REG(base) & MPU_RGD7_WORD3_PIDMASK_MASK) >> MPU_RGD7_WORD3_PIDMASK_SHIFT)
#define MPU_BRD_RGD7_WORD3_PIDMASK(base) (MPU_RD_RGD7_WORD3_PIDMASK(base))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_RGD7_WORD3_PIDMASK(base, value) (MPU_RMW_RGD7_WORD3(base, MPU_RGD7_WORD3_PIDMASK_MASK, MPU_RGD7_WORD3_PIDMASK(value)))
#define MPU_BWR_RGD7_WORD3_PIDMASK(base, value) (MPU_WR_RGD7_WORD3_PIDMASK(base, value))
/*@}*/

/*!
 * @name Register MPU_RGD7_WORD3, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGD7_WORD3_PID field. */
#define MPU_RD_RGD7_WORD3_PID(base) ((MPU_RGD7_WORD3_REG(base) & MPU_RGD7_WORD3_PID_MASK) >> MPU_RGD7_WORD3_PID_SHIFT)
#define MPU_BRD_RGD7_WORD3_PID(base) (MPU_RD_RGD7_WORD3_PID(base))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_RGD7_WORD3_PID(base, value) (MPU_RMW_RGD7_WORD3(base, MPU_RGD7_WORD3_PID_MASK, MPU_RGD7_WORD3_PID(value)))
#define MPU_BWR_RGD7_WORD3_PID(base, value) (MPU_WR_RGD7_WORD3_PID(base, value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC0 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC0 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC0 register
 */
/*@{*/
#define MPU_RD_RGDAAC0(base)     (MPU_RGDAAC0_REG(base))
#define MPU_WR_RGDAAC0(base, value) (MPU_RGDAAC0_REG(base) = (value))
#define MPU_RMW_RGDAAC0(base, mask, value) (MPU_WR_RGDAAC0(base, (MPU_RD_RGDAAC0(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC0(base, value) (MPU_WR_RGDAAC0(base, MPU_RD_RGDAAC0(base) |  (value)))
#define MPU_CLR_RGDAAC0(base, value) (MPU_WR_RGDAAC0(base, MPU_RD_RGDAAC0(base) & ~(value)))
#define MPU_TOG_RGDAAC0(base, value) (MPU_WR_RGDAAC0(base, MPU_RD_RGDAAC0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC0 bitfields
 */

/*!
 * @name Register MPU_RGDAAC0, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M0UM field. */
#define MPU_RD_RGDAAC0_M0UM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M0UM_MASK) >> MPU_RGDAAC0_M0UM_SHIFT)
#define MPU_BRD_RGDAAC0_M0UM(base) (MPU_RD_RGDAAC0_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC0_M0UM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M0UM_MASK, MPU_RGDAAC0_M0UM(value)))
#define MPU_BWR_RGDAAC0_M0UM(base, value) (MPU_WR_RGDAAC0_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M0SM field. */
#define MPU_RD_RGDAAC0_M0SM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M0SM_MASK) >> MPU_RGDAAC0_M0SM_SHIFT)
#define MPU_BRD_RGDAAC0_M0SM(base) (MPU_RD_RGDAAC0_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC0_M0SM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M0SM_MASK, MPU_RGDAAC0_M0SM(value)))
#define MPU_BWR_RGDAAC0_M0SM(base, value) (MPU_WR_RGDAAC0_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M0PE field. */
#define MPU_RD_RGDAAC0_M0PE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M0PE_MASK) >> MPU_RGDAAC0_M0PE_SHIFT)
#define MPU_BRD_RGDAAC0_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC0_M0PE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M0PE_MASK, MPU_RGDAAC0_M0PE(value)))
#define MPU_BWR_RGDAAC0_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M1UM field. */
#define MPU_RD_RGDAAC0_M1UM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M1UM_MASK) >> MPU_RGDAAC0_M1UM_SHIFT)
#define MPU_BRD_RGDAAC0_M1UM(base) (MPU_RD_RGDAAC0_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC0_M1UM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M1UM_MASK, MPU_RGDAAC0_M1UM(value)))
#define MPU_BWR_RGDAAC0_M1UM(base, value) (MPU_WR_RGDAAC0_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M1SM field. */
#define MPU_RD_RGDAAC0_M1SM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M1SM_MASK) >> MPU_RGDAAC0_M1SM_SHIFT)
#define MPU_BRD_RGDAAC0_M1SM(base) (MPU_RD_RGDAAC0_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC0_M1SM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M1SM_MASK, MPU_RGDAAC0_M1SM(value)))
#define MPU_BWR_RGDAAC0_M1SM(base, value) (MPU_WR_RGDAAC0_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M1PE field. */
#define MPU_RD_RGDAAC0_M1PE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M1PE_MASK) >> MPU_RGDAAC0_M1PE_SHIFT)
#define MPU_BRD_RGDAAC0_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC0_M1PE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M1PE_MASK, MPU_RGDAAC0_M1PE(value)))
#define MPU_BWR_RGDAAC0_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M2UM field. */
#define MPU_RD_RGDAAC0_M2UM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M2UM_MASK) >> MPU_RGDAAC0_M2UM_SHIFT)
#define MPU_BRD_RGDAAC0_M2UM(base) (MPU_RD_RGDAAC0_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC0_M2UM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M2UM_MASK, MPU_RGDAAC0_M2UM(value)))
#define MPU_BWR_RGDAAC0_M2UM(base, value) (MPU_WR_RGDAAC0_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M2SM field. */
#define MPU_RD_RGDAAC0_M2SM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M2SM_MASK) >> MPU_RGDAAC0_M2SM_SHIFT)
#define MPU_BRD_RGDAAC0_M2SM(base) (MPU_RD_RGDAAC0_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC0_M2SM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M2SM_MASK, MPU_RGDAAC0_M2SM(value)))
#define MPU_BWR_RGDAAC0_M2SM(base, value) (MPU_WR_RGDAAC0_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M2PE field. */
#define MPU_RD_RGDAAC0_M2PE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M2PE_MASK) >> MPU_RGDAAC0_M2PE_SHIFT)
#define MPU_BRD_RGDAAC0_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC0_M2PE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M2PE_MASK, MPU_RGDAAC0_M2PE(value)))
#define MPU_BWR_RGDAAC0_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M3UM field. */
#define MPU_RD_RGDAAC0_M3UM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M3UM_MASK) >> MPU_RGDAAC0_M3UM_SHIFT)
#define MPU_BRD_RGDAAC0_M3UM(base) (MPU_RD_RGDAAC0_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC0_M3UM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M3UM_MASK, MPU_RGDAAC0_M3UM(value)))
#define MPU_BWR_RGDAAC0_M3UM(base, value) (MPU_WR_RGDAAC0_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M3SM field. */
#define MPU_RD_RGDAAC0_M3SM(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M3SM_MASK) >> MPU_RGDAAC0_M3SM_SHIFT)
#define MPU_BRD_RGDAAC0_M3SM(base) (MPU_RD_RGDAAC0_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC0_M3SM(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M3SM_MASK, MPU_RGDAAC0_M3SM(value)))
#define MPU_BWR_RGDAAC0_M3SM(base, value) (MPU_WR_RGDAAC0_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M3PE field. */
#define MPU_RD_RGDAAC0_M3PE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M3PE_MASK) >> MPU_RGDAAC0_M3PE_SHIFT)
#define MPU_BRD_RGDAAC0_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC0_M3PE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M3PE_MASK, MPU_RGDAAC0_M3PE(value)))
#define MPU_BWR_RGDAAC0_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M4WE field. */
#define MPU_RD_RGDAAC0_M4WE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M4WE_MASK) >> MPU_RGDAAC0_M4WE_SHIFT)
#define MPU_BRD_RGDAAC0_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC0_M4WE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M4WE_MASK, MPU_RGDAAC0_M4WE(value)))
#define MPU_BWR_RGDAAC0_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M4RE field. */
#define MPU_RD_RGDAAC0_M4RE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M4RE_MASK) >> MPU_RGDAAC0_M4RE_SHIFT)
#define MPU_BRD_RGDAAC0_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC0_M4RE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M4RE_MASK, MPU_RGDAAC0_M4RE(value)))
#define MPU_BWR_RGDAAC0_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M5WE field. */
#define MPU_RD_RGDAAC0_M5WE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M5WE_MASK) >> MPU_RGDAAC0_M5WE_SHIFT)
#define MPU_BRD_RGDAAC0_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC0_M5WE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M5WE_MASK, MPU_RGDAAC0_M5WE(value)))
#define MPU_BWR_RGDAAC0_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M5RE field. */
#define MPU_RD_RGDAAC0_M5RE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M5RE_MASK) >> MPU_RGDAAC0_M5RE_SHIFT)
#define MPU_BRD_RGDAAC0_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC0_M5RE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M5RE_MASK, MPU_RGDAAC0_M5RE(value)))
#define MPU_BWR_RGDAAC0_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M6WE field. */
#define MPU_RD_RGDAAC0_M6WE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M6WE_MASK) >> MPU_RGDAAC0_M6WE_SHIFT)
#define MPU_BRD_RGDAAC0_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC0_M6WE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M6WE_MASK, MPU_RGDAAC0_M6WE(value)))
#define MPU_BWR_RGDAAC0_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M6RE field. */
#define MPU_RD_RGDAAC0_M6RE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M6RE_MASK) >> MPU_RGDAAC0_M6RE_SHIFT)
#define MPU_BRD_RGDAAC0_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC0_M6RE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M6RE_MASK, MPU_RGDAAC0_M6RE(value)))
#define MPU_BWR_RGDAAC0_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M7WE field. */
#define MPU_RD_RGDAAC0_M7WE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M7WE_MASK) >> MPU_RGDAAC0_M7WE_SHIFT)
#define MPU_BRD_RGDAAC0_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC0_M7WE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M7WE_MASK, MPU_RGDAAC0_M7WE(value)))
#define MPU_BWR_RGDAAC0_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC0, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC0_M7RE field. */
#define MPU_RD_RGDAAC0_M7RE(base) ((MPU_RGDAAC0_REG(base) & MPU_RGDAAC0_M7RE_MASK) >> MPU_RGDAAC0_M7RE_SHIFT)
#define MPU_BRD_RGDAAC0_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC0_M7RE(base, value) (MPU_RMW_RGDAAC0(base, MPU_RGDAAC0_M7RE_MASK, MPU_RGDAAC0_M7RE(value)))
#define MPU_BWR_RGDAAC0_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC0_REG(base), MPU_RGDAAC0_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC1 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC1 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC1 register
 */
/*@{*/
#define MPU_RD_RGDAAC1(base)     (MPU_RGDAAC1_REG(base))
#define MPU_WR_RGDAAC1(base, value) (MPU_RGDAAC1_REG(base) = (value))
#define MPU_RMW_RGDAAC1(base, mask, value) (MPU_WR_RGDAAC1(base, (MPU_RD_RGDAAC1(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC1(base, value) (MPU_WR_RGDAAC1(base, MPU_RD_RGDAAC1(base) |  (value)))
#define MPU_CLR_RGDAAC1(base, value) (MPU_WR_RGDAAC1(base, MPU_RD_RGDAAC1(base) & ~(value)))
#define MPU_TOG_RGDAAC1(base, value) (MPU_WR_RGDAAC1(base, MPU_RD_RGDAAC1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC1 bitfields
 */

/*!
 * @name Register MPU_RGDAAC1, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M0UM field. */
#define MPU_RD_RGDAAC1_M0UM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M0UM_MASK) >> MPU_RGDAAC1_M0UM_SHIFT)
#define MPU_BRD_RGDAAC1_M0UM(base) (MPU_RD_RGDAAC1_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC1_M0UM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M0UM_MASK, MPU_RGDAAC1_M0UM(value)))
#define MPU_BWR_RGDAAC1_M0UM(base, value) (MPU_WR_RGDAAC1_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M0SM field. */
#define MPU_RD_RGDAAC1_M0SM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M0SM_MASK) >> MPU_RGDAAC1_M0SM_SHIFT)
#define MPU_BRD_RGDAAC1_M0SM(base) (MPU_RD_RGDAAC1_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC1_M0SM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M0SM_MASK, MPU_RGDAAC1_M0SM(value)))
#define MPU_BWR_RGDAAC1_M0SM(base, value) (MPU_WR_RGDAAC1_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M0PE field. */
#define MPU_RD_RGDAAC1_M0PE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M0PE_MASK) >> MPU_RGDAAC1_M0PE_SHIFT)
#define MPU_BRD_RGDAAC1_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC1_M0PE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M0PE_MASK, MPU_RGDAAC1_M0PE(value)))
#define MPU_BWR_RGDAAC1_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M1UM field. */
#define MPU_RD_RGDAAC1_M1UM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M1UM_MASK) >> MPU_RGDAAC1_M1UM_SHIFT)
#define MPU_BRD_RGDAAC1_M1UM(base) (MPU_RD_RGDAAC1_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC1_M1UM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M1UM_MASK, MPU_RGDAAC1_M1UM(value)))
#define MPU_BWR_RGDAAC1_M1UM(base, value) (MPU_WR_RGDAAC1_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M1SM field. */
#define MPU_RD_RGDAAC1_M1SM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M1SM_MASK) >> MPU_RGDAAC1_M1SM_SHIFT)
#define MPU_BRD_RGDAAC1_M1SM(base) (MPU_RD_RGDAAC1_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC1_M1SM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M1SM_MASK, MPU_RGDAAC1_M1SM(value)))
#define MPU_BWR_RGDAAC1_M1SM(base, value) (MPU_WR_RGDAAC1_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M1PE field. */
#define MPU_RD_RGDAAC1_M1PE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M1PE_MASK) >> MPU_RGDAAC1_M1PE_SHIFT)
#define MPU_BRD_RGDAAC1_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC1_M1PE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M1PE_MASK, MPU_RGDAAC1_M1PE(value)))
#define MPU_BWR_RGDAAC1_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M2UM field. */
#define MPU_RD_RGDAAC1_M2UM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M2UM_MASK) >> MPU_RGDAAC1_M2UM_SHIFT)
#define MPU_BRD_RGDAAC1_M2UM(base) (MPU_RD_RGDAAC1_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC1_M2UM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M2UM_MASK, MPU_RGDAAC1_M2UM(value)))
#define MPU_BWR_RGDAAC1_M2UM(base, value) (MPU_WR_RGDAAC1_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M2SM field. */
#define MPU_RD_RGDAAC1_M2SM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M2SM_MASK) >> MPU_RGDAAC1_M2SM_SHIFT)
#define MPU_BRD_RGDAAC1_M2SM(base) (MPU_RD_RGDAAC1_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC1_M2SM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M2SM_MASK, MPU_RGDAAC1_M2SM(value)))
#define MPU_BWR_RGDAAC1_M2SM(base, value) (MPU_WR_RGDAAC1_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M2PE field. */
#define MPU_RD_RGDAAC1_M2PE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M2PE_MASK) >> MPU_RGDAAC1_M2PE_SHIFT)
#define MPU_BRD_RGDAAC1_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC1_M2PE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M2PE_MASK, MPU_RGDAAC1_M2PE(value)))
#define MPU_BWR_RGDAAC1_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M3UM field. */
#define MPU_RD_RGDAAC1_M3UM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M3UM_MASK) >> MPU_RGDAAC1_M3UM_SHIFT)
#define MPU_BRD_RGDAAC1_M3UM(base) (MPU_RD_RGDAAC1_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC1_M3UM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M3UM_MASK, MPU_RGDAAC1_M3UM(value)))
#define MPU_BWR_RGDAAC1_M3UM(base, value) (MPU_WR_RGDAAC1_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M3SM field. */
#define MPU_RD_RGDAAC1_M3SM(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M3SM_MASK) >> MPU_RGDAAC1_M3SM_SHIFT)
#define MPU_BRD_RGDAAC1_M3SM(base) (MPU_RD_RGDAAC1_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC1_M3SM(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M3SM_MASK, MPU_RGDAAC1_M3SM(value)))
#define MPU_BWR_RGDAAC1_M3SM(base, value) (MPU_WR_RGDAAC1_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M3PE field. */
#define MPU_RD_RGDAAC1_M3PE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M3PE_MASK) >> MPU_RGDAAC1_M3PE_SHIFT)
#define MPU_BRD_RGDAAC1_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC1_M3PE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M3PE_MASK, MPU_RGDAAC1_M3PE(value)))
#define MPU_BWR_RGDAAC1_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M4WE field. */
#define MPU_RD_RGDAAC1_M4WE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M4WE_MASK) >> MPU_RGDAAC1_M4WE_SHIFT)
#define MPU_BRD_RGDAAC1_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC1_M4WE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M4WE_MASK, MPU_RGDAAC1_M4WE(value)))
#define MPU_BWR_RGDAAC1_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M4RE field. */
#define MPU_RD_RGDAAC1_M4RE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M4RE_MASK) >> MPU_RGDAAC1_M4RE_SHIFT)
#define MPU_BRD_RGDAAC1_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC1_M4RE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M4RE_MASK, MPU_RGDAAC1_M4RE(value)))
#define MPU_BWR_RGDAAC1_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M5WE field. */
#define MPU_RD_RGDAAC1_M5WE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M5WE_MASK) >> MPU_RGDAAC1_M5WE_SHIFT)
#define MPU_BRD_RGDAAC1_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC1_M5WE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M5WE_MASK, MPU_RGDAAC1_M5WE(value)))
#define MPU_BWR_RGDAAC1_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M5RE field. */
#define MPU_RD_RGDAAC1_M5RE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M5RE_MASK) >> MPU_RGDAAC1_M5RE_SHIFT)
#define MPU_BRD_RGDAAC1_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC1_M5RE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M5RE_MASK, MPU_RGDAAC1_M5RE(value)))
#define MPU_BWR_RGDAAC1_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M6WE field. */
#define MPU_RD_RGDAAC1_M6WE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M6WE_MASK) >> MPU_RGDAAC1_M6WE_SHIFT)
#define MPU_BRD_RGDAAC1_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC1_M6WE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M6WE_MASK, MPU_RGDAAC1_M6WE(value)))
#define MPU_BWR_RGDAAC1_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M6RE field. */
#define MPU_RD_RGDAAC1_M6RE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M6RE_MASK) >> MPU_RGDAAC1_M6RE_SHIFT)
#define MPU_BRD_RGDAAC1_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC1_M6RE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M6RE_MASK, MPU_RGDAAC1_M6RE(value)))
#define MPU_BWR_RGDAAC1_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M7WE field. */
#define MPU_RD_RGDAAC1_M7WE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M7WE_MASK) >> MPU_RGDAAC1_M7WE_SHIFT)
#define MPU_BRD_RGDAAC1_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC1_M7WE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M7WE_MASK, MPU_RGDAAC1_M7WE(value)))
#define MPU_BWR_RGDAAC1_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC1, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC1_M7RE field. */
#define MPU_RD_RGDAAC1_M7RE(base) ((MPU_RGDAAC1_REG(base) & MPU_RGDAAC1_M7RE_MASK) >> MPU_RGDAAC1_M7RE_SHIFT)
#define MPU_BRD_RGDAAC1_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC1_M7RE(base, value) (MPU_RMW_RGDAAC1(base, MPU_RGDAAC1_M7RE_MASK, MPU_RGDAAC1_M7RE(value)))
#define MPU_BWR_RGDAAC1_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC1_REG(base), MPU_RGDAAC1_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC2 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC2 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC2 register
 */
/*@{*/
#define MPU_RD_RGDAAC2(base)     (MPU_RGDAAC2_REG(base))
#define MPU_WR_RGDAAC2(base, value) (MPU_RGDAAC2_REG(base) = (value))
#define MPU_RMW_RGDAAC2(base, mask, value) (MPU_WR_RGDAAC2(base, (MPU_RD_RGDAAC2(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC2(base, value) (MPU_WR_RGDAAC2(base, MPU_RD_RGDAAC2(base) |  (value)))
#define MPU_CLR_RGDAAC2(base, value) (MPU_WR_RGDAAC2(base, MPU_RD_RGDAAC2(base) & ~(value)))
#define MPU_TOG_RGDAAC2(base, value) (MPU_WR_RGDAAC2(base, MPU_RD_RGDAAC2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC2 bitfields
 */

/*!
 * @name Register MPU_RGDAAC2, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M0UM field. */
#define MPU_RD_RGDAAC2_M0UM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M0UM_MASK) >> MPU_RGDAAC2_M0UM_SHIFT)
#define MPU_BRD_RGDAAC2_M0UM(base) (MPU_RD_RGDAAC2_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC2_M0UM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M0UM_MASK, MPU_RGDAAC2_M0UM(value)))
#define MPU_BWR_RGDAAC2_M0UM(base, value) (MPU_WR_RGDAAC2_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M0SM field. */
#define MPU_RD_RGDAAC2_M0SM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M0SM_MASK) >> MPU_RGDAAC2_M0SM_SHIFT)
#define MPU_BRD_RGDAAC2_M0SM(base) (MPU_RD_RGDAAC2_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC2_M0SM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M0SM_MASK, MPU_RGDAAC2_M0SM(value)))
#define MPU_BWR_RGDAAC2_M0SM(base, value) (MPU_WR_RGDAAC2_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M0PE field. */
#define MPU_RD_RGDAAC2_M0PE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M0PE_MASK) >> MPU_RGDAAC2_M0PE_SHIFT)
#define MPU_BRD_RGDAAC2_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC2_M0PE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M0PE_MASK, MPU_RGDAAC2_M0PE(value)))
#define MPU_BWR_RGDAAC2_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M1UM field. */
#define MPU_RD_RGDAAC2_M1UM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M1UM_MASK) >> MPU_RGDAAC2_M1UM_SHIFT)
#define MPU_BRD_RGDAAC2_M1UM(base) (MPU_RD_RGDAAC2_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC2_M1UM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M1UM_MASK, MPU_RGDAAC2_M1UM(value)))
#define MPU_BWR_RGDAAC2_M1UM(base, value) (MPU_WR_RGDAAC2_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M1SM field. */
#define MPU_RD_RGDAAC2_M1SM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M1SM_MASK) >> MPU_RGDAAC2_M1SM_SHIFT)
#define MPU_BRD_RGDAAC2_M1SM(base) (MPU_RD_RGDAAC2_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC2_M1SM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M1SM_MASK, MPU_RGDAAC2_M1SM(value)))
#define MPU_BWR_RGDAAC2_M1SM(base, value) (MPU_WR_RGDAAC2_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M1PE field. */
#define MPU_RD_RGDAAC2_M1PE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M1PE_MASK) >> MPU_RGDAAC2_M1PE_SHIFT)
#define MPU_BRD_RGDAAC2_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC2_M1PE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M1PE_MASK, MPU_RGDAAC2_M1PE(value)))
#define MPU_BWR_RGDAAC2_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M2UM field. */
#define MPU_RD_RGDAAC2_M2UM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M2UM_MASK) >> MPU_RGDAAC2_M2UM_SHIFT)
#define MPU_BRD_RGDAAC2_M2UM(base) (MPU_RD_RGDAAC2_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC2_M2UM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M2UM_MASK, MPU_RGDAAC2_M2UM(value)))
#define MPU_BWR_RGDAAC2_M2UM(base, value) (MPU_WR_RGDAAC2_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M2SM field. */
#define MPU_RD_RGDAAC2_M2SM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M2SM_MASK) >> MPU_RGDAAC2_M2SM_SHIFT)
#define MPU_BRD_RGDAAC2_M2SM(base) (MPU_RD_RGDAAC2_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC2_M2SM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M2SM_MASK, MPU_RGDAAC2_M2SM(value)))
#define MPU_BWR_RGDAAC2_M2SM(base, value) (MPU_WR_RGDAAC2_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M2PE field. */
#define MPU_RD_RGDAAC2_M2PE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M2PE_MASK) >> MPU_RGDAAC2_M2PE_SHIFT)
#define MPU_BRD_RGDAAC2_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC2_M2PE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M2PE_MASK, MPU_RGDAAC2_M2PE(value)))
#define MPU_BWR_RGDAAC2_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M3UM field. */
#define MPU_RD_RGDAAC2_M3UM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M3UM_MASK) >> MPU_RGDAAC2_M3UM_SHIFT)
#define MPU_BRD_RGDAAC2_M3UM(base) (MPU_RD_RGDAAC2_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC2_M3UM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M3UM_MASK, MPU_RGDAAC2_M3UM(value)))
#define MPU_BWR_RGDAAC2_M3UM(base, value) (MPU_WR_RGDAAC2_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M3SM field. */
#define MPU_RD_RGDAAC2_M3SM(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M3SM_MASK) >> MPU_RGDAAC2_M3SM_SHIFT)
#define MPU_BRD_RGDAAC2_M3SM(base) (MPU_RD_RGDAAC2_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC2_M3SM(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M3SM_MASK, MPU_RGDAAC2_M3SM(value)))
#define MPU_BWR_RGDAAC2_M3SM(base, value) (MPU_WR_RGDAAC2_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M3PE field. */
#define MPU_RD_RGDAAC2_M3PE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M3PE_MASK) >> MPU_RGDAAC2_M3PE_SHIFT)
#define MPU_BRD_RGDAAC2_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC2_M3PE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M3PE_MASK, MPU_RGDAAC2_M3PE(value)))
#define MPU_BWR_RGDAAC2_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M4WE field. */
#define MPU_RD_RGDAAC2_M4WE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M4WE_MASK) >> MPU_RGDAAC2_M4WE_SHIFT)
#define MPU_BRD_RGDAAC2_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC2_M4WE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M4WE_MASK, MPU_RGDAAC2_M4WE(value)))
#define MPU_BWR_RGDAAC2_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M4RE field. */
#define MPU_RD_RGDAAC2_M4RE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M4RE_MASK) >> MPU_RGDAAC2_M4RE_SHIFT)
#define MPU_BRD_RGDAAC2_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC2_M4RE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M4RE_MASK, MPU_RGDAAC2_M4RE(value)))
#define MPU_BWR_RGDAAC2_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M5WE field. */
#define MPU_RD_RGDAAC2_M5WE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M5WE_MASK) >> MPU_RGDAAC2_M5WE_SHIFT)
#define MPU_BRD_RGDAAC2_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC2_M5WE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M5WE_MASK, MPU_RGDAAC2_M5WE(value)))
#define MPU_BWR_RGDAAC2_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M5RE field. */
#define MPU_RD_RGDAAC2_M5RE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M5RE_MASK) >> MPU_RGDAAC2_M5RE_SHIFT)
#define MPU_BRD_RGDAAC2_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC2_M5RE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M5RE_MASK, MPU_RGDAAC2_M5RE(value)))
#define MPU_BWR_RGDAAC2_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M6WE field. */
#define MPU_RD_RGDAAC2_M6WE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M6WE_MASK) >> MPU_RGDAAC2_M6WE_SHIFT)
#define MPU_BRD_RGDAAC2_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC2_M6WE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M6WE_MASK, MPU_RGDAAC2_M6WE(value)))
#define MPU_BWR_RGDAAC2_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M6RE field. */
#define MPU_RD_RGDAAC2_M6RE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M6RE_MASK) >> MPU_RGDAAC2_M6RE_SHIFT)
#define MPU_BRD_RGDAAC2_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC2_M6RE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M6RE_MASK, MPU_RGDAAC2_M6RE(value)))
#define MPU_BWR_RGDAAC2_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M7WE field. */
#define MPU_RD_RGDAAC2_M7WE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M7WE_MASK) >> MPU_RGDAAC2_M7WE_SHIFT)
#define MPU_BRD_RGDAAC2_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC2_M7WE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M7WE_MASK, MPU_RGDAAC2_M7WE(value)))
#define MPU_BWR_RGDAAC2_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC2, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC2_M7RE field. */
#define MPU_RD_RGDAAC2_M7RE(base) ((MPU_RGDAAC2_REG(base) & MPU_RGDAAC2_M7RE_MASK) >> MPU_RGDAAC2_M7RE_SHIFT)
#define MPU_BRD_RGDAAC2_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC2_M7RE(base, value) (MPU_RMW_RGDAAC2(base, MPU_RGDAAC2_M7RE_MASK, MPU_RGDAAC2_M7RE(value)))
#define MPU_BWR_RGDAAC2_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC2_REG(base), MPU_RGDAAC2_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC3 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC3 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC3 register
 */
/*@{*/
#define MPU_RD_RGDAAC3(base)     (MPU_RGDAAC3_REG(base))
#define MPU_WR_RGDAAC3(base, value) (MPU_RGDAAC3_REG(base) = (value))
#define MPU_RMW_RGDAAC3(base, mask, value) (MPU_WR_RGDAAC3(base, (MPU_RD_RGDAAC3(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC3(base, value) (MPU_WR_RGDAAC3(base, MPU_RD_RGDAAC3(base) |  (value)))
#define MPU_CLR_RGDAAC3(base, value) (MPU_WR_RGDAAC3(base, MPU_RD_RGDAAC3(base) & ~(value)))
#define MPU_TOG_RGDAAC3(base, value) (MPU_WR_RGDAAC3(base, MPU_RD_RGDAAC3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC3 bitfields
 */

/*!
 * @name Register MPU_RGDAAC3, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M0UM field. */
#define MPU_RD_RGDAAC3_M0UM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M0UM_MASK) >> MPU_RGDAAC3_M0UM_SHIFT)
#define MPU_BRD_RGDAAC3_M0UM(base) (MPU_RD_RGDAAC3_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC3_M0UM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M0UM_MASK, MPU_RGDAAC3_M0UM(value)))
#define MPU_BWR_RGDAAC3_M0UM(base, value) (MPU_WR_RGDAAC3_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M0SM field. */
#define MPU_RD_RGDAAC3_M0SM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M0SM_MASK) >> MPU_RGDAAC3_M0SM_SHIFT)
#define MPU_BRD_RGDAAC3_M0SM(base) (MPU_RD_RGDAAC3_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC3_M0SM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M0SM_MASK, MPU_RGDAAC3_M0SM(value)))
#define MPU_BWR_RGDAAC3_M0SM(base, value) (MPU_WR_RGDAAC3_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M0PE field. */
#define MPU_RD_RGDAAC3_M0PE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M0PE_MASK) >> MPU_RGDAAC3_M0PE_SHIFT)
#define MPU_BRD_RGDAAC3_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC3_M0PE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M0PE_MASK, MPU_RGDAAC3_M0PE(value)))
#define MPU_BWR_RGDAAC3_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M1UM field. */
#define MPU_RD_RGDAAC3_M1UM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M1UM_MASK) >> MPU_RGDAAC3_M1UM_SHIFT)
#define MPU_BRD_RGDAAC3_M1UM(base) (MPU_RD_RGDAAC3_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC3_M1UM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M1UM_MASK, MPU_RGDAAC3_M1UM(value)))
#define MPU_BWR_RGDAAC3_M1UM(base, value) (MPU_WR_RGDAAC3_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M1SM field. */
#define MPU_RD_RGDAAC3_M1SM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M1SM_MASK) >> MPU_RGDAAC3_M1SM_SHIFT)
#define MPU_BRD_RGDAAC3_M1SM(base) (MPU_RD_RGDAAC3_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC3_M1SM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M1SM_MASK, MPU_RGDAAC3_M1SM(value)))
#define MPU_BWR_RGDAAC3_M1SM(base, value) (MPU_WR_RGDAAC3_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M1PE field. */
#define MPU_RD_RGDAAC3_M1PE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M1PE_MASK) >> MPU_RGDAAC3_M1PE_SHIFT)
#define MPU_BRD_RGDAAC3_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC3_M1PE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M1PE_MASK, MPU_RGDAAC3_M1PE(value)))
#define MPU_BWR_RGDAAC3_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M2UM field. */
#define MPU_RD_RGDAAC3_M2UM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M2UM_MASK) >> MPU_RGDAAC3_M2UM_SHIFT)
#define MPU_BRD_RGDAAC3_M2UM(base) (MPU_RD_RGDAAC3_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC3_M2UM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M2UM_MASK, MPU_RGDAAC3_M2UM(value)))
#define MPU_BWR_RGDAAC3_M2UM(base, value) (MPU_WR_RGDAAC3_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M2SM field. */
#define MPU_RD_RGDAAC3_M2SM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M2SM_MASK) >> MPU_RGDAAC3_M2SM_SHIFT)
#define MPU_BRD_RGDAAC3_M2SM(base) (MPU_RD_RGDAAC3_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC3_M2SM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M2SM_MASK, MPU_RGDAAC3_M2SM(value)))
#define MPU_BWR_RGDAAC3_M2SM(base, value) (MPU_WR_RGDAAC3_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M2PE field. */
#define MPU_RD_RGDAAC3_M2PE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M2PE_MASK) >> MPU_RGDAAC3_M2PE_SHIFT)
#define MPU_BRD_RGDAAC3_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC3_M2PE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M2PE_MASK, MPU_RGDAAC3_M2PE(value)))
#define MPU_BWR_RGDAAC3_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M3UM field. */
#define MPU_RD_RGDAAC3_M3UM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M3UM_MASK) >> MPU_RGDAAC3_M3UM_SHIFT)
#define MPU_BRD_RGDAAC3_M3UM(base) (MPU_RD_RGDAAC3_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC3_M3UM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M3UM_MASK, MPU_RGDAAC3_M3UM(value)))
#define MPU_BWR_RGDAAC3_M3UM(base, value) (MPU_WR_RGDAAC3_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M3SM field. */
#define MPU_RD_RGDAAC3_M3SM(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M3SM_MASK) >> MPU_RGDAAC3_M3SM_SHIFT)
#define MPU_BRD_RGDAAC3_M3SM(base) (MPU_RD_RGDAAC3_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC3_M3SM(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M3SM_MASK, MPU_RGDAAC3_M3SM(value)))
#define MPU_BWR_RGDAAC3_M3SM(base, value) (MPU_WR_RGDAAC3_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M3PE field. */
#define MPU_RD_RGDAAC3_M3PE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M3PE_MASK) >> MPU_RGDAAC3_M3PE_SHIFT)
#define MPU_BRD_RGDAAC3_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC3_M3PE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M3PE_MASK, MPU_RGDAAC3_M3PE(value)))
#define MPU_BWR_RGDAAC3_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M4WE field. */
#define MPU_RD_RGDAAC3_M4WE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M4WE_MASK) >> MPU_RGDAAC3_M4WE_SHIFT)
#define MPU_BRD_RGDAAC3_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC3_M4WE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M4WE_MASK, MPU_RGDAAC3_M4WE(value)))
#define MPU_BWR_RGDAAC3_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M4RE field. */
#define MPU_RD_RGDAAC3_M4RE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M4RE_MASK) >> MPU_RGDAAC3_M4RE_SHIFT)
#define MPU_BRD_RGDAAC3_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC3_M4RE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M4RE_MASK, MPU_RGDAAC3_M4RE(value)))
#define MPU_BWR_RGDAAC3_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M5WE field. */
#define MPU_RD_RGDAAC3_M5WE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M5WE_MASK) >> MPU_RGDAAC3_M5WE_SHIFT)
#define MPU_BRD_RGDAAC3_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC3_M5WE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M5WE_MASK, MPU_RGDAAC3_M5WE(value)))
#define MPU_BWR_RGDAAC3_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M5RE field. */
#define MPU_RD_RGDAAC3_M5RE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M5RE_MASK) >> MPU_RGDAAC3_M5RE_SHIFT)
#define MPU_BRD_RGDAAC3_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC3_M5RE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M5RE_MASK, MPU_RGDAAC3_M5RE(value)))
#define MPU_BWR_RGDAAC3_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M6WE field. */
#define MPU_RD_RGDAAC3_M6WE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M6WE_MASK) >> MPU_RGDAAC3_M6WE_SHIFT)
#define MPU_BRD_RGDAAC3_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC3_M6WE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M6WE_MASK, MPU_RGDAAC3_M6WE(value)))
#define MPU_BWR_RGDAAC3_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M6RE field. */
#define MPU_RD_RGDAAC3_M6RE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M6RE_MASK) >> MPU_RGDAAC3_M6RE_SHIFT)
#define MPU_BRD_RGDAAC3_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC3_M6RE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M6RE_MASK, MPU_RGDAAC3_M6RE(value)))
#define MPU_BWR_RGDAAC3_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M7WE field. */
#define MPU_RD_RGDAAC3_M7WE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M7WE_MASK) >> MPU_RGDAAC3_M7WE_SHIFT)
#define MPU_BRD_RGDAAC3_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC3_M7WE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M7WE_MASK, MPU_RGDAAC3_M7WE(value)))
#define MPU_BWR_RGDAAC3_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC3, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC3_M7RE field. */
#define MPU_RD_RGDAAC3_M7RE(base) ((MPU_RGDAAC3_REG(base) & MPU_RGDAAC3_M7RE_MASK) >> MPU_RGDAAC3_M7RE_SHIFT)
#define MPU_BRD_RGDAAC3_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC3_M7RE(base, value) (MPU_RMW_RGDAAC3(base, MPU_RGDAAC3_M7RE_MASK, MPU_RGDAAC3_M7RE(value)))
#define MPU_BWR_RGDAAC3_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC3_REG(base), MPU_RGDAAC3_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC4 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC4 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC4 register
 */
/*@{*/
#define MPU_RD_RGDAAC4(base)     (MPU_RGDAAC4_REG(base))
#define MPU_WR_RGDAAC4(base, value) (MPU_RGDAAC4_REG(base) = (value))
#define MPU_RMW_RGDAAC4(base, mask, value) (MPU_WR_RGDAAC4(base, (MPU_RD_RGDAAC4(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC4(base, value) (MPU_WR_RGDAAC4(base, MPU_RD_RGDAAC4(base) |  (value)))
#define MPU_CLR_RGDAAC4(base, value) (MPU_WR_RGDAAC4(base, MPU_RD_RGDAAC4(base) & ~(value)))
#define MPU_TOG_RGDAAC4(base, value) (MPU_WR_RGDAAC4(base, MPU_RD_RGDAAC4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC4 bitfields
 */

/*!
 * @name Register MPU_RGDAAC4, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M0UM field. */
#define MPU_RD_RGDAAC4_M0UM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M0UM_MASK) >> MPU_RGDAAC4_M0UM_SHIFT)
#define MPU_BRD_RGDAAC4_M0UM(base) (MPU_RD_RGDAAC4_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC4_M0UM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M0UM_MASK, MPU_RGDAAC4_M0UM(value)))
#define MPU_BWR_RGDAAC4_M0UM(base, value) (MPU_WR_RGDAAC4_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M0SM field. */
#define MPU_RD_RGDAAC4_M0SM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M0SM_MASK) >> MPU_RGDAAC4_M0SM_SHIFT)
#define MPU_BRD_RGDAAC4_M0SM(base) (MPU_RD_RGDAAC4_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC4_M0SM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M0SM_MASK, MPU_RGDAAC4_M0SM(value)))
#define MPU_BWR_RGDAAC4_M0SM(base, value) (MPU_WR_RGDAAC4_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M0PE field. */
#define MPU_RD_RGDAAC4_M0PE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M0PE_MASK) >> MPU_RGDAAC4_M0PE_SHIFT)
#define MPU_BRD_RGDAAC4_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC4_M0PE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M0PE_MASK, MPU_RGDAAC4_M0PE(value)))
#define MPU_BWR_RGDAAC4_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M1UM field. */
#define MPU_RD_RGDAAC4_M1UM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M1UM_MASK) >> MPU_RGDAAC4_M1UM_SHIFT)
#define MPU_BRD_RGDAAC4_M1UM(base) (MPU_RD_RGDAAC4_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC4_M1UM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M1UM_MASK, MPU_RGDAAC4_M1UM(value)))
#define MPU_BWR_RGDAAC4_M1UM(base, value) (MPU_WR_RGDAAC4_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M1SM field. */
#define MPU_RD_RGDAAC4_M1SM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M1SM_MASK) >> MPU_RGDAAC4_M1SM_SHIFT)
#define MPU_BRD_RGDAAC4_M1SM(base) (MPU_RD_RGDAAC4_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC4_M1SM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M1SM_MASK, MPU_RGDAAC4_M1SM(value)))
#define MPU_BWR_RGDAAC4_M1SM(base, value) (MPU_WR_RGDAAC4_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M1PE field. */
#define MPU_RD_RGDAAC4_M1PE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M1PE_MASK) >> MPU_RGDAAC4_M1PE_SHIFT)
#define MPU_BRD_RGDAAC4_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC4_M1PE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M1PE_MASK, MPU_RGDAAC4_M1PE(value)))
#define MPU_BWR_RGDAAC4_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M2UM field. */
#define MPU_RD_RGDAAC4_M2UM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M2UM_MASK) >> MPU_RGDAAC4_M2UM_SHIFT)
#define MPU_BRD_RGDAAC4_M2UM(base) (MPU_RD_RGDAAC4_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC4_M2UM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M2UM_MASK, MPU_RGDAAC4_M2UM(value)))
#define MPU_BWR_RGDAAC4_M2UM(base, value) (MPU_WR_RGDAAC4_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M2SM field. */
#define MPU_RD_RGDAAC4_M2SM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M2SM_MASK) >> MPU_RGDAAC4_M2SM_SHIFT)
#define MPU_BRD_RGDAAC4_M2SM(base) (MPU_RD_RGDAAC4_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC4_M2SM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M2SM_MASK, MPU_RGDAAC4_M2SM(value)))
#define MPU_BWR_RGDAAC4_M2SM(base, value) (MPU_WR_RGDAAC4_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M2PE field. */
#define MPU_RD_RGDAAC4_M2PE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M2PE_MASK) >> MPU_RGDAAC4_M2PE_SHIFT)
#define MPU_BRD_RGDAAC4_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC4_M2PE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M2PE_MASK, MPU_RGDAAC4_M2PE(value)))
#define MPU_BWR_RGDAAC4_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M3UM field. */
#define MPU_RD_RGDAAC4_M3UM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M3UM_MASK) >> MPU_RGDAAC4_M3UM_SHIFT)
#define MPU_BRD_RGDAAC4_M3UM(base) (MPU_RD_RGDAAC4_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC4_M3UM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M3UM_MASK, MPU_RGDAAC4_M3UM(value)))
#define MPU_BWR_RGDAAC4_M3UM(base, value) (MPU_WR_RGDAAC4_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M3SM field. */
#define MPU_RD_RGDAAC4_M3SM(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M3SM_MASK) >> MPU_RGDAAC4_M3SM_SHIFT)
#define MPU_BRD_RGDAAC4_M3SM(base) (MPU_RD_RGDAAC4_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC4_M3SM(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M3SM_MASK, MPU_RGDAAC4_M3SM(value)))
#define MPU_BWR_RGDAAC4_M3SM(base, value) (MPU_WR_RGDAAC4_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M3PE field. */
#define MPU_RD_RGDAAC4_M3PE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M3PE_MASK) >> MPU_RGDAAC4_M3PE_SHIFT)
#define MPU_BRD_RGDAAC4_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC4_M3PE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M3PE_MASK, MPU_RGDAAC4_M3PE(value)))
#define MPU_BWR_RGDAAC4_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M4WE field. */
#define MPU_RD_RGDAAC4_M4WE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M4WE_MASK) >> MPU_RGDAAC4_M4WE_SHIFT)
#define MPU_BRD_RGDAAC4_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC4_M4WE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M4WE_MASK, MPU_RGDAAC4_M4WE(value)))
#define MPU_BWR_RGDAAC4_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M4RE field. */
#define MPU_RD_RGDAAC4_M4RE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M4RE_MASK) >> MPU_RGDAAC4_M4RE_SHIFT)
#define MPU_BRD_RGDAAC4_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC4_M4RE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M4RE_MASK, MPU_RGDAAC4_M4RE(value)))
#define MPU_BWR_RGDAAC4_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M5WE field. */
#define MPU_RD_RGDAAC4_M5WE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M5WE_MASK) >> MPU_RGDAAC4_M5WE_SHIFT)
#define MPU_BRD_RGDAAC4_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC4_M5WE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M5WE_MASK, MPU_RGDAAC4_M5WE(value)))
#define MPU_BWR_RGDAAC4_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M5RE field. */
#define MPU_RD_RGDAAC4_M5RE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M5RE_MASK) >> MPU_RGDAAC4_M5RE_SHIFT)
#define MPU_BRD_RGDAAC4_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC4_M5RE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M5RE_MASK, MPU_RGDAAC4_M5RE(value)))
#define MPU_BWR_RGDAAC4_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M6WE field. */
#define MPU_RD_RGDAAC4_M6WE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M6WE_MASK) >> MPU_RGDAAC4_M6WE_SHIFT)
#define MPU_BRD_RGDAAC4_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC4_M6WE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M6WE_MASK, MPU_RGDAAC4_M6WE(value)))
#define MPU_BWR_RGDAAC4_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M6RE field. */
#define MPU_RD_RGDAAC4_M6RE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M6RE_MASK) >> MPU_RGDAAC4_M6RE_SHIFT)
#define MPU_BRD_RGDAAC4_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC4_M6RE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M6RE_MASK, MPU_RGDAAC4_M6RE(value)))
#define MPU_BWR_RGDAAC4_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M7WE field. */
#define MPU_RD_RGDAAC4_M7WE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M7WE_MASK) >> MPU_RGDAAC4_M7WE_SHIFT)
#define MPU_BRD_RGDAAC4_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC4_M7WE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M7WE_MASK, MPU_RGDAAC4_M7WE(value)))
#define MPU_BWR_RGDAAC4_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC4, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC4_M7RE field. */
#define MPU_RD_RGDAAC4_M7RE(base) ((MPU_RGDAAC4_REG(base) & MPU_RGDAAC4_M7RE_MASK) >> MPU_RGDAAC4_M7RE_SHIFT)
#define MPU_BRD_RGDAAC4_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC4_M7RE(base, value) (MPU_RMW_RGDAAC4(base, MPU_RGDAAC4_M7RE_MASK, MPU_RGDAAC4_M7RE(value)))
#define MPU_BWR_RGDAAC4_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC4_REG(base), MPU_RGDAAC4_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC5 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC5 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC5 register
 */
/*@{*/
#define MPU_RD_RGDAAC5(base)     (MPU_RGDAAC5_REG(base))
#define MPU_WR_RGDAAC5(base, value) (MPU_RGDAAC5_REG(base) = (value))
#define MPU_RMW_RGDAAC5(base, mask, value) (MPU_WR_RGDAAC5(base, (MPU_RD_RGDAAC5(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC5(base, value) (MPU_WR_RGDAAC5(base, MPU_RD_RGDAAC5(base) |  (value)))
#define MPU_CLR_RGDAAC5(base, value) (MPU_WR_RGDAAC5(base, MPU_RD_RGDAAC5(base) & ~(value)))
#define MPU_TOG_RGDAAC5(base, value) (MPU_WR_RGDAAC5(base, MPU_RD_RGDAAC5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC5 bitfields
 */

/*!
 * @name Register MPU_RGDAAC5, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M0UM field. */
#define MPU_RD_RGDAAC5_M0UM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M0UM_MASK) >> MPU_RGDAAC5_M0UM_SHIFT)
#define MPU_BRD_RGDAAC5_M0UM(base) (MPU_RD_RGDAAC5_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC5_M0UM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M0UM_MASK, MPU_RGDAAC5_M0UM(value)))
#define MPU_BWR_RGDAAC5_M0UM(base, value) (MPU_WR_RGDAAC5_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M0SM field. */
#define MPU_RD_RGDAAC5_M0SM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M0SM_MASK) >> MPU_RGDAAC5_M0SM_SHIFT)
#define MPU_BRD_RGDAAC5_M0SM(base) (MPU_RD_RGDAAC5_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC5_M0SM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M0SM_MASK, MPU_RGDAAC5_M0SM(value)))
#define MPU_BWR_RGDAAC5_M0SM(base, value) (MPU_WR_RGDAAC5_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M0PE field. */
#define MPU_RD_RGDAAC5_M0PE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M0PE_MASK) >> MPU_RGDAAC5_M0PE_SHIFT)
#define MPU_BRD_RGDAAC5_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC5_M0PE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M0PE_MASK, MPU_RGDAAC5_M0PE(value)))
#define MPU_BWR_RGDAAC5_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M1UM field. */
#define MPU_RD_RGDAAC5_M1UM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M1UM_MASK) >> MPU_RGDAAC5_M1UM_SHIFT)
#define MPU_BRD_RGDAAC5_M1UM(base) (MPU_RD_RGDAAC5_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC5_M1UM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M1UM_MASK, MPU_RGDAAC5_M1UM(value)))
#define MPU_BWR_RGDAAC5_M1UM(base, value) (MPU_WR_RGDAAC5_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M1SM field. */
#define MPU_RD_RGDAAC5_M1SM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M1SM_MASK) >> MPU_RGDAAC5_M1SM_SHIFT)
#define MPU_BRD_RGDAAC5_M1SM(base) (MPU_RD_RGDAAC5_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC5_M1SM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M1SM_MASK, MPU_RGDAAC5_M1SM(value)))
#define MPU_BWR_RGDAAC5_M1SM(base, value) (MPU_WR_RGDAAC5_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M1PE field. */
#define MPU_RD_RGDAAC5_M1PE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M1PE_MASK) >> MPU_RGDAAC5_M1PE_SHIFT)
#define MPU_BRD_RGDAAC5_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC5_M1PE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M1PE_MASK, MPU_RGDAAC5_M1PE(value)))
#define MPU_BWR_RGDAAC5_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M2UM field. */
#define MPU_RD_RGDAAC5_M2UM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M2UM_MASK) >> MPU_RGDAAC5_M2UM_SHIFT)
#define MPU_BRD_RGDAAC5_M2UM(base) (MPU_RD_RGDAAC5_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC5_M2UM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M2UM_MASK, MPU_RGDAAC5_M2UM(value)))
#define MPU_BWR_RGDAAC5_M2UM(base, value) (MPU_WR_RGDAAC5_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M2SM field. */
#define MPU_RD_RGDAAC5_M2SM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M2SM_MASK) >> MPU_RGDAAC5_M2SM_SHIFT)
#define MPU_BRD_RGDAAC5_M2SM(base) (MPU_RD_RGDAAC5_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC5_M2SM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M2SM_MASK, MPU_RGDAAC5_M2SM(value)))
#define MPU_BWR_RGDAAC5_M2SM(base, value) (MPU_WR_RGDAAC5_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M2PE field. */
#define MPU_RD_RGDAAC5_M2PE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M2PE_MASK) >> MPU_RGDAAC5_M2PE_SHIFT)
#define MPU_BRD_RGDAAC5_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC5_M2PE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M2PE_MASK, MPU_RGDAAC5_M2PE(value)))
#define MPU_BWR_RGDAAC5_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M3UM field. */
#define MPU_RD_RGDAAC5_M3UM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M3UM_MASK) >> MPU_RGDAAC5_M3UM_SHIFT)
#define MPU_BRD_RGDAAC5_M3UM(base) (MPU_RD_RGDAAC5_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC5_M3UM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M3UM_MASK, MPU_RGDAAC5_M3UM(value)))
#define MPU_BWR_RGDAAC5_M3UM(base, value) (MPU_WR_RGDAAC5_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M3SM field. */
#define MPU_RD_RGDAAC5_M3SM(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M3SM_MASK) >> MPU_RGDAAC5_M3SM_SHIFT)
#define MPU_BRD_RGDAAC5_M3SM(base) (MPU_RD_RGDAAC5_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC5_M3SM(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M3SM_MASK, MPU_RGDAAC5_M3SM(value)))
#define MPU_BWR_RGDAAC5_M3SM(base, value) (MPU_WR_RGDAAC5_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M3PE field. */
#define MPU_RD_RGDAAC5_M3PE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M3PE_MASK) >> MPU_RGDAAC5_M3PE_SHIFT)
#define MPU_BRD_RGDAAC5_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC5_M3PE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M3PE_MASK, MPU_RGDAAC5_M3PE(value)))
#define MPU_BWR_RGDAAC5_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M4WE field. */
#define MPU_RD_RGDAAC5_M4WE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M4WE_MASK) >> MPU_RGDAAC5_M4WE_SHIFT)
#define MPU_BRD_RGDAAC5_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC5_M4WE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M4WE_MASK, MPU_RGDAAC5_M4WE(value)))
#define MPU_BWR_RGDAAC5_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M4RE field. */
#define MPU_RD_RGDAAC5_M4RE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M4RE_MASK) >> MPU_RGDAAC5_M4RE_SHIFT)
#define MPU_BRD_RGDAAC5_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC5_M4RE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M4RE_MASK, MPU_RGDAAC5_M4RE(value)))
#define MPU_BWR_RGDAAC5_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M5WE field. */
#define MPU_RD_RGDAAC5_M5WE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M5WE_MASK) >> MPU_RGDAAC5_M5WE_SHIFT)
#define MPU_BRD_RGDAAC5_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC5_M5WE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M5WE_MASK, MPU_RGDAAC5_M5WE(value)))
#define MPU_BWR_RGDAAC5_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M5RE field. */
#define MPU_RD_RGDAAC5_M5RE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M5RE_MASK) >> MPU_RGDAAC5_M5RE_SHIFT)
#define MPU_BRD_RGDAAC5_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC5_M5RE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M5RE_MASK, MPU_RGDAAC5_M5RE(value)))
#define MPU_BWR_RGDAAC5_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M6WE field. */
#define MPU_RD_RGDAAC5_M6WE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M6WE_MASK) >> MPU_RGDAAC5_M6WE_SHIFT)
#define MPU_BRD_RGDAAC5_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC5_M6WE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M6WE_MASK, MPU_RGDAAC5_M6WE(value)))
#define MPU_BWR_RGDAAC5_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M6RE field. */
#define MPU_RD_RGDAAC5_M6RE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M6RE_MASK) >> MPU_RGDAAC5_M6RE_SHIFT)
#define MPU_BRD_RGDAAC5_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC5_M6RE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M6RE_MASK, MPU_RGDAAC5_M6RE(value)))
#define MPU_BWR_RGDAAC5_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M7WE field. */
#define MPU_RD_RGDAAC5_M7WE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M7WE_MASK) >> MPU_RGDAAC5_M7WE_SHIFT)
#define MPU_BRD_RGDAAC5_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC5_M7WE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M7WE_MASK, MPU_RGDAAC5_M7WE(value)))
#define MPU_BWR_RGDAAC5_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC5, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC5_M7RE field. */
#define MPU_RD_RGDAAC5_M7RE(base) ((MPU_RGDAAC5_REG(base) & MPU_RGDAAC5_M7RE_MASK) >> MPU_RGDAAC5_M7RE_SHIFT)
#define MPU_BRD_RGDAAC5_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC5_M7RE(base, value) (MPU_RMW_RGDAAC5(base, MPU_RGDAAC5_M7RE_MASK, MPU_RGDAAC5_M7RE(value)))
#define MPU_BWR_RGDAAC5_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC5_REG(base), MPU_RGDAAC5_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC6 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC6 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC6 register
 */
/*@{*/
#define MPU_RD_RGDAAC6(base)     (MPU_RGDAAC6_REG(base))
#define MPU_WR_RGDAAC6(base, value) (MPU_RGDAAC6_REG(base) = (value))
#define MPU_RMW_RGDAAC6(base, mask, value) (MPU_WR_RGDAAC6(base, (MPU_RD_RGDAAC6(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC6(base, value) (MPU_WR_RGDAAC6(base, MPU_RD_RGDAAC6(base) |  (value)))
#define MPU_CLR_RGDAAC6(base, value) (MPU_WR_RGDAAC6(base, MPU_RD_RGDAAC6(base) & ~(value)))
#define MPU_TOG_RGDAAC6(base, value) (MPU_WR_RGDAAC6(base, MPU_RD_RGDAAC6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC6 bitfields
 */

/*!
 * @name Register MPU_RGDAAC6, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M0UM field. */
#define MPU_RD_RGDAAC6_M0UM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M0UM_MASK) >> MPU_RGDAAC6_M0UM_SHIFT)
#define MPU_BRD_RGDAAC6_M0UM(base) (MPU_RD_RGDAAC6_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC6_M0UM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M0UM_MASK, MPU_RGDAAC6_M0UM(value)))
#define MPU_BWR_RGDAAC6_M0UM(base, value) (MPU_WR_RGDAAC6_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M0SM field. */
#define MPU_RD_RGDAAC6_M0SM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M0SM_MASK) >> MPU_RGDAAC6_M0SM_SHIFT)
#define MPU_BRD_RGDAAC6_M0SM(base) (MPU_RD_RGDAAC6_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC6_M0SM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M0SM_MASK, MPU_RGDAAC6_M0SM(value)))
#define MPU_BWR_RGDAAC6_M0SM(base, value) (MPU_WR_RGDAAC6_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M0PE field. */
#define MPU_RD_RGDAAC6_M0PE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M0PE_MASK) >> MPU_RGDAAC6_M0PE_SHIFT)
#define MPU_BRD_RGDAAC6_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC6_M0PE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M0PE_MASK, MPU_RGDAAC6_M0PE(value)))
#define MPU_BWR_RGDAAC6_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M1UM field. */
#define MPU_RD_RGDAAC6_M1UM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M1UM_MASK) >> MPU_RGDAAC6_M1UM_SHIFT)
#define MPU_BRD_RGDAAC6_M1UM(base) (MPU_RD_RGDAAC6_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC6_M1UM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M1UM_MASK, MPU_RGDAAC6_M1UM(value)))
#define MPU_BWR_RGDAAC6_M1UM(base, value) (MPU_WR_RGDAAC6_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M1SM field. */
#define MPU_RD_RGDAAC6_M1SM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M1SM_MASK) >> MPU_RGDAAC6_M1SM_SHIFT)
#define MPU_BRD_RGDAAC6_M1SM(base) (MPU_RD_RGDAAC6_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC6_M1SM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M1SM_MASK, MPU_RGDAAC6_M1SM(value)))
#define MPU_BWR_RGDAAC6_M1SM(base, value) (MPU_WR_RGDAAC6_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M1PE field. */
#define MPU_RD_RGDAAC6_M1PE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M1PE_MASK) >> MPU_RGDAAC6_M1PE_SHIFT)
#define MPU_BRD_RGDAAC6_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC6_M1PE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M1PE_MASK, MPU_RGDAAC6_M1PE(value)))
#define MPU_BWR_RGDAAC6_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M2UM field. */
#define MPU_RD_RGDAAC6_M2UM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M2UM_MASK) >> MPU_RGDAAC6_M2UM_SHIFT)
#define MPU_BRD_RGDAAC6_M2UM(base) (MPU_RD_RGDAAC6_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC6_M2UM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M2UM_MASK, MPU_RGDAAC6_M2UM(value)))
#define MPU_BWR_RGDAAC6_M2UM(base, value) (MPU_WR_RGDAAC6_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M2SM field. */
#define MPU_RD_RGDAAC6_M2SM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M2SM_MASK) >> MPU_RGDAAC6_M2SM_SHIFT)
#define MPU_BRD_RGDAAC6_M2SM(base) (MPU_RD_RGDAAC6_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC6_M2SM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M2SM_MASK, MPU_RGDAAC6_M2SM(value)))
#define MPU_BWR_RGDAAC6_M2SM(base, value) (MPU_WR_RGDAAC6_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M2PE field. */
#define MPU_RD_RGDAAC6_M2PE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M2PE_MASK) >> MPU_RGDAAC6_M2PE_SHIFT)
#define MPU_BRD_RGDAAC6_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC6_M2PE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M2PE_MASK, MPU_RGDAAC6_M2PE(value)))
#define MPU_BWR_RGDAAC6_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M3UM field. */
#define MPU_RD_RGDAAC6_M3UM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M3UM_MASK) >> MPU_RGDAAC6_M3UM_SHIFT)
#define MPU_BRD_RGDAAC6_M3UM(base) (MPU_RD_RGDAAC6_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC6_M3UM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M3UM_MASK, MPU_RGDAAC6_M3UM(value)))
#define MPU_BWR_RGDAAC6_M3UM(base, value) (MPU_WR_RGDAAC6_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M3SM field. */
#define MPU_RD_RGDAAC6_M3SM(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M3SM_MASK) >> MPU_RGDAAC6_M3SM_SHIFT)
#define MPU_BRD_RGDAAC6_M3SM(base) (MPU_RD_RGDAAC6_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC6_M3SM(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M3SM_MASK, MPU_RGDAAC6_M3SM(value)))
#define MPU_BWR_RGDAAC6_M3SM(base, value) (MPU_WR_RGDAAC6_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M3PE field. */
#define MPU_RD_RGDAAC6_M3PE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M3PE_MASK) >> MPU_RGDAAC6_M3PE_SHIFT)
#define MPU_BRD_RGDAAC6_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC6_M3PE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M3PE_MASK, MPU_RGDAAC6_M3PE(value)))
#define MPU_BWR_RGDAAC6_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M4WE field. */
#define MPU_RD_RGDAAC6_M4WE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M4WE_MASK) >> MPU_RGDAAC6_M4WE_SHIFT)
#define MPU_BRD_RGDAAC6_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC6_M4WE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M4WE_MASK, MPU_RGDAAC6_M4WE(value)))
#define MPU_BWR_RGDAAC6_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M4RE field. */
#define MPU_RD_RGDAAC6_M4RE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M4RE_MASK) >> MPU_RGDAAC6_M4RE_SHIFT)
#define MPU_BRD_RGDAAC6_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC6_M4RE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M4RE_MASK, MPU_RGDAAC6_M4RE(value)))
#define MPU_BWR_RGDAAC6_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M5WE field. */
#define MPU_RD_RGDAAC6_M5WE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M5WE_MASK) >> MPU_RGDAAC6_M5WE_SHIFT)
#define MPU_BRD_RGDAAC6_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC6_M5WE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M5WE_MASK, MPU_RGDAAC6_M5WE(value)))
#define MPU_BWR_RGDAAC6_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M5RE field. */
#define MPU_RD_RGDAAC6_M5RE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M5RE_MASK) >> MPU_RGDAAC6_M5RE_SHIFT)
#define MPU_BRD_RGDAAC6_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC6_M5RE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M5RE_MASK, MPU_RGDAAC6_M5RE(value)))
#define MPU_BWR_RGDAAC6_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M6WE field. */
#define MPU_RD_RGDAAC6_M6WE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M6WE_MASK) >> MPU_RGDAAC6_M6WE_SHIFT)
#define MPU_BRD_RGDAAC6_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC6_M6WE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M6WE_MASK, MPU_RGDAAC6_M6WE(value)))
#define MPU_BWR_RGDAAC6_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M6RE field. */
#define MPU_RD_RGDAAC6_M6RE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M6RE_MASK) >> MPU_RGDAAC6_M6RE_SHIFT)
#define MPU_BRD_RGDAAC6_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC6_M6RE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M6RE_MASK, MPU_RGDAAC6_M6RE(value)))
#define MPU_BWR_RGDAAC6_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M7WE field. */
#define MPU_RD_RGDAAC6_M7WE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M7WE_MASK) >> MPU_RGDAAC6_M7WE_SHIFT)
#define MPU_BRD_RGDAAC6_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC6_M7WE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M7WE_MASK, MPU_RGDAAC6_M7WE(value)))
#define MPU_BWR_RGDAAC6_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC6, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC6_M7RE field. */
#define MPU_RD_RGDAAC6_M7RE(base) ((MPU_RGDAAC6_REG(base) & MPU_RGDAAC6_M7RE_MASK) >> MPU_RGDAAC6_M7RE_SHIFT)
#define MPU_BRD_RGDAAC6_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC6_M7RE(base, value) (MPU_RMW_RGDAAC6(base, MPU_RGDAAC6_M7RE_MASK, MPU_RGDAAC6_M7RE(value)))
#define MPU_BWR_RGDAAC6_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC6_REG(base), MPU_RGDAAC6_M7RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC7 - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC7 - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC7 register
 */
/*@{*/
#define MPU_RD_RGDAAC7(base)     (MPU_RGDAAC7_REG(base))
#define MPU_WR_RGDAAC7(base, value) (MPU_RGDAAC7_REG(base) = (value))
#define MPU_RMW_RGDAAC7(base, mask, value) (MPU_WR_RGDAAC7(base, (MPU_RD_RGDAAC7(base) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC7(base, value) (MPU_WR_RGDAAC7(base, MPU_RD_RGDAAC7(base) |  (value)))
#define MPU_CLR_RGDAAC7(base, value) (MPU_WR_RGDAAC7(base, MPU_RD_RGDAAC7(base) & ~(value)))
#define MPU_TOG_RGDAAC7(base, value) (MPU_WR_RGDAAC7(base, MPU_RD_RGDAAC7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC7 bitfields
 */

/*!
 * @name Register MPU_RGDAAC7, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M0UM field. */
#define MPU_RD_RGDAAC7_M0UM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M0UM_MASK) >> MPU_RGDAAC7_M0UM_SHIFT)
#define MPU_BRD_RGDAAC7_M0UM(base) (MPU_RD_RGDAAC7_M0UM(base))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC7_M0UM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M0UM_MASK, MPU_RGDAAC7_M0UM(value)))
#define MPU_BWR_RGDAAC7_M0UM(base, value) (MPU_WR_RGDAAC7_M0UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M0SM field. */
#define MPU_RD_RGDAAC7_M0SM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M0SM_MASK) >> MPU_RGDAAC7_M0SM_SHIFT)
#define MPU_BRD_RGDAAC7_M0SM(base) (MPU_RD_RGDAAC7_M0SM(base))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC7_M0SM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M0SM_MASK, MPU_RGDAAC7_M0SM(value)))
#define MPU_BWR_RGDAAC7_M0SM(base, value) (MPU_WR_RGDAAC7_M0SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M0PE field. */
#define MPU_RD_RGDAAC7_M0PE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M0PE_MASK) >> MPU_RGDAAC7_M0PE_SHIFT)
#define MPU_BRD_RGDAAC7_M0PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M0PE_SHIFT))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC7_M0PE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M0PE_MASK, MPU_RGDAAC7_M0PE(value)))
#define MPU_BWR_RGDAAC7_M0PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M0PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M1UM field. */
#define MPU_RD_RGDAAC7_M1UM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M1UM_MASK) >> MPU_RGDAAC7_M1UM_SHIFT)
#define MPU_BRD_RGDAAC7_M1UM(base) (MPU_RD_RGDAAC7_M1UM(base))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC7_M1UM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M1UM_MASK, MPU_RGDAAC7_M1UM(value)))
#define MPU_BWR_RGDAAC7_M1UM(base, value) (MPU_WR_RGDAAC7_M1UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M1SM field. */
#define MPU_RD_RGDAAC7_M1SM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M1SM_MASK) >> MPU_RGDAAC7_M1SM_SHIFT)
#define MPU_BRD_RGDAAC7_M1SM(base) (MPU_RD_RGDAAC7_M1SM(base))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC7_M1SM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M1SM_MASK, MPU_RGDAAC7_M1SM(value)))
#define MPU_BWR_RGDAAC7_M1SM(base, value) (MPU_WR_RGDAAC7_M1SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M1PE field. */
#define MPU_RD_RGDAAC7_M1PE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M1PE_MASK) >> MPU_RGDAAC7_M1PE_SHIFT)
#define MPU_BRD_RGDAAC7_M1PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M1PE_SHIFT))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC7_M1PE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M1PE_MASK, MPU_RGDAAC7_M1PE(value)))
#define MPU_BWR_RGDAAC7_M1PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M1PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M2UM field. */
#define MPU_RD_RGDAAC7_M2UM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M2UM_MASK) >> MPU_RGDAAC7_M2UM_SHIFT)
#define MPU_BRD_RGDAAC7_M2UM(base) (MPU_RD_RGDAAC7_M2UM(base))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC7_M2UM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M2UM_MASK, MPU_RGDAAC7_M2UM(value)))
#define MPU_BWR_RGDAAC7_M2UM(base, value) (MPU_WR_RGDAAC7_M2UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M2SM field. */
#define MPU_RD_RGDAAC7_M2SM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M2SM_MASK) >> MPU_RGDAAC7_M2SM_SHIFT)
#define MPU_BRD_RGDAAC7_M2SM(base) (MPU_RD_RGDAAC7_M2SM(base))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC7_M2SM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M2SM_MASK, MPU_RGDAAC7_M2SM(value)))
#define MPU_BWR_RGDAAC7_M2SM(base, value) (MPU_WR_RGDAAC7_M2SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M2PE field. */
#define MPU_RD_RGDAAC7_M2PE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M2PE_MASK) >> MPU_RGDAAC7_M2PE_SHIFT)
#define MPU_BRD_RGDAAC7_M2PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M2PE_SHIFT))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC7_M2PE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M2PE_MASK, MPU_RGDAAC7_M2PE(value)))
#define MPU_BWR_RGDAAC7_M2PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M2PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. The bit assignment sequence is as M3UM[2:0] -> rwx.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M3UM field. */
#define MPU_RD_RGDAAC7_M3UM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M3UM_MASK) >> MPU_RGDAAC7_M3UM_SHIFT)
#define MPU_BRD_RGDAAC7_M3UM(base) (MPU_RD_RGDAAC7_M3UM(base))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC7_M3UM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M3UM_MASK, MPU_RGDAAC7_M3UM(value)))
#define MPU_BWR_RGDAAC7_M3UM(base, value) (MPU_WR_RGDAAC7_M3UM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M3SM field. */
#define MPU_RD_RGDAAC7_M3SM(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M3SM_MASK) >> MPU_RGDAAC7_M3SM_SHIFT)
#define MPU_BRD_RGDAAC7_M3SM(base) (MPU_RD_RGDAAC7_M3SM(base))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC7_M3SM(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M3SM_MASK, MPU_RGDAAC7_M3SM(value)))
#define MPU_BWR_RGDAAC7_M3SM(base, value) (MPU_WR_RGDAAC7_M3SM(base, value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M3PE field. */
#define MPU_RD_RGDAAC7_M3PE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M3PE_MASK) >> MPU_RGDAAC7_M3PE_SHIFT)
#define MPU_BRD_RGDAAC7_M3PE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M3PE_SHIFT))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC7_M3PE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M3PE_MASK, MPU_RGDAAC7_M3PE(value)))
#define MPU_BWR_RGDAAC7_M3PE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M3PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M4WE field. */
#define MPU_RD_RGDAAC7_M4WE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M4WE_MASK) >> MPU_RGDAAC7_M4WE_SHIFT)
#define MPU_BRD_RGDAAC7_M4WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M4WE_SHIFT))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC7_M4WE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M4WE_MASK, MPU_RGDAAC7_M4WE(value)))
#define MPU_BWR_RGDAAC7_M4WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M4WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M4RE field. */
#define MPU_RD_RGDAAC7_M4RE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M4RE_MASK) >> MPU_RGDAAC7_M4RE_SHIFT)
#define MPU_BRD_RGDAAC7_M4RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M4RE_SHIFT))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC7_M4RE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M4RE_MASK, MPU_RGDAAC7_M4RE(value)))
#define MPU_BWR_RGDAAC7_M4RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M4RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M5WE field. */
#define MPU_RD_RGDAAC7_M5WE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M5WE_MASK) >> MPU_RGDAAC7_M5WE_SHIFT)
#define MPU_BRD_RGDAAC7_M5WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M5WE_SHIFT))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC7_M5WE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M5WE_MASK, MPU_RGDAAC7_M5WE(value)))
#define MPU_BWR_RGDAAC7_M5WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M5WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M5RE field. */
#define MPU_RD_RGDAAC7_M5RE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M5RE_MASK) >> MPU_RGDAAC7_M5RE_SHIFT)
#define MPU_BRD_RGDAAC7_M5RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M5RE_SHIFT))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC7_M5RE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M5RE_MASK, MPU_RGDAAC7_M5RE(value)))
#define MPU_BWR_RGDAAC7_M5RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M5RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M6WE field. */
#define MPU_RD_RGDAAC7_M6WE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M6WE_MASK) >> MPU_RGDAAC7_M6WE_SHIFT)
#define MPU_BRD_RGDAAC7_M6WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M6WE_SHIFT))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC7_M6WE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M6WE_MASK, MPU_RGDAAC7_M6WE(value)))
#define MPU_BWR_RGDAAC7_M6WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M6WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M6RE field. */
#define MPU_RD_RGDAAC7_M6RE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M6RE_MASK) >> MPU_RGDAAC7_M6RE_SHIFT)
#define MPU_BRD_RGDAAC7_M6RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M6RE_SHIFT))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC7_M6RE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M6RE_MASK, MPU_RGDAAC7_M6RE(value)))
#define MPU_BWR_RGDAAC7_M6RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M6RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M7WE field. */
#define MPU_RD_RGDAAC7_M7WE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M7WE_MASK) >> MPU_RGDAAC7_M7WE_SHIFT)
#define MPU_BRD_RGDAAC7_M7WE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M7WE_SHIFT))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC7_M7WE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M7WE_MASK, MPU_RGDAAC7_M7WE(value)))
#define MPU_BWR_RGDAAC7_M7WE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M7WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MPU_RGDAAC7, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC7_M7RE field. */
#define MPU_RD_RGDAAC7_M7RE(base) ((MPU_RGDAAC7_REG(base) & MPU_RGDAAC7_M7RE_MASK) >> MPU_RGDAAC7_M7RE_SHIFT)
#define MPU_BRD_RGDAAC7_M7RE(base) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M7RE_SHIFT))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC7_M7RE(base, value) (MPU_RMW_RGDAAC7(base, MPU_RGDAAC7_M7RE_MASK, MPU_RGDAAC7_M7RE(value)))
#define MPU_BWR_RGDAAC7_M7RE(base, value) (BITBAND_ACCESS32(&MPU_RGDAAC7_REG(base), MPU_RGDAAC7_M7RE_SHIFT) = (value))
/*@}*/

/*
 * S32K144 MSCM
 *
 * MSCM
 *
 * Registers defined in this header file:
 * - MSCM_CPxTYPE - Processor X Type Register
 * - MSCM_CPxNUM - Processor X Number Register
 * - MSCM_CPxMASTER - Processor X Master Register
 * - MSCM_CPxCOUNT - Processor X Count Register
 * - MSCM_CPxCFG - Processor X Configuration Register
 * - MSCM_CP0TYPE - Processor 0 Type Register
 * - MSCM_CP0NUM - Processor 0 Number Register
 * - MSCM_CP0MASTER - Processor 0 Master Register
 * - MSCM_CP0COUNT - Processor 0 Count Register
 * - MSCM_CP0CFG - Processor 0 Configuration Register
 * - MSCM_OCMDR - On-Chip Memory Descriptor Register
 */

#define MSCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MSCM module. */
#define MSCM_IDX (0U) /*!< Instance number for MSCM. */

/*******************************************************************************
 * MSCM_CPxTYPE - Processor X Type Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxTYPE - Processor X Type Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the personality of
 * the core making the access. The 32 bit response includes 3 ASCII characters
 * defining the CPU type along with a byte defining the logical revision number. The
 * logical revision number follows ARM's rYpZ nomenclature.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxTYPE register
 */
/*@{*/
#define MSCM_RD_CPxTYPE(base)    (MSCM_CPxTYPE_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxTYPE bitfields
 */

/*!
 * @name Register MSCM_CPxTYPE, field RYPZ[7:0] (RO)
 *
 * This read-only field defines the processor revision for CPx: 0x01 corresponds
 * to the r0p1 core release. ...
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxTYPE_RYPZ field. */
#define MSCM_RD_CPxTYPE_RYPZ(base) ((MSCM_CPxTYPE_REG(base) & MSCM_CPxTYPE_RYPZ_MASK) >> MSCM_CPxTYPE_RYPZ_SHIFT)
#define MSCM_BRD_CPxTYPE_RYPZ(base) (MSCM_RD_CPxTYPE_RYPZ(base))
/*@}*/

/*!
 * @name Register MSCM_CPxTYPE, field PERSONALITY[31:8] (RO)
 *
 * This read-only field defines the processor personality for CPx if CPx =
 * Cortex-M4, then PERSONALITY = 0x43_4D_34 ("CM4").
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxTYPE_PERSONALITY field. */
#define MSCM_RD_CPxTYPE_PERSONALITY(base) ((MSCM_CPxTYPE_REG(base) & MSCM_CPxTYPE_PERSONALITY_MASK) >> MSCM_CPxTYPE_PERSONALITY_SHIFT)
#define MSCM_BRD_CPxTYPE_PERSONALITY(base) (MSCM_RD_CPxTYPE_PERSONALITY(base))
/*@}*/

/*******************************************************************************
 * MSCM_CPxNUM - Processor X Number Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxNUM - Processor X Number Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the logical
 * processor number of the core making the access. In single processor configurations,
 * the logical processor number is always zero.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxNUM register
 */
/*@{*/
#define MSCM_RD_CPxNUM(base)     (MSCM_CPxNUM_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxNUM bitfields
 */

/*!
 * @name Register MSCM_CPxNUM, field CPN[0] (RO)
 *
 * This zero-filled word defines the logical processor number for CPx If single
 * core configuration, then CPN = 0.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxNUM_CPN field. */
#define MSCM_RD_CPxNUM_CPN(base) ((MSCM_CPxNUM_REG(base) & MSCM_CPxNUM_CPN_MASK) >> MSCM_CPxNUM_CPN_SHIFT)
#define MSCM_BRD_CPxNUM_CPN(base) (BITBAND_ACCESS32(&MSCM_CPxNUM_REG(base), MSCM_CPxNUM_CPN_SHIFT))
/*@}*/

/*******************************************************************************
 * MSCM_CPxMASTER - Processor X Master Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxMASTER - Processor X Master Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the physical bus
 * master number the core making the access. The 32 bit response defines the
 * physical master number for processor x. A privileged read from the CM4 returns the
 * appropriate processor information. Reads from any other bus master return all
 * zeroes. Attempted user mode or write accesses are terminated with an error.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxMASTER register
 */
/*@{*/
#define MSCM_RD_CPxMASTER(base)  (MSCM_CPxMASTER_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxMASTER bitfields
 */

/*!
 * @name Register MSCM_CPxMASTER, field PPN[5:0] (RO)
 *
 * This read-only field defines the physical port number for CPUx. For single
 * core (CPU0), PPN = 0x00.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxMASTER_PPN field. */
#define MSCM_RD_CPxMASTER_PPN(base) ((MSCM_CPxMASTER_REG(base) & MSCM_CPxMASTER_PPN_MASK) >> MSCM_CPxMASTER_PPN_SHIFT)
#define MSCM_BRD_CPxMASTER_PPN(base) (MSCM_RD_CPxMASTER_PPN(base))
/*@}*/

/*******************************************************************************
 * MSCM_CPxCOUNT - Processor X Count Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxCOUNT - Processor X Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the total number of
 * processor cores in the chip configuration.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxCOUNT register
 */
/*@{*/
#define MSCM_RD_CPxCOUNT(base)   (MSCM_CPxCOUNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxCOUNT bitfields
 */

/*!
 * @name Register MSCM_CPxCOUNT, field PCNT[1:0] (RO)
 *
 * This read-only field defines the processor count for the chip configuration:
 * If single core configuration, then PCNT = 00.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxCOUNT_PCNT field. */
#define MSCM_RD_CPxCOUNT_PCNT(base) ((MSCM_CPxCOUNT_REG(base) & MSCM_CPxCOUNT_PCNT_MASK) >> MSCM_CPxCOUNT_PCNT_SHIFT)
#define MSCM_BRD_CPxCOUNT_PCNT(base) (MSCM_RD_CPxCOUNT_PCNT(base))
/*@}*/

/*******************************************************************************
 * MSCM_CPxCFG - Processor X Configuration Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxCFG - Processor X Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * will MA512 contain L1 caches??The register provides information on the Level
 * 1 caches (if present).
 */
/*!
 * @name Constants and macros for entire MSCM_CPxCFG register
 */
/*@{*/
#define MSCM_RD_CPxCFG(base, index) (MSCM_CPxCFG_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxCFG bitfields
 */

/*!
 * @name Register MSCM_CPxCFG, field ICSZ[31:24] (RO)
 *
 * This read-only field provides an encoded value of the Instruction Cache size.
 * The capacity of the memory is expressed as Size [bytes] = 2(9+SZ), where SZ
 * is non-zero; a SZ = 0 indicates the memory is not present. if no Instruction
 * Cache, then ICSZ = 0x00 if a 4 Kbyte Instruction Cache, then ICSZ = 0x03 if an 8
 * Kbyte Instruction Cache, then ICSZ = 0x04 if a 16 Kbyte Instruction Cache,
 * then ICSZ = 0x05 if a 32 Kbyte Instruction Cache, then ICSZ = 0x06 if a 64 Kbyte
 * Instruction Cache, then ICSZ = 0x07 if a 128 Kbyte Instruction Cache, then
 * ICSZ = 0x08 if a 256 Kbyte Instruction Cache, then ICSZ = 0x09 if a 512 Kbyte
 * Instruction Cache, then ICSZ = 0x0A
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxCFG_ICSZ field. */
#define MSCM_RD_CPxCFG_ICSZ(base, index) ((MSCM_CPxCFG_REG(base, index) & MSCM_CPxCFG_ICSZ_MASK) >> MSCM_CPxCFG_ICSZ_SHIFT)
#define MSCM_BRD_CPxCFG_ICSZ(base, index) (MSCM_RD_CPxCFG_ICSZ(base, index))
/*@}*/

/*******************************************************************************
 * MSCM_CP0TYPE - Processor 0 Type Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0TYPE - Processor 0 Type Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the personality of
 * the core making the access. The 32 bit response includes 3 ASCII characters
 * defining the CPU type along with a byte defining the logical revision number. The
 * logical revision number follows ARM's rYpZ nomenclature.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0TYPE register
 */
/*@{*/
#define MSCM_RD_CP0TYPE(base)    (MSCM_CP0TYPE_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0TYPE bitfields
 */

/*!
 * @name Register MSCM_CP0TYPE, field RYPZ[7:0] (RO)
 *
 * This read-only field defines the processor revision for CPx: 0x01 corresponds
 * to the r0p1 core release. ...
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0TYPE_RYPZ field. */
#define MSCM_RD_CP0TYPE_RYPZ(base) ((MSCM_CP0TYPE_REG(base) & MSCM_CP0TYPE_RYPZ_MASK) >> MSCM_CP0TYPE_RYPZ_SHIFT)
#define MSCM_BRD_CP0TYPE_RYPZ(base) (MSCM_RD_CP0TYPE_RYPZ(base))
/*@}*/

/*!
 * @name Register MSCM_CP0TYPE, field PERSONALITY[31:8] (RO)
 *
 * This read-only field defines the processor personality for CPx if CPx =
 * Cortex-M4, then PERSONALITY = 0x43_4D_34 ("CM4").
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0TYPE_PERSONALITY field. */
#define MSCM_RD_CP0TYPE_PERSONALITY(base) ((MSCM_CP0TYPE_REG(base) & MSCM_CP0TYPE_PERSONALITY_MASK) >> MSCM_CP0TYPE_PERSONALITY_SHIFT)
#define MSCM_BRD_CP0TYPE_PERSONALITY(base) (MSCM_RD_CP0TYPE_PERSONALITY(base))
/*@}*/

/*******************************************************************************
 * MSCM_CP0NUM - Processor 0 Number Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0NUM - Processor 0 Number Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the logical
 * processor number of the core making the access. In single processor configurations,
 * the logical processor number is always zero.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0NUM register
 */
/*@{*/
#define MSCM_RD_CP0NUM(base)     (MSCM_CP0NUM_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0NUM bitfields
 */

/*!
 * @name Register MSCM_CP0NUM, field CPN[0] (RO)
 *
 * This zero-filled word defines the logical processor number for CPx If single
 * core configuration, then CPN = 0
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0NUM_CPN field. */
#define MSCM_RD_CP0NUM_CPN(base) ((MSCM_CP0NUM_REG(base) & MSCM_CP0NUM_CPN_MASK) >> MSCM_CP0NUM_CPN_SHIFT)
#define MSCM_BRD_CP0NUM_CPN(base) (BITBAND_ACCESS32(&MSCM_CP0NUM_REG(base), MSCM_CP0NUM_CPN_SHIFT))
/*@}*/

/*******************************************************************************
 * MSCM_CP0MASTER - Processor 0 Master Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0MASTER - Processor 0 Master Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the physical bus
 * master number the core making the access. The 32 bit response defines the
 * physical master number for processor x. A privileged read from the CA5 or the CM4
 * returns the appropriate processor information. Reads from any other bus master
 * return all zeroes. Attempted user mode or write accesses are terminated with an
 * error.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0MASTER register
 */
/*@{*/
#define MSCM_RD_CP0MASTER(base)  (MSCM_CP0MASTER_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0MASTER bitfields
 */

/*!
 * @name Register MSCM_CP0MASTER, field PPN[5:0] (RO)
 *
 * This read-only field defines the physical port number for CPUx. For CPU0, PPN
 * = 0x00
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0MASTER_PPN field. */
#define MSCM_RD_CP0MASTER_PPN(base) ((MSCM_CP0MASTER_REG(base) & MSCM_CP0MASTER_PPN_MASK) >> MSCM_CP0MASTER_PPN_SHIFT)
#define MSCM_BRD_CP0MASTER_PPN(base) (MSCM_RD_CP0MASTER_PPN(base))
/*@}*/

/*******************************************************************************
 * MSCM_CP0COUNT - Processor 0 Count Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0COUNT - Processor 0 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the total number of
 * processor cores in the chip configuration.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0COUNT register
 */
/*@{*/
#define MSCM_RD_CP0COUNT(base)   (MSCM_CP0COUNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0COUNT bitfields
 */

/*!
 * @name Register MSCM_CP0COUNT, field PCNT[1:0] (RO)
 *
 * This read-only field defines the processor count for the chip configuration:
 * If single core configuration, then PCNT = 00
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0COUNT_PCNT field. */
#define MSCM_RD_CP0COUNT_PCNT(base) ((MSCM_CP0COUNT_REG(base) & MSCM_CP0COUNT_PCNT_MASK) >> MSCM_CP0COUNT_PCNT_SHIFT)
#define MSCM_BRD_CP0COUNT_PCNT(base) (MSCM_RD_CP0COUNT_PCNT(base))
/*@}*/

/*******************************************************************************
 * MSCM_CP0CFG - Processor 0 Configuration Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0CFG - Processor 0 Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides information on the Level 1 caches (if present).
 */
/*!
 * @name Constants and macros for entire MSCM_CP0CFG register
 */
/*@{*/
#define MSCM_RD_CP0CFG(base, index) (MSCM_CP0CFG_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0CFG bitfields
 */

/*!
 * @name Register MSCM_CP0CFG, field ICSZ[31:24] (RO)
 *
 * This read-only field provides an encoded value of the Instruction Cache size.
 * The capacity of the memory is expressed as Size [bytes] = 2(9+SZ), where SZ
 * is non-zero; a SZ = 0 indicates the memory is not present. if no Instruction
 * Cache, then ICSZ = 0x00 if a 4 Kbyte Instruction Cache, then ICSZ = 0x03 if an 8
 * Kbyte Instruction Cache, then ICSZ = 0x04 if a 16 Kbyte Instruction Cache,
 * then ICSZ = 0x05 if a 32 Kbyte Instruction Cache, then ICSZ = 0x06 if a 64 Kbyte
 * Instruction Cache, then ICSZ = 0x07 if a 128 Kbyte Instruction Cache, then
 * ICSZ = 0x08 if a 256 Kbyte Instruction Cache, then ICSZ = 0x09 if a 512 Kbyte
 * Instruction Cache, then ICSZ = 0x0A
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0CFG_ICSZ field. */
#define MSCM_RD_CP0CFG_ICSZ(base, index) ((MSCM_CP0CFG_REG(base, index) & MSCM_CP0CFG_ICSZ_MASK) >> MSCM_CP0CFG_ICSZ_SHIFT)
#define MSCM_BRD_CP0CFG_ICSZ(base, index) (MSCM_RD_CP0CFG_ICSZ(base, index))
/*@}*/

/*******************************************************************************
 * MSCM_OCMDR - On-Chip Memory Descriptor Register
 ******************************************************************************/

/*!
 * @brief MSCM_OCMDR - On-Chip Memory Descriptor Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section of the programming model is an array of 32-bit generic on-chip
 * memory descriptor registers that provide static information on the attached
 * memories as well as configurable controls (where appropriate). Privileged 32-bit
 * reads from a processor core or the debugger return the appropriate processor
 * information. Reads from any other bus master return all zeroes. Privileged
 * writes from a processor core or the debugger to writeable registers update the
 * appropriate fields. Privileged writes from other bus masters are ignored.
 * Attempted user mode accesses or any access with a size other than 32 bits are
 * terminated with an error.
 */
/*!
 * @name Constants and macros for entire MSCM_OCMDR register
 */
/*@{*/
#define MSCM_RD_OCMDR(base, index) (MSCM_OCMDR_REG(base, index))
#define MSCM_WR_OCMDR(base, index, value) (MSCM_OCMDR_REG(base, index) = (value))
#define MSCM_RMW_OCMDR(base, index, mask, value) (MSCM_WR_OCMDR(base, index, (MSCM_RD_OCMDR(base, index) & ~(mask)) | (value)))
#define MSCM_SET_OCMDR(base, index, value) (MSCM_WR_OCMDR(base, index, MSCM_RD_OCMDR(base, index) |  (value)))
#define MSCM_CLR_OCMDR(base, index, value) (MSCM_WR_OCMDR(base, index, MSCM_RD_OCMDR(base, index) & ~(value)))
#define MSCM_TOG_OCMDR(base, index, value) (MSCM_WR_OCMDR(base, index, MSCM_RD_OCMDR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MSCM_OCMDR bitfields
 */

/*!
 * @name Register MSCM_OCMDR, field OCMC0[3:0] (RW)
 *
 * OCMEM Control Field 0. This 4-bit field (if used) defines the configuration
 * of the on-chip memory. The field's functionality is dependent on the OCMT value.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMC0 field. */
#define MSCM_RD_OCMDR_OCMC0(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMC0_MASK) >> MSCM_OCMDR_OCMC0_SHIFT)
#define MSCM_BRD_OCMDR_OCMC0(base, index) (MSCM_RD_OCMDR_OCMC0(base, index))

/*! @brief Set the OCMC0 field to a new value. */
#define MSCM_WR_OCMDR_OCMC0(base, index, value) (MSCM_RMW_OCMDR(base, index, MSCM_OCMDR_OCMC0_MASK, MSCM_OCMDR_OCMC0(value)))
#define MSCM_BWR_OCMDR_OCMC0(base, index, value) (MSCM_WR_OCMDR_OCMC0(base, index, value))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMC1[7:4] (RW)
 *
 * OCMEM Control Field 1. This 4-bit field (if used) defines the configuration
 * of the on-chip memory. The field's functionality is dependent on the OCMT
 * value. OCMDR0[5] or OCMDR1[5] bit controls whether prefetches (or speculative
 * accesses) are initiated in response to instruction fetches or data references, see
 * Speculative reads.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMC1 field. */
#define MSCM_RD_OCMDR_OCMC1(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMC1_MASK) >> MSCM_OCMDR_OCMC1_SHIFT)
#define MSCM_BRD_OCMDR_OCMC1(base, index) (MSCM_RD_OCMDR_OCMC1(base, index))

/*! @brief Set the OCMC1 field to a new value. */
#define MSCM_WR_OCMDR_OCMC1(base, index, value) (MSCM_RMW_OCMDR(base, index, MSCM_OCMDR_OCMC1_MASK, MSCM_OCMDR_OCMC1(value)))
#define MSCM_BWR_OCMDR_OCMC1(base, index, value) (MSCM_WR_OCMDR_OCMC1(base, index, value))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMC2[11:8] (RW)
 *
 * OCMEM Control Field 2. This 4-bit field (if used) defines the configuration
 * of the on-chip memory. The field's functionality is dependent on the OCMT value.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMC2 field. */
#define MSCM_RD_OCMDR_OCMC2(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMC2_MASK) >> MSCM_OCMDR_OCMC2_SHIFT)
#define MSCM_BRD_OCMDR_OCMC2(base, index) (MSCM_RD_OCMDR_OCMC2(base, index))

/*! @brief Set the OCMC2 field to a new value. */
#define MSCM_WR_OCMDR_OCMC2(base, index, value) (MSCM_RMW_OCMDR(base, index, MSCM_OCMDR_OCMC2_MASK, MSCM_OCMDR_OCMC2(value)))
#define MSCM_BWR_OCMDR_OCMC2(base, index, value) (MSCM_WR_OCMDR_OCMC2(base, index, value))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMPU[12] (RO)
 *
 * OCMEM Memory Protection Unit. This read-only field identifies a memory
 * protected by a Memory Protection Unit.
 *
 * Values:
 * - 0b0 - OCMEMn is not protected by an MPU.
 * - 0b1 - OCMEMn is protected by an MPU.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMPU field. */
#define MSCM_RD_OCMDR_OCMPU(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMPU_MASK) >> MSCM_OCMDR_OCMPU_SHIFT)
#define MSCM_BRD_OCMDR_OCMPU(base, index) (BITBAND_ACCESS32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMPU_SHIFT))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMT[15:13] (RO)
 *
 * OCMEM Type. This field defines the type of the on-chip memory:
 *
 * Values:
 * - 0b000 - Reserved
 * - 0b001 - Reserved
 * - 0b010 - Reserved
 * - 0b011 - OCMEMn is a ROM.
 * - 0b100 - OCMEMn is a program flash.
 * - 0b101 - OCMEMn is a data flash.
 * - 0b110 - OCMEMn is an EEE.
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMT field. */
#define MSCM_RD_OCMDR_OCMT(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMT_MASK) >> MSCM_OCMDR_OCMT_SHIFT)
#define MSCM_BRD_OCMDR_OCMT(base, index) (MSCM_RD_OCMDR_OCMT(base, index))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field RO[16] (RO)
 *
 * Read-Only. This register bit provides a mechanism to "lock" the configuration
 * state defined by OCMDRn[11:0]. Once asserted, attempted writes to the
 * OCMDRn[11:0] register are ignored until the next reset clears the flag.
 *
 * Values:
 * - 0b0 - writes to the OCMDRn[11:0] are allowed
 * - 0b1 - writes to the OCMDRn[11:0] are ignored
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_RO field. */
#define MSCM_RD_OCMDR_RO(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_RO_MASK) >> MSCM_OCMDR_RO_SHIFT)
#define MSCM_BRD_OCMDR_RO(base, index) (BITBAND_ACCESS32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_RO_SHIFT))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMW[19:17] (RO)
 *
 * OCMEM datapath Width. This read-only field defines the width of the on-chip
 * memory:
 *
 * Values:
 * - 0b010 - OCMEMn 32-bits wide
 * - 0b011 - OCMEMn 64-bits wide
 * - 0b100 - OCMEMn 128-bits wide
 * - 0b101 - OCMEMn 256-bits wide
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMW field. */
#define MSCM_RD_OCMDR_OCMW(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMW_MASK) >> MSCM_OCMDR_OCMW_SHIFT)
#define MSCM_BRD_OCMDR_OCMW(base, index) (MSCM_RD_OCMDR_OCMW(base, index))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMSZ[27:24] (RO)
 *
 * OCMEM Size. This read-only field provides an encoded value of the on-chip
 * memory size. The capacity of the memory is expressed as Size [bytes] = 2(9+SZ)
 * where SZ is non-zero; a SZ = 0 indicates the memory is not present.
 *
 * Values:
 * - 0b0000 - no OCMEMn
 * - 0b0011 - 4KB OCMEMn
 * - 0b0100 - 8KB OCMEMn
 * - 0b0101 - 16KB OCMEMn
 * - 0b0110 - 32KB OCMEMn
 * - 0b0111 - 64KB OCMEMn
 * - 0b1000 - 128KB OCMEMn
 * - 0b1001 - 256KB OCMEMn
 * - 0b1010 - 512KB OCMEMn
 * - 0b1011 - 1024KB OCMEMn
 * - 0b1100 - 2048KB OCMEMn
 * - 0b1101 - 4096KB OCMEMn
 * - 0b1110 - 8192KB OCMEMn
 * - 0b1111 - 16384KB OCMEMn
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMSZ field. */
#define MSCM_RD_OCMDR_OCMSZ(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMSZ_MASK) >> MSCM_OCMDR_OCMSZ_SHIFT)
#define MSCM_BRD_OCMDR_OCMSZ(base, index) (MSCM_RD_OCMDR_OCMSZ(base, index))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMSZH[28] (RO)
 *
 * OCMEM Size "Hole". For on-chip memories that are not fully populated, that
 * is, include a memory "hole" in the upper 25% of the address range, this bit is
 * used.
 *
 * Values:
 * - 0b0 - OCMEMn is a power-of-2 capacity.
 * - 0b1 - OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMSZH field. */
#define MSCM_RD_OCMDR_OCMSZH(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMSZH_MASK) >> MSCM_OCMDR_OCMSZH_SHIFT)
#define MSCM_BRD_OCMDR_OCMSZH(base, index) (BITBAND_ACCESS32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMSZH_SHIFT))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field V[31] (RO)
 *
 * OCMEM Valid bit. This read-only field defines the validity (presence) of the
 * on-chip memory
 *
 * Values:
 * - 0b0 - OCMEMn is not present.
 * - 0b1 - OCMEMn is present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_V field. */
#define MSCM_RD_OCMDR_V(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_V_MASK) >> MSCM_OCMDR_V_SHIFT)
#define MSCM_BRD_OCMDR_V(base, index) (BITBAND_ACCESS32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_V_SHIFT))
/*@}*/

/*
 * S32K144 OSC32
 *
 * RTC Oscillator
 *
 * Registers defined in this header file:
 * - OSC32_CR - RTC Oscillator Control Register
 */

#define OSC32_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC32 module. */
#define OSC32_IDX (0U) /*!< Instance number for OSC32. */

/*******************************************************************************
 * OSC32_CR - RTC Oscillator Control Register
 ******************************************************************************/

/*!
 * @brief OSC32_CR - RTC Oscillator Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire OSC32_CR register
 */
/*@{*/
#define OSC32_RD_CR(base)        (OSC32_CR_REG(base))
#define OSC32_WR_CR(base, value) (OSC32_CR_REG(base) = (value))
#define OSC32_RMW_CR(base, mask, value) (OSC32_WR_CR(base, (OSC32_RD_CR(base) & ~(mask)) | (value)))
#define OSC32_SET_CR(base, value) (OSC32_WR_CR(base, OSC32_RD_CR(base) |  (value)))
#define OSC32_CLR_CR(base, value) (OSC32_WR_CR(base, OSC32_RD_CR(base) & ~(value)))
#define OSC32_TOG_CR(base, value) (OSC32_WR_CR(base, OSC32_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual OSC32_CR bitfields
 */

/*!
 * @name Register OSC32_CR, field ROSCEREFS[4] (RW)
 *
 * Values:
 * - 0b0 - Bypass mode. RTC oscillator selects the external 32k clock.
 * - 0b1 - Crystal mode.
 */
/*@{*/
/*! @brief Read current value of the OSC32_CR_ROSCEREFS field. */
#define OSC32_RD_CR_ROSCEREFS(base) ((OSC32_CR_REG(base) & OSC32_CR_ROSCEREFS_MASK) >> OSC32_CR_ROSCEREFS_SHIFT)
#define OSC32_BRD_CR_ROSCEREFS(base) (BITBAND_ACCESS8(&OSC32_CR_REG(base), OSC32_CR_ROSCEREFS_SHIFT))

/*! @brief Set the ROSCEREFS field to a new value. */
#define OSC32_WR_CR_ROSCEREFS(base, value) (OSC32_RMW_CR(base, OSC32_CR_ROSCEREFS_MASK, OSC32_CR_ROSCEREFS(value)))
#define OSC32_BWR_CR_ROSCEREFS(base, value) (BITBAND_ACCESS8(&OSC32_CR_REG(base), OSC32_CR_ROSCEREFS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC32_CR, field ROSCSTB[5] (RO)
 *
 * This flag indicates when using the crystal mode if the oscillator has started
 * up stably after 4096 cycles.
 *
 * Values:
 * - 0b0 - RTC 32k oscillator is unstable now and no clock will go out of the
 *     block.
 * - 0b1 - RTC 32k oscillator is stable.
 */
/*@{*/
/*! @brief Read current value of the OSC32_CR_ROSCSTB field. */
#define OSC32_RD_CR_ROSCSTB(base) ((OSC32_CR_REG(base) & OSC32_CR_ROSCSTB_MASK) >> OSC32_CR_ROSCSTB_SHIFT)
#define OSC32_BRD_CR_ROSCSTB(base) (BITBAND_ACCESS8(&OSC32_CR_REG(base), OSC32_CR_ROSCSTB_SHIFT))
/*@}*/

/*!
 * @name Register OSC32_CR, field ROSCSTPEN[6] (RW)
 *
 * This bit is used to enable the RTC 32k VLP Oscillator in stop mode together
 * with ROSCEN bitfield.
 *
 * Values:
 * - 0b0 - Oscillator is disabled regardless the state of ROSCEN.
 * - 0b1 - Oscillator is enabled in Stop mode when ROSCEN is set.
 */
/*@{*/
/*! @brief Read current value of the OSC32_CR_ROSCSTPEN field. */
#define OSC32_RD_CR_ROSCSTPEN(base) ((OSC32_CR_REG(base) & OSC32_CR_ROSCSTPEN_MASK) >> OSC32_CR_ROSCSTPEN_SHIFT)
#define OSC32_BRD_CR_ROSCSTPEN(base) (BITBAND_ACCESS8(&OSC32_CR_REG(base), OSC32_CR_ROSCSTPEN_SHIFT))

/*! @brief Set the ROSCSTPEN field to a new value. */
#define OSC32_WR_CR_ROSCSTPEN(base, value) (OSC32_RMW_CR(base, OSC32_CR_ROSCSTPEN_MASK, OSC32_CR_ROSCSTPEN(value)))
#define OSC32_BWR_CR_ROSCSTPEN(base, value) (BITBAND_ACCESS8(&OSC32_CR_REG(base), OSC32_CR_ROSCSTPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC32_CR, field ROSCEN[7] (RW)
 *
 * This bit is used to enable the RTC 32k VLP Oscillator.
 *
 * Values:
 * - 0b0 - Oscillator is disabled.
 * - 0b1 - Oscillator is enabled.
 */
/*@{*/
/*! @brief Read current value of the OSC32_CR_ROSCEN field. */
#define OSC32_RD_CR_ROSCEN(base) ((OSC32_CR_REG(base) & OSC32_CR_ROSCEN_MASK) >> OSC32_CR_ROSCEN_SHIFT)
#define OSC32_BRD_CR_ROSCEN(base) (BITBAND_ACCESS8(&OSC32_CR_REG(base), OSC32_CR_ROSCEN_SHIFT))

/*! @brief Set the ROSCEN field to a new value. */
#define OSC32_WR_CR_ROSCEN(base, value) (OSC32_RMW_CR(base, OSC32_CR_ROSCEN_MASK, OSC32_CR_ROSCEN(value)))
#define OSC32_BWR_CR_ROSCEN(base, value) (BITBAND_ACCESS8(&OSC32_CR_REG(base), OSC32_CR_ROSCEN_SHIFT) = (value))
/*@}*/

/*
 * S32K144 PCC
 *
 * PCC
 *
 * Registers defined in this header file:
 * - PCC_IP - PCC Register
 */

#define PCC_INSTANCE_COUNT (1U) /*!< Number of instances of the PCC module. */
#define PCC_IDX (0U) /*!< Instance number for PCC. */

/*******************************************************************************
 * PCC_IP - PCC Register
 ******************************************************************************/

/*!
 * @brief PCC_IP - PCC Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * PCC Register
 */
/*!
 * @name Constants and macros for entire PCC_IP register
 */
/*@{*/
#define PCC_RD_IP(base, index)   (PCC_IP_REG(base, index))
#define PCC_WR_IP(base, index, value) (PCC_IP_REG(base, index) = (value))
#define PCC_RMW_IP(base, index, mask, value) (PCC_WR_IP(base, index, (PCC_RD_IP(base, index) & ~(mask)) | (value)))

/*@}*/

/*
 * Constants & macros for individual PCC_IP bitfields
 */

/*!
 * @name Register PCC_IP, field PCD[2:0] (RW)
 *
 * This read/write bit field is used for peripherals that require a clock
 * divider. At SOC integration, each peripheral is assigned either a divider or
 * not.This field can only be written when the CGC bit is 0 (clock disabled). Likewise,
 * if the INUSE flag is set, this field is locked.
 *
 * Values:
 * - 0b000 - Divide by 1 (pass-through, no clock divide).
 * - 0b001 - Divide by 2.
 * - 0b010 - Divide by 3.
 * - 0b011 - Divide by 4.
 * - 0b100 - Divide by 5.
 * - 0b101 - Divide by 6.
 * - 0b110 - Divide by 7.
 * - 0b111 - Divide by 8.
 */
/*@{*/
/*! @brief Read current value of the PCC_IP_PCD field. */
#define PCC_RD_IP_PCD(base, index) ((PCC_IP_REG(base, index) & PCC_IP_PCD_MASK) >> PCC_IP_PCD_SHIFT)
#define PCC_BRD_IP_PCD(base, index) (PCC_RD_IP_PCD(base, index))

/*! @brief Set the PCD field to a new value. */
#define PCC_WR_IP_PCD(base, index, value) (PCC_RMW_IP(base, index, PCC_IP_PCD_MASK, PCC_IP_PCD(value)))
#define PCC_BWR_IP_PCD(base, index, value) (PCC_WR_IP_PCD(base, index, value))
/*@}*/

/*!
 * @name Register PCC_IP, field FRAC[3] (RW)
 *
 * This read/write bit field sets the fraction multiply value for the fractional
 * clock divider used as a clock source. Divider output clock = Divider input
 * clock x [(FRAC+1)/(DIV+1)].This field can only be written when the CGC bit is 0
 * (clock disabled). Likewise, if the INUSE flag is set, this field is locked.
 *
 * Values:
 * - 0b0 - Fractional value is 0.
 * - 0b1 - Fractional value is 1.
 */
/*@{*/
/*! @brief Read current value of the PCC_IP_FRAC field. */
#define PCC_RD_IP_FRAC(base, index) ((PCC_IP_REG(base, index) & PCC_IP_FRAC_MASK) >> PCC_IP_FRAC_SHIFT)
#define PCC_BRD_IP_FRAC(base, index) (BITBAND_ACCESS32(&PCC_IP_REG(base, index), PCC_IP_FRAC_SHIFT))

/*! @brief Set the FRAC field to a new value. */
#define PCC_WR_IP_FRAC(base, index, value) (PCC_RMW_IP(base, index, PCC_IP_FRAC_MASK, PCC_IP_FRAC(value)))
#define PCC_BWR_IP_FRAC(base, index, value) (BITBAND_ACCESS32(&PCC_IP_REG(base, index), PCC_IP_FRAC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PCC_IP, field PCS[26:24] (RW)
 *
 * This read/write bit field is used for peripherals that support various clock
 * selections.This field can only be written when the CGC bit is 0 (clock
 * disabled). Likewise, if the INUSE flag is set, this field is locked.
 *
 * Values:
 * - 0b000 - Clock is off (or test clock is enabled) An external clock can be
 *     enabled for this peripheral.
 * - 0b001 - OSCCLK - System Oscillator Platform Clock(scg_sosc_plat_clk).
 * - 0b010 - SCGIRCLK - Slow IRC Clock(scg_sirc_plat_clk), (maximum is 8MHz).
 * - 0b011 - SCGFIRCLK - Fast IRC Clock(scg_firc_plat_clk), (maximum is 48MHz).
 * - 0b100 - Reserved.
 * - 0b101 - Reserved.
 * - 0b110 - SCGPCLK System PLL clock (scg_spll_plat_clk).
 * - 0b111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PCC_IP_PCS field. */
#define PCC_RD_IP_PCS(base, index) ((PCC_IP_REG(base, index) & PCC_IP_PCS_MASK) >> PCC_IP_PCS_SHIFT)
#define PCC_BRD_IP_PCS(base, index) (PCC_RD_IP_PCS(base, index))

/*! @brief Set the PCS field to a new value. */
#define PCC_WR_IP_PCS(base, index, value) (PCC_RMW_IP(base, index, PCC_IP_PCS_MASK, PCC_IP_PCS(value)))
#define PCC_BWR_IP_PCS(base, index, value) (PCC_WR_IP_PCS(base, index, value))
/*@}*/

/*!
 * @name Register PCC_IP, field INUSE[29] (RO)
 *
 * This read-only bit shows that this peripheral is already in use by another
 * core. That is, software on another core has already configured the clocking
 * options of this peripheral. For example, if CPU0 software has set this
 * peripheral's CGC bit first, it sees the INUSE bit as cleared. However, if software on
 * another core has set this peripheral's CGC bit first, CPU0 software sees the
 * INUSE bit as set.
 *
 * Values:
 * - 0b0 - Another core is not using this peripheral.
 * - 0b1 - Another core is using this peripheral. Software cannot modify the
 *     existing clocking configuration.
 */
/*@{*/
/*! @brief Read current value of the PCC_IP_INUSE field. */
#define PCC_RD_IP_INUSE(base, index) ((PCC_IP_REG(base, index) & PCC_IP_INUSE_MASK) >> PCC_IP_INUSE_SHIFT)
#define PCC_BRD_IP_INUSE(base, index) (BITBAND_ACCESS32(&PCC_IP_REG(base, index), PCC_IP_INUSE_SHIFT))
/*@}*/

/*!
 * @name Register PCC_IP, field CGC[30] (RW)
 *
 * This read/write bit enables the clock for the peripheral.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the PCC_IP_CGC field. */
#define PCC_RD_IP_CGC(base, index) ((PCC_IP_REG(base, index) & PCC_IP_CGC_MASK) >> PCC_IP_CGC_SHIFT)
#define PCC_BRD_IP_CGC(base, index) (BITBAND_ACCESS32(&PCC_IP_REG(base, index), PCC_IP_CGC_SHIFT))

/*! @brief Set the CGC field to a new value. */
#define PCC_WR_IP_CGC(base, index, value) (PCC_RMW_IP(base, index, PCC_IP_CGC_MASK, PCC_IP_CGC(value)))
#define PCC_BWR_IP_CGC(base, index, value) (BITBAND_ACCESS32(&PCC_IP_REG(base, index), PCC_IP_CGC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PCC_IP, field PR[31] (RO)
 *
 * This bit shows whether the peripheral is present on this device.
 *
 * Values:
 * - 0b0 - Peripheral is not present.
 * - 0b1 - Peripheral is present.
 */
/*@{*/
/*! @brief Read current value of the PCC_IP_PR field. */
#define PCC_RD_IP_PR(base, index) ((PCC_IP_REG(base, index) & PCC_IP_PR_MASK) >> PCC_IP_PR_SHIFT)
#define PCC_BRD_IP_PR(base, index) (BITBAND_ACCESS32(&PCC_IP_REG(base, index), PCC_IP_PR_SHIFT))
/*@}*/

/*
 * S32K144 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - PDB_SC - Status and Control register
 * - PDB_MOD - Modulus register
 * - PDB_CNT - Counter register
 * - PDB_IDLY - Interrupt Delay register
 * - PDB_CH0C1 - Channel n Control register 1
 * - PDB_CH0S - Channel n Status register
 * - PDB_CH0DLY0 - Channel n Delay 0 register
 * - PDB_CH0DLY1 - Channel n Delay 1 register
 * - PDB_CH0DLY2 - Channel n Delay 2 register
 * - PDB_CH0DLY3 - Channel n Delay 3 register
 * - PDB_CH0DLY4 - Channel n Delay 4 register
 * - PDB_CH0DLY5 - Channel n Delay 5 register
 * - PDB_CH0DLY6 - Channel n Delay 6 register
 * - PDB_CH0DLY7 - Channel n Delay 7 register
 * - PDB_CH1C1 - Channel n Control register 1
 * - PDB_CH1S - Channel n Status register
 * - PDB_CH1DLY0 - Channel n Delay 0 register
 * - PDB_CH1DLY1 - Channel n Delay 1 register
 * - PDB_CH1DLY2 - Channel n Delay 2 register
 * - PDB_CH1DLY3 - Channel n Delay 3 register
 * - PDB_CH1DLY4 - Channel n Delay 4 register
 * - PDB_CH1DLY5 - Channel n Delay 5 register
 * - PDB_CH1DLY6 - Channel n Delay 6 register
 * - PDB_CH1DLY7 - Channel n Delay 7 register
 * - PDB_POEN - Pulse-Out n Enable register
 * - PDB_PODLY - Pulse-Out n Delay register
 */

#define PDB_INSTANCE_COUNT (2U) /*!< Number of instances of the PDB module. */
#define PDB0_IDX (0U) /*!< Instance number for PDB0. */
#define PDB1_IDX (1U) /*!< Instance number for PDB1. */

/*******************************************************************************
 * PDB_SC - Status and Control register
 ******************************************************************************/

/*!
 * @brief PDB_SC - Status and Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_SC register
 */
/*@{*/
#define PDB_RD_SC(base)          (PDB_SC_REG(base))
#define PDB_WR_SC(base, value)   (PDB_SC_REG(base) = (value))
#define PDB_RMW_SC(base, mask, value) (PDB_WR_SC(base, (PDB_RD_SC(base) & ~(mask)) | (value)))
#define PDB_SET_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) |  (value)))
#define PDB_CLR_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) & ~(value)))
#define PDB_TOG_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_SC bitfields
 */

/*!
 * @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to this bit updates the internal registers of MOD, IDLY, CHnDLYm,
 * DACINTx,and POyDLY with the values written to their buffers. The MOD, IDLY,
 * CHnDLYm, DACINTx, and POyDLY will take effect according to the LDMOD. After 1 is
 * written to the LDOK field, the values in the buffers of above registers are
 * not effective and the buffers cannot be written until the values in buffers are
 * loaded into their internal registers. LDOK can be written only when PDBEN is
 * set or it can be written at the same time with PDBEN being written to 1. It is
 * automatically cleared when the values in buffers are loaded into the internal
 * registers or the PDBEN is cleared. Writing 0 to it has no effect.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDOK field. */
#define PDB_RD_SC_LDOK(base) ((PDB_SC_REG(base) & PDB_SC_LDOK_MASK) >> PDB_SC_LDOK_SHIFT)
#define PDB_BRD_SC_LDOK(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT))

/*! @brief Set the LDOK field to a new value. */
#define PDB_WR_SC_LDOK(base, value) (PDB_RMW_SC(base, PDB_SC_LDOK_MASK, PDB_SC_LDOK(value)))
#define PDB_BWR_SC_LDOK(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field CONT[1] (RW)
 *
 * Enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0b0 - PDB operation in One-Shot mode
 * - 0b1 - PDB operation in Continuous mode
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_CONT field. */
#define PDB_RD_SC_CONT(base) ((PDB_SC_REG(base) & PDB_SC_CONT_MASK) >> PDB_SC_CONT_SHIFT)
#define PDB_BRD_SC_CONT(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT))

/*! @brief Set the CONT field to a new value. */
#define PDB_WR_SC_CONT(base, value) (PDB_RMW_SC(base, PDB_SC_CONT_MASK, PDB_SC_CONT(value)))
#define PDB_BWR_SC_CONT(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * Selects the multiplication factor of the prescaler divider for the counter
 * clock.
 *
 * Values:
 * - 0b00 - Multiplication factor is 1.
 * - 0b01 - Multiplication factor is 10.
 * - 0b10 - Multiplication factor is 20.
 * - 0b11 - Multiplication factor is 40.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_MULT field. */
#define PDB_RD_SC_MULT(base) ((PDB_SC_REG(base) & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT)
#define PDB_BRD_SC_MULT(base) (PDB_RD_SC_MULT(base))

/*! @brief Set the MULT field to a new value. */
#define PDB_WR_SC_MULT(base, value) (PDB_RMW_SC(base, PDB_SC_MULT_MASK, PDB_SC_MULT(value)))
#define PDB_BWR_SC_MULT(base, value) (PDB_WR_SC_MULT(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * Enables the PDB interrupt. When this field is set and DMAEN is cleared, PDBIF
 * generates a PDB interrupt.
 *
 * Values:
 * - 0b0 - PDB interrupt disabled.
 * - 0b1 - PDB interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIE field. */
#define PDB_RD_SC_PDBIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBIE_MASK) >> PDB_SC_PDBIE_SHIFT)
#define PDB_BRD_SC_PDBIE(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT))

/*! @brief Set the PDBIE field to a new value. */
#define PDB_WR_SC_PDBIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIE_MASK, PDB_SC_PDBIE(value)))
#define PDB_BWR_SC_PDBIE(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This field is set when the counter value is equal to the IDLY register.
 * Writing zero clears this field.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIF field. */
#define PDB_RD_SC_PDBIF(base) ((PDB_SC_REG(base) & PDB_SC_PDBIF_MASK) >> PDB_SC_PDBIF_SHIFT)
#define PDB_BRD_SC_PDBIF(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT))

/*! @brief Set the PDBIF field to a new value. */
#define PDB_WR_SC_PDBIF(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIF_MASK, PDB_SC_PDBIF(value)))
#define PDB_BWR_SC_PDBIF(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0b0 - PDB disabled. Counter is off.
 * - 0b1 - PDB enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEN field. */
#define PDB_RD_SC_PDBEN(base) ((PDB_SC_REG(base) & PDB_SC_PDBEN_MASK) >> PDB_SC_PDBEN_SHIFT)
#define PDB_BRD_SC_PDBEN(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT))

/*! @brief Set the PDBEN field to a new value. */
#define PDB_WR_SC_PDBEN(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEN_MASK, PDB_SC_PDBEN(value)))
#define PDB_BWR_SC_PDBEN(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be
 * internal or external (EXTRG pin), or the software trigger. Refer to chip
 * configuration details for the actual PDB input trigger connections.
 *
 * Values:
 * - 0b0000 - Trigger-In 0 is selected.
 * - 0b0001 - Trigger-In 1 is selected.
 * - 0b0010 - Trigger-In 2 is selected.
 * - 0b0011 - Trigger-In 3 is selected.
 * - 0b0100 - Trigger-In 4 is selected.
 * - 0b0101 - Trigger-In 5 is selected.
 * - 0b0110 - Trigger-In 6 is selected.
 * - 0b0111 - Trigger-In 7 is selected.
 * - 0b1000 - Trigger-In 8 is selected.
 * - 0b1001 - Trigger-In 9 is selected.
 * - 0b1010 - Trigger-In 10 is selected.
 * - 0b1011 - Trigger-In 11 is selected.
 * - 0b1100 - Trigger-In 12 is selected.
 * - 0b1101 - Trigger-In 13 is selected.
 * - 0b1110 - Trigger-In 14 is selected.
 * - 0b1111 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_TRGSEL field. */
#define PDB_RD_SC_TRGSEL(base) ((PDB_SC_REG(base) & PDB_SC_TRGSEL_MASK) >> PDB_SC_TRGSEL_SHIFT)
#define PDB_BRD_SC_TRGSEL(base) (PDB_RD_SC_TRGSEL(base))

/*! @brief Set the TRGSEL field to a new value. */
#define PDB_WR_SC_TRGSEL(base, value) (PDB_RMW_SC(base, PDB_SC_TRGSEL_MASK, PDB_SC_TRGSEL(value)))
#define PDB_BWR_SC_TRGSEL(base, value) (PDB_WR_SC_TRGSEL(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 0b000 - Counting uses the peripheral clock divided by multiplication factor
 *     selected by MULT.
 * - 0b001 - Counting uses the peripheral clock divided by twice of the
 *     multiplication factor selected by MULT.
 * - 0b010 - Counting uses the peripheral clock divided by four times of the
 *     multiplication factor selected by MULT.
 * - 0b011 - Counting uses the peripheral clock divided by eight times of the
 *     multiplication factor selected by MULT.
 * - 0b100 - Counting uses the peripheral clock divided by 16 times of the
 *     multiplication factor selected by MULT.
 * - 0b101 - Counting uses the peripheral clock divided by 32 times of the
 *     multiplication factor selected by MULT.
 * - 0b110 - Counting uses the peripheral clock divided by 64 times of the
 *     multiplication factor selected by MULT.
 * - 0b111 - Counting uses the peripheral clock divided by 128 times of the
 *     multiplication factor selected by MULT.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PRESCALER field. */
#define PDB_RD_SC_PRESCALER(base) ((PDB_SC_REG(base) & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT)
#define PDB_BRD_SC_PRESCALER(base) (PDB_RD_SC_PRESCALER(base))

/*! @brief Set the PRESCALER field to a new value. */
#define PDB_WR_SC_PRESCALER(base, value) (PDB_RMW_SC(base, PDB_SC_PRESCALER_MASK, PDB_SC_PRESCALER(value)))
#define PDB_BWR_SC_PRESCALER(base, value) (PDB_WR_SC_PRESCALER(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an
 * interrupt.
 *
 * Values:
 * - 0b0 - DMA disabled.
 * - 0b1 - DMA enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_DMAEN field. */
#define PDB_RD_SC_DMAEN(base) ((PDB_SC_REG(base) & PDB_SC_DMAEN_MASK) >> PDB_SC_DMAEN_SHIFT)
#define PDB_BRD_SC_DMAEN(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define PDB_WR_SC_DMAEN(base, value) (PDB_RMW_SC(base, PDB_SC_DMAEN_MASK, PDB_SC_DMAEN(value)))
#define PDB_BWR_SC_DMAEN(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input
 * source, writing 1 to this field resets and restarts the counter. Writing 0 to
 * this field has no effect. Reading this field results 0.
 */
/*@{*/
/*! @brief Set the SWTRIG field to a new value. */
#define PDB_WR_SC_SWTRIG(base, value) (PDB_RMW_SC(base, PDB_SC_SWTRIG_MASK, PDB_SC_SWTRIG(value)))
#define PDB_BWR_SC_SWTRIG(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_SWTRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * Enables the PDB sequence error interrupt. When this field is set, any of the
 * PDB channel sequence error flags generates a PDB sequence error interrupt.
 *
 * Values:
 * - 0b0 - PDB sequence error interrupt disabled.
 * - 0b1 - PDB sequence error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEIE field. */
#define PDB_RD_SC_PDBEIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBEIE_MASK) >> PDB_SC_PDBEIE_SHIFT)
#define PDB_BRD_SC_PDBEIE(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT))

/*! @brief Set the PDBEIE field to a new value. */
#define PDB_WR_SC_PDBEIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEIE_MASK, PDB_SC_PDBEIE(value)))
#define PDB_BWR_SC_PDBEIE(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
 * after 1 is written to LDOK.
 *
 * Values:
 * - 0b00 - The internal registers are loaded with the values from their buffers
 *     immediately after 1 is written to LDOK.
 * - 0b01 - The internal registers are loaded with the values from their buffers
 *     when the PDB counter reaches the MOD register value after 1 is written to
 *     LDOK.
 * - 0b10 - The internal registers are loaded with the values from their buffers
 *     when a trigger input event is detected after 1 is written to LDOK.
 * - 0b11 - The internal registers are loaded with the values from their buffers
 *     when either the PDB counter reaches the MOD register value or a trigger
 *     input event is detected, after 1 is written to LDOK.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDMOD field. */
#define PDB_RD_SC_LDMOD(base) ((PDB_SC_REG(base) & PDB_SC_LDMOD_MASK) >> PDB_SC_LDMOD_SHIFT)
#define PDB_BRD_SC_LDMOD(base) (PDB_RD_SC_LDMOD(base))

/*! @brief Set the LDMOD field to a new value. */
#define PDB_WR_SC_LDMOD(base, value) (PDB_RMW_SC(base, PDB_SC_LDMOD_MASK, PDB_SC_LDMOD(value)))
#define PDB_BWR_SC_LDMOD(base, value) (PDB_WR_SC_LDMOD(base, value))
/*@}*/

/*******************************************************************************
 * PDB_MOD - Modulus register
 ******************************************************************************/

/*!
 * @brief PDB_MOD - Modulus register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_MOD register
 */
/*@{*/
#define PDB_RD_MOD(base)         (PDB_MOD_REG(base))
#define PDB_WR_MOD(base, value)  (PDB_MOD_REG(base) = (value))
#define PDB_RMW_MOD(base, mask, value) (PDB_WR_MOD(base, (PDB_RD_MOD(base) & ~(mask)) | (value)))
#define PDB_SET_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) |  (value)))
#define PDB_CLR_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) & ~(value)))
#define PDB_TOG_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_MOD bitfields
 */

/*!
 * @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * Specifies the period of the counter. When the counter reaches this value, it
 * will be reset back to zero. If the PDB is in Continuous mode, the count begins
 * anew. Reading this field returns the value of the internal register that is
 * effective for the current cycle of PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_MOD_MOD field. */
#define PDB_RD_MOD_MOD(base) ((PDB_MOD_REG(base) & PDB_MOD_MOD_MASK) >> PDB_MOD_MOD_SHIFT)
#define PDB_BRD_MOD_MOD(base) (PDB_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define PDB_WR_MOD_MOD(base, value) (PDB_RMW_MOD(base, PDB_MOD_MOD_MASK, PDB_MOD_MOD(value)))
#define PDB_BWR_MOD_MOD(base, value) (PDB_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CNT - Counter register
 ******************************************************************************/

/*!
 * @brief PDB_CNT - Counter register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CNT register
 */
/*@{*/
#define PDB_RD_CNT(base)         (PDB_CNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual PDB_CNT bitfields
 */

/*!
 * @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * Contains the current value of the counter.
 */
/*@{*/
/*! @brief Read current value of the PDB_CNT_CNT field. */
#define PDB_RD_CNT_CNT(base) ((PDB_CNT_REG(base) & PDB_CNT_CNT_MASK) >> PDB_CNT_CNT_SHIFT)
#define PDB_BRD_CNT_CNT(base) (PDB_RD_CNT_CNT(base))
/*@}*/

/*******************************************************************************
 * PDB_IDLY - Interrupt Delay register
 ******************************************************************************/

/*!
 * @brief PDB_IDLY - Interrupt Delay register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
/*@{*/
#define PDB_RD_IDLY(base)        (PDB_IDLY_REG(base))
#define PDB_WR_IDLY(base, value) (PDB_IDLY_REG(base) = (value))
#define PDB_RMW_IDLY(base, mask, value) (PDB_WR_IDLY(base, (PDB_RD_IDLY(base) & ~(mask)) | (value)))
#define PDB_SET_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) |  (value)))
#define PDB_CLR_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) & ~(value)))
#define PDB_TOG_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_IDLY bitfields
 */

/*!
 * @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * Specifies the delay value to schedule the PDB interrupt. It can be used to
 * schedule an independent interrupt at some point in the PDB cycle. If enabled, a
 * PDB interrupt is generated, when the counter is equal to the IDLY. Reading
 * this field returns the value of internal register that is effective for the
 * current cycle of the PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_IDLY_IDLY field. */
#define PDB_RD_IDLY_IDLY(base) ((PDB_IDLY_REG(base) & PDB_IDLY_IDLY_MASK) >> PDB_IDLY_IDLY_SHIFT)
#define PDB_BRD_IDLY_IDLY(base) (PDB_RD_IDLY_IDLY(base))

/*! @brief Set the IDLY field to a new value. */
#define PDB_WR_IDLY_IDLY(base, value) (PDB_RMW_IDLY(base, PDB_IDLY_IDLY_MASK, PDB_IDLY_IDLY(value)))
#define PDB_BWR_IDLY_IDLY(base, value) (PDB_WR_IDLY_IDLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0C1 - Channel n Control register 1
 ******************************************************************************/

/*!
 * @brief PDB_CH0C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register
 * control the functionality of each PDB channel operation.
 */
/*!
 * @name Constants and macros for entire PDB_CH0C1 register
 */
/*@{*/
#define PDB_RD_CH0C1(base)       (PDB_CH0C1_REG(base))
#define PDB_WR_CH0C1(base, value) (PDB_CH0C1_REG(base) = (value))
#define PDB_RMW_CH0C1(base, mask, value) (PDB_WR_CH0C1(base, (PDB_RD_CH0C1(base) & ~(mask)) | (value)))
#define PDB_SET_CH0C1(base, value) (PDB_WR_CH0C1(base, PDB_RD_CH0C1(base) |  (value)))
#define PDB_CLR_CH0C1(base, value) (PDB_WR_CH0C1(base, PDB_RD_CH0C1(base) & ~(value)))
#define PDB_TOG_CH0C1(base, value) (PDB_WR_CH0C1(base, PDB_RD_CH0C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0C1 bitfields
 */

/*!
 * @name Register PDB_CH0C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger
 * bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0C1_EN field. */
#define PDB_RD_CH0C1_EN(base) ((PDB_CH0C1_REG(base) & PDB_CH0C1_EN_MASK) >> PDB_CH0C1_EN_SHIFT)
#define PDB_BRD_CH0C1_EN(base) (PDB_RD_CH0C1_EN(base))

/*! @brief Set the EN field to a new value. */
#define PDB_WR_CH0C1_EN(base, value) (PDB_RMW_CH0C1(base, PDB_CH0C1_EN_MASK, PDB_CH0C1_EN(value)))
#define PDB_BWR_CH0C1_EN(base, value) (PDB_WR_CH0C1_EN(base, value))
/*@}*/

/*!
 * @name Register PDB_CH0C1, field TOS[15:8] (RW)
 *
 * Selects the PDB ADC pre-trigger outputs. Only lower M pre-trigger fields are
 * implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger is in bypassed mode.
 *     The pre-trigger asserts one peripheral clock cycle after a rising edge is
 *     detected on selected trigger input source or software trigger is selected
 *     and SWTRIG is written with 1.
 * - 0b00000001 - PDB channel's corresponding pre-trigger asserts when the
 *     counter reaches the channel delay register and one peripheral clock cycle after
 *     a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SETRIG is written with 1.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0C1_TOS field. */
#define PDB_RD_CH0C1_TOS(base) ((PDB_CH0C1_REG(base) & PDB_CH0C1_TOS_MASK) >> PDB_CH0C1_TOS_SHIFT)
#define PDB_BRD_CH0C1_TOS(base) (PDB_RD_CH0C1_TOS(base))

/*! @brief Set the TOS field to a new value. */
#define PDB_WR_CH0C1_TOS(base, value) (PDB_RMW_CH0C1(base, PDB_CH0C1_TOS_MASK, PDB_CH0C1_TOS(value)))
#define PDB_BWR_CH0C1_TOS(base, value) (PDB_WR_CH0C1_TOS(base, value))
/*@}*/

/*!
 * @name Register PDB_CH0C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode.
 * Only lower M pre-trigger bits are implemented in this MCU. Back-to-back operation
 * enables the ADC conversions complete to trigger the next PDB channel
 * pre-trigger and trigger output, so that the ADC conversions can be triggered on next
 * set of configuration and results registers. Application code must only enable
 * the back-to-back operation of the PDB pre-triggers at the leading of the
 * back-to-back connection chain.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger back-to-back operation
 *     disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger back-to-back operation
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0C1_BB field. */
#define PDB_RD_CH0C1_BB(base) ((PDB_CH0C1_REG(base) & PDB_CH0C1_BB_MASK) >> PDB_CH0C1_BB_SHIFT)
#define PDB_BRD_CH0C1_BB(base) (PDB_RD_CH0C1_BB(base))

/*! @brief Set the BB field to a new value. */
#define PDB_WR_CH0C1_BB(base, value) (PDB_RMW_CH0C1(base, PDB_CH0C1_BB_MASK, PDB_CH0C1_BB(value)))
#define PDB_BWR_CH0C1_BB(base, value) (PDB_WR_CH0C1_BB(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0S - Channel n Status register
 ******************************************************************************/

/*!
 * @brief PDB_CH0S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0S register
 */
/*@{*/
#define PDB_RD_CH0S(base)        (PDB_CH0S_REG(base))
#define PDB_WR_CH0S(base, value) (PDB_CH0S_REG(base) = (value))
#define PDB_RMW_CH0S(base, mask, value) (PDB_WR_CH0S(base, (PDB_RD_CH0S(base) & ~(mask)) | (value)))
#define PDB_SET_CH0S(base, value) (PDB_WR_CH0S(base, PDB_RD_CH0S(base) |  (value)))
#define PDB_CLR_CH0S(base, value) (PDB_WR_CH0S(base, PDB_RD_CH0S(base) & ~(value)))
#define PDB_TOG_CH0S(base, value) (PDB_WR_CH0S(base, PDB_RD_CH0S(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0S bitfields
 */

/*!
 * @name Register PDB_CH0S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - Sequence error not detected on PDB channel's corresponding
 *     pre-trigger.
 * - 0b00000001 - Sequence error detected on PDB channel's corresponding
 *     pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from
 *     PDB channel n. When one conversion, which is triggered by one of the
 *     pre-triggers from PDB channel n, is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is
 *     set. Writing 0's to clear the sequence error flags.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0S_ERR field. */
#define PDB_RD_CH0S_ERR(base) ((PDB_CH0S_REG(base) & PDB_CH0S_ERR_MASK) >> PDB_CH0S_ERR_SHIFT)
#define PDB_BRD_CH0S_ERR(base) (PDB_RD_CH0S_ERR(base))

/*! @brief Set the ERR field to a new value. */
#define PDB_WR_CH0S_ERR(base, value) (PDB_RMW_CH0S(base, PDB_CH0S_ERR_MASK, PDB_CH0S_ERR(value)))
#define PDB_BWR_CH0S_ERR(base, value) (PDB_WR_CH0S_ERR(base, value))
/*@}*/

/*!
 * @name Register PDB_CH0S, field CF[23:16] (RW)
 *
 * The CF[m] bit is set when the PDB counter matches the CHnDLYm. Write 0 to
 * clear these bits.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0S_CF field. */
#define PDB_RD_CH0S_CF(base) ((PDB_CH0S_REG(base) & PDB_CH0S_CF_MASK) >> PDB_CH0S_CF_SHIFT)
#define PDB_BRD_CH0S_CF(base) (PDB_RD_CH0S_CF(base))

/*! @brief Set the CF field to a new value. */
#define PDB_WR_CH0S_CF(base, value) (PDB_RMW_CH0S(base, PDB_CH0S_CF_MASK, PDB_CH0S_CF(value)))
#define PDB_BWR_CH0S_CF(base, value) (PDB_WR_CH0S_CF(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY0 - Channel n Delay 0 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY0 - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY0 register
 */
/*@{*/
#define PDB_RD_CH0DLY0(base)     (PDB_CH0DLY0_REG(base))
#define PDB_WR_CH0DLY0(base, value) (PDB_CH0DLY0_REG(base) = (value))
#define PDB_RMW_CH0DLY0(base, mask, value) (PDB_WR_CH0DLY0(base, (PDB_RD_CH0DLY0(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY0(base, value) (PDB_WR_CH0DLY0(base, PDB_RD_CH0DLY0(base) |  (value)))
#define PDB_CLR_CH0DLY0(base, value) (PDB_WR_CH0DLY0(base, PDB_RD_CH0DLY0(base) & ~(value)))
#define PDB_TOG_CH0DLY0(base, value) (PDB_WR_CH0DLY0(base, PDB_RD_CH0DLY0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY0 bitfields
 */

/*!
 * @name Register PDB_CH0DLY0, field DLY[15:0] (RW)
 *
 * Specifies the delay value for the channel's corresponding pre-trigger. The
 * pre-trigger asserts when the counter is equal to DLY. Reading this field returns
 * the value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY0_DLY field. */
#define PDB_RD_CH0DLY0_DLY(base) ((PDB_CH0DLY0_REG(base) & PDB_CH0DLY0_DLY_MASK) >> PDB_CH0DLY0_DLY_SHIFT)
#define PDB_BRD_CH0DLY0_DLY(base) (PDB_RD_CH0DLY0_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY0_DLY(base, value) (PDB_RMW_CH0DLY0(base, PDB_CH0DLY0_DLY_MASK, PDB_CH0DLY0_DLY(value)))
#define PDB_BWR_CH0DLY0_DLY(base, value) (PDB_WR_CH0DLY0_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY1 - Channel n Delay 1 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY1 - Channel n Delay 1 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY1 register
 */
/*@{*/
#define PDB_RD_CH0DLY1(base)     (PDB_CH0DLY1_REG(base))
#define PDB_WR_CH0DLY1(base, value) (PDB_CH0DLY1_REG(base) = (value))
#define PDB_RMW_CH0DLY1(base, mask, value) (PDB_WR_CH0DLY1(base, (PDB_RD_CH0DLY1(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY1(base, value) (PDB_WR_CH0DLY1(base, PDB_RD_CH0DLY1(base) |  (value)))
#define PDB_CLR_CH0DLY1(base, value) (PDB_WR_CH0DLY1(base, PDB_RD_CH0DLY1(base) & ~(value)))
#define PDB_TOG_CH0DLY1(base, value) (PDB_WR_CH0DLY1(base, PDB_RD_CH0DLY1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY1 bitfields
 */

/*!
 * @name Register PDB_CH0DLY1, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY1_DLY field. */
#define PDB_RD_CH0DLY1_DLY(base) ((PDB_CH0DLY1_REG(base) & PDB_CH0DLY1_DLY_MASK) >> PDB_CH0DLY1_DLY_SHIFT)
#define PDB_BRD_CH0DLY1_DLY(base) (PDB_RD_CH0DLY1_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY1_DLY(base, value) (PDB_RMW_CH0DLY1(base, PDB_CH0DLY1_DLY_MASK, PDB_CH0DLY1_DLY(value)))
#define PDB_BWR_CH0DLY1_DLY(base, value) (PDB_WR_CH0DLY1_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY2 - Channel n Delay 2 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY2 - Channel n Delay 2 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY2 register
 */
/*@{*/
#define PDB_RD_CH0DLY2(base)     (PDB_CH0DLY2_REG(base))
#define PDB_WR_CH0DLY2(base, value) (PDB_CH0DLY2_REG(base) = (value))
#define PDB_RMW_CH0DLY2(base, mask, value) (PDB_WR_CH0DLY2(base, (PDB_RD_CH0DLY2(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY2(base, value) (PDB_WR_CH0DLY2(base, PDB_RD_CH0DLY2(base) |  (value)))
#define PDB_CLR_CH0DLY2(base, value) (PDB_WR_CH0DLY2(base, PDB_RD_CH0DLY2(base) & ~(value)))
#define PDB_TOG_CH0DLY2(base, value) (PDB_WR_CH0DLY2(base, PDB_RD_CH0DLY2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY2 bitfields
 */

/*!
 * @name Register PDB_CH0DLY2, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY2_DLY field. */
#define PDB_RD_CH0DLY2_DLY(base) ((PDB_CH0DLY2_REG(base) & PDB_CH0DLY2_DLY_MASK) >> PDB_CH0DLY2_DLY_SHIFT)
#define PDB_BRD_CH0DLY2_DLY(base) (PDB_RD_CH0DLY2_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY2_DLY(base, value) (PDB_RMW_CH0DLY2(base, PDB_CH0DLY2_DLY_MASK, PDB_CH0DLY2_DLY(value)))
#define PDB_BWR_CH0DLY2_DLY(base, value) (PDB_WR_CH0DLY2_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY3 - Channel n Delay 3 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY3 - Channel n Delay 3 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY3 register
 */
/*@{*/
#define PDB_RD_CH0DLY3(base)     (PDB_CH0DLY3_REG(base))
#define PDB_WR_CH0DLY3(base, value) (PDB_CH0DLY3_REG(base) = (value))
#define PDB_RMW_CH0DLY3(base, mask, value) (PDB_WR_CH0DLY3(base, (PDB_RD_CH0DLY3(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY3(base, value) (PDB_WR_CH0DLY3(base, PDB_RD_CH0DLY3(base) |  (value)))
#define PDB_CLR_CH0DLY3(base, value) (PDB_WR_CH0DLY3(base, PDB_RD_CH0DLY3(base) & ~(value)))
#define PDB_TOG_CH0DLY3(base, value) (PDB_WR_CH0DLY3(base, PDB_RD_CH0DLY3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY3 bitfields
 */

/*!
 * @name Register PDB_CH0DLY3, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY3_DLY field. */
#define PDB_RD_CH0DLY3_DLY(base) ((PDB_CH0DLY3_REG(base) & PDB_CH0DLY3_DLY_MASK) >> PDB_CH0DLY3_DLY_SHIFT)
#define PDB_BRD_CH0DLY3_DLY(base) (PDB_RD_CH0DLY3_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY3_DLY(base, value) (PDB_RMW_CH0DLY3(base, PDB_CH0DLY3_DLY_MASK, PDB_CH0DLY3_DLY(value)))
#define PDB_BWR_CH0DLY3_DLY(base, value) (PDB_WR_CH0DLY3_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY4 - Channel n Delay 4 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY4 - Channel n Delay 4 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY4 register
 */
/*@{*/
#define PDB_RD_CH0DLY4(base)     (PDB_CH0DLY4_REG(base))
#define PDB_WR_CH0DLY4(base, value) (PDB_CH0DLY4_REG(base) = (value))
#define PDB_RMW_CH0DLY4(base, mask, value) (PDB_WR_CH0DLY4(base, (PDB_RD_CH0DLY4(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY4(base, value) (PDB_WR_CH0DLY4(base, PDB_RD_CH0DLY4(base) |  (value)))
#define PDB_CLR_CH0DLY4(base, value) (PDB_WR_CH0DLY4(base, PDB_RD_CH0DLY4(base) & ~(value)))
#define PDB_TOG_CH0DLY4(base, value) (PDB_WR_CH0DLY4(base, PDB_RD_CH0DLY4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY4 bitfields
 */

/*!
 * @name Register PDB_CH0DLY4, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY4_DLY field. */
#define PDB_RD_CH0DLY4_DLY(base) ((PDB_CH0DLY4_REG(base) & PDB_CH0DLY4_DLY_MASK) >> PDB_CH0DLY4_DLY_SHIFT)
#define PDB_BRD_CH0DLY4_DLY(base) (PDB_RD_CH0DLY4_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY4_DLY(base, value) (PDB_RMW_CH0DLY4(base, PDB_CH0DLY4_DLY_MASK, PDB_CH0DLY4_DLY(value)))
#define PDB_BWR_CH0DLY4_DLY(base, value) (PDB_WR_CH0DLY4_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY5 - Channel n Delay 5 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY5 - Channel n Delay 5 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY5 register
 */
/*@{*/
#define PDB_RD_CH0DLY5(base)     (PDB_CH0DLY5_REG(base))
#define PDB_WR_CH0DLY5(base, value) (PDB_CH0DLY5_REG(base) = (value))
#define PDB_RMW_CH0DLY5(base, mask, value) (PDB_WR_CH0DLY5(base, (PDB_RD_CH0DLY5(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY5(base, value) (PDB_WR_CH0DLY5(base, PDB_RD_CH0DLY5(base) |  (value)))
#define PDB_CLR_CH0DLY5(base, value) (PDB_WR_CH0DLY5(base, PDB_RD_CH0DLY5(base) & ~(value)))
#define PDB_TOG_CH0DLY5(base, value) (PDB_WR_CH0DLY5(base, PDB_RD_CH0DLY5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY5 bitfields
 */

/*!
 * @name Register PDB_CH0DLY5, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY5_DLY field. */
#define PDB_RD_CH0DLY5_DLY(base) ((PDB_CH0DLY5_REG(base) & PDB_CH0DLY5_DLY_MASK) >> PDB_CH0DLY5_DLY_SHIFT)
#define PDB_BRD_CH0DLY5_DLY(base) (PDB_RD_CH0DLY5_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY5_DLY(base, value) (PDB_RMW_CH0DLY5(base, PDB_CH0DLY5_DLY_MASK, PDB_CH0DLY5_DLY(value)))
#define PDB_BWR_CH0DLY5_DLY(base, value) (PDB_WR_CH0DLY5_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY6 - Channel n Delay 6 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY6 - Channel n Delay 6 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY6 register
 */
/*@{*/
#define PDB_RD_CH0DLY6(base)     (PDB_CH0DLY6_REG(base))
#define PDB_WR_CH0DLY6(base, value) (PDB_CH0DLY6_REG(base) = (value))
#define PDB_RMW_CH0DLY6(base, mask, value) (PDB_WR_CH0DLY6(base, (PDB_RD_CH0DLY6(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY6(base, value) (PDB_WR_CH0DLY6(base, PDB_RD_CH0DLY6(base) |  (value)))
#define PDB_CLR_CH0DLY6(base, value) (PDB_WR_CH0DLY6(base, PDB_RD_CH0DLY6(base) & ~(value)))
#define PDB_TOG_CH0DLY6(base, value) (PDB_WR_CH0DLY6(base, PDB_RD_CH0DLY6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY6 bitfields
 */

/*!
 * @name Register PDB_CH0DLY6, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY6_DLY field. */
#define PDB_RD_CH0DLY6_DLY(base) ((PDB_CH0DLY6_REG(base) & PDB_CH0DLY6_DLY_MASK) >> PDB_CH0DLY6_DLY_SHIFT)
#define PDB_BRD_CH0DLY6_DLY(base) (PDB_RD_CH0DLY6_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY6_DLY(base, value) (PDB_RMW_CH0DLY6(base, PDB_CH0DLY6_DLY_MASK, PDB_CH0DLY6_DLY(value)))
#define PDB_BWR_CH0DLY6_DLY(base, value) (PDB_WR_CH0DLY6_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH0DLY7 - Channel n Delay 7 register
 ******************************************************************************/

/*!
 * @brief PDB_CH0DLY7 - Channel n Delay 7 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH0DLY7 register
 */
/*@{*/
#define PDB_RD_CH0DLY7(base)     (PDB_CH0DLY7_REG(base))
#define PDB_WR_CH0DLY7(base, value) (PDB_CH0DLY7_REG(base) = (value))
#define PDB_RMW_CH0DLY7(base, mask, value) (PDB_WR_CH0DLY7(base, (PDB_RD_CH0DLY7(base) & ~(mask)) | (value)))
#define PDB_SET_CH0DLY7(base, value) (PDB_WR_CH0DLY7(base, PDB_RD_CH0DLY7(base) |  (value)))
#define PDB_CLR_CH0DLY7(base, value) (PDB_WR_CH0DLY7(base, PDB_RD_CH0DLY7(base) & ~(value)))
#define PDB_TOG_CH0DLY7(base, value) (PDB_WR_CH0DLY7(base, PDB_RD_CH0DLY7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH0DLY7 bitfields
 */

/*!
 * @name Register PDB_CH0DLY7, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH0DLY7_DLY field. */
#define PDB_RD_CH0DLY7_DLY(base) ((PDB_CH0DLY7_REG(base) & PDB_CH0DLY7_DLY_MASK) >> PDB_CH0DLY7_DLY_SHIFT)
#define PDB_BRD_CH0DLY7_DLY(base) (PDB_RD_CH0DLY7_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH0DLY7_DLY(base, value) (PDB_RMW_CH0DLY7(base, PDB_CH0DLY7_DLY_MASK, PDB_CH0DLY7_DLY(value)))
#define PDB_BWR_CH0DLY7_DLY(base, value) (PDB_WR_CH0DLY7_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1C1 - Channel n Control register 1
 ******************************************************************************/

/*!
 * @brief PDB_CH1C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register
 * control the functionality of each PDB channel operation.
 */
/*!
 * @name Constants and macros for entire PDB_CH1C1 register
 */
/*@{*/
#define PDB_RD_CH1C1(base)       (PDB_CH1C1_REG(base))
#define PDB_WR_CH1C1(base, value) (PDB_CH1C1_REG(base) = (value))
#define PDB_RMW_CH1C1(base, mask, value) (PDB_WR_CH1C1(base, (PDB_RD_CH1C1(base) & ~(mask)) | (value)))
#define PDB_SET_CH1C1(base, value) (PDB_WR_CH1C1(base, PDB_RD_CH1C1(base) |  (value)))
#define PDB_CLR_CH1C1(base, value) (PDB_WR_CH1C1(base, PDB_RD_CH1C1(base) & ~(value)))
#define PDB_TOG_CH1C1(base, value) (PDB_WR_CH1C1(base, PDB_RD_CH1C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1C1 bitfields
 */

/*!
 * @name Register PDB_CH1C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger
 * bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1C1_EN field. */
#define PDB_RD_CH1C1_EN(base) ((PDB_CH1C1_REG(base) & PDB_CH1C1_EN_MASK) >> PDB_CH1C1_EN_SHIFT)
#define PDB_BRD_CH1C1_EN(base) (PDB_RD_CH1C1_EN(base))

/*! @brief Set the EN field to a new value. */
#define PDB_WR_CH1C1_EN(base, value) (PDB_RMW_CH1C1(base, PDB_CH1C1_EN_MASK, PDB_CH1C1_EN(value)))
#define PDB_BWR_CH1C1_EN(base, value) (PDB_WR_CH1C1_EN(base, value))
/*@}*/

/*!
 * @name Register PDB_CH1C1, field TOS[15:8] (RW)
 *
 * Selects the PDB ADC pre-trigger outputs. Only lower M pre-trigger fields are
 * implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger is in bypassed mode.
 *     The pre-trigger asserts one peripheral clock cycle after a rising edge is
 *     detected on selected trigger input source or software trigger is selected
 *     and SWTRIG is written with 1.
 * - 0b00000001 - PDB channel's corresponding pre-trigger asserts when the
 *     counter reaches the channel delay register and one peripheral clock cycle after
 *     a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SETRIG is written with 1.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1C1_TOS field. */
#define PDB_RD_CH1C1_TOS(base) ((PDB_CH1C1_REG(base) & PDB_CH1C1_TOS_MASK) >> PDB_CH1C1_TOS_SHIFT)
#define PDB_BRD_CH1C1_TOS(base) (PDB_RD_CH1C1_TOS(base))

/*! @brief Set the TOS field to a new value. */
#define PDB_WR_CH1C1_TOS(base, value) (PDB_RMW_CH1C1(base, PDB_CH1C1_TOS_MASK, PDB_CH1C1_TOS(value)))
#define PDB_BWR_CH1C1_TOS(base, value) (PDB_WR_CH1C1_TOS(base, value))
/*@}*/

/*!
 * @name Register PDB_CH1C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode.
 * Only lower M pre-trigger bits are implemented in this MCU. Back-to-back operation
 * enables the ADC conversions complete to trigger the next PDB channel
 * pre-trigger and trigger output, so that the ADC conversions can be triggered on next
 * set of configuration and results registers. Application code must only enable
 * the back-to-back operation of the PDB pre-triggers at the leading of the
 * back-to-back connection chain.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger back-to-back operation
 *     disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger back-to-back operation
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1C1_BB field. */
#define PDB_RD_CH1C1_BB(base) ((PDB_CH1C1_REG(base) & PDB_CH1C1_BB_MASK) >> PDB_CH1C1_BB_SHIFT)
#define PDB_BRD_CH1C1_BB(base) (PDB_RD_CH1C1_BB(base))

/*! @brief Set the BB field to a new value. */
#define PDB_WR_CH1C1_BB(base, value) (PDB_RMW_CH1C1(base, PDB_CH1C1_BB_MASK, PDB_CH1C1_BB(value)))
#define PDB_BWR_CH1C1_BB(base, value) (PDB_WR_CH1C1_BB(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1S - Channel n Status register
 ******************************************************************************/

/*!
 * @brief PDB_CH1S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1S register
 */
/*@{*/
#define PDB_RD_CH1S(base)        (PDB_CH1S_REG(base))
#define PDB_WR_CH1S(base, value) (PDB_CH1S_REG(base) = (value))
#define PDB_RMW_CH1S(base, mask, value) (PDB_WR_CH1S(base, (PDB_RD_CH1S(base) & ~(mask)) | (value)))
#define PDB_SET_CH1S(base, value) (PDB_WR_CH1S(base, PDB_RD_CH1S(base) |  (value)))
#define PDB_CLR_CH1S(base, value) (PDB_WR_CH1S(base, PDB_RD_CH1S(base) & ~(value)))
#define PDB_TOG_CH1S(base, value) (PDB_WR_CH1S(base, PDB_RD_CH1S(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1S bitfields
 */

/*!
 * @name Register PDB_CH1S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - Sequence error not detected on PDB channel's corresponding
 *     pre-trigger.
 * - 0b00000001 - Sequence error detected on PDB channel's corresponding
 *     pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from
 *     PDB channel n. When one conversion, which is triggered by one of the
 *     pre-triggers from PDB channel n, is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is
 *     set. Writing 0's to clear the sequence error flags.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1S_ERR field. */
#define PDB_RD_CH1S_ERR(base) ((PDB_CH1S_REG(base) & PDB_CH1S_ERR_MASK) >> PDB_CH1S_ERR_SHIFT)
#define PDB_BRD_CH1S_ERR(base) (PDB_RD_CH1S_ERR(base))

/*! @brief Set the ERR field to a new value. */
#define PDB_WR_CH1S_ERR(base, value) (PDB_RMW_CH1S(base, PDB_CH1S_ERR_MASK, PDB_CH1S_ERR(value)))
#define PDB_BWR_CH1S_ERR(base, value) (PDB_WR_CH1S_ERR(base, value))
/*@}*/

/*!
 * @name Register PDB_CH1S, field CF[23:16] (RW)
 *
 * The CF[m] bit is set when the PDB counter matches the CHnDLYm. Write 0 to
 * clear these bits.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1S_CF field. */
#define PDB_RD_CH1S_CF(base) ((PDB_CH1S_REG(base) & PDB_CH1S_CF_MASK) >> PDB_CH1S_CF_SHIFT)
#define PDB_BRD_CH1S_CF(base) (PDB_RD_CH1S_CF(base))

/*! @brief Set the CF field to a new value. */
#define PDB_WR_CH1S_CF(base, value) (PDB_RMW_CH1S(base, PDB_CH1S_CF_MASK, PDB_CH1S_CF(value)))
#define PDB_BWR_CH1S_CF(base, value) (PDB_WR_CH1S_CF(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY0 - Channel n Delay 0 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY0 - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY0 register
 */
/*@{*/
#define PDB_RD_CH1DLY0(base)     (PDB_CH1DLY0_REG(base))
#define PDB_WR_CH1DLY0(base, value) (PDB_CH1DLY0_REG(base) = (value))
#define PDB_RMW_CH1DLY0(base, mask, value) (PDB_WR_CH1DLY0(base, (PDB_RD_CH1DLY0(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY0(base, value) (PDB_WR_CH1DLY0(base, PDB_RD_CH1DLY0(base) |  (value)))
#define PDB_CLR_CH1DLY0(base, value) (PDB_WR_CH1DLY0(base, PDB_RD_CH1DLY0(base) & ~(value)))
#define PDB_TOG_CH1DLY0(base, value) (PDB_WR_CH1DLY0(base, PDB_RD_CH1DLY0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY0 bitfields
 */

/*!
 * @name Register PDB_CH1DLY0, field DLY[15:0] (RW)
 *
 * Specifies the delay value for the channel's corresponding pre-trigger. The
 * pre-trigger asserts when the counter is equal to DLY. Reading this field returns
 * the value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY0_DLY field. */
#define PDB_RD_CH1DLY0_DLY(base) ((PDB_CH1DLY0_REG(base) & PDB_CH1DLY0_DLY_MASK) >> PDB_CH1DLY0_DLY_SHIFT)
#define PDB_BRD_CH1DLY0_DLY(base) (PDB_RD_CH1DLY0_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY0_DLY(base, value) (PDB_RMW_CH1DLY0(base, PDB_CH1DLY0_DLY_MASK, PDB_CH1DLY0_DLY(value)))
#define PDB_BWR_CH1DLY0_DLY(base, value) (PDB_WR_CH1DLY0_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY1 - Channel n Delay 1 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY1 - Channel n Delay 1 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY1 register
 */
/*@{*/
#define PDB_RD_CH1DLY1(base)     (PDB_CH1DLY1_REG(base))
#define PDB_WR_CH1DLY1(base, value) (PDB_CH1DLY1_REG(base) = (value))
#define PDB_RMW_CH1DLY1(base, mask, value) (PDB_WR_CH1DLY1(base, (PDB_RD_CH1DLY1(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY1(base, value) (PDB_WR_CH1DLY1(base, PDB_RD_CH1DLY1(base) |  (value)))
#define PDB_CLR_CH1DLY1(base, value) (PDB_WR_CH1DLY1(base, PDB_RD_CH1DLY1(base) & ~(value)))
#define PDB_TOG_CH1DLY1(base, value) (PDB_WR_CH1DLY1(base, PDB_RD_CH1DLY1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY1 bitfields
 */

/*!
 * @name Register PDB_CH1DLY1, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY1_DLY field. */
#define PDB_RD_CH1DLY1_DLY(base) ((PDB_CH1DLY1_REG(base) & PDB_CH1DLY1_DLY_MASK) >> PDB_CH1DLY1_DLY_SHIFT)
#define PDB_BRD_CH1DLY1_DLY(base) (PDB_RD_CH1DLY1_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY1_DLY(base, value) (PDB_RMW_CH1DLY1(base, PDB_CH1DLY1_DLY_MASK, PDB_CH1DLY1_DLY(value)))
#define PDB_BWR_CH1DLY1_DLY(base, value) (PDB_WR_CH1DLY1_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY2 - Channel n Delay 2 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY2 - Channel n Delay 2 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY2 register
 */
/*@{*/
#define PDB_RD_CH1DLY2(base)     (PDB_CH1DLY2_REG(base))
#define PDB_WR_CH1DLY2(base, value) (PDB_CH1DLY2_REG(base) = (value))
#define PDB_RMW_CH1DLY2(base, mask, value) (PDB_WR_CH1DLY2(base, (PDB_RD_CH1DLY2(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY2(base, value) (PDB_WR_CH1DLY2(base, PDB_RD_CH1DLY2(base) |  (value)))
#define PDB_CLR_CH1DLY2(base, value) (PDB_WR_CH1DLY2(base, PDB_RD_CH1DLY2(base) & ~(value)))
#define PDB_TOG_CH1DLY2(base, value) (PDB_WR_CH1DLY2(base, PDB_RD_CH1DLY2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY2 bitfields
 */

/*!
 * @name Register PDB_CH1DLY2, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY2_DLY field. */
#define PDB_RD_CH1DLY2_DLY(base) ((PDB_CH1DLY2_REG(base) & PDB_CH1DLY2_DLY_MASK) >> PDB_CH1DLY2_DLY_SHIFT)
#define PDB_BRD_CH1DLY2_DLY(base) (PDB_RD_CH1DLY2_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY2_DLY(base, value) (PDB_RMW_CH1DLY2(base, PDB_CH1DLY2_DLY_MASK, PDB_CH1DLY2_DLY(value)))
#define PDB_BWR_CH1DLY2_DLY(base, value) (PDB_WR_CH1DLY2_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY3 - Channel n Delay 3 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY3 - Channel n Delay 3 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY3 register
 */
/*@{*/
#define PDB_RD_CH1DLY3(base)     (PDB_CH1DLY3_REG(base))
#define PDB_WR_CH1DLY3(base, value) (PDB_CH1DLY3_REG(base) = (value))
#define PDB_RMW_CH1DLY3(base, mask, value) (PDB_WR_CH1DLY3(base, (PDB_RD_CH1DLY3(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY3(base, value) (PDB_WR_CH1DLY3(base, PDB_RD_CH1DLY3(base) |  (value)))
#define PDB_CLR_CH1DLY3(base, value) (PDB_WR_CH1DLY3(base, PDB_RD_CH1DLY3(base) & ~(value)))
#define PDB_TOG_CH1DLY3(base, value) (PDB_WR_CH1DLY3(base, PDB_RD_CH1DLY3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY3 bitfields
 */

/*!
 * @name Register PDB_CH1DLY3, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY3_DLY field. */
#define PDB_RD_CH1DLY3_DLY(base) ((PDB_CH1DLY3_REG(base) & PDB_CH1DLY3_DLY_MASK) >> PDB_CH1DLY3_DLY_SHIFT)
#define PDB_BRD_CH1DLY3_DLY(base) (PDB_RD_CH1DLY3_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY3_DLY(base, value) (PDB_RMW_CH1DLY3(base, PDB_CH1DLY3_DLY_MASK, PDB_CH1DLY3_DLY(value)))
#define PDB_BWR_CH1DLY3_DLY(base, value) (PDB_WR_CH1DLY3_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY4 - Channel n Delay 4 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY4 - Channel n Delay 4 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY4 register
 */
/*@{*/
#define PDB_RD_CH1DLY4(base)     (PDB_CH1DLY4_REG(base))
#define PDB_WR_CH1DLY4(base, value) (PDB_CH1DLY4_REG(base) = (value))
#define PDB_RMW_CH1DLY4(base, mask, value) (PDB_WR_CH1DLY4(base, (PDB_RD_CH1DLY4(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY4(base, value) (PDB_WR_CH1DLY4(base, PDB_RD_CH1DLY4(base) |  (value)))
#define PDB_CLR_CH1DLY4(base, value) (PDB_WR_CH1DLY4(base, PDB_RD_CH1DLY4(base) & ~(value)))
#define PDB_TOG_CH1DLY4(base, value) (PDB_WR_CH1DLY4(base, PDB_RD_CH1DLY4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY4 bitfields
 */

/*!
 * @name Register PDB_CH1DLY4, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY4_DLY field. */
#define PDB_RD_CH1DLY4_DLY(base) ((PDB_CH1DLY4_REG(base) & PDB_CH1DLY4_DLY_MASK) >> PDB_CH1DLY4_DLY_SHIFT)
#define PDB_BRD_CH1DLY4_DLY(base) (PDB_RD_CH1DLY4_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY4_DLY(base, value) (PDB_RMW_CH1DLY4(base, PDB_CH1DLY4_DLY_MASK, PDB_CH1DLY4_DLY(value)))
#define PDB_BWR_CH1DLY4_DLY(base, value) (PDB_WR_CH1DLY4_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY5 - Channel n Delay 5 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY5 - Channel n Delay 5 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY5 register
 */
/*@{*/
#define PDB_RD_CH1DLY5(base)     (PDB_CH1DLY5_REG(base))
#define PDB_WR_CH1DLY5(base, value) (PDB_CH1DLY5_REG(base) = (value))
#define PDB_RMW_CH1DLY5(base, mask, value) (PDB_WR_CH1DLY5(base, (PDB_RD_CH1DLY5(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY5(base, value) (PDB_WR_CH1DLY5(base, PDB_RD_CH1DLY5(base) |  (value)))
#define PDB_CLR_CH1DLY5(base, value) (PDB_WR_CH1DLY5(base, PDB_RD_CH1DLY5(base) & ~(value)))
#define PDB_TOG_CH1DLY5(base, value) (PDB_WR_CH1DLY5(base, PDB_RD_CH1DLY5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY5 bitfields
 */

/*!
 * @name Register PDB_CH1DLY5, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY5_DLY field. */
#define PDB_RD_CH1DLY5_DLY(base) ((PDB_CH1DLY5_REG(base) & PDB_CH1DLY5_DLY_MASK) >> PDB_CH1DLY5_DLY_SHIFT)
#define PDB_BRD_CH1DLY5_DLY(base) (PDB_RD_CH1DLY5_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY5_DLY(base, value) (PDB_RMW_CH1DLY5(base, PDB_CH1DLY5_DLY_MASK, PDB_CH1DLY5_DLY(value)))
#define PDB_BWR_CH1DLY5_DLY(base, value) (PDB_WR_CH1DLY5_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY6 - Channel n Delay 6 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY6 - Channel n Delay 6 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY6 register
 */
/*@{*/
#define PDB_RD_CH1DLY6(base)     (PDB_CH1DLY6_REG(base))
#define PDB_WR_CH1DLY6(base, value) (PDB_CH1DLY6_REG(base) = (value))
#define PDB_RMW_CH1DLY6(base, mask, value) (PDB_WR_CH1DLY6(base, (PDB_RD_CH1DLY6(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY6(base, value) (PDB_WR_CH1DLY6(base, PDB_RD_CH1DLY6(base) |  (value)))
#define PDB_CLR_CH1DLY6(base, value) (PDB_WR_CH1DLY6(base, PDB_RD_CH1DLY6(base) & ~(value)))
#define PDB_TOG_CH1DLY6(base, value) (PDB_WR_CH1DLY6(base, PDB_RD_CH1DLY6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY6 bitfields
 */

/*!
 * @name Register PDB_CH1DLY6, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY6_DLY field. */
#define PDB_RD_CH1DLY6_DLY(base) ((PDB_CH1DLY6_REG(base) & PDB_CH1DLY6_DLY_MASK) >> PDB_CH1DLY6_DLY_SHIFT)
#define PDB_BRD_CH1DLY6_DLY(base) (PDB_RD_CH1DLY6_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY6_DLY(base, value) (PDB_RMW_CH1DLY6(base, PDB_CH1DLY6_DLY_MASK, PDB_CH1DLY6_DLY(value)))
#define PDB_BWR_CH1DLY6_DLY(base, value) (PDB_WR_CH1DLY6_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CH1DLY7 - Channel n Delay 7 register
 ******************************************************************************/

/*!
 * @brief PDB_CH1DLY7 - Channel n Delay 7 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CH1DLY7 register
 */
/*@{*/
#define PDB_RD_CH1DLY7(base)     (PDB_CH1DLY7_REG(base))
#define PDB_WR_CH1DLY7(base, value) (PDB_CH1DLY7_REG(base) = (value))
#define PDB_RMW_CH1DLY7(base, mask, value) (PDB_WR_CH1DLY7(base, (PDB_RD_CH1DLY7(base) & ~(mask)) | (value)))
#define PDB_SET_CH1DLY7(base, value) (PDB_WR_CH1DLY7(base, PDB_RD_CH1DLY7(base) |  (value)))
#define PDB_CLR_CH1DLY7(base, value) (PDB_WR_CH1DLY7(base, PDB_RD_CH1DLY7(base) & ~(value)))
#define PDB_TOG_CH1DLY7(base, value) (PDB_WR_CH1DLY7(base, PDB_RD_CH1DLY7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_CH1DLY7 bitfields
 */

/*!
 * @name Register PDB_CH1DLY7, field DLY[15:0] (RW)
 *
 * These bits specify the delay value for the channel's corresponding
 * pre-trigger. The pre-trigger asserts when the counter is equal to DLY. Reading these
 * bits returns the value of internal register that is effective for the current PDB
 * cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_CH1DLY7_DLY field. */
#define PDB_RD_CH1DLY7_DLY(base) ((PDB_CH1DLY7_REG(base) & PDB_CH1DLY7_DLY_MASK) >> PDB_CH1DLY7_DLY_SHIFT)
#define PDB_BRD_CH1DLY7_DLY(base) (PDB_RD_CH1DLY7_DLY(base))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_CH1DLY7_DLY(base, value) (PDB_RMW_CH1DLY7(base, PDB_CH1DLY7_DLY_MASK, PDB_CH1DLY7_DLY(value)))
#define PDB_BWR_CH1DLY7_DLY(base, value) (PDB_WR_CH1DLY7_DLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_POEN - Pulse-Out n Enable register
 ******************************************************************************/

/*!
 * @brief PDB_POEN - Pulse-Out n Enable register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_POEN register
 */
/*@{*/
#define PDB_RD_POEN(base)        (PDB_POEN_REG(base))
#define PDB_WR_POEN(base, value) (PDB_POEN_REG(base) = (value))
#define PDB_RMW_POEN(base, mask, value) (PDB_WR_POEN(base, (PDB_RD_POEN(base) & ~(mask)) | (value)))
#define PDB_SET_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) |  (value)))
#define PDB_CLR_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) & ~(value)))
#define PDB_TOG_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_POEN bitfields
 */

/*!
 * @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * Enables the pulse output. Only lower Y bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB Pulse-Out disabled
 * - 0b00000001 - PDB Pulse-Out enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_POEN_POEN field. */
#define PDB_RD_POEN_POEN(base) ((PDB_POEN_REG(base) & PDB_POEN_POEN_MASK) >> PDB_POEN_POEN_SHIFT)
#define PDB_BRD_POEN_POEN(base) (PDB_RD_POEN_POEN(base))

/*! @brief Set the POEN field to a new value. */
#define PDB_WR_POEN_POEN(base, value) (PDB_RMW_POEN(base, PDB_POEN_POEN_MASK, PDB_POEN_POEN(value)))
#define PDB_BWR_POEN_POEN(base, value) (PDB_WR_POEN_POEN(base, value))
/*@}*/

/*******************************************************************************
 * PDB_PODLY - Pulse-Out n Delay register
 ******************************************************************************/

/*!
 * @brief PDB_PODLY - Pulse-Out n Delay register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_PODLY register
 */
/*@{*/
#define PDB_RD_PODLY(base, index) (PDB_PODLY_REG(base, index))
#define PDB_WR_PODLY(base, index, value) (PDB_PODLY_REG(base, index) = (value))
#define PDB_RMW_PODLY(base, index, mask, value) (PDB_WR_PODLY(base, index, (PDB_RD_PODLY(base, index) & ~(mask)) | (value)))
#define PDB_SET_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) |  (value)))
#define PDB_CLR_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) & ~(value)))
#define PDB_TOG_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_PODLY bitfields
 */

/*!
 * @name Register PDB_PODLY, field DLY2[15:0] (RW)
 *
 * These bits specify the delay 2 value for the PDB Pulse-Out. Pulse-Out goes
 * low when the PDB counter is equal to the DLY2. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY2 field. */
#define PDB_RD_PODLY_DLY2(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY2_MASK) >> PDB_PODLY_DLY2_SHIFT)
#define PDB_BRD_PODLY_DLY2(base, index) (PDB_RD_PODLY_DLY2(base, index))

/*! @brief Set the DLY2 field to a new value. */
#define PDB_WR_PODLY_DLY2(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY2_MASK, PDB_PODLY_DLY2(value)))
#define PDB_BWR_PODLY_DLY2(base, index, value) (PDB_WR_PODLY_DLY2(base, index, value))
/*@}*/

/*!
 * @name Register PDB_PODLY, field DLY1[31:16] (RW)
 *
 * These bits specify the delay 1 value for the PDB Pulse-Out. Pulse-Out goes
 * high when the PDB counter is equal to the DLY1. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY1 field. */
#define PDB_RD_PODLY_DLY1(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY1_MASK) >> PDB_PODLY_DLY1_SHIFT)
#define PDB_BRD_PODLY_DLY1(base, index) (PDB_RD_PODLY_DLY1(base, index))

/*! @brief Set the DLY1 field to a new value. */
#define PDB_WR_PODLY_DLY1(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY1_MASK, PDB_PODLY_DLY1(value)))
#define PDB_BWR_PODLY_DLY1(base, index, value) (PDB_WR_PODLY_DLY1(base, index, value))
/*@}*/

/*
 * S32K144 PMC
 *
 * PMC
 *
 * Registers defined in this header file:
 * - PMC_LVDSC1 - Low Voltage Detect Status and Control 1 Register
 * - PMC_LVDSC2 - Low Voltage Detect Status and Control 2 Register
 * - PMC_REGSC - Regulator Status and Control Register
 * - PMC_LPOTRIM - Low Power Oscillator Trim Register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status and Control 1 Register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status and Control 1 Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. When the internal voltage regulator is in lowe power mode, the
 * LVD system is disabled, regardless of the PMC_LVDSC1 settings.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) |  (value)))
#define PMC_CLR_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) & ~(value)))
#define PMC_TOG_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This bit enables the low voltage detect events to generate a system reset.
 *
 * Values:
 * - 0b0 - No system resets on low voltage detect events.
 * - 0b1 - If the supply voltage falls below VLVD, a system reset will be
 *     generated.
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * This bit enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WO)
 *
 * This write-only bit is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Read always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (PMC_WR_LVDSC1_LVDACK(base, value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This bit's read-only status bit indicates a low-voltage detect event. The
 * threshold voltage is VLVD.
 *
 * Values:
 * - 0b0 - Low-voltage event not detected
 * - 0b1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status and Control 2 Register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status and Control 2 Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning (LVW) function. When the internal voltage regulator is in low power mode,
 * the LVD system is disabled regardless of the PMC_LVDSC2 settings.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) |  (value)))
#define PMC_CLR_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) & ~(value)))
#define PMC_TOG_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * This bit enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVWF=1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVDWCK[6] (WO)
 *
 * This write-only bit is used to acknowledge low voltage warning errors. Write
 * 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDWCK field to a new value. */
#define PMC_WR_LVDSC2_LVDWCK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVDWCK_MASK, PMC_LVDSC2_LVDWCK(value)))
#define PMC_BWR_LVDSC2_LVDWCK(base, value) (PMC_WR_LVDSC2_LVDWCK(base, value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This bit read-only status bit indicates a low-voltage detect event. The
 * threshold voltage is VLVW.
 *
 * Values:
 * - 0b0 - Low-voltage warning event not detected
 * - 0b1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status and Control Register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status and Control Register (RW)
 *
 * Reset value: 0x04U
 *
 * This register contains general control and status bits for the regulator and
 * the LPO.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) |  (value)))
#define PMC_CLR_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) & ~(value)))
#define PMC_TOG_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BIASEN[0] (RW)
 *
 * This bit enables source and well biasing for the core logic in low power
 * mode. In full performance mode this bit has no effect. This is useful to further
 * reduce MCU power consumption in low power mode.
 *
 * Values:
 * - 0b0 - Biasing disabled, core logic can run in full performance
 * - 0b0 - Biasing enabled, core logic is slower and there are restrictions in
 *     allowed system clock speed (see device level specification for details)
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BIASEN field. */
#define PMC_RD_REGSC_BIASEN(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BIASEN_MASK) >> PMC_REGSC_BIASEN_SHIFT)
#define PMC_BRD_REGSC_BIASEN(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BIASEN_SHIFT))

/*! @brief Set the BIASEN field to a new value. */
#define PMC_WR_REGSC_BIASEN(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_BIASEN_MASK, PMC_REGSC_BIASEN(value)))
#define PMC_BWR_REGSC_BIASEN(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BIASEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGFPM[2] (RW)
 *
 * This read-only bit provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0b0 - Regulator is in low power mode or transition to/from
 * - 0b0 - Regulator is in full performance mode
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGFPM field. */
#define PMC_RD_REGSC_REGFPM(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGFPM_MASK) >> PMC_REGSC_REGFPM_SHIFT)
#define PMC_BRD_REGSC_REGFPM(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_REGFPM_SHIFT))

/*! @brief Set the REGFPM field to a new value. */
#define PMC_WR_REGSC_REGFPM(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_REGFPM_MASK, PMC_REGSC_REGFPM(value)))
#define PMC_BWR_REGSC_REGFPM(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_REGFPM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_REGSC, field LPOSTAT[6] (RO)
 *
 * This bit shows the status of the LPO clock to be either in high phase or low
 * phase. Software can poll this status bit to measure actual LOP clock frequency
 * and eventually use the LPOTRIM[4:0] register to change the LPO frequency.
 *
 * Values:
 * - 0b0 - Low power oscillator in low phase
 * - 0b0 - Low power oscillator in high phase
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_LPOSTAT field. */
#define PMC_RD_REGSC_LPOSTAT(base) ((PMC_REGSC_REG(base) & PMC_REGSC_LPOSTAT_MASK) >> PMC_REGSC_LPOSTAT_SHIFT)
#define PMC_BRD_REGSC_LPOSTAT(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_LPOSTAT_SHIFT))
/*@}*/

/*!
 * @name Register PMC_REGSC, field LPODIS[7] (RW)
 *
 * This bit enables or disable the low power oscillator. After disabling the LPO
 * a time of 2 LPO clock cycles is required before it is allowed to enable it
 * again. Violating this waiting time of 2 cycles can result in malfunction of the
 * LPO.
 *
 * Values:
 * - 0b0 - Low power oscillator disabled
 * - 0b1 - Low power oscillator enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_LPODIS field. */
#define PMC_RD_REGSC_LPODIS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_LPODIS_MASK) >> PMC_REGSC_LPODIS_SHIFT)
#define PMC_BRD_REGSC_LPODIS(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_LPODIS_SHIFT))

/*! @brief Set the LPODIS field to a new value. */
#define PMC_WR_REGSC_LPODIS(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_LPODIS_MASK, PMC_REGSC_LPODIS(value)))
#define PMC_BWR_REGSC_LPODIS(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_LPODIS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PMC_LPOTRIM - Low Power Oscillator Trim Register
 ******************************************************************************/

/*!
 * @brief PMC_LPOTRIM - Low Power Oscillator Trim Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the period trimming bits for the low power oscillator.
 * Trimming effect of LPOTRIM[4:0] LPOTRIM[4:0] Decimal Period of LPO clock
 * 10000 -16 lowest 10001 -15 increasing ... ... 11110 -2 11111 -1 00000 0 typical
 * 128 kHz 00001 +1 increasing ... ... 01110 +14 01111 +15 highest
 */
/*!
 * @name Constants and macros for entire PMC_LPOTRIM register
 */
/*@{*/
#define PMC_RD_LPOTRIM(base)     (PMC_LPOTRIM_REG(base))
#define PMC_WR_LPOTRIM(base, value) (PMC_LPOTRIM_REG(base) = (value))
#define PMC_RMW_LPOTRIM(base, mask, value) (PMC_WR_LPOTRIM(base, (PMC_RD_LPOTRIM(base) & ~(mask)) | (value)))
#define PMC_SET_LPOTRIM(base, value) (PMC_WR_LPOTRIM(base, PMC_RD_LPOTRIM(base) |  (value)))
#define PMC_CLR_LPOTRIM(base, value) (PMC_WR_LPOTRIM(base, PMC_RD_LPOTRIM(base) & ~(value)))
#define PMC_TOG_LPOTRIM(base, value) (PMC_WR_LPOTRIM(base, PMC_RD_LPOTRIM(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LPOTRIM bitfields
 */

/*!
 * @name Register PMC_LPOTRIM, field LPOTRIM[4:0] (RW)
 *
 * These bits are used for trimming the frequency of the low power oscillator.
 * See the table above for trimming effect.
 */
/*@{*/
/*! @brief Read current value of the PMC_LPOTRIM_LPOTRIM field. */
#define PMC_RD_LPOTRIM_LPOTRIM(base) ((PMC_LPOTRIM_REG(base) & PMC_LPOTRIM_LPOTRIM_MASK) >> PMC_LPOTRIM_LPOTRIM_SHIFT)
#define PMC_BRD_LPOTRIM_LPOTRIM(base) (PMC_RD_LPOTRIM_LPOTRIM(base))

/*! @brief Set the LPOTRIM field to a new value. */
#define PMC_WR_LPOTRIM_LPOTRIM(base, value) (PMC_RMW_LPOTRIM(base, PMC_LPOTRIM_LPOTRIM_MASK, PMC_LPOTRIM_LPOTRIM(value)))
#define PMC_BWR_LPOTRIM_LPOTRIM(base, value) (PMC_WR_LPOTRIM_LPOTRIM(base, value))
/*@}*/

/*
 * S32K144 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 * - PORT_DFER - Digital Filter Enable Register
 * - PORT_DFCR - Digital Filter Clock Register
 * - PORT_DFWR - Digital Filter Width Register
 */

#define PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */
#define PORTD_IDX (3U) /*!< Instance number for PORTD. */
#define PORTE_IDX (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000002U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) |  (value)))
#define PORT_CLR_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) & ~(value)))
#define PORT_TOG_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pulldown resistor is enabled on the corresponding pin, if
 *     the corresponding PE field is set.
 * - 0b1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 0b1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 0b1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field PFE[4] (RW)
 *
 * Passive filter configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Passive input filter is disabled on the corresponding pin.
 * - 0b1 - Passive input filter is enabled on the corresponding pin, if the pin
 *     is configured as a digital input. Refer to the device data sheet for
 *     filter characteristics.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PFE field. */
#define PORT_RD_PCR_PFE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PFE_MASK) >> PORT_PCR_PFE_SHIFT)
#define PORT_BRD_PCR_PFE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT))

/*! @brief Set the PFE field to a new value. */
#define PORT_WR_PCR_PFE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PFE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PFE(value)))
#define PORT_BWR_PCR_PFE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field ODE[5] (RW)
 *
 * Open drain configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Open drain output is disabled on the corresponding pin.
 * - 0b1 - Open drain output is enabled on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ODE field. */
#define PORT_RD_PCR_ODE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ODE_MASK) >> PORT_PCR_ODE_SHIFT)
#define PORT_BRD_PCR_ODE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT))

/*! @brief Set the ODE field to a new value. */
#define PORT_WR_PCR_ODE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_ODE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_ODE(value)))
#define PORT_BWR_PCR_ODE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field DSE[6] (RW)
 *
 * Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 0b1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_DSE field. */
#define PORT_RD_PCR_DSE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_DSE_MASK) >> PORT_PCR_DSE_SHIFT)
#define PORT_BRD_PCR_DSE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT))

/*! @brief Set the DSE field to a new value. */
#define PORT_WR_PCR_DSE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_DSE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_DSE(value)))
#define PORT_BWR_PCR_DSE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[10:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 0b000 - Pin disabled (analog).
 * - 0b001 - Alternative 1 (GPIO).
 * - 0b010 - Alternative 2 (chip-specific).
 * - 0b011 - Alternative 3 (chip-specific).
 * - 0b100 - Alternative 4 (chip-specific).
 * - 0b101 - Alternative 5 (chip-specific).
 * - 0b110 - Alternative 6 (chip-specific).
 * - 0b111 - Alternative 7 (chip-specific).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (PORT_RD_PCR_MUX(base, index))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (PORT_WR_PCR_MUX(base, index, value))
/*@}*/

/*!
 * @name Register PORT_PCR, field LK[15] (RW)
 *
 * Values:
 * - 0b0 - Pin Control Register fields [15:0] are not locked.
 * - 0b1 - Pin Control Register fields [15:0] are locked and cannot be updated
 *     until the next system reset.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_LK field. */
#define PORT_RD_PCR_LK(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_LK_MASK) >> PORT_PCR_LK_SHIFT)
#define PORT_BRD_PCR_LK(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define PORT_WR_PCR_LK(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_LK_MASK | PORT_PCR_ISF_MASK), PORT_PCR_LK(value)))
#define PORT_BWR_PCR_LK(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0b0000 - Interrupt Status Flag (ISF) is disabled.
 * - 0b0001 - ISF flag and DMA request on rising edge.
 * - 0b0010 - ISF flag and DMA request on falling edge.
 * - 0b0011 - ISF flag and DMA request on either edge.
 * - 0b0100 - Reserved.
 * - 0b0101 - Reserved.
 * - 0b0110 - Reserved.
 * - 0b0111 - Reserved.
 * - 0b1000 - ISF flag and Interrupt when logic 0.
 * - 0b1001 - ISF flag and Interrupt on rising-edge.
 * - 0b1010 - ISF flag and Interrupt on falling-edge.
 * - 0b1011 - ISF flag and Interrupt on either edge.
 * - 0b1100 - ISF flag and Interrupt when logic 1.
 * - 0b1101 - Reserved.
 * - 0b1110 - Reserved.
 * - 0b1111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (PORT_RD_PCR_IRQC(base, index))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (PORT_WR_PCR_IRQC(base, index, value))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Configured interrupt is not detected.
 * - 0b1 - Configured interrupt is detected. If the pin is configured to
 *     generate a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured
 *     for a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (PORT_WR_GPCLR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (PORT_WR_GPCLR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (PORT_WR_GPCHR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (PORT_WR_GPCHR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * Interrupt Status Flag for each pin is also visible in the corresponding Pin
 * Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) |  (value)))
#define PORT_CLR_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) & ~(value)))
#define PORT_TOG_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * PORT_DFER - Digital Filter Enable Register
 ******************************************************************************/

/*!
 * @brief PORT_DFER - Digital Filter Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFER register
 */
/*@{*/
#define PORT_RD_DFER(base)       (PORT_DFER_REG(base))
#define PORT_WR_DFER(base, value) (PORT_DFER_REG(base) = (value))
#define PORT_RMW_DFER(base, mask, value) (PORT_WR_DFER(base, (PORT_RD_DFER(base) & ~(mask)) | (value)))
#define PORT_SET_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) |  (value)))
#define PORT_CLR_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) & ~(value)))
#define PORT_TOG_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * PORT_DFCR - Digital Filter Clock Register
 ******************************************************************************/

/*!
 * @brief PORT_DFCR - Digital Filter Clock Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFCR register
 */
/*@{*/
#define PORT_RD_DFCR(base)       (PORT_DFCR_REG(base))
#define PORT_WR_DFCR(base, value) (PORT_DFCR_REG(base) = (value))
#define PORT_RMW_DFCR(base, mask, value) (PORT_WR_DFCR(base, (PORT_RD_DFCR(base) & ~(mask)) | (value)))
#define PORT_SET_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) |  (value)))
#define PORT_CLR_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) & ~(value)))
#define PORT_TOG_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFCR bitfields
 */

/*!
 * @name Register PORT_DFCR, field CS[0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the clock source for the digital input filters. Changing the filter
 * clock source must be done only when all digital filters are disabled.
 *
 * Values:
 * - 0b0 - Digital filters are clocked by the bus clock.
 * - 0b1 - Digital filters are clocked by the LPO clock.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFCR_CS field. */
#define PORT_RD_DFCR_CS(base) ((PORT_DFCR_REG(base) & PORT_DFCR_CS_MASK) >> PORT_DFCR_CS_SHIFT)
#define PORT_BRD_DFCR_CS(base) (BITBAND_ACCESS32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT))

/*! @brief Set the CS field to a new value. */
#define PORT_WR_DFCR_CS(base, value) (PORT_RMW_DFCR(base, PORT_DFCR_CS_MASK, PORT_DFCR_CS(value)))
#define PORT_BWR_DFCR_CS(base, value) (BITBAND_ACCESS32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PORT_DFWR - Digital Filter Width Register
 ******************************************************************************/

/*!
 * @brief PORT_DFWR - Digital Filter Width Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFWR register
 */
/*@{*/
#define PORT_RD_DFWR(base)       (PORT_DFWR_REG(base))
#define PORT_WR_DFWR(base, value) (PORT_DFWR_REG(base) = (value))
#define PORT_RMW_DFWR(base, mask, value) (PORT_WR_DFWR(base, (PORT_RD_DFWR(base) & ~(mask)) | (value)))
#define PORT_SET_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) |  (value)))
#define PORT_CLR_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) & ~(value)))
#define PORT_TOG_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFWR bitfields
 */

/*!
 * @name Register PORT_DFWR, field FILT[4:0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the maximum size of the glitches, in clock cycles, that the digital
 * filter absorbs for the enabled digital filters. Glitches that are longer than
 * this register setting will pass through the digital filter, and glitches that
 * are equal to or less than this register setting are filtered. Changing the
 * filter length must be done only after all filters are disabled.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFWR_FILT field. */
#define PORT_RD_DFWR_FILT(base) ((PORT_DFWR_REG(base) & PORT_DFWR_FILT_MASK) >> PORT_DFWR_FILT_SHIFT)
#define PORT_BRD_DFWR_FILT(base) (PORT_RD_DFWR_FILT(base))

/*! @brief Set the FILT field to a new value. */
#define PORT_WR_DFWR_FILT(base, value) (PORT_RMW_DFWR(base, PORT_DFWR_FILT_MASK, PORT_DFWR_FILT(value)))
#define PORT_BWR_DFWR_FILT(base, value) (PORT_WR_DFWR_FILT(base, value))
/*@}*/

/*
 * S32K144 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_VERID - Version ID Register
 * - RCM_PARAM - Parameter Register
 * - RCM_SRS - System Reset Status Register
 * - RCM_RPC - Reset Pin Control register
 * - RCM_MR - Mode Register
 * - RCM_FM - Force Mode Register
 * - RCM_SSRS - Sticky System Reset Status Register
 * - RCM_SRIE - System Reset Interrupt Enable Register
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief RCM_VERID - Version ID Register (RO)
 *
 * Reset value: 0x03000003U
 */
/*!
 * @name Constants and macros for entire RCM_VERID register
 */
/*@{*/
#define RCM_RD_VERID(base)       (RCM_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_VERID bitfields
 */

/*!
 * @name Register RCM_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000011 - Standard feature set.
 */
/*@{*/
/*! @brief Read current value of the RCM_VERID_FEATURE field. */
#define RCM_RD_VERID_FEATURE(base) ((RCM_VERID_REG(base) & RCM_VERID_FEATURE_MASK) >> RCM_VERID_FEATURE_SHIFT)
#define RCM_BRD_VERID_FEATURE(base) (RCM_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register RCM_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the RCM_VERID_MINOR field. */
#define RCM_RD_VERID_MINOR(base) ((RCM_VERID_REG(base) & RCM_VERID_MINOR_MASK) >> RCM_VERID_MINOR_SHIFT)
#define RCM_BRD_VERID_MINOR(base) (RCM_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register RCM_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the RCM_VERID_MAJOR field. */
#define RCM_RD_VERID_MAJOR(base) ((RCM_VERID_REG(base) & RCM_VERID_MAJOR_MASK) >> RCM_VERID_MAJOR_SHIFT)
#define RCM_BRD_VERID_MAJOR(base) (RCM_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * RCM_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief RCM_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RCM_PARAM register
 */
/*@{*/
#define RCM_RD_PARAM(base)       (RCM_PARAM_REG(base))
/*@}*/

/*******************************************************************************
 * RCM_SRS - System Reset Status Register
 ******************************************************************************/

/*!
 * @brief RCM_SRS - System Reset Status Register (RO)
 *
 * Reset value: 0x00000082U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 Other reset - a bit is set if
 * its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS register
 */
/*@{*/
#define RCM_RD_SRS(base)         (RCM_SRS_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS bitfields
 */

/*!
 * @name Register RCM_SRS, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. If PMC_HVDSC1[HVDRE] is set and the supply rises above
 * the HVD trip voltage, an HVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip, HVD trip or POR
 * - 0b1 - Reset caused by LVD trip, HVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LVD field. */
#define RCM_RD_SRS_LVD(base) ((RCM_SRS_REG(base) & RCM_SRS_LVD_MASK) >> RCM_SRS_LVD_SHIFT)
#define RCM_BRD_SRS_LVD(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_LVD_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The SCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed SCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LOC field. */
#define RCM_RD_SRS_LOC(base) ((RCM_SRS_REG(base) & RCM_SRS_LOC_MASK) >> RCM_SRS_LOC_SHIFT)
#define RCM_BRD_SRS_LOC(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_LOC_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field LOL[3] (RO)
 *
 * Indicates a reset has been caused by a loss of lock/clock in the SCG PLL.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LOL field. */
#define RCM_RD_SRS_LOL(base) ((RCM_SRS_REG(base) & RCM_SRS_LOL_MASK) >> RCM_SRS_LOL_SHIFT)
#define RCM_BRD_SRS_LOL(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_LOL_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_WDOG field. */
#define RCM_RD_SRS_WDOG(base) ((RCM_SRS_REG(base) & RCM_SRS_WDOG_MASK) >> RCM_SRS_WDOG_SHIFT)
#define RCM_BRD_SRS_WDOG(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_WDOG_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET (RESET_b) pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_PIN field. */
#define RCM_RD_SRS_PIN(base) ((RCM_SRS_REG(base) & RCM_SRS_PIN_MASK) >> RCM_SRS_PIN_SHIFT)
#define RCM_BRD_SRS_PIN(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_PIN_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_POR field. */
#define RCM_RD_SRS_POR(base) ((RCM_SRS_REG(base) & RCM_SRS_POR_MASK) >> RCM_SRS_POR_SHIFT)
#define RCM_BRD_SRS_POR(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_POR_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field LOCKUP[9] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LOCKUP field. */
#define RCM_RD_SRS_LOCKUP(base) ((RCM_SRS_REG(base) & RCM_SRS_LOCKUP_MASK) >> RCM_SRS_LOCKUP_SHIFT)
#define RCM_BRD_SRS_LOCKUP(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_LOCKUP_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field SW[10] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core. no
 * SYSRESETREQ bit in CM4 TRM ?
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_SW field. */
#define RCM_RD_SRS_SW(base)  ((RCM_SRS_REG(base) & RCM_SRS_SW_MASK) >> RCM_SRS_SW_SHIFT)
#define RCM_BRD_SRS_SW(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_SW_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS, field SACKERR[13] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_SACKERR field. */
#define RCM_RD_SRS_SACKERR(base) ((RCM_SRS_REG(base) & RCM_SRS_SACKERR_MASK) >> RCM_SRS_SACKERR_SHIFT)
#define RCM_BRD_SRS_SACKERR(base) (BITBAND_ACCESS32(&RCM_SRS_REG(base), RCM_SRS_SACKERR_SHIFT))
/*@}*/

/*******************************************************************************
 * RCM_RPC - Reset Pin Control register
 ******************************************************************************/

/*!
 * @brief RCM_RPC - Reset Pin Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is reset on Chip POR only, it is unaffected by other reset
 * types. The bus clock filter is reset when disabled or when entering stop mode. The
 * LPO filter is reset when disabled.
 */
/*!
 * @name Constants and macros for entire RCM_RPC register
 */
/*@{*/
#define RCM_RD_RPC(base)         (RCM_RPC_REG(base))
#define RCM_WR_RPC(base, value)  (RCM_RPC_REG(base) = (value))
#define RCM_RMW_RPC(base, mask, value) (RCM_WR_RPC(base, (RCM_RD_RPC(base) & ~(mask)) | (value)))
#define RCM_SET_RPC(base, value) (RCM_WR_RPC(base, RCM_RD_RPC(base) |  (value)))
#define RCM_CLR_RPC(base, value) (RCM_WR_RPC(base, RCM_RD_RPC(base) & ~(value)))
#define RCM_TOG_RPC(base, value) (RCM_WR_RPC(base, RCM_RD_RPC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPC bitfields
 */

/*!
 * @name Register RCM_RPC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 0b00 - All filtering disabled
 * - 0b01 - Bus clock filter enabled for normal operation
 * - 0b10 - LPO clock filter enabled for normal operation
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the RCM_RPC_RSTFLTSRW field. */
#define RCM_RD_RPC_RSTFLTSRW(base) ((RCM_RPC_REG(base) & RCM_RPC_RSTFLTSRW_MASK) >> RCM_RPC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPC_RSTFLTSRW(base) (RCM_RD_RPC_RSTFLTSRW(base))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPC_RSTFLTSRW(base, value) (RCM_RMW_RPC(base, RCM_RPC_RSTFLTSRW_MASK, RCM_RPC_RSTFLTSRW(value)))
#define RCM_BWR_RPC_RSTFLTSRW(base, value) (RCM_WR_RPC_RSTFLTSRW(base, value))
/*@}*/

/*!
 * @name Register RCM_RPC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in any stop mode.
 *
 * Values:
 * - 0b0 - All filtering disabled
 * - 0b1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPC_RSTFLTSS field. */
#define RCM_RD_RPC_RSTFLTSS(base) ((RCM_RPC_REG(base) & RCM_RPC_RSTFLTSS_MASK) >> RCM_RPC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPC_RSTFLTSS(base) (BITBAND_ACCESS32(&RCM_RPC_REG(base), RCM_RPC_RSTFLTSS_SHIFT))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPC_RSTFLTSS(base, value) (RCM_RMW_RPC(base, RCM_RPC_RSTFLTSS_MASK, RCM_RPC_RSTFLTSS(value)))
#define RCM_BWR_RPC_RSTFLTSS(base, value) (BITBAND_ACCESS32(&RCM_RPC_REG(base), RCM_RPC_RSTFLTSS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_RPC, field RSTFLTSEL[12:8] (RW)
 *
 * Selects the reset pin bus clock filter width. Transitions for less than
 * (RSTFLTSEL+1) bus clock cycles are always filtered, transitions equal to
 * (RSTFLTSEL+1) bus clock cycles may be filtered.
 */
/*@{*/
/*! @brief Read current value of the RCM_RPC_RSTFLTSEL field. */
#define RCM_RD_RPC_RSTFLTSEL(base) ((RCM_RPC_REG(base) & RCM_RPC_RSTFLTSEL_MASK) >> RCM_RPC_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPC_RSTFLTSEL(base) (RCM_RD_RPC_RSTFLTSEL(base))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPC_RSTFLTSEL(base, value) (RCM_RMW_RPC(base, RCM_RPC_RSTFLTSEL_MASK, RCM_RPC_RSTFLTSEL(value)))
#define RCM_BWR_RPC_RSTFLTSEL(base, value) (RCM_WR_RPC_RSTFLTSEL(base, value))
/*@}*/

/*******************************************************************************
 * RCM_MR - Mode Register
 ******************************************************************************/

/*!
 * @brief RCM_MR - Mode Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register includes status flags to indicate the state of the mode pins
 * during the last Chip Reset.
 */
/*!
 * @name Constants and macros for entire RCM_MR register
 */
/*@{*/
#define RCM_RD_MR(base)          (RCM_MR_REG(base))
#define RCM_WR_MR(base, value)   (RCM_MR_REG(base) = (value))
#define RCM_RMW_MR(base, mask, value) (RCM_WR_MR(base, (RCM_RD_MR(base) & ~(mask)) | (value)))
#define RCM_SET_MR(base, value)  (RCM_WR_MR(base, RCM_RD_MR(base) |  (value)))
#define RCM_CLR_MR(base, value)  (RCM_WR_MR(base, RCM_RD_MR(base) & ~(value)))
#define RCM_TOG_MR(base, value)  (RCM_WR_MR(base, RCM_RD_MR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_MR bitfields
 */

/*!
 * @name Register RCM_MR, field BOOTROM[2:1] (W1C)
 *
 * Indicates the boot source, the boot source remains set until the next System
 * Reset or software can write logic one to clear the corresponding mode bit.
 * While either bit is set, the NMI input is disabled and the vector table is
 * relocated to the ROM base address at $1C00_0000. These bits should be cleared by
 * writing logic one before executing any code from either Flash or SRAM.
 *
 * Values:
 * - 0b00 - Boot from Flash
 * - 0b01 - Boot from ROM due to BOOTCFG0 pin assertion
 * - 0b10 - Boot form ROM due to FOPT[7:6] configuration
 * - 0b11 - Boot from ROM due to both BOOTCFG0 pin assertion and FOPT[7:6]
 *     configuration
 */
/*@{*/
/*! @brief Read current value of the RCM_MR_BOOTROM field. */
#define RCM_RD_MR_BOOTROM(base) ((RCM_MR_REG(base) & RCM_MR_BOOTROM_MASK) >> RCM_MR_BOOTROM_SHIFT)
#define RCM_BRD_MR_BOOTROM(base) (RCM_RD_MR_BOOTROM(base))

/*! @brief Set the BOOTROM field to a new value. */
#define RCM_WR_MR_BOOTROM(base, value) (RCM_RMW_MR(base, RCM_MR_BOOTROM_MASK, RCM_MR_BOOTROM(value)))
#define RCM_BWR_MR_BOOTROM(base, value) (RCM_WR_MR_BOOTROM(base, value))
/*@}*/

/*******************************************************************************
 * RCM_FM - Force Mode Register
 ******************************************************************************/

/*!
 * @brief RCM_FM - Force Mode Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset values of the bits in the FORCEROM field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_FM register
 */
/*@{*/
#define RCM_RD_FM(base)          (RCM_FM_REG(base))
#define RCM_WR_FM(base, value)   (RCM_FM_REG(base) = (value))
#define RCM_RMW_FM(base, mask, value) (RCM_WR_FM(base, (RCM_RD_FM(base) & ~(mask)) | (value)))
#define RCM_SET_FM(base, value)  (RCM_WR_FM(base, RCM_RD_FM(base) |  (value)))
#define RCM_CLR_FM(base, value)  (RCM_WR_FM(base, RCM_RD_FM(base) & ~(value)))
#define RCM_TOG_FM(base, value)  (RCM_WR_FM(base, RCM_RD_FM(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_FM bitfields
 */

/*!
 * @name Register RCM_FM, field FORCEROM[2:1] (RW)
 *
 * When either bit is set, will force boot from ROM during all subsequent system
 * resets.
 *
 * Values:
 * - 0b00 - No effect
 * - 0b01 - Force boot from ROM with RCM_MR[1] set.
 * - 0b10 - Force boot from ROM with RCM_MR[2] set.
 * - 0b11 - Force boot from ROM with RCM_MR[2:1] set.
 */
/*@{*/
/*! @brief Read current value of the RCM_FM_FORCEROM field. */
#define RCM_RD_FM_FORCEROM(base) ((RCM_FM_REG(base) & RCM_FM_FORCEROM_MASK) >> RCM_FM_FORCEROM_SHIFT)
#define RCM_BRD_FM_FORCEROM(base) (RCM_RD_FM_FORCEROM(base))

/*! @brief Set the FORCEROM field to a new value. */
#define RCM_WR_FM_FORCEROM(base, value) (RCM_RMW_FM(base, RCM_FM_FORCEROM_MASK, RCM_FM_FORCEROM(value)))
#define RCM_BWR_FM_FORCEROM(base, value) (RCM_WR_FM_FORCEROM(base, value))
/*@}*/

/*******************************************************************************
 * RCM_SSRS - Sticky System Reset Status Register
 ******************************************************************************/

/*!
 * @brief RCM_SSRS - Sticky System Reset Status Register (RW)
 *
 * Reset value: 0x00000082U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR or LVD Wakeup that have not been cleared by software. Software can
 * clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS register
 */
/*@{*/
#define RCM_RD_SSRS(base)        (RCM_SSRS_REG(base))
#define RCM_WR_SSRS(base, value) (RCM_SSRS_REG(base) = (value))
#define RCM_RMW_SSRS(base, mask, value) (RCM_WR_SSRS(base, (RCM_RD_SSRS(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS(base, value) (RCM_WR_SSRS(base, RCM_RD_SSRS(base) |  (value)))
#define RCM_CLR_SSRS(base, value) (RCM_WR_SSRS(base, RCM_RD_SSRS(base) & ~(value)))
#define RCM_TOG_SSRS(base, value) (RCM_WR_SSRS(base, RCM_RD_SSRS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS bitfields
 */

/*!
 * @name Register RCM_SSRS, field SLVD[1] (W1C)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip or POR
 * - 0b1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLVD field. */
#define RCM_RD_SSRS_SLVD(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLVD_MASK) >> RCM_SSRS_SLVD_SHIFT)
#define RCM_BRD_SSRS_SLVD(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLVD_SHIFT))

/*! @brief Set the SLVD field to a new value. */
#define RCM_WR_SSRS_SLVD(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SLVD(value)))
#define RCM_BWR_SSRS_SLVD(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLVD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SLOC[2] (W1C)
 *
 * Indicates a reset has been caused by a loss of external clock. The SCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed SCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLOC field. */
#define RCM_RD_SSRS_SLOC(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLOC_MASK) >> RCM_SSRS_SLOC_SHIFT)
#define RCM_BRD_SSRS_SLOC(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLOC_SHIFT))

/*! @brief Set the SLOC field to a new value. */
#define RCM_WR_SSRS_SLOC(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLOC_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SLOC(value)))
#define RCM_BWR_SSRS_SLOC(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLOC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SLOL[3] (W1C)
 *
 * Indicates a reset has been caused by a loss of lock in the SCG PLL. See the
 * SCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLOL field. */
#define RCM_RD_SSRS_SLOL(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLOL_MASK) >> RCM_SSRS_SLOL_SHIFT)
#define RCM_BRD_SSRS_SLOL(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLOL_SHIFT))

/*! @brief Set the SLOL field to a new value. */
#define RCM_WR_SSRS_SLOL(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLOL_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SLOL(value)))
#define RCM_BWR_SSRS_SLOL(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SWDOG[5] (W1C)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SWDOG field. */
#define RCM_RD_SSRS_SWDOG(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SWDOG_MASK) >> RCM_SSRS_SWDOG_SHIFT)
#define RCM_BRD_SSRS_SWDOG(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SWDOG_SHIFT))

/*! @brief Set the SWDOG field to a new value. */
#define RCM_WR_SSRS_SWDOG(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SWDOG_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SWDOG(value)))
#define RCM_BWR_SSRS_SWDOG(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SWDOG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SPIN[6] (W1C)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET (RESET_b) pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SPIN field. */
#define RCM_RD_SSRS_SPIN(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SPIN_MASK) >> RCM_SSRS_SPIN_SHIFT)
#define RCM_BRD_SSRS_SPIN(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SPIN_SHIFT))

/*! @brief Set the SPIN field to a new value. */
#define RCM_WR_SSRS_SPIN(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SPIN_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SPIN(value)))
#define RCM_BWR_SSRS_SPIN(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SPIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SPOR[7] (W1C)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SPOR field. */
#define RCM_RD_SSRS_SPOR(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SPOR_MASK) >> RCM_SSRS_SPOR_SHIFT)
#define RCM_BRD_SSRS_SPOR(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SPOR_SHIFT))

/*! @brief Set the SPOR field to a new value. */
#define RCM_WR_SSRS_SPOR(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SPOR_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SPOR(value)))
#define RCM_BWR_SSRS_SPOR(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SPOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SLOCKUP[9] (W1C)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLOCKUP field. */
#define RCM_RD_SSRS_SLOCKUP(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLOCKUP_MASK) >> RCM_SSRS_SLOCKUP_SHIFT)
#define RCM_BRD_SSRS_SLOCKUP(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLOCKUP_SHIFT))

/*! @brief Set the SLOCKUP field to a new value. */
#define RCM_WR_SSRS_SLOCKUP(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SLOCKUP(value)))
#define RCM_BWR_SSRS_SLOCKUP(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SLOCKUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SSW[10] (W1C)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core. no
 * SYSRESETREQ bit in CM4 TRM ?
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SSW field. */
#define RCM_RD_SSRS_SSW(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SSW_MASK) >> RCM_SSRS_SSW_SHIFT)
#define RCM_BRD_SSRS_SSW(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SSW_SHIFT))

/*! @brief Set the SSW field to a new value. */
#define RCM_WR_SSRS_SSW(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SSW_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SSW(value)))
#define RCM_BWR_SSRS_SSW(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SSW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SSACKERR[13] (W1C)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SSACKERR field. */
#define RCM_RD_SSRS_SSACKERR(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SSACKERR_MASK) >> RCM_SSRS_SSACKERR_SHIFT)
#define RCM_BRD_SSRS_SSACKERR(base) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SSACKERR_SHIFT))

/*! @brief Set the SSACKERR field to a new value. */
#define RCM_WR_SSRS_SSACKERR(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK), RCM_SSRS_SSACKERR(value)))
#define RCM_BWR_SSRS_SSACKERR(base, value) (BITBAND_ACCESS32(&RCM_SSRS_REG(base), RCM_SSRS_SSACKERR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RCM_SRIE - System Reset Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RCM_SRIE - System Reset Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This registers delays the assertion of a system reset for a period of time
 * (DELAY field) while an interrupt is generated. This allows software to perform a
 * graceful shutdown. A Chip POR source cannot be delayed by this feature, and
 * entering Stop mode will terminate the delay. The SRS will only update after the
 * system reset occurs.
 */
/*!
 * @name Constants and macros for entire RCM_SRIE register
 */
/*@{*/
#define RCM_RD_SRIE(base)        (RCM_SRIE_REG(base))
#define RCM_WR_SRIE(base, value) (RCM_SRIE_REG(base) = (value))
#define RCM_RMW_SRIE(base, mask, value) (RCM_WR_SRIE(base, (RCM_RD_SRIE(base) & ~(mask)) | (value)))
#define RCM_SET_SRIE(base, value) (RCM_WR_SRIE(base, RCM_RD_SRIE(base) |  (value)))
#define RCM_CLR_SRIE(base, value) (RCM_WR_SRIE(base, RCM_RD_SRIE(base) & ~(value)))
#define RCM_TOG_SRIE(base, value) (RCM_WR_SRIE(base, RCM_RD_SRIE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SRIE bitfields
 */

/*!
 * @name Register RCM_SRIE, field DELAY[1:0] (RW)
 *
 * Configures the maximum reset delay time from when the interrupt is asserted
 * and the system reset occurs.
 *
 * Values:
 * - 0b00 - 8 LPO cycles
 * - 0b01 - 32 LPO cycles
 * - 0b10 - 128 LPO cycles
 * - 0b11 - 512 LPO cycles
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_DELAY field. */
#define RCM_RD_SRIE_DELAY(base) ((RCM_SRIE_REG(base) & RCM_SRIE_DELAY_MASK) >> RCM_SRIE_DELAY_SHIFT)
#define RCM_BRD_SRIE_DELAY(base) (RCM_RD_SRIE_DELAY(base))

/*! @brief Set the DELAY field to a new value. */
#define RCM_WR_SRIE_DELAY(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_DELAY_MASK, RCM_SRIE_DELAY(value)))
#define RCM_BWR_SRIE_DELAY(base, value) (RCM_WR_SRIE_DELAY(base, value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field LOC[2] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_LOC field. */
#define RCM_RD_SRIE_LOC(base) ((RCM_SRIE_REG(base) & RCM_SRIE_LOC_MASK) >> RCM_SRIE_LOC_SHIFT)
#define RCM_BRD_SRIE_LOC(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_LOC_SHIFT))

/*! @brief Set the LOC field to a new value. */
#define RCM_WR_SRIE_LOC(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_LOC_MASK, RCM_SRIE_LOC(value)))
#define RCM_BWR_SRIE_LOC(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_LOC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field LOL[3] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_LOL field. */
#define RCM_RD_SRIE_LOL(base) ((RCM_SRIE_REG(base) & RCM_SRIE_LOL_MASK) >> RCM_SRIE_LOL_SHIFT)
#define RCM_BRD_SRIE_LOL(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_LOL_SHIFT))

/*! @brief Set the LOL field to a new value. */
#define RCM_WR_SRIE_LOL(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_LOL_MASK, RCM_SRIE_LOL(value)))
#define RCM_BWR_SRIE_LOL(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_LOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field WDOG[5] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_WDOG field. */
#define RCM_RD_SRIE_WDOG(base) ((RCM_SRIE_REG(base) & RCM_SRIE_WDOG_MASK) >> RCM_SRIE_WDOG_SHIFT)
#define RCM_BRD_SRIE_WDOG(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_WDOG_SHIFT))

/*! @brief Set the WDOG field to a new value. */
#define RCM_WR_SRIE_WDOG(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_WDOG_MASK, RCM_SRIE_WDOG(value)))
#define RCM_BWR_SRIE_WDOG(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_WDOG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field PIN[6] (RW)
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_PIN field. */
#define RCM_RD_SRIE_PIN(base) ((RCM_SRIE_REG(base) & RCM_SRIE_PIN_MASK) >> RCM_SRIE_PIN_SHIFT)
#define RCM_BRD_SRIE_PIN(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_PIN_SHIFT))

/*! @brief Set the PIN field to a new value. */
#define RCM_WR_SRIE_PIN(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_PIN_MASK, RCM_SRIE_PIN(value)))
#define RCM_BWR_SRIE_PIN(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_PIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field GIE[7] (RW)
 *
 * Values:
 * - 0b0 - All interrupt sources disabled.
 * - 0b1 - All interrupt sources enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_GIE field. */
#define RCM_RD_SRIE_GIE(base) ((RCM_SRIE_REG(base) & RCM_SRIE_GIE_MASK) >> RCM_SRIE_GIE_SHIFT)
#define RCM_BRD_SRIE_GIE(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_GIE_SHIFT))

/*! @brief Set the GIE field to a new value. */
#define RCM_WR_SRIE_GIE(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_GIE_MASK, RCM_SRIE_GIE(value)))
#define RCM_BWR_SRIE_GIE(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_GIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field LOCKUP[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_LOCKUP field. */
#define RCM_RD_SRIE_LOCKUP(base) ((RCM_SRIE_REG(base) & RCM_SRIE_LOCKUP_MASK) >> RCM_SRIE_LOCKUP_SHIFT)
#define RCM_BRD_SRIE_LOCKUP(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_LOCKUP_SHIFT))

/*! @brief Set the LOCKUP field to a new value. */
#define RCM_WR_SRIE_LOCKUP(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_LOCKUP_MASK, RCM_SRIE_LOCKUP(value)))
#define RCM_BWR_SRIE_LOCKUP(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_LOCKUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field SW[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_SW field. */
#define RCM_RD_SRIE_SW(base) ((RCM_SRIE_REG(base) & RCM_SRIE_SW_MASK) >> RCM_SRIE_SW_SHIFT)
#define RCM_BRD_SRIE_SW(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_SW_SHIFT))

/*! @brief Set the SW field to a new value. */
#define RCM_WR_SRIE_SW(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_SW_MASK, RCM_SRIE_SW(value)))
#define RCM_BWR_SRIE_SW(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_SW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SRIE, field SACKERR[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_SACKERR field. */
#define RCM_RD_SRIE_SACKERR(base) ((RCM_SRIE_REG(base) & RCM_SRIE_SACKERR_MASK) >> RCM_SRIE_SACKERR_SHIFT)
#define RCM_BRD_SRIE_SACKERR(base) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_SACKERR_SHIFT))

/*! @brief Set the SACKERR field to a new value. */
#define RCM_WR_SRIE_SACKERR(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_SACKERR_MASK, RCM_SRIE_SACKERR(value)))
#define RCM_BWR_SRIE_SACKERR(base, value) (BITBAND_ACCESS32(&RCM_SRIE_REG(base), RCM_SRIE_SACKERR_SHIFT) = (value))
/*@}*/

/*
 * S32K144 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - RTC_TSR - RTC Time Seconds Register
 * - RTC_TPR - RTC Time Prescaler Register
 * - RTC_TAR - RTC Time Alarm Register
 * - RTC_TCR - RTC Time Compensation Register
 * - RTC_CR - RTC Control Register
 * - RTC_SR - RTC Status Register
 * - RTC_LR - RTC Lock Register
 * - RTC_IER - RTC Interrupt Enable Register
 * - RTC_WAR - RTC Write Access Register
 * - RTC_RAR - RTC Read Access Register
 */

#define RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define RTC_IDX (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * RTC_TSR - RTC Time Seconds Register
 ******************************************************************************/

/*!
 * @brief RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TSR register
 */
/*@{*/
#define RTC_RD_TSR(base)         (RTC_TSR_REG(base))
#define RTC_WR_TSR(base, value)  (RTC_TSR_REG(base) = (value))
#define RTC_RMW_TSR(base, mask, value) (RTC_WR_TSR(base, (RTC_RD_TSR(base) & ~(mask)) | (value)))
#define RTC_SET_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) |  (value)))
#define RTC_CLR_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) & ~(value)))
#define RTC_TOG_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * RTC_TPR - RTC Time Prescaler Register
 ******************************************************************************/

/*!
 * @brief RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TPR register
 */
/*@{*/
#define RTC_RD_TPR(base)         (RTC_TPR_REG(base))
#define RTC_WR_TPR(base, value)  (RTC_TPR_REG(base) = (value))
#define RTC_RMW_TPR(base, mask, value) (RTC_WR_TPR(base, (RTC_RD_TPR(base) & ~(mask)) | (value)))
#define RTC_SET_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) |  (value)))
#define RTC_CLR_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) & ~(value)))
#define RTC_TOG_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_TPR_TPR field. */
#define RTC_RD_TPR_TPR(base) ((RTC_TPR_REG(base) & RTC_TPR_TPR_MASK) >> RTC_TPR_TPR_SHIFT)
#define RTC_BRD_TPR_TPR(base) (RTC_RD_TPR_TPR(base))

/*! @brief Set the TPR field to a new value. */
#define RTC_WR_TPR_TPR(base, value) (RTC_RMW_TPR(base, RTC_TPR_TPR_MASK, RTC_TPR_TPR(value)))
#define RTC_BWR_TPR_TPR(base, value) (RTC_WR_TPR_TPR(base, value))
/*@}*/

/*******************************************************************************
 * RTC_TAR - RTC Time Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TAR register
 */
/*@{*/
#define RTC_RD_TAR(base)         (RTC_TAR_REG(base))
#define RTC_WR_TAR(base, value)  (RTC_TAR_REG(base) = (value))
#define RTC_RMW_TAR(base, mask, value) (RTC_WR_TAR(base, (RTC_RD_TAR(base) & ~(mask)) | (value)))
#define RTC_SET_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) |  (value)))
#define RTC_CLR_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) & ~(value)))
#define RTC_TOG_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * RTC_TCR - RTC Time Compensation Register
 ******************************************************************************/

/*!
 * @brief RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TCR register
 */
/*@{*/
#define RTC_RD_TCR(base)         (RTC_TCR_REG(base))
#define RTC_WR_TCR(base, value)  (RTC_TCR_REG(base) = (value))
#define RTC_RMW_TCR(base, mask, value) (RTC_WR_TCR(base, (RTC_RD_TCR(base) & ~(mask)) | (value)))
#define RTC_SET_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) |  (value)))
#define RTC_CLR_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) & ~(value)))
#define RTC_TOG_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 0b10000000 - Time Prescaler Register overflows every 32896 clock cycles.
 * - 0b11111111 - Time Prescaler Register overflows every 32769 clock cycles.
 * - 0b00000000 - Time Prescaler Register overflows every 32768 clock cycles.
 * - 0b00000001 - Time Prescaler Register overflows every 32767 clock cycles.
 * - 0b01111111 - Time Prescaler Register overflows every 32641 clock cycles.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCR field. */
#define RTC_RD_TCR_TCR(base) ((RTC_TCR_REG(base) & RTC_TCR_TCR_MASK) >> RTC_TCR_TCR_SHIFT)
#define RTC_BRD_TCR_TCR(base) (RTC_RD_TCR_TCR(base))

/*! @brief Set the TCR field to a new value. */
#define RTC_WR_TCR_TCR(base, value) (RTC_RMW_TCR(base, RTC_TCR_TCR_MASK, RTC_TCR_TCR(value)))
#define RTC_BWR_TCR_TCR(base, value) (RTC_WR_TCR_TCR(base, value))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds. For
 * example, write zero to configure for a compensation interval of one second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIR field. */
#define RTC_RD_TCR_CIR(base) ((RTC_TCR_REG(base) & RTC_TCR_CIR_MASK) >> RTC_TCR_CIR_SHIFT)
#define RTC_BRD_TCR_CIR(base) (RTC_RD_TCR_CIR(base))

/*! @brief Set the CIR field to a new value. */
#define RTC_WR_TCR_CIR(base, value) (RTC_RMW_TCR(base, RTC_TCR_CIR_MASK, RTC_TCR_CIR(value)))
#define RTC_BWR_TCR_CIR(base, value) (RTC_WR_TCR_CIR(base, value))
/*@}*/

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCV field. */
#define RTC_RD_TCR_TCV(base) ((RTC_TCR_REG(base) & RTC_TCR_TCV_MASK) >> RTC_TCR_TCV_SHIFT)
#define RTC_BRD_TCR_TCV(base) (RTC_RD_TCR_TCV(base))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIC field. */
#define RTC_RD_TCR_CIC(base) ((RTC_TCR_REG(base) & RTC_TCR_CIC_MASK) >> RTC_TCR_CIC_SHIFT)
#define RTC_BRD_TCR_CIC(base) (RTC_RD_TCR_CIC(base))
/*@}*/

/*******************************************************************************
 * RTC_CR - RTC Control Register
 ******************************************************************************/

/*!
 * @brief RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_CR register
 */
/*@{*/
#define RTC_RD_CR(base)          (RTC_CR_REG(base))
#define RTC_WR_CR(base, value)   (RTC_CR_REG(base) = (value))
#define RTC_RMW_CR(base, mask, value) (RTC_WR_CR(base, (RTC_RD_CR(base) & ~(mask)) | (value)))
#define RTC_SET_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) |  (value)))
#define RTC_CLR_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) & ~(value)))
#define RTC_TOG_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Resets all RTC registers except for the SWR bit and the RTC_WAR and
 *     RTC_RAR registers . The SWR bit is cleared by POR and by software
 *     explicitly clearing it.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SWR field. */
#define RTC_RD_CR_SWR(base)  ((RTC_CR_REG(base) & RTC_CR_SWR_MASK) >> RTC_CR_SWR_SHIFT)
#define RTC_BRD_CR_SWR(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT))

/*! @brief Set the SWR field to a new value. */
#define RTC_WR_CR_SWR(base, value) (RTC_RMW_CR(base, RTC_CR_SWR_MASK, RTC_CR_SWR(value)))
#define RTC_BWR_CR_SWR(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0b0 - Wakeup pin is disabled.
 * - 0b1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPE field. */
#define RTC_RD_CR_WPE(base)  ((RTC_CR_REG(base) & RTC_CR_WPE_MASK) >> RTC_CR_WPE_SHIFT)
#define RTC_BRD_CR_WPE(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT))

/*! @brief Set the WPE field to a new value. */
#define RTC_WR_CR_WPE(base, value) (RTC_RMW_CR(base, RTC_CR_WPE_MASK, RTC_CR_WPE(value)))
#define RTC_BWR_CR_WPE(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0b0 - Non-supervisor mode write accesses are not supported and generate a
 *     bus error.
 * - 0b1 - Non-supervisor mode write accesses are supported.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SUP field. */
#define RTC_RD_CR_SUP(base)  ((RTC_CR_REG(base) & RTC_CR_SUP_MASK) >> RTC_CR_SUP_SHIFT)
#define RTC_BRD_CR_SUP(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT))

/*! @brief Set the SUP field to a new value. */
#define RTC_WR_CR_SUP(base, value) (RTC_RMW_CR(base, RTC_CR_SUP_MASK, RTC_CR_SUP(value)))
#define RTC_BWR_CR_SUP(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows SR[TCE] to be written even when the Status Register is locked. When
 * set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or if
 * the SR[TCE] is clear.
 *
 * Values:
 * - 0b0 - Registers cannot be written when locked.
 * - 0b1 - Registers can be written when locked under limited conditions.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_UM field. */
#define RTC_RD_CR_UM(base)   ((RTC_CR_REG(base) & RTC_CR_UM_MASK) >> RTC_CR_UM_SHIFT)
#define RTC_BRD_CR_UM(base)  (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT))

/*! @brief Set the UM field to a new value. */
#define RTC_WR_CR_UM(base, value) (RTC_RMW_CR(base, RTC_CR_UM_MASK, RTC_CR_UM(value)))
#define RTC_BWR_CR_UM(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field WPS[4] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0b0 - Wakeup pin asserts (active low, open drain) if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 * - 0b1 - Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup
 *     pin is turned on and the 32kHz clock is output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPS field. */
#define RTC_RD_CR_WPS(base)  ((RTC_CR_REG(base) & RTC_CR_WPS_MASK) >> RTC_CR_WPS_SHIFT)
#define RTC_BRD_CR_WPS(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPS_SHIFT))

/*! @brief Set the WPS field to a new value. */
#define RTC_WR_CR_WPS(base, value) (RTC_RMW_CR(base, RTC_CR_WPS_MASK, RTC_CR_WPS(value)))
#define RTC_BWR_CR_WPS(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field CPS[5] (RW)
 *
 * Values:
 * - 0b0 - The prescaler output clock (as configured by TSIC) is output on
 *     RTC_CLKOUT.
 * - 0b1 - The RTC 32kHz crystal clock is output on RTC_CLKOUT.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CPS field. */
#define RTC_RD_CR_CPS(base)  ((RTC_CR_REG(base) & RTC_CR_CPS_MASK) >> RTC_CR_CPS_SHIFT)
#define RTC_BRD_CR_CPS(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CPS_SHIFT))

/*! @brief Set the CPS field to a new value. */
#define RTC_WR_CR_CPS(base, value) (RTC_RMW_CR(base, RTC_CR_CPS_MASK, RTC_CR_CPS(value)))
#define RTC_BWR_CR_CPS(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CPS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field LPOS[7] (RW)
 *
 * When set, the RTC prescaler increments using the LPO 1kHz clock and not the
 * RTC 32kHz crystal clock. The LPO increments the prescaler from bit TPR[5]
 * (TPR[4:0] are ignored), supporting close to 1 second increment of the seconds
 * register. Although compensation is supported when clocked from the LPO, TCR[4:0] of
 * the compensation register are also ignored and only TCR[7:5] set the
 * compensation value (can overflow after 1020 to 1027 cycles).
 *
 * Values:
 * - 0b0 - RTC prescaler increments using 32kHz crystal.
 * - 0b1 - RTC prescaler increments using 1kHz LPO, bits [4:0] of the prescaler
 *     are bypassed.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_LPOS field. */
#define RTC_RD_CR_LPOS(base) ((RTC_CR_REG(base) & RTC_CR_LPOS_MASK) >> RTC_CR_LPOS_SHIFT)
#define RTC_BRD_CR_LPOS(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_LPOS_SHIFT))

/*! @brief Set the LPOS field to a new value. */
#define RTC_WR_CR_LPOS(base, value) (RTC_RMW_CR(base, RTC_CR_LPOS_MASK, RTC_CR_LPOS(value)))
#define RTC_BWR_CR_LPOS(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_LPOS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0b0 - 32.768 kHz oscillator is disabled.
 * - 0b1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_OSCE field. */
#define RTC_RD_CR_OSCE(base) ((RTC_CR_REG(base) & RTC_CR_OSCE_MASK) >> RTC_CR_OSCE_SHIFT)
#define RTC_BRD_CR_OSCE(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT))

/*! @brief Set the OSCE field to a new value. */
#define RTC_WR_CR_OSCE(base, value) (RTC_RMW_CR(base, RTC_CR_OSCE_MASK, RTC_CR_OSCE(value)))
#define RTC_BWR_CR_OSCE(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0b0 - The 32 kHz clock is output to other peripherals.
 * - 0b1 - The 32 kHz clock is not output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CLKO field. */
#define RTC_RD_CR_CLKO(base) ((RTC_CR_REG(base) & RTC_CR_CLKO_MASK) >> RTC_CR_CLKO_SHIFT)
#define RTC_BRD_CR_CLKO(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT))

/*! @brief Set the CLKO field to a new value. */
#define RTC_WR_CR_CLKO(base, value) (RTC_RMW_CR(base, RTC_CR_CLKO_MASK, RTC_CR_CLKO(value)))
#define RTC_BWR_CR_CLKO(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC16P field. */
#define RTC_RD_CR_SC16P(base) ((RTC_CR_REG(base) & RTC_CR_SC16P_MASK) >> RTC_CR_SC16P_SHIFT)
#define RTC_BRD_CR_SC16P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT))

/*! @brief Set the SC16P field to a new value. */
#define RTC_WR_CR_SC16P(base, value) (RTC_RMW_CR(base, RTC_CR_SC16P_MASK, RTC_CR_SC16P(value)))
#define RTC_BWR_CR_SC16P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC8P field. */
#define RTC_RD_CR_SC8P(base) ((RTC_CR_REG(base) & RTC_CR_SC8P_MASK) >> RTC_CR_SC8P_SHIFT)
#define RTC_BRD_CR_SC8P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT))

/*! @brief Set the SC8P field to a new value. */
#define RTC_WR_CR_SC8P(base, value) (RTC_RMW_CR(base, RTC_CR_SC8P_MASK, RTC_CR_SC8P(value)))
#define RTC_BWR_CR_SC8P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC4P field. */
#define RTC_RD_CR_SC4P(base) ((RTC_CR_REG(base) & RTC_CR_SC4P_MASK) >> RTC_CR_SC4P_SHIFT)
#define RTC_BRD_CR_SC4P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT))

/*! @brief Set the SC4P field to a new value. */
#define RTC_WR_CR_SC4P(base, value) (RTC_RMW_CR(base, RTC_CR_SC4P_MASK, RTC_CR_SC4P(value)))
#define RTC_BWR_CR_SC4P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC2P field. */
#define RTC_RD_CR_SC2P(base) ((RTC_CR_REG(base) & RTC_CR_SC2P_MASK) >> RTC_CR_SC2P_SHIFT)
#define RTC_BRD_CR_SC2P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT))

/*! @brief Set the SC2P field to a new value. */
#define RTC_WR_CR_SC2P(base, value) (RTC_RMW_CR(base, RTC_CR_SC2P_MASK, RTC_CR_SC2P(value)))
#define RTC_BWR_CR_SC2P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field CPE[25:24] (RW)
 *
 * The CPE field should be configured to 01 or 11 (i.e. CPE[0] = 1), if we want
 * the RTC_CLKOUT signal as output.
 *
 * Values:
 * - 0b00 - RTC_CLKOUT is disabled.
 * - 0b01 - RTC_CLKOUT is enabled on pin PTE0.
 * - 0b10 - RTC_CLKOUT is enabled on pin PTE26.
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CPE field. */
#define RTC_RD_CR_CPE(base)  ((RTC_CR_REG(base) & RTC_CR_CPE_MASK) >> RTC_CR_CPE_SHIFT)
#define RTC_BRD_CR_CPE(base) (RTC_RD_CR_CPE(base))

/*! @brief Set the CPE field to a new value. */
#define RTC_WR_CR_CPE(base, value) (RTC_RMW_CR(base, RTC_CR_CPE_MASK, RTC_CR_CPE(value)))
#define RTC_BWR_CR_CPE(base, value) (RTC_WR_CR_CPE(base, value))
/*@}*/

/*******************************************************************************
 * RTC_SR - RTC Status Register
 ******************************************************************************/

/*!
 * @brief RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire RTC_SR register
 */
/*@{*/
#define RTC_RD_SR(base)          (RTC_SR_REG(base))
#define RTC_WR_SR(base, value)   (RTC_SR_REG(base) = (value))
#define RTC_RMW_SR(base, mask, value) (RTC_WR_SR(base, (RTC_RD_SR(base) & ~(mask)) | (value)))
#define RTC_SET_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) |  (value)))
#define RTC_CLR_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) & ~(value)))
#define RTC_TOG_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on POR or software reset. The TSR and TPR do not
 * increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0b0 - Time is valid.
 * - 0b1 - Time is invalid and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TIF field. */
#define RTC_RD_SR_TIF(base)  ((RTC_SR_REG(base) & RTC_SR_TIF_MASK) >> RTC_SR_TIF_SHIFT)
#define RTC_BRD_SR_TIF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TIF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0b0 - Time overflow has not occurred.
 * - 0b1 - Time overflow has occurred and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TOF field. */
#define RTC_RD_SR_TOF(base)  ((RTC_SR_REG(base) & RTC_SR_TOF_MASK) >> RTC_SR_TOF_SHIFT)
#define RTC_BRD_SR_TOF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TOF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0b0 - Time alarm has not occurred.
 * - 0b1 - Time alarm has occurred.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TAF field. */
#define RTC_RD_SR_TAF(base)  ((RTC_SR_REG(base) & RTC_SR_TAF_MASK) >> RTC_SR_TAF_SHIFT)
#define RTC_BRD_SR_TAF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TAF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0b0 - Time counter is disabled.
 * - 0b1 - Time counter is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TCE field. */
#define RTC_RD_SR_TCE(base)  ((RTC_SR_REG(base) & RTC_SR_TCE_MASK) >> RTC_SR_TCE_SHIFT)
#define RTC_BRD_SR_TCE(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT))

/*! @brief Set the TCE field to a new value. */
#define RTC_WR_SR_TCE(base, value) (RTC_RMW_SR(base, RTC_SR_TCE_MASK, RTC_SR_TCE(value)))
#define RTC_BWR_SR_TCE(base, value) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_LR - RTC Lock Register
 ******************************************************************************/

/*!
 * @brief RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_LR register
 */
/*@{*/
#define RTC_RD_LR(base)          (RTC_LR_REG(base))
#define RTC_WR_LR(base, value)   (RTC_LR_REG(base) = (value))
#define RTC_RMW_LR(base, mask, value) (RTC_WR_LR(base, (RTC_RD_LR(base) & ~(mask)) | (value)))
#define RTC_SET_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) |  (value)))
#define RTC_CLR_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) & ~(value)))
#define RTC_TOG_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Time Compensation Register is locked and writes are ignored.
 * - 0b1 - Time Compensation Register is not locked and writes complete as
 *     normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_TCL field. */
#define RTC_RD_LR_TCL(base)  ((RTC_LR_REG(base) & RTC_LR_TCL_MASK) >> RTC_LR_TCL_SHIFT)
#define RTC_BRD_LR_TCL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT))

/*! @brief Set the TCL field to a new value. */
#define RTC_WR_LR_TCL(base, value) (RTC_RMW_LR(base, RTC_LR_TCL_MASK, RTC_LR_TCL(value)))
#define RTC_BWR_LR_TCL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * After being cleared, this bit can only be set by POR.
 *
 * Values:
 * - 0b0 - Control Register is locked and writes are ignored.
 * - 0b1 - Control Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_CRL field. */
#define RTC_RD_LR_CRL(base)  ((RTC_LR_REG(base) & RTC_LR_CRL_MASK) >> RTC_LR_CRL_SHIFT)
#define RTC_BRD_LR_CRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT))

/*! @brief Set the CRL field to a new value. */
#define RTC_WR_LR_CRL(base, value) (RTC_RMW_LR(base, RTC_LR_CRL_MASK, RTC_LR_CRL(value)))
#define RTC_BWR_LR_CRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Status Register is locked and writes are ignored.
 * - 0b1 - Status Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_SRL field. */
#define RTC_RD_LR_SRL(base)  ((RTC_LR_REG(base) & RTC_LR_SRL_MASK) >> RTC_LR_SRL_SHIFT)
#define RTC_BRD_LR_SRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT))

/*! @brief Set the SRL field to a new value. */
#define RTC_WR_LR_SRL(base, value) (RTC_RMW_LR(base, RTC_LR_SRL_MASK, RTC_LR_SRL(value)))
#define RTC_BWR_LR_SRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Lock Register is locked and writes are ignored.
 * - 0b1 - Lock Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_LRL field. */
#define RTC_RD_LR_LRL(base)  ((RTC_LR_REG(base) & RTC_LR_LRL_MASK) >> RTC_LR_LRL_SHIFT)
#define RTC_BRD_LR_LRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT))

/*! @brief Set the LRL field to a new value. */
#define RTC_WR_LR_LRL(base, value) (RTC_RMW_LR(base, RTC_LR_LRL_MASK, RTC_LR_LRL(value)))
#define RTC_BWR_LR_LRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define RTC_RD_IER(base)         (RTC_IER_REG(base))
#define RTC_WR_IER(base, value)  (RTC_IER_REG(base) = (value))
#define RTC_RMW_IER(base, mask, value) (RTC_WR_IER(base, (RTC_RD_IER(base) & ~(mask)) | (value)))
#define RTC_SET_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) |  (value)))
#define RTC_CLR_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) & ~(value)))
#define RTC_TOG_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0b0 - Time invalid flag does not generate an interrupt.
 * - 0b1 - Time invalid flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TIIE field. */
#define RTC_RD_IER_TIIE(base) ((RTC_IER_REG(base) & RTC_IER_TIIE_MASK) >> RTC_IER_TIIE_SHIFT)
#define RTC_BRD_IER_TIIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT))

/*! @brief Set the TIIE field to a new value. */
#define RTC_WR_IER_TIIE(base, value) (RTC_RMW_IER(base, RTC_IER_TIIE_MASK, RTC_IER_TIIE(value)))
#define RTC_BWR_IER_TIIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0b0 - Time overflow flag does not generate an interrupt.
 * - 0b1 - Time overflow flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TOIE field. */
#define RTC_RD_IER_TOIE(base) ((RTC_IER_REG(base) & RTC_IER_TOIE_MASK) >> RTC_IER_TOIE_SHIFT)
#define RTC_BRD_IER_TOIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT))

/*! @brief Set the TOIE field to a new value. */
#define RTC_WR_IER_TOIE(base, value) (RTC_RMW_IER(base, RTC_IER_TOIE_MASK, RTC_IER_TOIE(value)))
#define RTC_BWR_IER_TOIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0b0 - Time alarm flag does not generate an interrupt.
 * - 0b1 - Time alarm flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TAIE field. */
#define RTC_RD_IER_TAIE(base) ((RTC_IER_REG(base) & RTC_IER_TAIE_MASK) >> RTC_IER_TAIE_SHIFT)
#define RTC_BRD_IER_TAIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT))

/*! @brief Set the TAIE field to a new value. */
#define RTC_WR_IER_TAIE(base, value) (RTC_RMW_IER(base, RTC_IER_TAIE_MASK, RTC_IER_TAIE(value)))
#define RTC_BWR_IER_TAIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0b0 - Seconds interrupt is disabled.
 * - 0b1 - Seconds interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TSIE field. */
#define RTC_RD_IER_TSIE(base) ((RTC_IER_REG(base) & RTC_IER_TSIE_MASK) >> RTC_IER_TSIE_SHIFT)
#define RTC_BRD_IER_TSIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT))

/*! @brief Set the TSIE field to a new value. */
#define RTC_WR_IER_TSIE(base, value) (RTC_RMW_IER(base, RTC_IER_TSIE_MASK, RTC_IER_TSIE(value)))
#define RTC_BWR_IER_TSIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field WPON[7] (RW)
 *
 * The wakeup pin is optional and not available on all devices. Whenever the
 * wakeup pin is enabled and this bit is set, the wakeup pin will assert.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - If the wakeup pin is enabled, then the wakeup pin will assert.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_WPON field. */
#define RTC_RD_IER_WPON(base) ((RTC_IER_REG(base) & RTC_IER_WPON_MASK) >> RTC_IER_WPON_SHIFT)
#define RTC_BRD_IER_WPON(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_WPON_SHIFT))

/*! @brief Set the WPON field to a new value. */
#define RTC_WR_IER_WPON(base, value) (RTC_RMW_IER(base, RTC_IER_WPON_MASK, RTC_IER_WPON(value)))
#define RTC_BWR_IER_WPON(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_WPON_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIC[18:16] (RW)
 *
 * Configures the frequency of the RTC Seconds interrupt and the RTC_CLKOUT
 * prescaler output. This field should only be altered when TSIE is clear.
 *
 * Values:
 * - 0b000 - 1 Hz.
 * - 0b001 - 2 Hz.
 * - 0b010 - 4 Hz.
 * - 0b011 - 8 Hz.
 * - 0b100 - 16 Hz.
 * - 0b101 - 32 Hz.
 * - 0b110 - 64 Hz.
 * - 0b111 - 128 Hz.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TSIC field. */
#define RTC_RD_IER_TSIC(base) ((RTC_IER_REG(base) & RTC_IER_TSIC_MASK) >> RTC_IER_TSIC_SHIFT)
#define RTC_BRD_IER_TSIC(base) (RTC_RD_IER_TSIC(base))

/*! @brief Set the TSIC field to a new value. */
#define RTC_WR_IER_TSIC(base, value) (RTC_RMW_IER(base, RTC_IER_TSIC_MASK, RTC_IER_TSIC(value)))
#define RTC_BWR_IER_TSIC(base, value) (RTC_WR_IER_TSIC(base, value))
/*@}*/

/*******************************************************************************
 * RTC_WAR - RTC Write Access Register
 ******************************************************************************/

/*!
 * @brief RTC_WAR - RTC Write Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_WAR register
 */
/*@{*/
#define RTC_RD_WAR(base)         (RTC_WAR_REG(base))
#define RTC_WR_WAR(base, value)  (RTC_WAR_REG(base) = (value))
#define RTC_RMW_WAR(base, mask, value) (RTC_WR_WAR(base, (RTC_RD_WAR(base) & ~(mask)) | (value)))
#define RTC_SET_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) |  (value)))
#define RTC_CLR_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) & ~(value)))
#define RTC_TOG_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_WAR bitfields
 */

/*!
 * @name Register RTC_WAR, field TSRW[0] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Time Seconds Register are ignored.
 * - 0b1 - Writes to the Time Seconds Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TSRW field. */
#define RTC_RD_WAR_TSRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TSRW_MASK) >> RTC_WAR_TSRW_SHIFT)
#define RTC_BRD_WAR_TSRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TSRW_SHIFT))

/*! @brief Set the TSRW field to a new value. */
#define RTC_WR_WAR_TSRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TSRW_MASK, RTC_WAR_TSRW(value)))
#define RTC_BWR_WAR_TSRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TSRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TPRW[1] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Time Prescaler Register are ignored.
 * - 0b1 - Writes to the Time Prescaler Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TPRW field. */
#define RTC_RD_WAR_TPRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TPRW_MASK) >> RTC_WAR_TPRW_SHIFT)
#define RTC_BRD_WAR_TPRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TPRW_SHIFT))

/*! @brief Set the TPRW field to a new value. */
#define RTC_WR_WAR_TPRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TPRW_MASK, RTC_WAR_TPRW(value)))
#define RTC_BWR_WAR_TPRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TPRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TARW[2] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Time Alarm Register are ignored.
 * - 0b1 - Writes to the Time Alarm Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TARW field. */
#define RTC_RD_WAR_TARW(base) ((RTC_WAR_REG(base) & RTC_WAR_TARW_MASK) >> RTC_WAR_TARW_SHIFT)
#define RTC_BRD_WAR_TARW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TARW_SHIFT))

/*! @brief Set the TARW field to a new value. */
#define RTC_WR_WAR_TARW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TARW_MASK, RTC_WAR_TARW(value)))
#define RTC_BWR_WAR_TARW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TARW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TCRW[3] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Time Compensation Register are ignored.
 * - 0b1 - Writes to the Time Compensation Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TCRW field. */
#define RTC_RD_WAR_TCRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TCRW_MASK) >> RTC_WAR_TCRW_SHIFT)
#define RTC_BRD_WAR_TCRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TCRW_SHIFT))

/*! @brief Set the TCRW field to a new value. */
#define RTC_WR_WAR_TCRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TCRW_MASK, RTC_WAR_TCRW(value)))
#define RTC_BWR_WAR_TCRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TCRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field CRW[4] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Control Register are ignored.
 * - 0b1 - Writes to the Control Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_CRW field. */
#define RTC_RD_WAR_CRW(base) ((RTC_WAR_REG(base) & RTC_WAR_CRW_MASK) >> RTC_WAR_CRW_SHIFT)
#define RTC_BRD_WAR_CRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_CRW_SHIFT))

/*! @brief Set the CRW field to a new value. */
#define RTC_WR_WAR_CRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_CRW_MASK, RTC_WAR_CRW(value)))
#define RTC_BWR_WAR_CRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_CRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field SRW[5] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Status Register are ignored.
 * - 0b1 - Writes to the Status Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_SRW field. */
#define RTC_RD_WAR_SRW(base) ((RTC_WAR_REG(base) & RTC_WAR_SRW_MASK) >> RTC_WAR_SRW_SHIFT)
#define RTC_BRD_WAR_SRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_SRW_SHIFT))

/*! @brief Set the SRW field to a new value. */
#define RTC_WR_WAR_SRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_SRW_MASK, RTC_WAR_SRW(value)))
#define RTC_BWR_WAR_SRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_SRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field LRW[6] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Lock Register are ignored.
 * - 0b1 - Writes to the Lock Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_LRW field. */
#define RTC_RD_WAR_LRW(base) ((RTC_WAR_REG(base) & RTC_WAR_LRW_MASK) >> RTC_WAR_LRW_SHIFT)
#define RTC_BRD_WAR_LRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_LRW_SHIFT))

/*! @brief Set the LRW field to a new value. */
#define RTC_WR_WAR_LRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_LRW_MASK, RTC_WAR_LRW(value)))
#define RTC_BWR_WAR_LRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_LRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field IERW[7] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Writes to the Interupt Enable Register are ignored.
 * - 0b1 - Writes to the Interrupt Enable Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_IERW field. */
#define RTC_RD_WAR_IERW(base) ((RTC_WAR_REG(base) & RTC_WAR_IERW_MASK) >> RTC_WAR_IERW_SHIFT)
#define RTC_BRD_WAR_IERW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_IERW_SHIFT))

/*! @brief Set the IERW field to a new value. */
#define RTC_WR_WAR_IERW(base, value) (RTC_RMW_WAR(base, RTC_WAR_IERW_MASK, RTC_WAR_IERW(value)))
#define RTC_BWR_WAR_IERW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_IERW_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_RAR - RTC Read Access Register
 ******************************************************************************/

/*!
 * @brief RTC_RAR - RTC Read Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_RAR register
 */
/*@{*/
#define RTC_RD_RAR(base)         (RTC_RAR_REG(base))
#define RTC_WR_RAR(base, value)  (RTC_RAR_REG(base) = (value))
#define RTC_RMW_RAR(base, mask, value) (RTC_WR_RAR(base, (RTC_RD_RAR(base) & ~(mask)) | (value)))
#define RTC_SET_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) |  (value)))
#define RTC_CLR_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) & ~(value)))
#define RTC_TOG_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_RAR bitfields
 */

/*!
 * @name Register RTC_RAR, field TSRR[0] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Time Seconds Register are ignored.
 * - 0b1 - Reads to the Time Seconds Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TSRR field. */
#define RTC_RD_RAR_TSRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TSRR_MASK) >> RTC_RAR_TSRR_SHIFT)
#define RTC_BRD_RAR_TSRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TSRR_SHIFT))

/*! @brief Set the TSRR field to a new value. */
#define RTC_WR_RAR_TSRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TSRR_MASK, RTC_RAR_TSRR(value)))
#define RTC_BWR_RAR_TSRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TSRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TPRR[1] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Time Pprescaler Register are ignored.
 * - 0b1 - Reads to the Time Prescaler Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TPRR field. */
#define RTC_RD_RAR_TPRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TPRR_MASK) >> RTC_RAR_TPRR_SHIFT)
#define RTC_BRD_RAR_TPRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TPRR_SHIFT))

/*! @brief Set the TPRR field to a new value. */
#define RTC_WR_RAR_TPRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TPRR_MASK, RTC_RAR_TPRR(value)))
#define RTC_BWR_RAR_TPRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TPRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TARR[2] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Time Alarm Register are ignored.
 * - 0b1 - Reads to the Time Alarm Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TARR field. */
#define RTC_RD_RAR_TARR(base) ((RTC_RAR_REG(base) & RTC_RAR_TARR_MASK) >> RTC_RAR_TARR_SHIFT)
#define RTC_BRD_RAR_TARR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TARR_SHIFT))

/*! @brief Set the TARR field to a new value. */
#define RTC_WR_RAR_TARR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TARR_MASK, RTC_RAR_TARR(value)))
#define RTC_BWR_RAR_TARR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TARR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TCRR[3] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Time Compensation Register are ignored.
 * - 0b1 - Reads to the Time Compensation Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TCRR field. */
#define RTC_RD_RAR_TCRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TCRR_MASK) >> RTC_RAR_TCRR_SHIFT)
#define RTC_BRD_RAR_TCRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TCRR_SHIFT))

/*! @brief Set the TCRR field to a new value. */
#define RTC_WR_RAR_TCRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TCRR_MASK, RTC_RAR_TCRR(value)))
#define RTC_BWR_RAR_TCRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TCRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field CRR[4] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Control Register are ignored.
 * - 0b1 - Reads to the Control Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_CRR field. */
#define RTC_RD_RAR_CRR(base) ((RTC_RAR_REG(base) & RTC_RAR_CRR_MASK) >> RTC_RAR_CRR_SHIFT)
#define RTC_BRD_RAR_CRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_CRR_SHIFT))

/*! @brief Set the CRR field to a new value. */
#define RTC_WR_RAR_CRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_CRR_MASK, RTC_RAR_CRR(value)))
#define RTC_BWR_RAR_CRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_CRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field SRR[5] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Status Register are ignored.
 * - 0b1 - Reads to the Status Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_SRR field. */
#define RTC_RD_RAR_SRR(base) ((RTC_RAR_REG(base) & RTC_RAR_SRR_MASK) >> RTC_RAR_SRR_SHIFT)
#define RTC_BRD_RAR_SRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_SRR_SHIFT))

/*! @brief Set the SRR field to a new value. */
#define RTC_WR_RAR_SRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_SRR_MASK, RTC_RAR_SRR(value)))
#define RTC_BWR_RAR_SRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_SRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field LRR[6] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Lock Register are ignored.
 * - 0b1 - Reads to the Lock Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_LRR field. */
#define RTC_RD_RAR_LRR(base) ((RTC_RAR_REG(base) & RTC_RAR_LRR_MASK) >> RTC_RAR_LRR_SHIFT)
#define RTC_BRD_RAR_LRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_LRR_SHIFT))

/*! @brief Set the LRR field to a new value. */
#define RTC_WR_RAR_LRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_LRR_MASK, RTC_RAR_LRR(value)))
#define RTC_BWR_RAR_LRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_LRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field IERR[7] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by software reset.
 *
 * Values:
 * - 0b0 - Reads to the Interrupt Enable Register are ignored.
 * - 0b1 - Reads to the Interrupt Enable Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_IERR field. */
#define RTC_RD_RAR_IERR(base) ((RTC_RAR_REG(base) & RTC_RAR_IERR_MASK) >> RTC_RAR_IERR_SHIFT)
#define RTC_BRD_RAR_IERR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_IERR_SHIFT))

/*! @brief Set the IERR field to a new value. */
#define RTC_WR_RAR_IERR(base, value) (RTC_RMW_RAR(base, RTC_RAR_IERR_MASK, RTC_RAR_IERR(value)))
#define RTC_BWR_RAR_IERR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_IERR_SHIFT) = (value))
/*@}*/

/*
 * S32K144 SCG
 *
 * System Clock Generator
 *
 * Registers defined in this header file:
 * - SCG_VERID - Version ID Register
 * - SCG_PARAM - Parameter Register
 * - SCG_CSR - Clock Status Register
 * - SCG_RCCR - Run Clock Control Register
 * - SCG_VCCR - VLPR Clock Control Register
 * - SCG_HCCR - HSRUN Clock Control Register
 * - SCG_CLKOUTCNFG - SCG CLKOUT Configuration Register
 * - SCG_SOSCCSR - System OSC Control Status Register
 * - SCG_SOSCDIV - System OSC Divide Register
 * - SCG_SOSCCFG - System Oscillator Configuration Register
 * - SCG_SIRCCSR - Slow IRC Control Status Register
 * - SCG_SIRCDIV - Slow IRC Divide Register
 * - SCG_SIRCCFG - Slow IRC Configuration Register
 * - SCG_SIRCTRIM - Slow IRC Trim Register
 * - SCG_FIRCCSR - Fast IRC Control Status Register
 * - SCG_FIRCDIV - Fast IRC Divide Register
 * - SCG_FIRCCFG - Fast IRC Configuration Register
 * - SCG_FIRCTCFG - Fast IRC Trim Configuration Register
 * - SCG_FIRCTRIML - Fast IRC Trim Low Register
 * - SCG_FIRCTRIMH - Fast IRC Trim High Register
 * - SCG_FIRCSTAT - Fast IRC Status Register
 * - SCG_ROSCCSR - RTC OSC Control Status Register
 * - SCG_SPLLCSR - System PLL Control Status Register
 * - SCG_SPLLDIV - System PLL Divide Register
 * - SCG_SPLLCFG - System PLL Configuration Register
 */

#define SCG_INSTANCE_COUNT (1U) /*!< Number of instances of the SCG module. */
#define SCG_IDX (0U) /*!< Instance number for SCG. */

/*******************************************************************************
 * SCG_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief SCG_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire SCG_VERID register
 */
/*@{*/
#define SCG_RD_VERID(base)       (SCG_VERID_REG(base))
/*@}*/

/*******************************************************************************
 * SCG_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief SCG_PARAM - Parameter Register (RO)
 *
 * Reset value: 0xF80000FEU
 */
/*!
 * @name Constants and macros for entire SCG_PARAM register
 */
/*@{*/
#define SCG_RD_PARAM(base)       (SCG_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual SCG_PARAM bitfields
 */

/*!
 * @name Register SCG_PARAM, field CLKPRES[7:0] (RO)
 *
 * Indicates which clock sources are present in this instance of SCG. Any bits
 * not defined in this bit field are Reserved and always has the value 0 when read.
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_CLKPRES field. */
#define SCG_RD_PARAM_CLKPRES(base) ((SCG_PARAM_REG(base) & SCG_PARAM_CLKPRES_MASK) >> SCG_PARAM_CLKPRES_SHIFT)
#define SCG_BRD_PARAM_CLKPRES(base) (SCG_RD_PARAM_CLKPRES(base))
/*@}*/

/*!
 * @name Register SCG_PARAM, field UNDEFINED1[15:8] (ROZ)
 *
 * -
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_UNDEFINED1 field. */
#define SCG_RD_PARAM_UNDEFINED1(base) ((SCG_PARAM_REG(base) & SCG_PARAM_UNDEFINED1_MASK) >> SCG_PARAM_UNDEFINED1_SHIFT)
#define SCG_BRD_PARAM_UNDEFINED1(base) (SCG_RD_PARAM_UNDEFINED1(base))
/*@}*/

/*!
 * @name Register SCG_PARAM, field UNDEFINED2[26:16] (ROZ)
 *
 * -
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_UNDEFINED2 field. */
#define SCG_RD_PARAM_UNDEFINED2(base) ((SCG_PARAM_REG(base) & SCG_PARAM_UNDEFINED2_MASK) >> SCG_PARAM_UNDEFINED2_SHIFT)
#define SCG_BRD_PARAM_UNDEFINED2(base) (SCG_RD_PARAM_UNDEFINED2(base))
/*@}*/

/*!
 * @name Register SCG_PARAM, field DIVPRES[31:27] (RO)
 *
 * Indicates which system clock dividers are present in this instance of SCG.
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_DIVPRES field. */
#define SCG_RD_PARAM_DIVPRES(base) ((SCG_PARAM_REG(base) & SCG_PARAM_DIVPRES_MASK) >> SCG_PARAM_DIVPRES_SHIFT)
#define SCG_BRD_PARAM_DIVPRES(base) (SCG_RD_PARAM_DIVPRES(base))
/*@}*/

/*******************************************************************************
 * SCG_CSR - Clock Status Register
 ******************************************************************************/

/*!
 * @brief SCG_CSR - Clock Status Register (RO)
 *
 * Reset value: 0x03000001U
 *
 * This register returns the currently configured system clock source and the
 * system clock dividers for the core, platform, external and bus clock domains.
 */
/*!
 * @name Constants and macros for entire SCG_CSR register
 */
/*@{*/
#define SCG_RD_CSR(base)         (SCG_CSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual SCG_CSR bitfields
 */

/*!
 * @name Register SCG_CSR, field DIVSLOW[3:0] (RO)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_DIVSLOW field. */
#define SCG_RD_CSR_DIVSLOW(base) ((SCG_CSR_REG(base) & SCG_CSR_DIVSLOW_MASK) >> SCG_CSR_DIVSLOW_SHIFT)
#define SCG_BRD_CSR_DIVSLOW(base) (SCG_RD_CSR_DIVSLOW(base))
/*@}*/

/*!
 * @name Register SCG_CSR, field DIVBUS[7:4] (RO)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_DIVBUS field. */
#define SCG_RD_CSR_DIVBUS(base) ((SCG_CSR_REG(base) & SCG_CSR_DIVBUS_MASK) >> SCG_CSR_DIVBUS_SHIFT)
#define SCG_BRD_CSR_DIVBUS(base) (SCG_RD_CSR_DIVBUS(base))
/*@}*/

/*!
 * @name Register SCG_CSR, field DIVPLAT[15:12] (RO)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Reserved
 * - 0b0010 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - Reserved
 * - 0b1001 - Reserved
 * - 0b1010 - Reserved
 * - 0b1011 - Reserved
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_DIVPLAT field. */
#define SCG_RD_CSR_DIVPLAT(base) ((SCG_CSR_REG(base) & SCG_CSR_DIVPLAT_MASK) >> SCG_CSR_DIVPLAT_SHIFT)
#define SCG_BRD_CSR_DIVPLAT(base) (SCG_RD_CSR_DIVPLAT(base))
/*@}*/

/*!
 * @name Register SCG_CSR, field DIVCORE[19:16] (RO)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_DIVCORE field. */
#define SCG_RD_CSR_DIVCORE(base) ((SCG_CSR_REG(base) & SCG_CSR_DIVCORE_MASK) >> SCG_CSR_DIVCORE_SHIFT)
#define SCG_BRD_CSR_DIVCORE(base) (SCG_RD_CSR_DIVCORE(base))
/*@}*/

/*!
 * @name Register SCG_CSR, field SCS[27:24] (RO)
 *
 * Returns the currently configured clock source generating the system clock.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - RTC OSC
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_SCS field. */
#define SCG_RD_CSR_SCS(base) ((SCG_CSR_REG(base) & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT)
#define SCG_BRD_CSR_SCS(base) (SCG_RD_CSR_SCS(base))
/*@}*/

/*******************************************************************************
 * SCG_RCCR - Run Clock Control Register
 ******************************************************************************/

/*!
 * @brief SCG_RCCR - Run Clock Control Register (RW)
 *
 * Reset value: 0x03000001U
 *
 * This register controls the system clock source and the system clock dividers
 * for the core, platform, external and bus clock domains when in Run mode only.
 * This register can only be written using a 32-bit write. Selecting a different
 * clock source when in RUN requires that clock source to be enabled first and be
 * valid before system clocks switch to that clock source. If system clock
 * divide ratios also change when selecting a different clock mode when in RUN, new
 * system clock divide ratios will not take affect until new clock source is valid.
 */
/*!
 * @name Constants and macros for entire SCG_RCCR register
 */
/*@{*/
#define SCG_RD_RCCR(base)        (SCG_RCCR_REG(base))
#define SCG_WR_RCCR(base, value) (SCG_RCCR_REG(base) = (value))
#define SCG_RMW_RCCR(base, mask, value) (SCG_WR_RCCR(base, (SCG_RD_RCCR(base) & ~(mask)) | (value)))
#define SCG_SET_RCCR(base, value) (SCG_WR_RCCR(base, SCG_RD_RCCR(base) |  (value)))
#define SCG_CLR_RCCR(base, value) (SCG_WR_RCCR(base, SCG_RD_RCCR(base) & ~(value)))
#define SCG_TOG_RCCR(base, value) (SCG_WR_RCCR(base, SCG_RD_RCCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_RCCR bitfields
 */

/*!
 * @name Register SCG_RCCR, field DIVSLOW[3:0] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_DIVSLOW field. */
#define SCG_RD_RCCR_DIVSLOW(base) ((SCG_RCCR_REG(base) & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT)
#define SCG_BRD_RCCR_DIVSLOW(base) (SCG_RD_RCCR_DIVSLOW(base))

/*! @brief Set the DIVSLOW field to a new value. */
#define SCG_WR_RCCR_DIVSLOW(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_DIVSLOW_MASK, SCG_RCCR_DIVSLOW(value)))
#define SCG_BWR_RCCR_DIVSLOW(base, value) (SCG_WR_RCCR_DIVSLOW(base, value))
/*@}*/

/*!
 * @name Register SCG_RCCR, field DIVBUS[7:4] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_DIVBUS field. */
#define SCG_RD_RCCR_DIVBUS(base) ((SCG_RCCR_REG(base) & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT)
#define SCG_BRD_RCCR_DIVBUS(base) (SCG_RD_RCCR_DIVBUS(base))

/*! @brief Set the DIVBUS field to a new value. */
#define SCG_WR_RCCR_DIVBUS(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_DIVBUS_MASK, SCG_RCCR_DIVBUS(value)))
#define SCG_BWR_RCCR_DIVBUS(base, value) (SCG_WR_RCCR_DIVBUS(base, value))
/*@}*/

/*!
 * @name Register SCG_RCCR, field DIVPLAT[15:12] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Reserved
 * - 0b0010 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - Reserved
 * - 0b1001 - Reserved
 * - 0b1010 - Reserved
 * - 0b1011 - Reserved
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_DIVPLAT field. */
#define SCG_RD_RCCR_DIVPLAT(base) ((SCG_RCCR_REG(base) & SCG_RCCR_DIVPLAT_MASK) >> SCG_RCCR_DIVPLAT_SHIFT)
#define SCG_BRD_RCCR_DIVPLAT(base) (SCG_RD_RCCR_DIVPLAT(base))

/*! @brief Set the DIVPLAT field to a new value. */
#define SCG_WR_RCCR_DIVPLAT(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_DIVPLAT_MASK, SCG_RCCR_DIVPLAT(value)))
#define SCG_BWR_RCCR_DIVPLAT(base, value) (SCG_WR_RCCR_DIVPLAT(base, value))
/*@}*/

/*!
 * @name Register SCG_RCCR, field DIVCORE[19:16] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_DIVCORE field. */
#define SCG_RD_RCCR_DIVCORE(base) ((SCG_RCCR_REG(base) & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT)
#define SCG_BRD_RCCR_DIVCORE(base) (SCG_RD_RCCR_DIVCORE(base))

/*! @brief Set the DIVCORE field to a new value. */
#define SCG_WR_RCCR_DIVCORE(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_DIVCORE_MASK, SCG_RCCR_DIVCORE(value)))
#define SCG_BWR_RCCR_DIVCORE(base, value) (SCG_WR_RCCR_DIVCORE(base, value))
/*@}*/

/*!
 * @name Register SCG_RCCR, field SCS[27:24] (RW)
 *
 * Selects the clock source generating the system clock in Run mode. Attempting
 * to select a clock that is not valid will be ignored. Selecting a different
 * clock source when in Run mode requires that clock source to be enabled first and
 * be valid before system clocks are allowed to switch to that clock source.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - RTC OSC
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_SCS field. */
#define SCG_RD_RCCR_SCS(base) ((SCG_RCCR_REG(base) & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT)
#define SCG_BRD_RCCR_SCS(base) (SCG_RD_RCCR_SCS(base))

/*! @brief Set the SCS field to a new value. */
#define SCG_WR_RCCR_SCS(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_SCS_MASK, SCG_RCCR_SCS(value)))
#define SCG_BWR_RCCR_SCS(base, value) (SCG_WR_RCCR_SCS(base, value))
/*@}*/

/*******************************************************************************
 * SCG_VCCR - VLPR Clock Control Register
 ******************************************************************************/

/*!
 * @brief SCG_VCCR - VLPR Clock Control Register (RW)
 *
 * Reset value: 0x02000001U
 *
 * This register controls the system clock source and the system clock dividers
 * for the core, platform, external and bus clock domains when in VLPR mode only.
 * This register can only be written using a 32-bit write. Selecting a different
 * clock source when in VLPR requires that clock source to be enabled first and
 * be valid before system clocks switch to that clock source. If system clock
 * divide ratios also change when selecting a different clock mode when in VLPR, new
 * system clock divide ratios will not take affect until new clock source is
 * valid.
 */
/*!
 * @name Constants and macros for entire SCG_VCCR register
 */
/*@{*/
#define SCG_RD_VCCR(base)        (SCG_VCCR_REG(base))
#define SCG_WR_VCCR(base, value) (SCG_VCCR_REG(base) = (value))
#define SCG_RMW_VCCR(base, mask, value) (SCG_WR_VCCR(base, (SCG_RD_VCCR(base) & ~(mask)) | (value)))
#define SCG_SET_VCCR(base, value) (SCG_WR_VCCR(base, SCG_RD_VCCR(base) |  (value)))
#define SCG_CLR_VCCR(base, value) (SCG_WR_VCCR(base, SCG_RD_VCCR(base) & ~(value)))
#define SCG_TOG_VCCR(base, value) (SCG_WR_VCCR(base, SCG_RD_VCCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_VCCR bitfields
 */

/*!
 * @name Register SCG_VCCR, field DIVSLOW[3:0] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_DIVSLOW field. */
#define SCG_RD_VCCR_DIVSLOW(base) ((SCG_VCCR_REG(base) & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT)
#define SCG_BRD_VCCR_DIVSLOW(base) (SCG_RD_VCCR_DIVSLOW(base))

/*! @brief Set the DIVSLOW field to a new value. */
#define SCG_WR_VCCR_DIVSLOW(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_DIVSLOW_MASK, SCG_VCCR_DIVSLOW(value)))
#define SCG_BWR_VCCR_DIVSLOW(base, value) (SCG_WR_VCCR_DIVSLOW(base, value))
/*@}*/

/*!
 * @name Register SCG_VCCR, field DIVBUS[7:4] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_DIVBUS field. */
#define SCG_RD_VCCR_DIVBUS(base) ((SCG_VCCR_REG(base) & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT)
#define SCG_BRD_VCCR_DIVBUS(base) (SCG_RD_VCCR_DIVBUS(base))

/*! @brief Set the DIVBUS field to a new value. */
#define SCG_WR_VCCR_DIVBUS(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_DIVBUS_MASK, SCG_VCCR_DIVBUS(value)))
#define SCG_BWR_VCCR_DIVBUS(base, value) (SCG_WR_VCCR_DIVBUS(base, value))
/*@}*/

/*!
 * @name Register SCG_VCCR, field DIVPLAT[15:12] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Reserved
 * - 0b0010 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - Reserved
 * - 0b1001 - Reserved
 * - 0b1010 - Reserved
 * - 0b1011 - Reserved
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_DIVPLAT field. */
#define SCG_RD_VCCR_DIVPLAT(base) ((SCG_VCCR_REG(base) & SCG_VCCR_DIVPLAT_MASK) >> SCG_VCCR_DIVPLAT_SHIFT)
#define SCG_BRD_VCCR_DIVPLAT(base) (SCG_RD_VCCR_DIVPLAT(base))

/*! @brief Set the DIVPLAT field to a new value. */
#define SCG_WR_VCCR_DIVPLAT(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_DIVPLAT_MASK, SCG_VCCR_DIVPLAT(value)))
#define SCG_BWR_VCCR_DIVPLAT(base, value) (SCG_WR_VCCR_DIVPLAT(base, value))
/*@}*/

/*!
 * @name Register SCG_VCCR, field DIVCORE[19:16] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_DIVCORE field. */
#define SCG_RD_VCCR_DIVCORE(base) ((SCG_VCCR_REG(base) & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT)
#define SCG_BRD_VCCR_DIVCORE(base) (SCG_RD_VCCR_DIVCORE(base))

/*! @brief Set the DIVCORE field to a new value. */
#define SCG_WR_VCCR_DIVCORE(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_DIVCORE_MASK, SCG_VCCR_DIVCORE(value)))
#define SCG_BWR_VCCR_DIVCORE(base, value) (SCG_WR_VCCR_DIVCORE(base, value))
/*@}*/

/*!
 * @name Register SCG_VCCR, field SCS[27:24] (RW)
 *
 * Selects the clock source generating the system clock in VLPR mode. Attempting
 * to select a clock that is not valid will be ignored. Selects the clock source
 * generating the system clock. Selecting a different clock source when in VLPR
 * mode requires that clock source to be enabled first and be valid before system
 * clocks switch to that clock source.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Reserved
 * - 0b0100 - RTC OSC
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_SCS field. */
#define SCG_RD_VCCR_SCS(base) ((SCG_VCCR_REG(base) & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT)
#define SCG_BRD_VCCR_SCS(base) (SCG_RD_VCCR_SCS(base))

/*! @brief Set the SCS field to a new value. */
#define SCG_WR_VCCR_SCS(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_SCS_MASK, SCG_VCCR_SCS(value)))
#define SCG_BWR_VCCR_SCS(base, value) (SCG_WR_VCCR_SCS(base, value))
/*@}*/

/*******************************************************************************
 * SCG_HCCR - HSRUN Clock Control Register
 ******************************************************************************/

/*!
 * @brief SCG_HCCR - HSRUN Clock Control Register (RW)
 *
 * Reset value: 0x03000001U
 *
 * This register controls the system clock source and the system clock dividers
 * for the core, platform, external and bus clock domains when in HSRUN mode
 * only. This register can only be written using a 32-bit write. Selecting a
 * different clock source when in HSRUN requires that clock source to be enabled first
 * and be valid before system clocks switch to that clock source. If system clock
 * divide ratios also change when selecting a different clock mode when in HSRUN,
 * new system clock divide ratios will not take affect until new clock source is
 * valid.
 */
/*!
 * @name Constants and macros for entire SCG_HCCR register
 */
/*@{*/
#define SCG_RD_HCCR(base)        (SCG_HCCR_REG(base))
#define SCG_WR_HCCR(base, value) (SCG_HCCR_REG(base) = (value))
#define SCG_RMW_HCCR(base, mask, value) (SCG_WR_HCCR(base, (SCG_RD_HCCR(base) & ~(mask)) | (value)))
#define SCG_SET_HCCR(base, value) (SCG_WR_HCCR(base, SCG_RD_HCCR(base) |  (value)))
#define SCG_CLR_HCCR(base, value) (SCG_WR_HCCR(base, SCG_RD_HCCR(base) & ~(value)))
#define SCG_TOG_HCCR(base, value) (SCG_WR_HCCR(base, SCG_RD_HCCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_HCCR bitfields
 */

/*!
 * @name Register SCG_HCCR, field DIVSLOW[3:0] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_DIVSLOW field. */
#define SCG_RD_HCCR_DIVSLOW(base) ((SCG_HCCR_REG(base) & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT)
#define SCG_BRD_HCCR_DIVSLOW(base) (SCG_RD_HCCR_DIVSLOW(base))

/*! @brief Set the DIVSLOW field to a new value. */
#define SCG_WR_HCCR_DIVSLOW(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_DIVSLOW_MASK, SCG_HCCR_DIVSLOW(value)))
#define SCG_BWR_HCCR_DIVSLOW(base, value) (SCG_WR_HCCR_DIVSLOW(base, value))
/*@}*/

/*!
 * @name Register SCG_HCCR, field DIVBUS[7:4] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_DIVBUS field. */
#define SCG_RD_HCCR_DIVBUS(base) ((SCG_HCCR_REG(base) & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT)
#define SCG_BRD_HCCR_DIVBUS(base) (SCG_RD_HCCR_DIVBUS(base))

/*! @brief Set the DIVBUS field to a new value. */
#define SCG_WR_HCCR_DIVBUS(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_DIVBUS_MASK, SCG_HCCR_DIVBUS(value)))
#define SCG_BWR_HCCR_DIVBUS(base, value) (SCG_WR_HCCR_DIVBUS(base, value))
/*@}*/

/*!
 * @name Register SCG_HCCR, field DIVPLAT[15:12] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Reserved
 * - 0b0010 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - Reserved
 * - 0b1001 - Reserved
 * - 0b1010 - Reserved
 * - 0b1011 - Reserved
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_DIVPLAT field. */
#define SCG_RD_HCCR_DIVPLAT(base) ((SCG_HCCR_REG(base) & SCG_HCCR_DIVPLAT_MASK) >> SCG_HCCR_DIVPLAT_SHIFT)
#define SCG_BRD_HCCR_DIVPLAT(base) (SCG_RD_HCCR_DIVPLAT(base))

/*! @brief Set the DIVPLAT field to a new value. */
#define SCG_WR_HCCR_DIVPLAT(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_DIVPLAT_MASK, SCG_HCCR_DIVPLAT(value)))
#define SCG_BWR_HCCR_DIVPLAT(base, value) (SCG_WR_HCCR_DIVPLAT(base, value))
/*@}*/

/*!
 * @name Register SCG_HCCR, field DIVCORE[19:16] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_DIVCORE field. */
#define SCG_RD_HCCR_DIVCORE(base) ((SCG_HCCR_REG(base) & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT)
#define SCG_BRD_HCCR_DIVCORE(base) (SCG_RD_HCCR_DIVCORE(base))

/*! @brief Set the DIVCORE field to a new value. */
#define SCG_WR_HCCR_DIVCORE(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_DIVCORE_MASK, SCG_HCCR_DIVCORE(value)))
#define SCG_BWR_HCCR_DIVCORE(base, value) (SCG_WR_HCCR_DIVCORE(base, value))
/*@}*/

/*!
 * @name Register SCG_HCCR, field SCS[27:24] (RW)
 *
 * Selects the clock source generating the system clock in HSRUN mode.
 * Attempting to select a clock that is not valid will be ignored. Selecting a different
 * clock source when in HSRUN mode will enable that clock source and switch to
 * that clock mode when it is valid.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - RTC OSC
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_SCS field. */
#define SCG_RD_HCCR_SCS(base) ((SCG_HCCR_REG(base) & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT)
#define SCG_BRD_HCCR_SCS(base) (SCG_RD_HCCR_SCS(base))

/*! @brief Set the SCS field to a new value. */
#define SCG_WR_HCCR_SCS(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_SCS_MASK, SCG_HCCR_SCS(value)))
#define SCG_BWR_HCCR_SCS(base, value) (SCG_WR_HCCR_SCS(base, value))
/*@}*/

/*******************************************************************************
 * SCG_CLKOUTCNFG - SCG CLKOUT Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_CLKOUTCNFG - SCG CLKOUT Configuration Register (RW)
 *
 * Reset value: 0x03000000U
 */
/*!
 * @name Constants and macros for entire SCG_CLKOUTCNFG register
 */
/*@{*/
#define SCG_RD_CLKOUTCNFG(base)  (SCG_CLKOUTCNFG_REG(base))
#define SCG_WR_CLKOUTCNFG(base, value) (SCG_CLKOUTCNFG_REG(base) = (value))
#define SCG_RMW_CLKOUTCNFG(base, mask, value) (SCG_WR_CLKOUTCNFG(base, (SCG_RD_CLKOUTCNFG(base) & ~(mask)) | (value)))
#define SCG_SET_CLKOUTCNFG(base, value) (SCG_WR_CLKOUTCNFG(base, SCG_RD_CLKOUTCNFG(base) |  (value)))
#define SCG_CLR_CLKOUTCNFG(base, value) (SCG_WR_CLKOUTCNFG(base, SCG_RD_CLKOUTCNFG(base) & ~(value)))
#define SCG_TOG_CLKOUTCNFG(base, value) (SCG_WR_CLKOUTCNFG(base, SCG_RD_CLKOUTCNFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_CLKOUTCNFG bitfields
 */

/*!
 * @name Register SCG_CLKOUTCNFG, field CLKOUTSEL[27:24] (RW)
 *
 * Selects the SCG system clock.
 *
 * Values:
 * - 0b0000 - SCG SLOW Clock
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - RTC OSC
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_CLKOUTCNFG_CLKOUTSEL field. */
#define SCG_RD_CLKOUTCNFG_CLKOUTSEL(base) ((SCG_CLKOUTCNFG_REG(base) & SCG_CLKOUTCNFG_CLKOUTSEL_MASK) >> SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT)
#define SCG_BRD_CLKOUTCNFG_CLKOUTSEL(base) (SCG_RD_CLKOUTCNFG_CLKOUTSEL(base))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SCG_WR_CLKOUTCNFG_CLKOUTSEL(base, value) (SCG_RMW_CLKOUTCNFG(base, SCG_CLKOUTCNFG_CLKOUTSEL_MASK, SCG_CLKOUTCNFG_CLKOUTSEL(value)))
#define SCG_BWR_CLKOUTCNFG_CLKOUTSEL(base, value) (SCG_WR_CLKOUTCNFG_CLKOUTSEL(base, value))
/*@}*/

/*******************************************************************************
 * SCG_SOSCCSR - System OSC Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_SOSCCSR - System OSC Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SCG_SOSCCSR register
 */
/*@{*/
#define SCG_RD_SOSCCSR(base)     (SCG_SOSCCSR_REG(base))
#define SCG_WR_SOSCCSR(base, value) (SCG_SOSCCSR_REG(base) = (value))
#define SCG_RMW_SOSCCSR(base, mask, value) (SCG_WR_SOSCCSR(base, (SCG_RD_SOSCCSR(base) & ~(mask)) | (value)))
#define SCG_SET_SOSCCSR(base, value) (SCG_WR_SOSCCSR(base, SCG_RD_SOSCCSR(base) |  (value)))
#define SCG_CLR_SOSCCSR(base, value) (SCG_WR_SOSCCSR(base, SCG_RD_SOSCCSR(base) & ~(value)))
#define SCG_TOG_SOSCCSR(base, value) (SCG_WR_SOSCCSR(base, SCG_RD_SOSCCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SOSCCSR bitfields
 */

/*!
 * @name Register SCG_SOSCCSR, field SOSCEN[0] (RW)
 *
 * Values:
 * - 0b0 - System OSC is disabled
 * - 0b1 - System OSC is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCEN field. */
#define SCG_RD_SOSCCSR_SOSCEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCEN(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCEN_SHIFT))

/*! @brief Set the SOSCEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCEN(value)))
#define SCG_BWR_SOSCCSR_SOSCEN(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - System OSC is disabled in Stop modes
 * - 0b1 - System OSC is enabled in Stop modes if SOSCEN=1.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCSTEN field. */
#define SCG_RD_SOSCCSR_SOSCSTEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCSTEN_MASK) >> SCG_SOSCCSR_SOSCSTEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCSTEN(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCSTEN_SHIFT))

/*! @brief Set the SOSCSTEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCSTEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCSTEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCSTEN(value)))
#define SCG_BWR_SOSCCSR_SOSCSTEN(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCLPEN[2] (RW)
 *
 * SOSCLPEN is required for low power modes. In VLPS mode (low power stop mode),
 * if you want the clock to remain ON, then both SOSCLPEN and SOSCSTEN bits must
 * be enabled.
 *
 * Values:
 * - 0b0 - System OSC is disabled in VLP modes
 * - 0b1 - System OSC is enabled in VLP modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCLPEN field. */
#define SCG_RD_SOSCCSR_SOSCLPEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCLPEN_MASK) >> SCG_SOSCCSR_SOSCLPEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCLPEN(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCLPEN_SHIFT))

/*! @brief Set the SOSCLPEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCLPEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCLPEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCLPEN(value)))
#define SCG_BWR_SOSCCSR_SOSCLPEN(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCLPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCERCLKEN[3] (RW)
 *
 * SOSCERCLKEN is required for stop modes.
 *
 * Values:
 * - 0b0 - System OSC 3V ERCLK output clock is disabled.
 * - 0b1 - System OSC 3V ERCLK output clock is enabled when SYSOSC is enabled.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCERCLKEN field. */
#define SCG_RD_SOSCCSR_SOSCERCLKEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCERCLKEN_MASK) >> SCG_SOSCCSR_SOSCERCLKEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCERCLKEN(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCERCLKEN_SHIFT))

/*! @brief Set the SOSCERCLKEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCERCLKEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCERCLKEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCERCLKEN(value)))
#define SCG_BWR_SOSCCSR_SOSCERCLKEN(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCERCLKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCCM[16] (RW)
 *
 * Enables the clock monitor, if the clock source is disabled in a low power
 * mode then the clock monitor is also disabled in the low power mode. When the
 * clock monitor is disabled in a low power mode, it remains disabled until the clock
 * valid flag is set following exit from the low power mode.
 *
 * Values:
 * - 0b0 - System OSC Clock Monitor is disabled
 * - 0b1 - System OSC Clock Monitor is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCCM field. */
#define SCG_RD_SOSCCSR_SOSCCM(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCCM_MASK) >> SCG_SOSCCSR_SOSCCM_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCCM(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCCM_SHIFT))

/*! @brief Set the SOSCCM field to a new value. */
#define SCG_WR_SOSCCSR_SOSCCM(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCCM_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCCM(value)))
#define SCG_BWR_SOSCCSR_SOSCCM(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCCM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCCMRE[17] (RW)
 *
 * Values:
 * - 0b0 - Clock Monitor generates interrupt when error detected
 * - 0b1 - Clock Monitor generates reset when error detected
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCCMRE field. */
#define SCG_RD_SOSCCSR_SOSCCMRE(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCCMRE_MASK) >> SCG_SOSCCSR_SOSCCMRE_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCCMRE(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCCMRE_SHIFT))

/*! @brief Set the SOSCCMRE field to a new value. */
#define SCG_WR_SOSCCSR_SOSCCMRE(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCCMRE_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCCMRE(value)))
#define SCG_BWR_SOSCCSR_SOSCCMRE(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCCMRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until the next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_LK field. */
#define SCG_RD_SOSCCSR_LK(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_LK_MASK) >> SCG_SOSCCSR_LK_SHIFT)
#define SCG_BRD_SOSCCSR_LK(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_SOSCCSR_LK(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_LK_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_LK(value)))
#define SCG_BWR_SOSCCSR_LK(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCVLD[24] (RO)
 *
 * Values:
 * - 0b0 - System OSC is not enabled or clock is not valid
 * - 0b1 - System OSC is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCVLD field. */
#define SCG_RD_SOSCCSR_SOSCVLD(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCVLD(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCVLD_SHIFT))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCSEL[25] (RO)
 *
 * Values:
 * - 0b0 - System OSC is not the system clock source
 * - 0b1 - System OSC is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCSEL field. */
#define SCG_RD_SOSCCSR_SOSCSEL(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCSEL_MASK) >> SCG_SOSCCSR_SOSCSEL_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCSEL(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCSEL_SHIFT))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCERR[26] (W1C)
 *
 * This flag is reset on Chip POR only, software can also clear this flag by
 * writing a logic one.
 *
 * Values:
 * - 0b0 - System OSC Clock Monitor is disabled or has not detected an error
 * - 0b1 - System OSC Clock Monitor is enabled and detected an error
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCERR field. */
#define SCG_RD_SOSCCSR_SOSCERR(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCERR_MASK) >> SCG_SOSCCSR_SOSCERR_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCERR(base) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCERR_SHIFT))

/*! @brief Set the SOSCERR field to a new value. */
#define SCG_WR_SOSCCSR_SOSCERR(base, value) (SCG_RMW_SOSCCSR(base, SCG_SOSCCSR_SOSCERR_MASK, SCG_SOSCCSR_SOSCERR(value)))
#define SCG_BWR_SOSCCSR_SOSCERR(base, value) (BITBAND_ACCESS32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCERR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SCG_SOSCDIV - System OSC Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_SOSCDIV - System OSC Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Changes to SOSCDIV should be done when System OSC is disabled to prevent
 * glitches to output divided clock.
 */
/*!
 * @name Constants and macros for entire SCG_SOSCDIV register
 */
/*@{*/
#define SCG_RD_SOSCDIV(base)     (SCG_SOSCDIV_REG(base))
#define SCG_WR_SOSCDIV(base, value) (SCG_SOSCDIV_REG(base) = (value))
#define SCG_RMW_SOSCDIV(base, mask, value) (SCG_WR_SOSCDIV(base, (SCG_RD_SOSCDIV(base) & ~(mask)) | (value)))
#define SCG_SET_SOSCDIV(base, value) (SCG_WR_SOSCDIV(base, SCG_RD_SOSCDIV(base) |  (value)))
#define SCG_CLR_SOSCDIV(base, value) (SCG_WR_SOSCDIV(base, SCG_RD_SOSCDIV(base) & ~(value)))
#define SCG_TOG_SOSCDIV(base, value) (SCG_WR_SOSCDIV(base, SCG_RD_SOSCDIV(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SOSCDIV bitfields
 */

/*!
 * @name Register SCG_SOSCDIV, field SOSCDIV1[2:0] (RW)
 *
 * Clock divider 1 for System OSC. Used to generate the system clock source and
 * by platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCDIV_SOSCDIV1 field. */
#define SCG_RD_SOSCDIV_SOSCDIV1(base) ((SCG_SOSCDIV_REG(base) & SCG_SOSCDIV_SOSCDIV1_MASK) >> SCG_SOSCDIV_SOSCDIV1_SHIFT)
#define SCG_BRD_SOSCDIV_SOSCDIV1(base) (SCG_RD_SOSCDIV_SOSCDIV1(base))

/*! @brief Set the SOSCDIV1 field to a new value. */
#define SCG_WR_SOSCDIV_SOSCDIV1(base, value) (SCG_RMW_SOSCDIV(base, SCG_SOSCDIV_SOSCDIV1_MASK, SCG_SOSCDIV_SOSCDIV1(value)))
#define SCG_BWR_SOSCDIV_SOSCDIV1(base, value) (SCG_WR_SOSCDIV_SOSCDIV1(base, value))
/*@}*/

/*!
 * @name Register SCG_SOSCDIV, field SOSCDIV2[10:8] (RW)
 *
 * Clock divider 2 for System OSC. Used by bus clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCDIV_SOSCDIV2 field. */
#define SCG_RD_SOSCDIV_SOSCDIV2(base) ((SCG_SOSCDIV_REG(base) & SCG_SOSCDIV_SOSCDIV2_MASK) >> SCG_SOSCDIV_SOSCDIV2_SHIFT)
#define SCG_BRD_SOSCDIV_SOSCDIV2(base) (SCG_RD_SOSCDIV_SOSCDIV2(base))

/*! @brief Set the SOSCDIV2 field to a new value. */
#define SCG_WR_SOSCDIV_SOSCDIV2(base, value) (SCG_RMW_SOSCDIV(base, SCG_SOSCDIV_SOSCDIV2_MASK, SCG_SOSCDIV_SOSCDIV2(value)))
#define SCG_BWR_SOSCDIV_SOSCDIV2(base, value) (SCG_WR_SOSCDIV_SOSCDIV2(base, value))
/*@}*/

/*!
 * @name Register SCG_SOSCDIV, field SOSCDIV3[18:16] (RW)
 *
 * Clock divider 3 for System OSC. Used by slow clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCDIV_SOSCDIV3 field. */
#define SCG_RD_SOSCDIV_SOSCDIV3(base) ((SCG_SOSCDIV_REG(base) & SCG_SOSCDIV_SOSCDIV3_MASK) >> SCG_SOSCDIV_SOSCDIV3_SHIFT)
#define SCG_BRD_SOSCDIV_SOSCDIV3(base) (SCG_RD_SOSCDIV_SOSCDIV3(base))

/*! @brief Set the SOSCDIV3 field to a new value. */
#define SCG_WR_SOSCDIV_SOSCDIV3(base, value) (SCG_RMW_SOSCDIV(base, SCG_SOSCDIV_SOSCDIV3_MASK, SCG_SOSCDIV_SOSCDIV3(value)))
#define SCG_BWR_SOSCDIV_SOSCDIV3(base, value) (SCG_WR_SOSCDIV_SOSCDIV3(base, value))
/*@}*/

/*******************************************************************************
 * SCG_SOSCCFG - System Oscillator Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_SOSCCFG - System Oscillator Configuration Register (RW)
 *
 * Reset value: 0x00000010U
 *
 * The SOSCCFG register cannot be changed when the System OSC is enabled. When
 * the System OSC is enabled, writes to this register are ignored, and there is no
 * transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_SOSCCFG register
 */
/*@{*/
#define SCG_RD_SOSCCFG(base)     (SCG_SOSCCFG_REG(base))
#define SCG_WR_SOSCCFG(base, value) (SCG_SOSCCFG_REG(base) = (value))
#define SCG_RMW_SOSCCFG(base, mask, value) (SCG_WR_SOSCCFG(base, (SCG_RD_SOSCCFG(base) & ~(mask)) | (value)))
#define SCG_SET_SOSCCFG(base, value) (SCG_WR_SOSCCFG(base, SCG_RD_SOSCCFG(base) |  (value)))
#define SCG_CLR_SOSCCFG(base, value) (SCG_WR_SOSCCFG(base, SCG_RD_SOSCCFG(base) & ~(value)))
#define SCG_TOG_SOSCCFG(base, value) (SCG_WR_SOSCCFG(base, SCG_RD_SOSCCFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SOSCCFG bitfields
 */

/*!
 * @name Register SCG_SOSCCFG, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock.
 *
 * Values:
 * - 0b0 - External reference clock from PAD pin selected
 * - 0b1 - Internal oscillator of OSC requested.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_EREFS field. */
#define SCG_RD_SOSCCFG_EREFS(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_EREFS_MASK) >> SCG_SOSCCFG_EREFS_SHIFT)
#define SCG_BRD_SOSCCFG_EREFS(base) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_EREFS_SHIFT))

/*! @brief Set the EREFS field to a new value. */
#define SCG_WR_SOSCCFG_EREFS(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_EREFS_MASK, SCG_SOSCCFG_EREFS(value)))
#define SCG_BWR_SOSCCFG_EREFS(base, value) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_EREFS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field HGO[3] (RW)
 *
 * Controls the crystal oscillator power mode of operations.
 *
 * Values:
 * - 0b0 - Configure crystal oscillator for low-power operation
 * - 0b1 - Configure crystal oscillator for high-gain operation
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_HGO field. */
#define SCG_RD_SOSCCFG_HGO(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_HGO_MASK) >> SCG_SOSCCFG_HGO_SHIFT)
#define SCG_BRD_SOSCCFG_HGO(base) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_HGO_SHIFT))

/*! @brief Set the HGO field to a new value. */
#define SCG_WR_SOSCCFG_HGO(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_HGO_MASK, SCG_SOSCCFG_HGO(value)))
#define SCG_BWR_SOSCCFG_HGO(base, value) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_HGO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the system crystal oscillator (OSC)
 *
 * Values:
 * - 0b00 - Reserved
 * - 0b01 - Low frequency range selected for the crystal oscillator of 32 kHz to
 *     40 kHz.
 * - 0b10 - Medium frequency range selected for the crytstal oscillator of 1 MHz
 *     to 8 MHz.
 * - 0b11 - High frequency range selected for the crystal oscillator of 8 MHz to
 *     32 MHz.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_RANGE field. */
#define SCG_RD_SOSCCFG_RANGE(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_RANGE_MASK) >> SCG_SOSCCFG_RANGE_SHIFT)
#define SCG_BRD_SOSCCFG_RANGE(base) (SCG_RD_SOSCCFG_RANGE(base))

/*! @brief Set the RANGE field to a new value. */
#define SCG_WR_SOSCCFG_RANGE(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_RANGE_MASK, SCG_SOSCCFG_RANGE(value)))
#define SCG_BWR_SOSCCFG_RANGE(base, value) (SCG_WR_SOSCCFG_RANGE(base, value))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC16P[8] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC16P field. */
#define SCG_RD_SOSCCFG_SC16P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC16P_MASK) >> SCG_SOSCCFG_SC16P_SHIFT)
#define SCG_BRD_SOSCCFG_SC16P(base) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC16P_SHIFT))

/*! @brief Set the SC16P field to a new value. */
#define SCG_WR_SOSCCFG_SC16P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC16P_MASK, SCG_SOSCCFG_SC16P(value)))
#define SCG_BWR_SOSCCFG_SC16P(base, value) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC16P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC8P[9] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC8P field. */
#define SCG_RD_SOSCCFG_SC8P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC8P_MASK) >> SCG_SOSCCFG_SC8P_SHIFT)
#define SCG_BRD_SOSCCFG_SC8P(base) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC8P_SHIFT))

/*! @brief Set the SC8P field to a new value. */
#define SCG_WR_SOSCCFG_SC8P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC8P_MASK, SCG_SOSCCFG_SC8P(value)))
#define SCG_BWR_SOSCCFG_SC8P(base, value) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC8P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC4P[10] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC4P field. */
#define SCG_RD_SOSCCFG_SC4P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC4P_MASK) >> SCG_SOSCCFG_SC4P_SHIFT)
#define SCG_BRD_SOSCCFG_SC4P(base) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC4P_SHIFT))

/*! @brief Set the SC4P field to a new value. */
#define SCG_WR_SOSCCFG_SC4P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC4P_MASK, SCG_SOSCCFG_SC4P(value)))
#define SCG_BWR_SOSCCFG_SC4P(base, value) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC4P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC2P[11] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC2P field. */
#define SCG_RD_SOSCCFG_SC2P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC2P_MASK) >> SCG_SOSCCFG_SC2P_SHIFT)
#define SCG_BRD_SOSCCFG_SC2P(base) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC2P_SHIFT))

/*! @brief Set the SC2P field to a new value. */
#define SCG_WR_SOSCCFG_SC2P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC2P_MASK, SCG_SOSCCFG_SC2P(value)))
#define SCG_BWR_SOSCCFG_SC2P(base, value) (BITBAND_ACCESS32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC2P_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SCG_SIRCCSR - Slow IRC Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_SIRCCSR - Slow IRC Control Status Register (RW)
 *
 * Reset value: 0x03000005U
 */
/*!
 * @name Constants and macros for entire SCG_SIRCCSR register
 */
/*@{*/
#define SCG_RD_SIRCCSR(base)     (SCG_SIRCCSR_REG(base))
#define SCG_WR_SIRCCSR(base, value) (SCG_SIRCCSR_REG(base) = (value))
#define SCG_RMW_SIRCCSR(base, mask, value) (SCG_WR_SIRCCSR(base, (SCG_RD_SIRCCSR(base) & ~(mask)) | (value)))
#define SCG_SET_SIRCCSR(base, value) (SCG_WR_SIRCCSR(base, SCG_RD_SIRCCSR(base) |  (value)))
#define SCG_CLR_SIRCCSR(base, value) (SCG_WR_SIRCCSR(base, SCG_RD_SIRCCSR(base) & ~(value)))
#define SCG_TOG_SIRCCSR(base, value) (SCG_WR_SIRCCSR(base, SCG_RD_SIRCCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SIRCCSR bitfields
 */

/*!
 * @name Register SCG_SIRCCSR, field SIRCEN[0] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC is disabled
 * - 0b1 - Slow IRC is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCEN field. */
#define SCG_RD_SIRCCSR_SIRCEN(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCEN_MASK) >> SCG_SIRCCSR_SIRCEN_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCEN(base) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCEN_SHIFT))

/*! @brief Set the SIRCEN field to a new value. */
#define SCG_WR_SIRCCSR_SIRCEN(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_SIRCEN_MASK, SCG_SIRCCSR_SIRCEN(value)))
#define SCG_BWR_SIRCCSR_SIRCEN(base, value) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC is disabled in Stop modes
 * - 0b1 - Slow IRC is enabled in Stop modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCSTEN field. */
#define SCG_RD_SIRCCSR_SIRCSTEN(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCSTEN_MASK) >> SCG_SIRCCSR_SIRCSTEN_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCSTEN(base) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCSTEN_SHIFT))

/*! @brief Set the SIRCSTEN field to a new value. */
#define SCG_WR_SIRCCSR_SIRCSTEN(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_SIRCSTEN_MASK, SCG_SIRCCSR_SIRCSTEN(value)))
#define SCG_BWR_SIRCCSR_SIRCSTEN(base, value) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCLPEN[2] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC is disabled in VLP modes
 * - 0b1 - Slow IRC is enabled in VLP modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCLPEN field. */
#define SCG_RD_SIRCCSR_SIRCLPEN(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCLPEN_MASK) >> SCG_SIRCCSR_SIRCLPEN_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCLPEN(base) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCLPEN_SHIFT))

/*! @brief Set the SIRCLPEN field to a new value. */
#define SCG_WR_SIRCCSR_SIRCLPEN(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_SIRCLPEN_MASK, SCG_SIRCCSR_SIRCLPEN(value)))
#define SCG_BWR_SIRCCSR_SIRCLPEN(base, value) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCLPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_LK field. */
#define SCG_RD_SIRCCSR_LK(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_LK_MASK) >> SCG_SIRCCSR_LK_SHIFT)
#define SCG_BRD_SIRCCSR_LK(base) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_SIRCCSR_LK(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_LK_MASK, SCG_SIRCCSR_LK(value)))
#define SCG_BWR_SIRCCSR_LK(base, value) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCVLD[24] (RO)
 *
 * Values:
 * - 0b0 - Slow IRC is not enabled or clock is not valid
 * - 0b1 - Slow IRC is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCVLD field. */
#define SCG_RD_SIRCCSR_SIRCVLD(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCVLD(base) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCVLD_SHIFT))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCSEL[25] (RO)
 *
 * Values:
 * - 0b0 - Slow IRC is not the system clock source
 * - 0b1 - Slow IRC is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCSEL field. */
#define SCG_RD_SIRCCSR_SIRCSEL(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCSEL_MASK) >> SCG_SIRCCSR_SIRCSEL_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCSEL(base) (BITBAND_ACCESS32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCSEL_SHIFT))
/*@}*/

/*******************************************************************************
 * SCG_SIRCDIV - Slow IRC Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_SIRCDIV - Slow IRC Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Changes to SIRCDIV should be done when Slow IRC is disabled to prevent
 * glitches to output divided clock. The recommended method for changing the SIRCDIV
 * Register is: Disable SIRC Configure the SIRCDIV values as needed Enable SIRC
 */
/*!
 * @name Constants and macros for entire SCG_SIRCDIV register
 */
/*@{*/
#define SCG_RD_SIRCDIV(base)     (SCG_SIRCDIV_REG(base))
#define SCG_WR_SIRCDIV(base, value) (SCG_SIRCDIV_REG(base) = (value))
#define SCG_RMW_SIRCDIV(base, mask, value) (SCG_WR_SIRCDIV(base, (SCG_RD_SIRCDIV(base) & ~(mask)) | (value)))
#define SCG_SET_SIRCDIV(base, value) (SCG_WR_SIRCDIV(base, SCG_RD_SIRCDIV(base) |  (value)))
#define SCG_CLR_SIRCDIV(base, value) (SCG_WR_SIRCDIV(base, SCG_RD_SIRCDIV(base) & ~(value)))
#define SCG_TOG_SIRCDIV(base, value) (SCG_WR_SIRCDIV(base, SCG_RD_SIRCDIV(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SIRCDIV bitfields
 */

/*!
 * @name Register SCG_SIRCDIV, field SIRCDIV1[2:0] (RW)
 *
 * Clock divider 1 for Slow IRC. Used to generate the system clock source and by
 * platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCDIV_SIRCDIV1 field. */
#define SCG_RD_SIRCDIV_SIRCDIV1(base) ((SCG_SIRCDIV_REG(base) & SCG_SIRCDIV_SIRCDIV1_MASK) >> SCG_SIRCDIV_SIRCDIV1_SHIFT)
#define SCG_BRD_SIRCDIV_SIRCDIV1(base) (SCG_RD_SIRCDIV_SIRCDIV1(base))

/*! @brief Set the SIRCDIV1 field to a new value. */
#define SCG_WR_SIRCDIV_SIRCDIV1(base, value) (SCG_RMW_SIRCDIV(base, SCG_SIRCDIV_SIRCDIV1_MASK, SCG_SIRCDIV_SIRCDIV1(value)))
#define SCG_BWR_SIRCDIV_SIRCDIV1(base, value) (SCG_WR_SIRCDIV_SIRCDIV1(base, value))
/*@}*/

/*!
 * @name Register SCG_SIRCDIV, field SIRCDIV2[10:8] (RW)
 *
 * Clock divider 2 for Slow IRC. Used by bus clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCDIV_SIRCDIV2 field. */
#define SCG_RD_SIRCDIV_SIRCDIV2(base) ((SCG_SIRCDIV_REG(base) & SCG_SIRCDIV_SIRCDIV2_MASK) >> SCG_SIRCDIV_SIRCDIV2_SHIFT)
#define SCG_BRD_SIRCDIV_SIRCDIV2(base) (SCG_RD_SIRCDIV_SIRCDIV2(base))

/*! @brief Set the SIRCDIV2 field to a new value. */
#define SCG_WR_SIRCDIV_SIRCDIV2(base, value) (SCG_RMW_SIRCDIV(base, SCG_SIRCDIV_SIRCDIV2_MASK, SCG_SIRCDIV_SIRCDIV2(value)))
#define SCG_BWR_SIRCDIV_SIRCDIV2(base, value) (SCG_WR_SIRCDIV_SIRCDIV2(base, value))
/*@}*/

/*!
 * @name Register SCG_SIRCDIV, field SIRCDIV3[18:16] (RW)
 *
 * Clock divider 3 for Slow IRC. Used by slow clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCDIV_SIRCDIV3 field. */
#define SCG_RD_SIRCDIV_SIRCDIV3(base) ((SCG_SIRCDIV_REG(base) & SCG_SIRCDIV_SIRCDIV3_MASK) >> SCG_SIRCDIV_SIRCDIV3_SHIFT)
#define SCG_BRD_SIRCDIV_SIRCDIV3(base) (SCG_RD_SIRCDIV_SIRCDIV3(base))

/*! @brief Set the SIRCDIV3 field to a new value. */
#define SCG_WR_SIRCDIV_SIRCDIV3(base, value) (SCG_RMW_SIRCDIV(base, SCG_SIRCDIV_SIRCDIV3_MASK, SCG_SIRCDIV_SIRCDIV3(value)))
#define SCG_BWR_SIRCDIV_SIRCDIV3(base, value) (SCG_WR_SIRCDIV_SIRCDIV3(base, value))
/*@}*/

/*******************************************************************************
 * SCG_SIRCCFG - Slow IRC Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_SIRCCFG - Slow IRC Configuration Register (RW)
 *
 * Reset value: 0x00000001U
 *
 * The SIRCCFG register cannot be changed when the slow IRC clock is enabled.
 * When the slow IRC clock is enabled, writes to this register are ignored, and
 * there is no transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_SIRCCFG register
 */
/*@{*/
#define SCG_RD_SIRCCFG(base)     (SCG_SIRCCFG_REG(base))
#define SCG_WR_SIRCCFG(base, value) (SCG_SIRCCFG_REG(base) = (value))
#define SCG_RMW_SIRCCFG(base, mask, value) (SCG_WR_SIRCCFG(base, (SCG_RD_SIRCCFG(base) & ~(mask)) | (value)))
#define SCG_SET_SIRCCFG(base, value) (SCG_WR_SIRCCFG(base, SCG_RD_SIRCCFG(base) |  (value)))
#define SCG_CLR_SIRCCFG(base, value) (SCG_WR_SIRCCFG(base, SCG_RD_SIRCCFG(base) & ~(value)))
#define SCG_TOG_SIRCCFG(base, value) (SCG_WR_SIRCCFG(base, SCG_RD_SIRCCFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SIRCCFG bitfields
 */

/*!
 * @name Register SCG_SIRCCFG, field RANGE[0] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC low range clock (2 MHz)
 * - 0b1 - Slow IRC high range clock (8 MHz)
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCFG_RANGE field. */
#define SCG_RD_SIRCCFG_RANGE(base) ((SCG_SIRCCFG_REG(base) & SCG_SIRCCFG_RANGE_MASK) >> SCG_SIRCCFG_RANGE_SHIFT)
#define SCG_BRD_SIRCCFG_RANGE(base) (BITBAND_ACCESS32(&SCG_SIRCCFG_REG(base), SCG_SIRCCFG_RANGE_SHIFT))

/*! @brief Set the RANGE field to a new value. */
#define SCG_WR_SIRCCFG_RANGE(base, value) (SCG_RMW_SIRCCFG(base, SCG_SIRCCFG_RANGE_MASK, SCG_SIRCCFG_RANGE(value)))
#define SCG_BWR_SIRCCFG_RANGE(base, value) (BITBAND_ACCESS32(&SCG_SIRCCFG_REG(base), SCG_SIRCCFG_RANGE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SCG_SIRCTRIM - Slow IRC Trim Register
 ******************************************************************************/

/*!
 * @brief SCG_SIRCTRIM - Slow IRC Trim Register (RW)
 *
 * Reset value: 0x037F037FU
 *
 * This register is loaded from IFR during reset. It can be written in
 * functional test mode only.
 */
/*!
 * @name Constants and macros for entire SCG_SIRCTRIM register
 */
/*@{*/
#define SCG_RD_SIRCTRIM(base)    (SCG_SIRCTRIM_REG(base))
#define SCG_WR_SIRCTRIM(base, value) (SCG_SIRCTRIM_REG(base) = (value))
#define SCG_RMW_SIRCTRIM(base, mask, value) (SCG_WR_SIRCTRIM(base, (SCG_RD_SIRCTRIM(base) & ~(mask)) | (value)))
#define SCG_SET_SIRCTRIM(base, value) (SCG_WR_SIRCTRIM(base, SCG_RD_SIRCTRIM(base) |  (value)))
#define SCG_CLR_SIRCTRIM(base, value) (SCG_WR_SIRCTRIM(base, SCG_RD_SIRCTRIM(base) & ~(value)))
#define SCG_TOG_SIRCTRIM(base, value) (SCG_WR_SIRCTRIM(base, SCG_RD_SIRCTRIM(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SIRCTRIM bitfields
 */

/*!
 * @name Register SCG_SIRCTRIM, field TRIMLO[6:0] (RW)
 *
 * Trim High Range trims the Slow IRC low range clock. Writing a large trim
 * value will speed up the clock. Writing a small value will slow down the clock.
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCTRIM_TRIMLO field. */
#define SCG_RD_SIRCTRIM_TRIMLO(base) ((SCG_SIRCTRIM_REG(base) & SCG_SIRCTRIM_TRIMLO_MASK) >> SCG_SIRCTRIM_TRIMLO_SHIFT)
#define SCG_BRD_SIRCTRIM_TRIMLO(base) (SCG_RD_SIRCTRIM_TRIMLO(base))

/*! @brief Set the TRIMLO field to a new value. */
#define SCG_WR_SIRCTRIM_TRIMLO(base, value) (SCG_RMW_SIRCTRIM(base, SCG_SIRCTRIM_TRIMLO_MASK, SCG_SIRCTRIM_TRIMLO(value)))
#define SCG_BWR_SIRCTRIM_TRIMLO(base, value) (SCG_WR_SIRCTRIM_TRIMLO(base, value))
/*@}*/

/*!
 * @name Register SCG_SIRCTRIM, field LOTRIMRNG[9:8] (RW)
 *
 * Trim effect level of SIRC TRIMLO can be enlarged by setting this field. Loads
 * from a factory programmed location when out of reset.
 *
 * Values:
 * - 0b00 - Frequency shift by 10%
 * - 0b01 - No frequency shift
 * - 0b10 - No frequency shift
 * - 0b11 - Frequency shift by -10%
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCTRIM_LOTRIMRNG field. */
#define SCG_RD_SIRCTRIM_LOTRIMRNG(base) ((SCG_SIRCTRIM_REG(base) & SCG_SIRCTRIM_LOTRIMRNG_MASK) >> SCG_SIRCTRIM_LOTRIMRNG_SHIFT)
#define SCG_BRD_SIRCTRIM_LOTRIMRNG(base) (SCG_RD_SIRCTRIM_LOTRIMRNG(base))

/*! @brief Set the LOTRIMRNG field to a new value. */
#define SCG_WR_SIRCTRIM_LOTRIMRNG(base, value) (SCG_RMW_SIRCTRIM(base, SCG_SIRCTRIM_LOTRIMRNG_MASK, SCG_SIRCTRIM_LOTRIMRNG(value)))
#define SCG_BWR_SIRCTRIM_LOTRIMRNG(base, value) (SCG_WR_SIRCTRIM_LOTRIMRNG(base, value))
/*@}*/

/*!
 * @name Register SCG_SIRCTRIM, field TRIMHI[22:16] (RW)
 *
 * Trim High Range trims the Slow IRC high range clock. Writing a large trim
 * value will speed up the clock. Writing a small value will slow down the clock.
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCTRIM_TRIMHI field. */
#define SCG_RD_SIRCTRIM_TRIMHI(base) ((SCG_SIRCTRIM_REG(base) & SCG_SIRCTRIM_TRIMHI_MASK) >> SCG_SIRCTRIM_TRIMHI_SHIFT)
#define SCG_BRD_SIRCTRIM_TRIMHI(base) (SCG_RD_SIRCTRIM_TRIMHI(base))

/*! @brief Set the TRIMHI field to a new value. */
#define SCG_WR_SIRCTRIM_TRIMHI(base, value) (SCG_RMW_SIRCTRIM(base, SCG_SIRCTRIM_TRIMHI_MASK, SCG_SIRCTRIM_TRIMHI(value)))
#define SCG_BWR_SIRCTRIM_TRIMHI(base, value) (SCG_WR_SIRCTRIM_TRIMHI(base, value))
/*@}*/

/*!
 * @name Register SCG_SIRCTRIM, field HTRIMRNG[25:24] (RW)
 *
 * Trim effect level of SIRC TRIMHI can be enlarged by setting this field. Loads
 * from a factory programmed location when out of reset.
 *
 * Values:
 * - 0b00 - Frequency shift by 10%
 * - 0b01 - No frequency shift
 * - 0b10 - No frequency shift
 * - 0b11 - Frequency shift by -10%
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCTRIM_HTRIMRNG field. */
#define SCG_RD_SIRCTRIM_HTRIMRNG(base) ((SCG_SIRCTRIM_REG(base) & SCG_SIRCTRIM_HTRIMRNG_MASK) >> SCG_SIRCTRIM_HTRIMRNG_SHIFT)
#define SCG_BRD_SIRCTRIM_HTRIMRNG(base) (SCG_RD_SIRCTRIM_HTRIMRNG(base))

/*! @brief Set the HTRIMRNG field to a new value. */
#define SCG_WR_SIRCTRIM_HTRIMRNG(base, value) (SCG_RMW_SIRCTRIM(base, SCG_SIRCTRIM_HTRIMRNG_MASK, SCG_SIRCTRIM_HTRIMRNG(value)))
#define SCG_BWR_SIRCTRIM_HTRIMRNG(base, value) (SCG_WR_SIRCTRIM_HTRIMRNG(base, value))
/*@}*/

/*******************************************************************************
 * SCG_FIRCCSR - Fast IRC Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCCSR - Fast IRC Control Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire SCG_FIRCCSR register
 */
/*@{*/
#define SCG_RD_FIRCCSR(base)     (SCG_FIRCCSR_REG(base))
#define SCG_WR_FIRCCSR(base, value) (SCG_FIRCCSR_REG(base) = (value))
#define SCG_RMW_FIRCCSR(base, mask, value) (SCG_WR_FIRCCSR(base, (SCG_RD_FIRCCSR(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCCSR(base, value) (SCG_WR_FIRCCSR(base, SCG_RD_FIRCCSR(base) |  (value)))
#define SCG_CLR_FIRCCSR(base, value) (SCG_WR_FIRCCSR(base, SCG_RD_FIRCCSR(base) & ~(value)))
#define SCG_TOG_FIRCCSR(base, value) (SCG_WR_FIRCCSR(base, SCG_RD_FIRCCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCCSR bitfields
 */

/*!
 * @name Register SCG_FIRCCSR, field FIRCEN[0] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC is disabled
 * - 0b1 - Fast IRC is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCEN field. */
#define SCG_RD_FIRCCSR_FIRCEN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCEN(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCEN_SHIFT))

/*! @brief Set the FIRCEN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCEN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCEN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCEN(value)))
#define SCG_BWR_FIRCCSR_FIRCEN(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC is disabled in Stop modes. When selected as the reference
 *     clock to the System PLL and if the System PLL is enabled in STOP mode, the
 *     Fast IRC will stay enabled even if FIRCSTEN=0.
 * - 0b1 - Fast IRC is enabled in Stop modes
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCSTEN field. */
#define SCG_RD_FIRCCSR_FIRCSTEN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCSTEN_MASK) >> SCG_FIRCCSR_FIRCSTEN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCSTEN(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCSTEN_SHIFT))

/*! @brief Set the FIRCSTEN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCSTEN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCSTEN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCSTEN(value)))
#define SCG_BWR_FIRCCSR_FIRCSTEN(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCREGOFF[2] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC Regulator is enabled.
 * - 0b1 - Fast IRC Regulator is disabled.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCREGOFF field. */
#define SCG_RD_FIRCCSR_FIRCREGOFF(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCREGOFF(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCREGOFF_SHIFT))

/*! @brief Set the FIRCREGOFF field to a new value. */
#define SCG_WR_FIRCCSR_FIRCREGOFF(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCREGOFF_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCREGOFF(value)))
#define SCG_BWR_FIRCCSR_FIRCREGOFF(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCREGOFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCLPEN[3] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC is disabled in VLP modes
 * - 0b1 - Fast IRC is enabled in VLP modes
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCLPEN field. */
#define SCG_RD_FIRCCSR_FIRCLPEN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCLPEN_MASK) >> SCG_FIRCCSR_FIRCLPEN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCLPEN(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCLPEN_SHIFT))

/*! @brief Set the FIRCLPEN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCLPEN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCLPEN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCLPEN(value)))
#define SCG_BWR_FIRCCSR_FIRCLPEN(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCLPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCTREN[8] (RW)
 *
 * When FIRC is enabled, writes to this field are allowed.
 *
 * Values:
 * - 0b0 - Disable trimming Fast IRC to an external clock source
 * - 0b1 - Enable trimming Fast IRC to an external clock source If FIRC is
 *     enabled, and FIRCTREN=1, the external reference clock always needs to be valid.
 *     If this is a concern, a clock monitor for this external reference clock
 *     can be enabled to generate an interrupt or reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCTREN field. */
#define SCG_RD_FIRCCSR_FIRCTREN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCTREN_MASK) >> SCG_FIRCCSR_FIRCTREN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCTREN(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCTREN_SHIFT))

/*! @brief Set the FIRCTREN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCTREN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCTREN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCTREN(value)))
#define SCG_BWR_FIRCCSR_FIRCTREN(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCTREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCTRUP[9] (RW)
 *
 * Values:
 * - 0b0 - Disable Fast IRC trimming updates
 * - 0b1 - Enable Fast IRC trimming updates
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCTRUP field. */
#define SCG_RD_FIRCCSR_FIRCTRUP(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCTRUP_MASK) >> SCG_FIRCCSR_FIRCTRUP_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCTRUP(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCTRUP_SHIFT))

/*! @brief Set the FIRCTRUP field to a new value. */
#define SCG_WR_FIRCCSR_FIRCTRUP(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCTRUP_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCTRUP(value)))
#define SCG_BWR_FIRCCSR_FIRCTRUP(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCTRUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until the next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_LK field. */
#define SCG_RD_FIRCCSR_LK(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_LK_MASK) >> SCG_FIRCCSR_LK_SHIFT)
#define SCG_BRD_FIRCCSR_LK(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_FIRCCSR_LK(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_LK_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_LK(value)))
#define SCG_BWR_FIRCCSR_LK(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCVLD[24] (RO)
 *
 * Values:
 * - 0b0 - Fast IRC is not enabled or clock is not valid
 * - 0b1 - Fast IRC is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCVLD field. */
#define SCG_RD_FIRCCSR_FIRCVLD(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCVLD(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCVLD_SHIFT))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCSEL[25] (RO)
 *
 * Values:
 * - 0b0 - Fast IRC is not the system clock source
 * - 0b1 - Fast IRC is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCSEL field. */
#define SCG_RD_FIRCCSR_FIRCSEL(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCSEL_MASK) >> SCG_FIRCCSR_FIRCSEL_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCSEL(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCSEL_SHIFT))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCERR[26] (W1C)
 *
 * This flag is reset on Chip POR only, software can also clear this flag by
 * writing a logic one
 *
 * Values:
 * - 0b0 - Error not detected with the Fast IRC trimming.
 * - 0b1 - Error detected with the Fast IRC trimming.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCERR field. */
#define SCG_RD_FIRCCSR_FIRCERR(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCERR_MASK) >> SCG_FIRCCSR_FIRCERR_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCERR(base) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCERR_SHIFT))

/*! @brief Set the FIRCERR field to a new value. */
#define SCG_WR_FIRCCSR_FIRCERR(base, value) (SCG_RMW_FIRCCSR(base, SCG_FIRCCSR_FIRCERR_MASK, SCG_FIRCCSR_FIRCERR(value)))
#define SCG_BWR_FIRCCSR_FIRCERR(base, value) (BITBAND_ACCESS32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCERR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SCG_FIRCDIV - Fast IRC Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCDIV - Fast IRC Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Changes to FIRCDIV should be done when FAST IRC is disabled to prevent
 * glitches to output divided clock.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCDIV register
 */
/*@{*/
#define SCG_RD_FIRCDIV(base)     (SCG_FIRCDIV_REG(base))
#define SCG_WR_FIRCDIV(base, value) (SCG_FIRCDIV_REG(base) = (value))
#define SCG_RMW_FIRCDIV(base, mask, value) (SCG_WR_FIRCDIV(base, (SCG_RD_FIRCDIV(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCDIV(base, value) (SCG_WR_FIRCDIV(base, SCG_RD_FIRCDIV(base) |  (value)))
#define SCG_CLR_FIRCDIV(base, value) (SCG_WR_FIRCDIV(base, SCG_RD_FIRCDIV(base) & ~(value)))
#define SCG_TOG_FIRCDIV(base, value) (SCG_WR_FIRCDIV(base, SCG_RD_FIRCDIV(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCDIV bitfields
 */

/*!
 * @name Register SCG_FIRCDIV, field FIRCDIV1[2:0] (RW)
 *
 * Clock divider 1 for Fast IRC. Used to generate the system clock source and by
 * platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCDIV_FIRCDIV1 field. */
#define SCG_RD_FIRCDIV_FIRCDIV1(base) ((SCG_FIRCDIV_REG(base) & SCG_FIRCDIV_FIRCDIV1_MASK) >> SCG_FIRCDIV_FIRCDIV1_SHIFT)
#define SCG_BRD_FIRCDIV_FIRCDIV1(base) (SCG_RD_FIRCDIV_FIRCDIV1(base))

/*! @brief Set the FIRCDIV1 field to a new value. */
#define SCG_WR_FIRCDIV_FIRCDIV1(base, value) (SCG_RMW_FIRCDIV(base, SCG_FIRCDIV_FIRCDIV1_MASK, SCG_FIRCDIV_FIRCDIV1(value)))
#define SCG_BWR_FIRCDIV_FIRCDIV1(base, value) (SCG_WR_FIRCDIV_FIRCDIV1(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCDIV, field FIRCDIV2[10:8] (RW)
 *
 * Clock divider 2 for the Fast IRC. Used by bus clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCDIV_FIRCDIV2 field. */
#define SCG_RD_FIRCDIV_FIRCDIV2(base) ((SCG_FIRCDIV_REG(base) & SCG_FIRCDIV_FIRCDIV2_MASK) >> SCG_FIRCDIV_FIRCDIV2_SHIFT)
#define SCG_BRD_FIRCDIV_FIRCDIV2(base) (SCG_RD_FIRCDIV_FIRCDIV2(base))

/*! @brief Set the FIRCDIV2 field to a new value. */
#define SCG_WR_FIRCDIV_FIRCDIV2(base, value) (SCG_RMW_FIRCDIV(base, SCG_FIRCDIV_FIRCDIV2_MASK, SCG_FIRCDIV_FIRCDIV2(value)))
#define SCG_BWR_FIRCDIV_FIRCDIV2(base, value) (SCG_WR_FIRCDIV_FIRCDIV2(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCDIV, field FIRCDIV3[18:16] (RW)
 *
 * Clock divider 2 for the Fast IRC. Used by slow clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCDIV_FIRCDIV3 field. */
#define SCG_RD_FIRCDIV_FIRCDIV3(base) ((SCG_FIRCDIV_REG(base) & SCG_FIRCDIV_FIRCDIV3_MASK) >> SCG_FIRCDIV_FIRCDIV3_SHIFT)
#define SCG_BRD_FIRCDIV_FIRCDIV3(base) (SCG_RD_FIRCDIV_FIRCDIV3(base))

/*! @brief Set the FIRCDIV3 field to a new value. */
#define SCG_WR_FIRCDIV_FIRCDIV3(base, value) (SCG_RMW_FIRCDIV(base, SCG_FIRCDIV_FIRCDIV3_MASK, SCG_FIRCDIV_FIRCDIV3(value)))
#define SCG_BWR_FIRCDIV_FIRCDIV3(base, value) (SCG_WR_FIRCDIV_FIRCDIV3(base, value))
/*@}*/

/*******************************************************************************
 * SCG_FIRCCFG - Fast IRC Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCCFG - Fast IRC Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The FIRCCFG register cannot be changed when the Fast IRC is enabled. When the
 * Fast IRC is enabled, writes to this register are ignored, and there is no
 * transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCCFG register
 */
/*@{*/
#define SCG_RD_FIRCCFG(base)     (SCG_FIRCCFG_REG(base))
#define SCG_WR_FIRCCFG(base, value) (SCG_FIRCCFG_REG(base) = (value))
#define SCG_RMW_FIRCCFG(base, mask, value) (SCG_WR_FIRCCFG(base, (SCG_RD_FIRCCFG(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCCFG(base, value) (SCG_WR_FIRCCFG(base, SCG_RD_FIRCCFG(base) |  (value)))
#define SCG_CLR_FIRCCFG(base, value) (SCG_WR_FIRCCFG(base, SCG_RD_FIRCCFG(base) & ~(value)))
#define SCG_TOG_FIRCCFG(base, value) (SCG_WR_FIRCCFG(base, SCG_RD_FIRCCFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCCFG bitfields
 */

/*!
 * @name Register SCG_FIRCCFG, field RANGE[1:0] (RW)
 *
 * Values:
 * - 0b00 - Fast IRC is trimmed to 48 MHz
 * - 0b01 - Fast IRC is trimmed to 52 MHz
 * - 0b10 - Fast IRC is trimmed to 56 MHz
 * - 0b11 - Fast IRC is trimmed to 60 MHz
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCFG_RANGE field. */
#define SCG_RD_FIRCCFG_RANGE(base) ((SCG_FIRCCFG_REG(base) & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)
#define SCG_BRD_FIRCCFG_RANGE(base) (SCG_RD_FIRCCFG_RANGE(base))

/*! @brief Set the RANGE field to a new value. */
#define SCG_WR_FIRCCFG_RANGE(base, value) (SCG_RMW_FIRCCFG(base, SCG_FIRCCFG_RANGE_MASK, SCG_FIRCCFG_RANGE(value)))
#define SCG_BWR_FIRCCFG_RANGE(base, value) (SCG_WR_FIRCCFG_RANGE(base, value))
/*@}*/

/*******************************************************************************
 * SCG_FIRCTCFG - Fast IRC Trim Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCTCFG - Fast IRC Trim Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The FIRCTCFG register cannot be changed when Fast IRC tuning is enabled. When
 * the Fast IRC tuning is enabled, writes to this register are ignored, and
 * there is no transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCTCFG register
 */
/*@{*/
#define SCG_RD_FIRCTCFG(base)    (SCG_FIRCTCFG_REG(base))
#define SCG_WR_FIRCTCFG(base, value) (SCG_FIRCTCFG_REG(base) = (value))
#define SCG_RMW_FIRCTCFG(base, mask, value) (SCG_WR_FIRCTCFG(base, (SCG_RD_FIRCTCFG(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCTCFG(base, value) (SCG_WR_FIRCTCFG(base, SCG_RD_FIRCTCFG(base) |  (value)))
#define SCG_CLR_FIRCTCFG(base, value) (SCG_WR_FIRCTCFG(base, SCG_RD_FIRCTCFG(base) & ~(value)))
#define SCG_TOG_FIRCTCFG(base, value) (SCG_WR_FIRCTCFG(base, SCG_RD_FIRCTCFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCTCFG bitfields
 */

/*!
 * @name Register SCG_FIRCTCFG, field TRIMSRC[1:0] (RW)
 *
 * Configures the external clock source to tune the Fast IRC.
 *
 * Values:
 * - 0b00 - USB0 Start of Frame (1 kHz)
 * - 0b01 - USB1 Start of Frame (1 kHz)
 * - 0b10 - System OSC
 * - 0b11 - RTC OSC (32.768 kHz)
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTCFG_TRIMSRC field. */
#define SCG_RD_FIRCTCFG_TRIMSRC(base) ((SCG_FIRCTCFG_REG(base) & SCG_FIRCTCFG_TRIMSRC_MASK) >> SCG_FIRCTCFG_TRIMSRC_SHIFT)
#define SCG_BRD_FIRCTCFG_TRIMSRC(base) (SCG_RD_FIRCTCFG_TRIMSRC(base))

/*! @brief Set the TRIMSRC field to a new value. */
#define SCG_WR_FIRCTCFG_TRIMSRC(base, value) (SCG_RMW_FIRCTCFG(base, SCG_FIRCTCFG_TRIMSRC_MASK, SCG_FIRCTCFG_TRIMSRC(value)))
#define SCG_BWR_FIRCTCFG_TRIMSRC(base, value) (SCG_WR_FIRCTCFG_TRIMSRC(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCTCFG, field TRIMDIV[10:8] (RW)
 *
 * Divide the System OSC down for Fast IRC trimming. The resulting frequency
 * after this divide should be 31.250 kHz.
 *
 * Values:
 * - 0b000 - Divide by 1
 * - 0b001 - Divide by 128
 * - 0b010 - Divide by 256
 * - 0b011 - Divide by 512
 * - 0b100 - Divide by 1024
 * - 0b101 - Divide by 2048
 * - 0b110 - Reserved. Writing this value will result in Divide by 1.
 * - 0b111 - Reserved. Writing this value will result in a Divide by 1.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTCFG_TRIMDIV field. */
#define SCG_RD_FIRCTCFG_TRIMDIV(base) ((SCG_FIRCTCFG_REG(base) & SCG_FIRCTCFG_TRIMDIV_MASK) >> SCG_FIRCTCFG_TRIMDIV_SHIFT)
#define SCG_BRD_FIRCTCFG_TRIMDIV(base) (SCG_RD_FIRCTCFG_TRIMDIV(base))

/*! @brief Set the TRIMDIV field to a new value. */
#define SCG_WR_FIRCTCFG_TRIMDIV(base, value) (SCG_RMW_FIRCTCFG(base, SCG_FIRCTCFG_TRIMDIV_MASK, SCG_FIRCTCFG_TRIMDIV(value)))
#define SCG_BWR_FIRCTCFG_TRIMDIV(base, value) (SCG_WR_FIRCTCFG_TRIMDIV(base, value))
/*@}*/

/*******************************************************************************
 * SCG_FIRCTRIML - Fast IRC Trim Low Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCTRIML - Fast IRC Trim Low Register (RW)
 *
 * Reset value: 0x001F3F7FU
 *
 * This register is loaded from IFR during reset. It can be written in
 * functional test mode only. These values are used for trimming the two low range
 * (RANGE=00 and RANGE=01) frequencies of FIRC.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCTRIML register
 */
/*@{*/
#define SCG_RD_FIRCTRIML(base)   (SCG_FIRCTRIML_REG(base))
#define SCG_WR_FIRCTRIML(base, value) (SCG_FIRCTRIML_REG(base) = (value))
#define SCG_RMW_FIRCTRIML(base, mask, value) (SCG_WR_FIRCTRIML(base, (SCG_RD_FIRCTRIML(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCTRIML(base, value) (SCG_WR_FIRCTRIML(base, SCG_RD_FIRCTRIML(base) |  (value)))
#define SCG_CLR_FIRCTRIML(base, value) (SCG_WR_FIRCTRIML(base, SCG_RD_FIRCTRIML(base) & ~(value)))
#define SCG_TOG_FIRCTRIML(base, value) (SCG_WR_FIRCTRIML(base, SCG_RD_FIRCTRIML(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCTRIML bitfields
 */

/*!
 * @name Register SCG_FIRCTRIML, field TRIMFINE[6:0] (RW)
 *
 * Once the Fast IRC Clock is trimmed to 0.7% of the target frequency using the
 * TRIMCOAR bits, the TRIMFINE bits can be used to trim the Fast IRC Clock to
 * within 0.04% of the target frequency.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTRIML_TRIMFINE field. */
#define SCG_RD_FIRCTRIML_TRIMFINE(base) ((SCG_FIRCTRIML_REG(base) & SCG_FIRCTRIML_TRIMFINE_MASK) >> SCG_FIRCTRIML_TRIMFINE_SHIFT)
#define SCG_BRD_FIRCTRIML_TRIMFINE(base) (SCG_RD_FIRCTRIML_TRIMFINE(base))

/*! @brief Set the TRIMFINE field to a new value. */
#define SCG_WR_FIRCTRIML_TRIMFINE(base, value) (SCG_RMW_FIRCTRIML(base, SCG_FIRCTRIML_TRIMFINE_MASK, SCG_FIRCTRIML_TRIMFINE(value)))
#define SCG_BWR_FIRCTRIML_TRIMFINE(base, value) (SCG_WR_FIRCTRIML_TRIMFINE(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCTRIML, field TRIMCOAR[13:8] (RW)
 *
 * TRIMCOAR bits are used to coursely trim the Fast IRC Clock to within
 * approximately 0.7% of the target frequency.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTRIML_TRIMCOAR field. */
#define SCG_RD_FIRCTRIML_TRIMCOAR(base) ((SCG_FIRCTRIML_REG(base) & SCG_FIRCTRIML_TRIMCOAR_MASK) >> SCG_FIRCTRIML_TRIMCOAR_SHIFT)
#define SCG_BRD_FIRCTRIML_TRIMCOAR(base) (SCG_RD_FIRCTRIML_TRIMCOAR(base))

/*! @brief Set the TRIMCOAR field to a new value. */
#define SCG_WR_FIRCTRIML_TRIMCOAR(base, value) (SCG_RMW_FIRCTRIML(base, SCG_FIRCTRIML_TRIMCOAR_MASK, SCG_FIRCTRIML_TRIMCOAR(value)))
#define SCG_BWR_FIRCTRIML_TRIMCOAR(base, value) (SCG_WR_FIRCTRIML_TRIMCOAR(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCTRIML, field TRIMTEMP[20:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTRIML_TRIMTEMP field. */
#define SCG_RD_FIRCTRIML_TRIMTEMP(base) ((SCG_FIRCTRIML_REG(base) & SCG_FIRCTRIML_TRIMTEMP_MASK) >> SCG_FIRCTRIML_TRIMTEMP_SHIFT)
#define SCG_BRD_FIRCTRIML_TRIMTEMP(base) (SCG_RD_FIRCTRIML_TRIMTEMP(base))

/*! @brief Set the TRIMTEMP field to a new value. */
#define SCG_WR_FIRCTRIML_TRIMTEMP(base, value) (SCG_RMW_FIRCTRIML(base, SCG_FIRCTRIML_TRIMTEMP_MASK, SCG_FIRCTRIML_TRIMTEMP(value)))
#define SCG_BWR_FIRCTRIML_TRIMTEMP(base, value) (SCG_WR_FIRCTRIML_TRIMTEMP(base, value))
/*@}*/

/*******************************************************************************
 * SCG_FIRCTRIMH - Fast IRC Trim High Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCTRIMH - Fast IRC Trim High Register (RW)
 *
 * Reset value: 0x001F3F7FU
 *
 * This register is loaded from IFR during reset. It can be written in
 * functional test mode only. These values are used for trimming the two high range
 * (RANGE=10 and RANGE=11) frequencies of FIRC.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCTRIMH register
 */
/*@{*/
#define SCG_RD_FIRCTRIMH(base)   (SCG_FIRCTRIMH_REG(base))
#define SCG_WR_FIRCTRIMH(base, value) (SCG_FIRCTRIMH_REG(base) = (value))
#define SCG_RMW_FIRCTRIMH(base, mask, value) (SCG_WR_FIRCTRIMH(base, (SCG_RD_FIRCTRIMH(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCTRIMH(base, value) (SCG_WR_FIRCTRIMH(base, SCG_RD_FIRCTRIMH(base) |  (value)))
#define SCG_CLR_FIRCTRIMH(base, value) (SCG_WR_FIRCTRIMH(base, SCG_RD_FIRCTRIMH(base) & ~(value)))
#define SCG_TOG_FIRCTRIMH(base, value) (SCG_WR_FIRCTRIMH(base, SCG_RD_FIRCTRIMH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCTRIMH bitfields
 */

/*!
 * @name Register SCG_FIRCTRIMH, field TRIMFINE[6:0] (RW)
 *
 * Once the Fast IRC Clock is trimmed to 0.7% of the target frequency using the
 * TRIMCOAR bits, the TRIMFINE bits can be used to trim the Fast IRC Clock to
 * within 0.04% of the target frequency.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTRIMH_TRIMFINE field. */
#define SCG_RD_FIRCTRIMH_TRIMFINE(base) ((SCG_FIRCTRIMH_REG(base) & SCG_FIRCTRIMH_TRIMFINE_MASK) >> SCG_FIRCTRIMH_TRIMFINE_SHIFT)
#define SCG_BRD_FIRCTRIMH_TRIMFINE(base) (SCG_RD_FIRCTRIMH_TRIMFINE(base))

/*! @brief Set the TRIMFINE field to a new value. */
#define SCG_WR_FIRCTRIMH_TRIMFINE(base, value) (SCG_RMW_FIRCTRIMH(base, SCG_FIRCTRIMH_TRIMFINE_MASK, SCG_FIRCTRIMH_TRIMFINE(value)))
#define SCG_BWR_FIRCTRIMH_TRIMFINE(base, value) (SCG_WR_FIRCTRIMH_TRIMFINE(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCTRIMH, field TRIMCOAR[13:8] (RW)
 *
 * TRIMCOAR bits are used to coursely trim the Fast IRC Clock to within
 * approximately 0.7% of the target frequency.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTRIMH_TRIMCOAR field. */
#define SCG_RD_FIRCTRIMH_TRIMCOAR(base) ((SCG_FIRCTRIMH_REG(base) & SCG_FIRCTRIMH_TRIMCOAR_MASK) >> SCG_FIRCTRIMH_TRIMCOAR_SHIFT)
#define SCG_BRD_FIRCTRIMH_TRIMCOAR(base) (SCG_RD_FIRCTRIMH_TRIMCOAR(base))

/*! @brief Set the TRIMCOAR field to a new value. */
#define SCG_WR_FIRCTRIMH_TRIMCOAR(base, value) (SCG_RMW_FIRCTRIMH(base, SCG_FIRCTRIMH_TRIMCOAR_MASK, SCG_FIRCTRIMH_TRIMCOAR(value)))
#define SCG_BWR_FIRCTRIMH_TRIMCOAR(base, value) (SCG_WR_FIRCTRIMH_TRIMCOAR(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCTRIMH, field TRIMTEMP[20:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTRIMH_TRIMTEMP field. */
#define SCG_RD_FIRCTRIMH_TRIMTEMP(base) ((SCG_FIRCTRIMH_REG(base) & SCG_FIRCTRIMH_TRIMTEMP_MASK) >> SCG_FIRCTRIMH_TRIMTEMP_SHIFT)
#define SCG_BRD_FIRCTRIMH_TRIMTEMP(base) (SCG_RD_FIRCTRIMH_TRIMTEMP(base))

/*! @brief Set the TRIMTEMP field to a new value. */
#define SCG_WR_FIRCTRIMH_TRIMTEMP(base, value) (SCG_RMW_FIRCTRIMH(base, SCG_FIRCTRIMH_TRIMTEMP_MASK, SCG_FIRCTRIMH_TRIMTEMP(value)))
#define SCG_BWR_FIRCTRIMH_TRIMTEMP(base, value) (SCG_WR_FIRCTRIMH_TRIMTEMP(base, value))
/*@}*/

/*******************************************************************************
 * SCG_FIRCSTAT - Fast IRC Status Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCSTAT - Fast IRC Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded from IFR during reset. These register gets uploaded
 * with the trim values generated by FIRC auto trimming which is enabled when FIRC
 * is enabled and FIRCTREN=1 and FIRCTRUP=1. When FIRC auto trimming is enabled
 * and FIRCTRUP is off, writes to this register is allowed and values written to
 * this register are used to trim FIRC clock.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCSTAT register
 */
/*@{*/
#define SCG_RD_FIRCSTAT(base)    (SCG_FIRCSTAT_REG(base))
#define SCG_WR_FIRCSTAT(base, value) (SCG_FIRCSTAT_REG(base) = (value))
#define SCG_RMW_FIRCSTAT(base, mask, value) (SCG_WR_FIRCSTAT(base, (SCG_RD_FIRCSTAT(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCSTAT(base, value) (SCG_WR_FIRCSTAT(base, SCG_RD_FIRCSTAT(base) |  (value)))
#define SCG_CLR_FIRCSTAT(base, value) (SCG_WR_FIRCSTAT(base, SCG_RD_FIRCSTAT(base) & ~(value)))
#define SCG_TOG_FIRCSTAT(base, value) (SCG_WR_FIRCSTAT(base, SCG_RD_FIRCSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCSTAT bitfields
 */

/*!
 * @name Register SCG_FIRCSTAT, field TRIMFINE[6:0] (RW)
 *
 * When FIRC is enabled and auto trimming is enabled (FIRCTREN=1 and FIRCTRUP=1)
 * these register gets uploaded with the trimmed coarse value. When FIRCTRUP=0,
 * these register is writeable to allow user programming of fine trim values.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCSTAT_TRIMFINE field. */
#define SCG_RD_FIRCSTAT_TRIMFINE(base) ((SCG_FIRCSTAT_REG(base) & SCG_FIRCSTAT_TRIMFINE_MASK) >> SCG_FIRCSTAT_TRIMFINE_SHIFT)
#define SCG_BRD_FIRCSTAT_TRIMFINE(base) (SCG_RD_FIRCSTAT_TRIMFINE(base))

/*! @brief Set the TRIMFINE field to a new value. */
#define SCG_WR_FIRCSTAT_TRIMFINE(base, value) (SCG_RMW_FIRCSTAT(base, SCG_FIRCSTAT_TRIMFINE_MASK, SCG_FIRCSTAT_TRIMFINE(value)))
#define SCG_BWR_FIRCSTAT_TRIMFINE(base, value) (SCG_WR_FIRCSTAT_TRIMFINE(base, value))
/*@}*/

/*!
 * @name Register SCG_FIRCSTAT, field TRIMCOAR[15:8] (RW)
 *
 * When FIRC is enabled and auto trimming is enabled (FIRCTREN=1 and FIRCTRUP=1)
 * these register gets uploaded with the trimmed coarse value. When FIRCTRUP=0,
 * these register is writable to allow user programming of coarse trim values.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCSTAT_TRIMCOAR field. */
#define SCG_RD_FIRCSTAT_TRIMCOAR(base) ((SCG_FIRCSTAT_REG(base) & SCG_FIRCSTAT_TRIMCOAR_MASK) >> SCG_FIRCSTAT_TRIMCOAR_SHIFT)
#define SCG_BRD_FIRCSTAT_TRIMCOAR(base) (SCG_RD_FIRCSTAT_TRIMCOAR(base))

/*! @brief Set the TRIMCOAR field to a new value. */
#define SCG_WR_FIRCSTAT_TRIMCOAR(base, value) (SCG_RMW_FIRCSTAT(base, SCG_FIRCSTAT_TRIMCOAR_MASK, SCG_FIRCSTAT_TRIMCOAR(value)))
#define SCG_BWR_FIRCSTAT_TRIMCOAR(base, value) (SCG_WR_FIRCSTAT_TRIMCOAR(base, value))
/*@}*/

/*******************************************************************************
 * SCG_ROSCCSR - RTC OSC Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_ROSCCSR - RTC OSC Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SCG_ROSCCSR register
 */
/*@{*/
#define SCG_RD_ROSCCSR(base)     (SCG_ROSCCSR_REG(base))
#define SCG_WR_ROSCCSR(base, value) (SCG_ROSCCSR_REG(base) = (value))
#define SCG_RMW_ROSCCSR(base, mask, value) (SCG_WR_ROSCCSR(base, (SCG_RD_ROSCCSR(base) & ~(mask)) | (value)))
#define SCG_SET_ROSCCSR(base, value) (SCG_WR_ROSCCSR(base, SCG_RD_ROSCCSR(base) |  (value)))
#define SCG_CLR_ROSCCSR(base, value) (SCG_WR_ROSCCSR(base, SCG_RD_ROSCCSR(base) & ~(value)))
#define SCG_TOG_ROSCCSR(base, value) (SCG_WR_ROSCCSR(base, SCG_RD_ROSCCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_ROSCCSR bitfields
 */

/*!
 * @name Register SCG_ROSCCSR, field ROSCCM[16] (RW)
 *
 * Enables the clock monitor, if the clock source is disabled in a low power
 * mode then the clock monitor is also disabled in the low power mode. The clock
 * monitor is always disabled in LLS/VLLS modes. When the clock monitor is disabled
 * in a low power mode, it remains disabled until the clock valid flag is set
 * following exit from the low power mode.
 *
 * Values:
 * - 0b0 - RTC OSC Clock Monitor is disabled
 * - 0b1 - RTC OSC Clock Monitor is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_ROSCCSR_ROSCCM field. */
#define SCG_RD_ROSCCSR_ROSCCM(base) ((SCG_ROSCCSR_REG(base) & SCG_ROSCCSR_ROSCCM_MASK) >> SCG_ROSCCSR_ROSCCM_SHIFT)
#define SCG_BRD_ROSCCSR_ROSCCM(base) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCCM_SHIFT))

/*! @brief Set the ROSCCM field to a new value. */
#define SCG_WR_ROSCCSR_ROSCCM(base, value) (SCG_RMW_ROSCCSR(base, (SCG_ROSCCSR_ROSCCM_MASK | SCG_ROSCCSR_ROSCERR_MASK), SCG_ROSCCSR_ROSCCM(value)))
#define SCG_BWR_ROSCCSR_ROSCCM(base, value) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCCM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_ROSCCSR, field ROSCCMRE[17] (RW)
 *
 * Values:
 * - 0b0 - Clock Monitor generates interrupt when error detected
 * - 0b1 - Clock Monitor generates reset when error detected
 */
/*@{*/
/*! @brief Read current value of the SCG_ROSCCSR_ROSCCMRE field. */
#define SCG_RD_ROSCCSR_ROSCCMRE(base) ((SCG_ROSCCSR_REG(base) & SCG_ROSCCSR_ROSCCMRE_MASK) >> SCG_ROSCCSR_ROSCCMRE_SHIFT)
#define SCG_BRD_ROSCCSR_ROSCCMRE(base) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCCMRE_SHIFT))

/*! @brief Set the ROSCCMRE field to a new value. */
#define SCG_WR_ROSCCSR_ROSCCMRE(base, value) (SCG_RMW_ROSCCSR(base, (SCG_ROSCCSR_ROSCCMRE_MASK | SCG_ROSCCSR_ROSCERR_MASK), SCG_ROSCCSR_ROSCCMRE(value)))
#define SCG_BWR_ROSCCSR_ROSCCMRE(base, value) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCCMRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_ROSCCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until the next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_ROSCCSR_LK field. */
#define SCG_RD_ROSCCSR_LK(base) ((SCG_ROSCCSR_REG(base) & SCG_ROSCCSR_LK_MASK) >> SCG_ROSCCSR_LK_SHIFT)
#define SCG_BRD_ROSCCSR_LK(base) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_ROSCCSR_LK(base, value) (SCG_RMW_ROSCCSR(base, (SCG_ROSCCSR_LK_MASK | SCG_ROSCCSR_ROSCERR_MASK), SCG_ROSCCSR_LK(value)))
#define SCG_BWR_ROSCCSR_LK(base, value) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_ROSCCSR, field ROSCVLD[24] (RO)
 *
 * Values:
 * - 0b0 - RTC OSC is not enabled or clock is not valid
 * - 0b1 - RTC OSC is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_ROSCCSR_ROSCVLD field. */
#define SCG_RD_ROSCCSR_ROSCVLD(base) ((SCG_ROSCCSR_REG(base) & SCG_ROSCCSR_ROSCVLD_MASK) >> SCG_ROSCCSR_ROSCVLD_SHIFT)
#define SCG_BRD_ROSCCSR_ROSCVLD(base) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCVLD_SHIFT))
/*@}*/

/*!
 * @name Register SCG_ROSCCSR, field ROSCSEL[25] (RO)
 *
 * Values:
 * - 0b0 - RTC OSC is not the system clock source
 * - 0b1 - RTC OSC is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_ROSCCSR_ROSCSEL field. */
#define SCG_RD_ROSCCSR_ROSCSEL(base) ((SCG_ROSCCSR_REG(base) & SCG_ROSCCSR_ROSCSEL_MASK) >> SCG_ROSCCSR_ROSCSEL_SHIFT)
#define SCG_BRD_ROSCCSR_ROSCSEL(base) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCSEL_SHIFT))
/*@}*/

/*!
 * @name Register SCG_ROSCCSR, field ROSCERR[26] (W1C)
 *
 * This flag is reset on Chip POR only, software can also clear this flag by
 * writing a logic one
 *
 * Values:
 * - 0b0 - RTC OSC Clock Monitor is disabled or has not detected an error
 * - 0b1 - RTC OSC Clock Monitor is enabled and detected an RTC loss of clock
 *     error
 */
/*@{*/
/*! @brief Read current value of the SCG_ROSCCSR_ROSCERR field. */
#define SCG_RD_ROSCCSR_ROSCERR(base) ((SCG_ROSCCSR_REG(base) & SCG_ROSCCSR_ROSCERR_MASK) >> SCG_ROSCCSR_ROSCERR_SHIFT)
#define SCG_BRD_ROSCCSR_ROSCERR(base) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCERR_SHIFT))

/*! @brief Set the ROSCERR field to a new value. */
#define SCG_WR_ROSCCSR_ROSCERR(base, value) (SCG_RMW_ROSCCSR(base, SCG_ROSCCSR_ROSCERR_MASK, SCG_ROSCCSR_ROSCERR(value)))
#define SCG_BWR_ROSCCSR_ROSCERR(base, value) (BITBAND_ACCESS32(&SCG_ROSCCSR_REG(base), SCG_ROSCCSR_ROSCERR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SCG_SPLLCSR - System PLL Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_SPLLCSR - System PLL Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SCG_SPLLCSR register
 */
/*@{*/
#define SCG_RD_SPLLCSR(base)     (SCG_SPLLCSR_REG(base))
#define SCG_WR_SPLLCSR(base, value) (SCG_SPLLCSR_REG(base) = (value))
#define SCG_RMW_SPLLCSR(base, mask, value) (SCG_WR_SPLLCSR(base, (SCG_RD_SPLLCSR(base) & ~(mask)) | (value)))
#define SCG_SET_SPLLCSR(base, value) (SCG_WR_SPLLCSR(base, SCG_RD_SPLLCSR(base) |  (value)))
#define SCG_CLR_SPLLCSR(base, value) (SCG_WR_SPLLCSR(base, SCG_RD_SPLLCSR(base) & ~(value)))
#define SCG_TOG_SPLLCSR(base, value) (SCG_WR_SPLLCSR(base, SCG_RD_SPLLCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SPLLCSR bitfields
 */

/*!
 * @name Register SCG_SPLLCSR, field SPLLEN[0] (RW)
 *
 * Values:
 * - 0b0 - System PLL is disabled
 * - 0b1 - System PLL is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLEN field. */
#define SCG_RD_SPLLCSR_SPLLEN(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLEN(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLEN_SHIFT))

/*! @brief Set the SPLLEN field to a new value. */
#define SCG_WR_SPLLCSR_SPLLEN(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLEN_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLEN(value)))
#define SCG_BWR_SPLLCSR_SPLLEN(base, value) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - System PLL is disabled in Stop modes
 * - 0b1 - System PLL is enabled in Stop modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLSTEN field. */
#define SCG_RD_SPLLCSR_SPLLSTEN(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLSTEN_MASK) >> SCG_SPLLCSR_SPLLSTEN_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLSTEN(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLSTEN_SHIFT))

/*! @brief Set the SPLLSTEN field to a new value. */
#define SCG_WR_SPLLCSR_SPLLSTEN(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLSTEN_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLSTEN(value)))
#define SCG_BWR_SPLLCSR_SPLLSTEN(base, value) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLCM[16] (RW)
 *
 * Enables the clock monitor, if the clock source is disabled in a low power
 * mode then the clock monitor is also disabled in the low power mode. When the
 * clock monitor is disabled in a low power mode, it remains disabled until the clock
 * valid flag is set following exit from the low power mode.
 *
 * Values:
 * - 0b0 - System PLL Clock Monitor is disabled
 * - 0b1 - System PLL Clock Monitor is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLCM field. */
#define SCG_RD_SPLLCSR_SPLLCM(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLCM_MASK) >> SCG_SPLLCSR_SPLLCM_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLCM(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLCM_SHIFT))

/*! @brief Set the SPLLCM field to a new value. */
#define SCG_WR_SPLLCSR_SPLLCM(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLCM_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLCM(value)))
#define SCG_BWR_SPLLCSR_SPLLCM(base, value) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLCM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLCMRE[17] (RW)
 *
 * Values:
 * - 0b0 - Clock Monitor generates interrupt when error detected
 * - 0b1 - Clock Monitor generates reset when error detected
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLCMRE field. */
#define SCG_RD_SPLLCSR_SPLLCMRE(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLCMRE_MASK) >> SCG_SPLLCSR_SPLLCMRE_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLCMRE(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLCMRE_SHIFT))

/*! @brief Set the SPLLCMRE field to a new value. */
#define SCG_WR_SPLLCSR_SPLLCMRE(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLCMRE_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLCMRE(value)))
#define SCG_BWR_SPLLCSR_SPLLCMRE(base, value) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLCMRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until the next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_LK field. */
#define SCG_RD_SPLLCSR_LK(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_LK_MASK) >> SCG_SPLLCSR_LK_SHIFT)
#define SCG_BRD_SPLLCSR_LK(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_SPLLCSR_LK(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_LK_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_LK(value)))
#define SCG_BWR_SPLLCSR_LK(base, value) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLVLD[24] (RO)
 *
 * Indicates when the SPLL clock is valid. Disabling the SPLL or a SOSC error
 * when selected as the reference clock to the SPLL will cause the SPLLVLD to clear
 * without setting SPLLERROR.
 *
 * Values:
 * - 0b0 - System PLL is not enabled or clock is not valid
 * - 0b1 - System PLL is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLVLD field. */
#define SCG_RD_SPLLCSR_SPLLVLD(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLVLD(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLVLD_SHIFT))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLSEL[25] (RO)
 *
 * Values:
 * - 0b0 - System PLL is not the system clock source
 * - 0b1 - System PLL is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLSEL field. */
#define SCG_RD_SPLLCSR_SPLLSEL(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLSEL_MASK) >> SCG_SPLLCSR_SPLLSEL_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLSEL(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLSEL_SHIFT))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLERR[26] (W1C)
 *
 * This flag is reset on Chip POR only, software can also clear this flag by
 * writing a logic one
 *
 * Values:
 * - 0b0 - System PLL Clock Monitor is disabled or has not detected an error
 * - 0b1 - System PLL Clock Monitor is enabled and detected an error. System PLL
 *     Clock Error flag will not set when System OSC is selected as its source
 *     and SOSCERR has set.
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLERR field. */
#define SCG_RD_SPLLCSR_SPLLERR(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLERR_MASK) >> SCG_SPLLCSR_SPLLERR_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLERR(base) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLERR_SHIFT))

/*! @brief Set the SPLLERR field to a new value. */
#define SCG_WR_SPLLCSR_SPLLERR(base, value) (SCG_RMW_SPLLCSR(base, SCG_SPLLCSR_SPLLERR_MASK, SCG_SPLLCSR_SPLLERR(value)))
#define SCG_BWR_SPLLCSR_SPLLERR(base, value) (BITBAND_ACCESS32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLERR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SCG_SPLLDIV - System PLL Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_SPLLDIV - System PLL Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Changes to SPLLDIV should be done when System PLL is disabled to prevent
 * glitches to output divided clock.
 */
/*!
 * @name Constants and macros for entire SCG_SPLLDIV register
 */
/*@{*/
#define SCG_RD_SPLLDIV(base)     (SCG_SPLLDIV_REG(base))
#define SCG_WR_SPLLDIV(base, value) (SCG_SPLLDIV_REG(base) = (value))
#define SCG_RMW_SPLLDIV(base, mask, value) (SCG_WR_SPLLDIV(base, (SCG_RD_SPLLDIV(base) & ~(mask)) | (value)))
#define SCG_SET_SPLLDIV(base, value) (SCG_WR_SPLLDIV(base, SCG_RD_SPLLDIV(base) |  (value)))
#define SCG_CLR_SPLLDIV(base, value) (SCG_WR_SPLLDIV(base, SCG_RD_SPLLDIV(base) & ~(value)))
#define SCG_TOG_SPLLDIV(base, value) (SCG_WR_SPLLDIV(base, SCG_RD_SPLLDIV(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SPLLDIV bitfields
 */

/*!
 * @name Register SCG_SPLLDIV, field SPLLDIV1[2:0] (RW)
 *
 * Clock divider 1 for System PLL. Used to generate the system clock source used
 * by platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLDIV_SPLLDIV1 field. */
#define SCG_RD_SPLLDIV_SPLLDIV1(base) ((SCG_SPLLDIV_REG(base) & SCG_SPLLDIV_SPLLDIV1_MASK) >> SCG_SPLLDIV_SPLLDIV1_SHIFT)
#define SCG_BRD_SPLLDIV_SPLLDIV1(base) (SCG_RD_SPLLDIV_SPLLDIV1(base))

/*! @brief Set the SPLLDIV1 field to a new value. */
#define SCG_WR_SPLLDIV_SPLLDIV1(base, value) (SCG_RMW_SPLLDIV(base, SCG_SPLLDIV_SPLLDIV1_MASK, SCG_SPLLDIV_SPLLDIV1(value)))
#define SCG_BWR_SPLLDIV_SPLLDIV1(base, value) (SCG_WR_SPLLDIV_SPLLDIV1(base, value))
/*@}*/

/*!
 * @name Register SCG_SPLLDIV, field SPLLDIV2[10:8] (RW)
 *
 * Clock divider 2 for System PLL. Used by bus clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLDIV_SPLLDIV2 field. */
#define SCG_RD_SPLLDIV_SPLLDIV2(base) ((SCG_SPLLDIV_REG(base) & SCG_SPLLDIV_SPLLDIV2_MASK) >> SCG_SPLLDIV_SPLLDIV2_SHIFT)
#define SCG_BRD_SPLLDIV_SPLLDIV2(base) (SCG_RD_SPLLDIV_SPLLDIV2(base))

/*! @brief Set the SPLLDIV2 field to a new value. */
#define SCG_WR_SPLLDIV_SPLLDIV2(base, value) (SCG_RMW_SPLLDIV(base, SCG_SPLLDIV_SPLLDIV2_MASK, SCG_SPLLDIV_SPLLDIV2(value)))
#define SCG_BWR_SPLLDIV_SPLLDIV2(base, value) (SCG_WR_SPLLDIV_SPLLDIV2(base, value))
/*@}*/

/*!
 * @name Register SCG_SPLLDIV, field SPLLDIV3[18:16] (RW)
 *
 * Clock divider 3 for System PLL. Used by slow clock modules that need an
 * asynchronous clock source.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLDIV_SPLLDIV3 field. */
#define SCG_RD_SPLLDIV_SPLLDIV3(base) ((SCG_SPLLDIV_REG(base) & SCG_SPLLDIV_SPLLDIV3_MASK) >> SCG_SPLLDIV_SPLLDIV3_SHIFT)
#define SCG_BRD_SPLLDIV_SPLLDIV3(base) (SCG_RD_SPLLDIV_SPLLDIV3(base))

/*! @brief Set the SPLLDIV3 field to a new value. */
#define SCG_WR_SPLLDIV_SPLLDIV3(base, value) (SCG_RMW_SPLLDIV(base, SCG_SPLLDIV_SPLLDIV3_MASK, SCG_SPLLDIV_SPLLDIV3(value)))
#define SCG_BWR_SPLLDIV_SPLLDIV3(base, value) (SCG_WR_SPLLDIV_SPLLDIV3(base, value))
/*@}*/

/*******************************************************************************
 * SCG_SPLLCFG - System PLL Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_SPLLCFG - System PLL Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SPLLCFG register cannot be changed when the System PLL is enabled. When
 * the System PLL is enabled, writes to this register are ignored, and there is no
 * transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_SPLLCFG register
 */
/*@{*/
#define SCG_RD_SPLLCFG(base)     (SCG_SPLLCFG_REG(base))
#define SCG_WR_SPLLCFG(base, value) (SCG_SPLLCFG_REG(base) = (value))
#define SCG_RMW_SPLLCFG(base, mask, value) (SCG_WR_SPLLCFG(base, (SCG_RD_SPLLCFG(base) & ~(mask)) | (value)))
#define SCG_SET_SPLLCFG(base, value) (SCG_WR_SPLLCFG(base, SCG_RD_SPLLCFG(base) |  (value)))
#define SCG_CLR_SPLLCFG(base, value) (SCG_WR_SPLLCFG(base, SCG_RD_SPLLCFG(base) & ~(value)))
#define SCG_TOG_SPLLCFG(base, value) (SCG_WR_SPLLCFG(base, SCG_RD_SPLLCFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SPLLCFG bitfields
 */

/*!
 * @name Register SCG_SPLLCFG, field SOURCE[0] (RW)
 *
 * Configures the input clock source for the System PLL.
 *
 * Values:
 * - 0b0 - System OSC
 * - 0b1 - Fast IRC
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCFG_SOURCE field. */
#define SCG_RD_SPLLCFG_SOURCE(base) ((SCG_SPLLCFG_REG(base) & SCG_SPLLCFG_SOURCE_MASK) >> SCG_SPLLCFG_SOURCE_SHIFT)
#define SCG_BRD_SPLLCFG_SOURCE(base) (BITBAND_ACCESS32(&SCG_SPLLCFG_REG(base), SCG_SPLLCFG_SOURCE_SHIFT))

/*! @brief Set the SOURCE field to a new value. */
#define SCG_WR_SPLLCFG_SOURCE(base, value) (SCG_RMW_SPLLCFG(base, SCG_SPLLCFG_SOURCE_MASK, SCG_SPLLCFG_SOURCE(value)))
#define SCG_BWR_SPLLCFG_SOURCE(base, value) (BITBAND_ACCESS32(&SCG_SPLLCFG_REG(base), SCG_SPLLCFG_SOURCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SCG_SPLLCFG, field PREDIV[10:8] (RW)
 *
 * Selects the amount to divide down the reference clock for the System PLL. The
 * resulting frequency must be in the range of 8 MHz to 32 MHz. System PLL
 * Reference Divide Factor PERDIV Divide Factor 000 1 001 2 010 3 011 4 100 5 101 6
 * 110 7 111 8
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCFG_PREDIV field. */
#define SCG_RD_SPLLCFG_PREDIV(base) ((SCG_SPLLCFG_REG(base) & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT)
#define SCG_BRD_SPLLCFG_PREDIV(base) (SCG_RD_SPLLCFG_PREDIV(base))

/*! @brief Set the PREDIV field to a new value. */
#define SCG_WR_SPLLCFG_PREDIV(base, value) (SCG_RMW_SPLLCFG(base, SCG_SPLLCFG_PREDIV_MASK, SCG_SPLLCFG_PREDIV(value)))
#define SCG_BWR_SPLLCFG_PREDIV(base, value) (SCG_WR_SPLLCFG_PREDIV(base, value))
/*@}*/

/*!
 * @name Register SCG_SPLLCFG, field MULT[20:16] (RW)
 *
 * Multiplier for the System PLL. The MULT bits establish the multiplication
 * factor applied to the PLL reference clock frequency. PLL VCO Multiply Factor MULT
 * Multiply Factor MULT Multiply Factor MULT Multiply Factor MULT Multiply
 * Factor 00000 16 01000 24 10000 32 11000 40 00001 17 01001 25 10001 33 11001 41
 * 00010 18 01010 26 10010 34 11010 42 00011 19 01011 27 10011 35 11011 43 00100 20
 * 01100 28 10100 36 11100 44 00101 21 01101 29 10101 37 11101 45 00110 22 01110
 * 30 10110 38 11110 46 00111 23 01111 31 10111 39 11111 47
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCFG_MULT field. */
#define SCG_RD_SPLLCFG_MULT(base) ((SCG_SPLLCFG_REG(base) & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT)
#define SCG_BRD_SPLLCFG_MULT(base) (SCG_RD_SPLLCFG_MULT(base))

/*! @brief Set the MULT field to a new value. */
#define SCG_WR_SPLLCFG_MULT(base, value) (SCG_RMW_SPLLCFG(base, SCG_SPLLCFG_MULT_MASK, SCG_SPLLCFG_MULT(value)))
#define SCG_BWR_SPLLCFG_MULT(base, value) (SCG_WR_SPLLCFG_MULT(base, value))
/*@}*/

/*
 * S32K144 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_CHIPCTL - Chip Control register
 * - SIM_FTMOPT0 - FTM Option Register 0
 * - SIM_LPOCLKS - LPO Clock Select Register
 * - SIM_ADCOPT - ADC Options Register
 * - SIM_FTMOPT1 - FTM Option Register 1
 * - SIM_SDID - System Device Identification Register
 * - SIM_PLATCGC - Platform Clock Gating Control Register
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDH - Unique Identification Register High
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid Low
 * - SIM_UIDL - Unique Identification Register Low
 * - SIM_CLKDIV4 - System Clock Divider Register 4
 * - SIM_MISCTRL - Miscellaneous Control register
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_CHIPCTL - Chip Control register
 ******************************************************************************/

/*!
 * @brief SIM_CHIPCTL - Chip Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * SIM_CHIPCTL contains the controls for selecting ADC COCO trigger, trace
 * clock, clock out source, PDB back-to-back mode and ADC interleave channel.
 */
/*!
 * @name Constants and macros for entire SIM_CHIPCTL register
 */
/*@{*/
#define SIM_RD_CHIPCTL(base)     (SIM_CHIPCTL_REG(base))
#define SIM_WR_CHIPCTL(base, value) (SIM_CHIPCTL_REG(base) = (value))
#define SIM_RMW_CHIPCTL(base, mask, value) (SIM_WR_CHIPCTL(base, (SIM_RD_CHIPCTL(base) & ~(mask)) | (value)))
#define SIM_SET_CHIPCTL(base, value) (SIM_WR_CHIPCTL(base, SIM_RD_CHIPCTL(base) |  (value)))
#define SIM_CLR_CHIPCTL(base, value) (SIM_WR_CHIPCTL(base, SIM_RD_CHIPCTL(base) & ~(value)))
#define SIM_TOG_CHIPCTL(base, value) (SIM_WR_CHIPCTL(base, SIM_RD_CHIPCTL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CHIPCTL bitfields
 */

/*!
 * @name Register SIM_CHIPCTL, field ADC_INTERLEAVE_SEL[3:0] (RW)
 *
 * Select ADC interleave pins. Bit 3 to 0 are for PTB14, PTB13, PTB1 and PTB0
 * respectively.
 *
 * Values:
 * - 0b0000 - No interleave channel
 */
/*@{*/
/*! @brief Read current value of the SIM_CHIPCTL_ADC_INTERLEAVE_SEL field. */
#define SIM_RD_CHIPCTL_ADC_INTERLEAVE_SEL(base) ((SIM_CHIPCTL_REG(base) & SIM_CHIPCTL_ADC_INTERLEAVE_SEL_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_SEL_SHIFT)
#define SIM_BRD_CHIPCTL_ADC_INTERLEAVE_SEL(base) (SIM_RD_CHIPCTL_ADC_INTERLEAVE_SEL(base))

/*! @brief Set the ADC_INTERLEAVE_SEL field to a new value. */
#define SIM_WR_CHIPCTL_ADC_INTERLEAVE_SEL(base, value) (SIM_RMW_CHIPCTL(base, SIM_CHIPCTL_ADC_INTERLEAVE_SEL_MASK, SIM_CHIPCTL_ADC_INTERLEAVE_SEL(value)))
#define SIM_BWR_CHIPCTL_ADC_INTERLEAVE_SEL(base, value) (SIM_WR_CHIPCTL_ADC_INTERLEAVE_SEL(base, value))
/*@}*/

/*!
 * @name Register SIM_CHIPCTL, field CLKOUTSEL[7:6] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 0b00 - Reseved
 * - 0b01 - System oscillator clock
 * - 0b10 - RTC oscillator clock (32 kHz)
 * - 0b11 - LPO clock (128 kHz)
 */
/*@{*/
/*! @brief Read current value of the SIM_CHIPCTL_CLKOUTSEL field. */
#define SIM_RD_CHIPCTL_CLKOUTSEL(base) ((SIM_CHIPCTL_REG(base) & SIM_CHIPCTL_CLKOUTSEL_MASK) >> SIM_CHIPCTL_CLKOUTSEL_SHIFT)
#define SIM_BRD_CHIPCTL_CLKOUTSEL(base) (SIM_RD_CHIPCTL_CLKOUTSEL(base))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SIM_WR_CHIPCTL_CLKOUTSEL(base, value) (SIM_RMW_CHIPCTL(base, SIM_CHIPCTL_CLKOUTSEL_MASK, SIM_CHIPCTL_CLKOUTSEL(value)))
#define SIM_BWR_CHIPCTL_CLKOUTSEL(base, value) (SIM_WR_CHIPCTL_CLKOUTSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_CHIPCTL, field TRACECLK_SEL[12] (RW)
 *
 * Selects core clock or platform clock as the trace clock source.
 *
 * Values:
 * - 0b0 - core clock
 * - 0b1 - platform clock
 */
/*@{*/
/*! @brief Read current value of the SIM_CHIPCTL_TRACECLK_SEL field. */
#define SIM_RD_CHIPCTL_TRACECLK_SEL(base) ((SIM_CHIPCTL_REG(base) & SIM_CHIPCTL_TRACECLK_SEL_MASK) >> SIM_CHIPCTL_TRACECLK_SEL_SHIFT)
#define SIM_BRD_CHIPCTL_TRACECLK_SEL(base) (BITBAND_ACCESS32(&SIM_CHIPCTL_REG(base), SIM_CHIPCTL_TRACECLK_SEL_SHIFT))

/*! @brief Set the TRACECLK_SEL field to a new value. */
#define SIM_WR_CHIPCTL_TRACECLK_SEL(base, value) (SIM_RMW_CHIPCTL(base, SIM_CHIPCTL_TRACECLK_SEL_MASK, SIM_CHIPCTL_TRACECLK_SEL(value)))
#define SIM_BWR_CHIPCTL_TRACECLK_SEL(base, value) (BITBAND_ACCESS32(&SIM_CHIPCTL_REG(base), SIM_CHIPCTL_TRACECLK_SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_CHIPCTL, field PDB_BB_SEL[13] (RW)
 *
 * Selects ADC COCO source as pdb back-to-back mode, see Back-to-back
 * acknowledgement connections for details.
 *
 * Values:
 * - 0b0 - PDB0 channel 0 back-to-back operation with ADC0 COCO[7:0]; PDB1
 *     channel 0 back-to-back operation with ADC1 COCO[7:0]; PDB2 channel 0
 *     back-to-back operation with ADC2 COCO[7:0].
 * - 0b1 - Channel 0 of PDB0,PDB1 and PDB2 back-to-back operation with COCO[7:0]
 *     of ADC0, ADC1 and ADC2.
 */
/*@{*/
/*! @brief Read current value of the SIM_CHIPCTL_PDB_BB_SEL field. */
#define SIM_RD_CHIPCTL_PDB_BB_SEL(base) ((SIM_CHIPCTL_REG(base) & SIM_CHIPCTL_PDB_BB_SEL_MASK) >> SIM_CHIPCTL_PDB_BB_SEL_SHIFT)
#define SIM_BRD_CHIPCTL_PDB_BB_SEL(base) (BITBAND_ACCESS32(&SIM_CHIPCTL_REG(base), SIM_CHIPCTL_PDB_BB_SEL_SHIFT))

/*! @brief Set the PDB_BB_SEL field to a new value. */
#define SIM_WR_CHIPCTL_PDB_BB_SEL(base, value) (SIM_RMW_CHIPCTL(base, SIM_CHIPCTL_PDB_BB_SEL_MASK, SIM_CHIPCTL_PDB_BB_SEL(value)))
#define SIM_BWR_CHIPCTL_PDB_BB_SEL(base, value) (BITBAND_ACCESS32(&SIM_CHIPCTL_REG(base), SIM_CHIPCTL_PDB_BB_SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_CHIPCTL, field COCO_TRG_SEL[14] (RW)
 *
 * Selects ADC1 or ADC2 COCO output as TRGMUX input.
 *
 * Values:
 * - 0b0 - ADC1 COCO
 * - 0b1 - ADC2 COCO
 */
/*@{*/
/*! @brief Read current value of the SIM_CHIPCTL_COCO_TRG_SEL field. */
#define SIM_RD_CHIPCTL_COCO_TRG_SEL(base) ((SIM_CHIPCTL_REG(base) & SIM_CHIPCTL_COCO_TRG_SEL_MASK) >> SIM_CHIPCTL_COCO_TRG_SEL_SHIFT)
#define SIM_BRD_CHIPCTL_COCO_TRG_SEL(base) (BITBAND_ACCESS32(&SIM_CHIPCTL_REG(base), SIM_CHIPCTL_COCO_TRG_SEL_SHIFT))

/*! @brief Set the COCO_TRG_SEL field to a new value. */
#define SIM_WR_CHIPCTL_COCO_TRG_SEL(base, value) (SIM_RMW_CHIPCTL(base, SIM_CHIPCTL_COCO_TRG_SEL_MASK, SIM_CHIPCTL_COCO_TRG_SEL(value)))
#define SIM_BWR_CHIPCTL_COCO_TRG_SEL(base, value) (BITBAND_ACCESS32(&SIM_CHIPCTL_REG(base), SIM_CHIPCTL_COCO_TRG_SEL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_FTMOPT0 - FTM Option Register 0
 ******************************************************************************/

/*!
 * @brief SIM_FTMOPT0 - FTM Option Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_FTMOPT0 register
 */
/*@{*/
#define SIM_RD_FTMOPT0(base)     (SIM_FTMOPT0_REG(base))
#define SIM_WR_FTMOPT0(base, value) (SIM_FTMOPT0_REG(base) = (value))
#define SIM_RMW_FTMOPT0(base, mask, value) (SIM_WR_FTMOPT0(base, (SIM_RD_FTMOPT0(base) & ~(mask)) | (value)))
#define SIM_SET_FTMOPT0(base, value) (SIM_WR_FTMOPT0(base, SIM_RD_FTMOPT0(base) |  (value)))
#define SIM_CLR_FTMOPT0(base, value) (SIM_WR_FTMOPT0(base, SIM_RD_FTMOPT0(base) & ~(value)))
#define SIM_TOG_FTMOPT0(base, value) (SIM_WR_FTMOPT0(base, SIM_RD_FTMOPT0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FTMOPT0 bitfields
 */

/*!
 * @name Register SIM_FTMOPT0, field FTM0FLTxSEL[2:0] (RW)
 *
 * Selects the source of FTM0 fault. Every bit means one fault input
 * respectively. The pin source for fault must be configured for the FTM module fault
 * function through the appropriate pin control register in the port control module
 * when it comes from external fault pin. TRGMUX_FTM0 SELx is corresponding to FTM0
 * Fault x input.
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM0FLTxSEL field. */
#define SIM_RD_FTMOPT0_FTM0FLTxSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM0FLTxSEL_MASK) >> SIM_FTMOPT0_FTM0FLTxSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM0FLTxSEL(base) (SIM_RD_FTMOPT0_FTM0FLTxSEL(base))

/*! @brief Set the FTM0FLTxSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM0FLTxSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM0FLTxSEL_MASK, SIM_FTMOPT0_FTM0FLTxSEL(value)))
#define SIM_BWR_FTMOPT0_FTM0FLTxSEL(base, value) (SIM_WR_FTMOPT0_FTM0FLTxSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT0, field FTM1FLTxSEL[6:4] (RW)
 *
 * Selects the source of FTM1 fault. Every bit means one fault input
 * respectively. The pin source for fault must be configured for the FTM module fault
 * function through the appropriate pin control register in the port control module
 * when it comes from external fault pin. TRGMUX_FTM1 SELx is corresponding to FTM1
 * Fault x input.
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM1FLTxSEL field. */
#define SIM_RD_FTMOPT0_FTM1FLTxSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM1FLTxSEL_MASK) >> SIM_FTMOPT0_FTM1FLTxSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM1FLTxSEL(base) (SIM_RD_FTMOPT0_FTM1FLTxSEL(base))

/*! @brief Set the FTM1FLTxSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM1FLTxSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM1FLTxSEL_MASK, SIM_FTMOPT0_FTM1FLTxSEL(value)))
#define SIM_BWR_FTMOPT0_FTM1FLTxSEL(base, value) (SIM_WR_FTMOPT0_FTM1FLTxSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT0, field FTM2FLTxSEL[10:8] (RW)
 *
 * Selects the source of FTM2 fault. Every bit means one fault input
 * respectively. The pin source for fault must be configured for the FTM module fault
 * function through the appropriate pin control register in the port control module
 * when it comes from external fault pin. TRGMUX_FTM2 SELx is corresponding to FTM2
 * Fault x input .
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM2FLTxSEL field. */
#define SIM_RD_FTMOPT0_FTM2FLTxSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM2FLTxSEL_MASK) >> SIM_FTMOPT0_FTM2FLTxSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM2FLTxSEL(base) (SIM_RD_FTMOPT0_FTM2FLTxSEL(base))

/*! @brief Set the FTM2FLTxSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM2FLTxSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM2FLTxSEL_MASK, SIM_FTMOPT0_FTM2FLTxSEL(value)))
#define SIM_BWR_FTMOPT0_FTM2FLTxSEL(base, value) (SIM_WR_FTMOPT0_FTM2FLTxSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT0, field FTM3FLTxSEL[14:12] (RW)
 *
 * Selects the source of FTM3 fault. Every bit means one fault input
 * respectively. The pin source for fault must be configured for the FTM module fault
 * function through the appropriate pin control register in the port control module
 * when it comes from external fault pin. TRGMUX_FTM3 SELx is corresponding to FTM3
 * Fault x input .
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM3FLTxSEL field. */
#define SIM_RD_FTMOPT0_FTM3FLTxSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM3FLTxSEL_MASK) >> SIM_FTMOPT0_FTM3FLTxSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM3FLTxSEL(base) (SIM_RD_FTMOPT0_FTM3FLTxSEL(base))

/*! @brief Set the FTM3FLTxSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM3FLTxSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM3FLTxSEL_MASK, SIM_FTMOPT0_FTM3FLTxSEL(value)))
#define SIM_BWR_FTMOPT0_FTM3FLTxSEL(base, value) (SIM_WR_FTMOPT0_FTM3FLTxSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT0, field FTM0CLKSEL[25:24] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM0 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate Pin Control Register in the Port Control module.
 *
 * Values:
 * - 0b00 - FTM0 external clock driven by TCLK0 pin.
 * - 0b01 - FTM0 external clock driven by TCLK1 pin.
 * - 0b10 - FTM0 external clock driven by TCLK2 pin.
 * - 0b11 - No clock input
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM0CLKSEL field. */
#define SIM_RD_FTMOPT0_FTM0CLKSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM0CLKSEL_MASK) >> SIM_FTMOPT0_FTM0CLKSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM0CLKSEL(base) (SIM_RD_FTMOPT0_FTM0CLKSEL(base))

/*! @brief Set the FTM0CLKSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM0CLKSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM0CLKSEL_MASK, SIM_FTMOPT0_FTM0CLKSEL(value)))
#define SIM_BWR_FTMOPT0_FTM0CLKSEL(base, value) (SIM_WR_FTMOPT0_FTM0CLKSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT0, field FTM1CLKSEL[27:26] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM1 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate Pin Control Register in the Port Control module.
 *
 * Values:
 * - 0b00 - FTM1 external clock driven by TCLK0 pin.
 * - 0b01 - FTM1 external clock driven by TCLK1 pin.
 * - 0b10 - FTM1 external clock driven by TCLK2 pin.
 * - 0b11 - No clock input
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM1CLKSEL field. */
#define SIM_RD_FTMOPT0_FTM1CLKSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM1CLKSEL_MASK) >> SIM_FTMOPT0_FTM1CLKSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM1CLKSEL(base) (SIM_RD_FTMOPT0_FTM1CLKSEL(base))

/*! @brief Set the FTM1CLKSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM1CLKSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM1CLKSEL_MASK, SIM_FTMOPT0_FTM1CLKSEL(value)))
#define SIM_BWR_FTMOPT0_FTM1CLKSEL(base, value) (SIM_WR_FTMOPT0_FTM1CLKSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT0, field FTM2CLKSEL[29:28] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM2 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate Pin Control Register in the Port Control module.
 *
 * Values:
 * - 0b00 - FTM2 external clock driven by TCLK0 pin.
 * - 0b01 - FTM2 external clock driven by TCLK1 pin.
 * - 0b10 - FTM2 external clock driven by TCLK2 pin.
 * - 0b11 - No clock input
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM2CLKSEL field. */
#define SIM_RD_FTMOPT0_FTM2CLKSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM2CLKSEL_MASK) >> SIM_FTMOPT0_FTM2CLKSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM2CLKSEL(base) (SIM_RD_FTMOPT0_FTM2CLKSEL(base))

/*! @brief Set the FTM2CLKSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM2CLKSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM2CLKSEL_MASK, SIM_FTMOPT0_FTM2CLKSEL(value)))
#define SIM_BWR_FTMOPT0_FTM2CLKSEL(base, value) (SIM_WR_FTMOPT0_FTM2CLKSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT0, field FTM3CLKSEL[31:30] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM3 module. The
 * selected pin must also be configured for the FTM external clock function through
 * the appropriate Pin Control Register in the Port Control module.
 *
 * Values:
 * - 0b00 - FTM3 external clock driven by TCLK0 pin.
 * - 0b01 - FTM3 external clock driven by TCLK1 pin.
 * - 0b10 - FTM3 external clock driven by TCLK2 pin.
 * - 0b11 - No clock input
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT0_FTM3CLKSEL field. */
#define SIM_RD_FTMOPT0_FTM3CLKSEL(base) ((SIM_FTMOPT0_REG(base) & SIM_FTMOPT0_FTM3CLKSEL_MASK) >> SIM_FTMOPT0_FTM3CLKSEL_SHIFT)
#define SIM_BRD_FTMOPT0_FTM3CLKSEL(base) (SIM_RD_FTMOPT0_FTM3CLKSEL(base))

/*! @brief Set the FTM3CLKSEL field to a new value. */
#define SIM_WR_FTMOPT0_FTM3CLKSEL(base, value) (SIM_RMW_FTMOPT0(base, SIM_FTMOPT0_FTM3CLKSEL_MASK, SIM_FTMOPT0_FTM3CLKSEL(value)))
#define SIM_BWR_FTMOPT0_FTM3CLKSEL(base, value) (SIM_WR_FTMOPT0_FTM3CLKSEL(base, value))
/*@}*/

/*******************************************************************************
 * SIM_LPOCLKS - LPO Clock Select Register
 ******************************************************************************/

/*!
 * @brief SIM_LPOCLKS - LPO Clock Select Register (RW)
 *
 * Reset value: 0x00000003U
 *
 * The LPOCLKS register is a write-once register, and only reset on POR or LVD.
 */
/*!
 * @name Constants and macros for entire SIM_LPOCLKS register
 */
/*@{*/
#define SIM_RD_LPOCLKS(base)     (SIM_LPOCLKS_REG(base))
#define SIM_WR_LPOCLKS(base, value) (SIM_LPOCLKS_REG(base) = (value))
#define SIM_RMW_LPOCLKS(base, mask, value) (SIM_WR_LPOCLKS(base, (SIM_RD_LPOCLKS(base) & ~(mask)) | (value)))
#define SIM_SET_LPOCLKS(base, value) (SIM_WR_LPOCLKS(base, SIM_RD_LPOCLKS(base) |  (value)))
#define SIM_CLR_LPOCLKS(base, value) (SIM_WR_LPOCLKS(base, SIM_RD_LPOCLKS(base) & ~(value)))
#define SIM_TOG_LPOCLKS(base, value) (SIM_WR_LPOCLKS(base, SIM_RD_LPOCLKS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_LPOCLKS bitfields
 */

/*!
 * @name Register SIM_LPOCLKS, field LPO1KCLKEN[0] (RW)
 *
 * Values:
 * - 0b0 - Disable 1 kHz LPO clock output
 * - 0b1 - Enable 1 kHz LPO clock output
 */
/*@{*/
/*! @brief Read current value of the SIM_LPOCLKS_LPO1KCLKEN field. */
#define SIM_RD_LPOCLKS_LPO1KCLKEN(base) ((SIM_LPOCLKS_REG(base) & SIM_LPOCLKS_LPO1KCLKEN_MASK) >> SIM_LPOCLKS_LPO1KCLKEN_SHIFT)
#define SIM_BRD_LPOCLKS_LPO1KCLKEN(base) (BITBAND_ACCESS32(&SIM_LPOCLKS_REG(base), SIM_LPOCLKS_LPO1KCLKEN_SHIFT))

/*! @brief Set the LPO1KCLKEN field to a new value. */
#define SIM_WR_LPOCLKS_LPO1KCLKEN(base, value) (SIM_RMW_LPOCLKS(base, SIM_LPOCLKS_LPO1KCLKEN_MASK, SIM_LPOCLKS_LPO1KCLKEN(value)))
#define SIM_BWR_LPOCLKS_LPO1KCLKEN(base, value) (BITBAND_ACCESS32(&SIM_LPOCLKS_REG(base), SIM_LPOCLKS_LPO1KCLKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_LPOCLKS, field LPO32KCLKEN[1] (RW)
 *
 * Values:
 * - 0b0 - Disable 32 kHz LPO clock output
 * - 0b1 - Enable 32 kHz LPO clock output
 */
/*@{*/
/*! @brief Read current value of the SIM_LPOCLKS_LPO32KCLKEN field. */
#define SIM_RD_LPOCLKS_LPO32KCLKEN(base) ((SIM_LPOCLKS_REG(base) & SIM_LPOCLKS_LPO32KCLKEN_MASK) >> SIM_LPOCLKS_LPO32KCLKEN_SHIFT)
#define SIM_BRD_LPOCLKS_LPO32KCLKEN(base) (BITBAND_ACCESS32(&SIM_LPOCLKS_REG(base), SIM_LPOCLKS_LPO32KCLKEN_SHIFT))

/*! @brief Set the LPO32KCLKEN field to a new value. */
#define SIM_WR_LPOCLKS_LPO32KCLKEN(base, value) (SIM_RMW_LPOCLKS(base, SIM_LPOCLKS_LPO32KCLKEN_MASK, SIM_LPOCLKS_LPO32KCLKEN(value)))
#define SIM_BWR_LPOCLKS_LPO32KCLKEN(base, value) (BITBAND_ACCESS32(&SIM_LPOCLKS_REG(base), SIM_LPOCLKS_LPO32KCLKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_LPOCLKS, field LPOCLKSEL[3:2] (RW)
 *
 * Selects LPO clock source for peripherals Is this really configurable? Figure
 * 5-1 shows only one option for LPO_CLK, the 128 kHz LPO
 *
 * Values:
 * - 0b00 - 128 kHz LPO clock
 * - 0b01 - 32 kHz oscillator clock
 * - 0b10 - 32 kHz LPO clock which is divided by the 128 kHz LPO clock
 * - 0b11 - 1 kHz LPO clock which is divided by the 128 kHz LPO clock
 */
/*@{*/
/*! @brief Read current value of the SIM_LPOCLKS_LPOCLKSEL field. */
#define SIM_RD_LPOCLKS_LPOCLKSEL(base) ((SIM_LPOCLKS_REG(base) & SIM_LPOCLKS_LPOCLKSEL_MASK) >> SIM_LPOCLKS_LPOCLKSEL_SHIFT)
#define SIM_BRD_LPOCLKS_LPOCLKSEL(base) (SIM_RD_LPOCLKS_LPOCLKSEL(base))

/*! @brief Set the LPOCLKSEL field to a new value. */
#define SIM_WR_LPOCLKS_LPOCLKSEL(base, value) (SIM_RMW_LPOCLKS(base, SIM_LPOCLKS_LPOCLKSEL_MASK, SIM_LPOCLKS_LPOCLKSEL(value)))
#define SIM_BWR_LPOCLKS_LPOCLKSEL(base, value) (SIM_WR_LPOCLKS_LPOCLKSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_LPOCLKS, field CLK32KSEL[5:4] (RW)
 *
 * Selects 32 kHz clock source for peripherals
 *
 * Values:
 * - 0b00 - 32 kHz oscillator clock
 * - 0b01 - 32 kHz LPO clock
 * - 0b10 - RTC_CLKIN clock
 * - 0b11 - no clock
 */
/*@{*/
/*! @brief Read current value of the SIM_LPOCLKS_CLK32KSEL field. */
#define SIM_RD_LPOCLKS_CLK32KSEL(base) ((SIM_LPOCLKS_REG(base) & SIM_LPOCLKS_CLK32KSEL_MASK) >> SIM_LPOCLKS_CLK32KSEL_SHIFT)
#define SIM_BRD_LPOCLKS_CLK32KSEL(base) (SIM_RD_LPOCLKS_CLK32KSEL(base))

/*! @brief Set the CLK32KSEL field to a new value. */
#define SIM_WR_LPOCLKS_CLK32KSEL(base, value) (SIM_RMW_LPOCLKS(base, SIM_LPOCLKS_CLK32KSEL_MASK, SIM_LPOCLKS_CLK32KSEL(value)))
#define SIM_BWR_LPOCLKS_CLK32KSEL(base, value) (SIM_WR_LPOCLKS_CLK32KSEL(base, value))
/*@}*/

/*******************************************************************************
 * SIM_ADCOPT - ADC Options Register
 ******************************************************************************/

/*!
 * @brief SIM_ADCOPT - ADC Options Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_ADCOPT register
 */
/*@{*/
#define SIM_RD_ADCOPT(base)      (SIM_ADCOPT_REG(base))
#define SIM_WR_ADCOPT(base, value) (SIM_ADCOPT_REG(base) = (value))
#define SIM_RMW_ADCOPT(base, mask, value) (SIM_WR_ADCOPT(base, (SIM_RD_ADCOPT(base) & ~(mask)) | (value)))
#define SIM_SET_ADCOPT(base, value) (SIM_WR_ADCOPT(base, SIM_RD_ADCOPT(base) |  (value)))
#define SIM_CLR_ADCOPT(base, value) (SIM_WR_ADCOPT(base, SIM_RD_ADCOPT(base) & ~(value)))
#define SIM_TOG_ADCOPT(base, value) (SIM_WR_ADCOPT(base, SIM_RD_ADCOPT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_ADCOPT bitfields
 */

/*!
 * @name Register SIM_ADCOPT, field ADC0TRGSEL[0] (RW)
 *
 * Selects trigger source for ADC0.
 *
 * Values:
 * - 0b0 - PDB output
 * - 0b1 - TRGMUX output
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC0TRGSEL field. */
#define SIM_RD_ADCOPT_ADC0TRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC0TRGSEL_MASK) >> SIM_ADCOPT_ADC0TRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC0TRGSEL(base) (BITBAND_ACCESS32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC0TRGSEL_SHIFT))

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC0TRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC0TRGSEL_MASK, SIM_ADCOPT_ADC0TRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC0TRGSEL(base, value) (BITBAND_ACCESS32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC0TRGSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC0SWPRETRG[3:1] (RW)
 *
 * Values:
 * - 0b000 - software pre-trigger disabled
 * - 0b001 - software pre-trigger 0
 * - 0b010 - software pre-trigger 1
 * - 0b011 - software pre-trigger 2
 * - 0b100 - software pre-trigger 3
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC0SWPRETRG field. */
#define SIM_RD_ADCOPT_ADC0SWPRETRG(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC0SWPRETRG_MASK) >> SIM_ADCOPT_ADC0SWPRETRG_SHIFT)
#define SIM_BRD_ADCOPT_ADC0SWPRETRG(base) (SIM_RD_ADCOPT_ADC0SWPRETRG(base))

/*! @brief Set the ADC0SWPRETRG field to a new value. */
#define SIM_WR_ADCOPT_ADC0SWPRETRG(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC0SWPRETRG_MASK, SIM_ADCOPT_ADC0SWPRETRG(value)))
#define SIM_BWR_ADCOPT_ADC0SWPRETRG(base, value) (SIM_WR_ADCOPT_ADC0SWPRETRG(base, value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC0PRETRGSEL[5:4] (RW)
 *
 * Selects pre-trigger source for ADC0.
 *
 * Values:
 * - 0b00 - PDB pre-trigger (default)
 * - 0b01 - TRGMUX pre-trigger
 * - 0b10 - Software pre-trigger
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC0PRETRGSEL field. */
#define SIM_RD_ADCOPT_ADC0PRETRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC0PRETRGSEL_MASK) >> SIM_ADCOPT_ADC0PRETRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC0PRETRGSEL(base) (SIM_RD_ADCOPT_ADC0PRETRGSEL(base))

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC0PRETRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC0PRETRGSEL_MASK, SIM_ADCOPT_ADC0PRETRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC0PRETRGSEL(base, value) (SIM_WR_ADCOPT_ADC0PRETRGSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC1TRGSEL[8] (RW)
 *
 * Selects trigger source for ADC1.
 *
 * Values:
 * - 0b0 - PDB output
 * - 0b1 - TRGMUX output
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC1TRGSEL field. */
#define SIM_RD_ADCOPT_ADC1TRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC1TRGSEL_MASK) >> SIM_ADCOPT_ADC1TRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC1TRGSEL(base) (BITBAND_ACCESS32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC1TRGSEL_SHIFT))

/*! @brief Set the ADC1TRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC1TRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC1TRGSEL_MASK, SIM_ADCOPT_ADC1TRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC1TRGSEL(base, value) (BITBAND_ACCESS32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC1TRGSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC1SWPRETRG[11:9] (RW)
 *
 * Values:
 * - 0b000 - software pre-trigger disabled
 * - 0b001 - software pre-trigger 0
 * - 0b010 - software pre-trigger 1
 * - 0b011 - software pre-trigger 2
 * - 0b100 - software pre-trigger 3
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC1SWPRETRG field. */
#define SIM_RD_ADCOPT_ADC1SWPRETRG(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC1SWPRETRG_MASK) >> SIM_ADCOPT_ADC1SWPRETRG_SHIFT)
#define SIM_BRD_ADCOPT_ADC1SWPRETRG(base) (SIM_RD_ADCOPT_ADC1SWPRETRG(base))

/*! @brief Set the ADC1SWPRETRG field to a new value. */
#define SIM_WR_ADCOPT_ADC1SWPRETRG(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC1SWPRETRG_MASK, SIM_ADCOPT_ADC1SWPRETRG(value)))
#define SIM_BWR_ADCOPT_ADC1SWPRETRG(base, value) (SIM_WR_ADCOPT_ADC1SWPRETRG(base, value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC1PRETRGSEL[13:12] (RW)
 *
 * Selects pre-trigger source for ADC1.
 *
 * Values:
 * - 0b00 - PDB pre-trigger (default)
 * - 0b01 - TRGMUX pre-trigger
 * - 0b10 - Software pre-trigger
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC1PRETRGSEL field. */
#define SIM_RD_ADCOPT_ADC1PRETRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC1PRETRGSEL_MASK) >> SIM_ADCOPT_ADC1PRETRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC1PRETRGSEL(base) (SIM_RD_ADCOPT_ADC1PRETRGSEL(base))

/*! @brief Set the ADC1PRETRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC1PRETRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC1PRETRGSEL_MASK, SIM_ADCOPT_ADC1PRETRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC1PRETRGSEL(base, value) (SIM_WR_ADCOPT_ADC1PRETRGSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC2TRGSEL[16] (RW)
 *
 * Selects trigger source for ADC2.
 *
 * Values:
 * - 0b0 - PDB output
 * - 0b1 - TRGMUX output
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC2TRGSEL field. */
#define SIM_RD_ADCOPT_ADC2TRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC2TRGSEL_MASK) >> SIM_ADCOPT_ADC2TRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC2TRGSEL(base) (BITBAND_ACCESS32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC2TRGSEL_SHIFT))

/*! @brief Set the ADC2TRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC2TRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC2TRGSEL_MASK, SIM_ADCOPT_ADC2TRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC2TRGSEL(base, value) (BITBAND_ACCESS32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC2TRGSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC2SWPRETRG[19:17] (RW)
 *
 * Values:
 * - 0b000 - software pre-trigger disabled
 * - 0b001 - software pre-trigger 0
 * - 0b010 - software pre-trigger 1
 * - 0b011 - software pre-trigger 2
 * - 0b100 - software pre-trigger 3
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC2SWPRETRG field. */
#define SIM_RD_ADCOPT_ADC2SWPRETRG(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC2SWPRETRG_MASK) >> SIM_ADCOPT_ADC2SWPRETRG_SHIFT)
#define SIM_BRD_ADCOPT_ADC2SWPRETRG(base) (SIM_RD_ADCOPT_ADC2SWPRETRG(base))

/*! @brief Set the ADC2SWPRETRG field to a new value. */
#define SIM_WR_ADCOPT_ADC2SWPRETRG(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC2SWPRETRG_MASK, SIM_ADCOPT_ADC2SWPRETRG(value)))
#define SIM_BWR_ADCOPT_ADC2SWPRETRG(base, value) (SIM_WR_ADCOPT_ADC2SWPRETRG(base, value))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC2PRETRGSEL[21:20] (RW)
 *
 * Selects pre-trigger source for ADC2
 *
 * Values:
 * - 0b00 - PDB pre-trigger (default)
 * - 0b01 - TRGMUX pre-trigger
 * - 0b10 - Software pre-trigger
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC2PRETRGSEL field. */
#define SIM_RD_ADCOPT_ADC2PRETRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC2PRETRGSEL_MASK) >> SIM_ADCOPT_ADC2PRETRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC2PRETRGSEL(base) (SIM_RD_ADCOPT_ADC2PRETRGSEL(base))

/*! @brief Set the ADC2PRETRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC2PRETRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC2PRETRGSEL_MASK, SIM_ADCOPT_ADC2PRETRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC2PRETRGSEL(base, value) (SIM_WR_ADCOPT_ADC2PRETRGSEL(base, value))
/*@}*/

/*******************************************************************************
 * SIM_FTMOPT1 - FTM Option Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FTMOPT1 - FTM Option Register 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_FTMOPT1 register
 */
/*@{*/
#define SIM_RD_FTMOPT1(base)     (SIM_FTMOPT1_REG(base))
#define SIM_WR_FTMOPT1(base, value) (SIM_FTMOPT1_REG(base) = (value))
#define SIM_RMW_FTMOPT1(base, mask, value) (SIM_WR_FTMOPT1(base, (SIM_RD_FTMOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_FTMOPT1(base, value) (SIM_WR_FTMOPT1(base, SIM_RD_FTMOPT1(base) |  (value)))
#define SIM_CLR_FTMOPT1(base, value) (SIM_WR_FTMOPT1(base, SIM_RD_FTMOPT1(base) & ~(value)))
#define SIM_TOG_FTMOPT1(base, value) (SIM_WR_FTMOPT1(base, SIM_RD_FTMOPT1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FTMOPT1 bitfields
 */

/*!
 * @name Register SIM_FTMOPT1, field FTM0SYNCBIT[0] (RW)
 *
 * value description TBD
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM0SYNCBIT field. */
#define SIM_RD_FTMOPT1_FTM0SYNCBIT(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM0SYNCBIT_MASK) >> SIM_FTMOPT1_FTM0SYNCBIT_SHIFT)
#define SIM_BRD_FTMOPT1_FTM0SYNCBIT(base) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM0SYNCBIT_SHIFT))

/*! @brief Set the FTM0SYNCBIT field to a new value. */
#define SIM_WR_FTMOPT1_FTM0SYNCBIT(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM0SYNCBIT_MASK, SIM_FTMOPT1_FTM0SYNCBIT(value)))
#define SIM_BWR_FTMOPT1_FTM0SYNCBIT(base, value) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM0SYNCBIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM1SYNCBIT[1] (RW)
 *
 * value description TBD
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM1SYNCBIT field. */
#define SIM_RD_FTMOPT1_FTM1SYNCBIT(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM1SYNCBIT_MASK) >> SIM_FTMOPT1_FTM1SYNCBIT_SHIFT)
#define SIM_BRD_FTMOPT1_FTM1SYNCBIT(base) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM1SYNCBIT_SHIFT))

/*! @brief Set the FTM1SYNCBIT field to a new value. */
#define SIM_WR_FTMOPT1_FTM1SYNCBIT(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM1SYNCBIT_MASK, SIM_FTMOPT1_FTM1SYNCBIT(value)))
#define SIM_BWR_FTMOPT1_FTM1SYNCBIT(base, value) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM1SYNCBIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM2SYNCBIT[2] (RW)
 *
 * value description TBD
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM2SYNCBIT field. */
#define SIM_RD_FTMOPT1_FTM2SYNCBIT(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM2SYNCBIT_MASK) >> SIM_FTMOPT1_FTM2SYNCBIT_SHIFT)
#define SIM_BRD_FTMOPT1_FTM2SYNCBIT(base) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM2SYNCBIT_SHIFT))

/*! @brief Set the FTM2SYNCBIT field to a new value. */
#define SIM_WR_FTMOPT1_FTM2SYNCBIT(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM2SYNCBIT_MASK, SIM_FTMOPT1_FTM2SYNCBIT(value)))
#define SIM_BWR_FTMOPT1_FTM2SYNCBIT(base, value) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM2SYNCBIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM3SYNCBIT[3] (RW)
 *
 * These bits need a description and expected values.
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM3SYNCBIT field. */
#define SIM_RD_FTMOPT1_FTM3SYNCBIT(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM3SYNCBIT_MASK) >> SIM_FTMOPT1_FTM3SYNCBIT_SHIFT)
#define SIM_BRD_FTMOPT1_FTM3SYNCBIT(base) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM3SYNCBIT_SHIFT))

/*! @brief Set the FTM3SYNCBIT field to a new value. */
#define SIM_WR_FTMOPT1_FTM3SYNCBIT(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM3SYNCBIT_MASK, SIM_FTMOPT1_FTM3SYNCBIT(value)))
#define SIM_BWR_FTMOPT1_FTM3SYNCBIT(base, value) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM3SYNCBIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM1CH0SEL[5:4] (RW)
 *
 * Selects FTM1 CH0 input
 *
 * Values:
 * - 0b00 - FTM1_CH0 input
 * - 0b01 - CMP0 output
 * - 0b10 - CMP1 output
 * - 0b11 - CMP2 output
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM1CH0SEL field. */
#define SIM_RD_FTMOPT1_FTM1CH0SEL(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM1CH0SEL_MASK) >> SIM_FTMOPT1_FTM1CH0SEL_SHIFT)
#define SIM_BRD_FTMOPT1_FTM1CH0SEL(base) (SIM_RD_FTMOPT1_FTM1CH0SEL(base))

/*! @brief Set the FTM1CH0SEL field to a new value. */
#define SIM_WR_FTMOPT1_FTM1CH0SEL(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM1CH0SEL_MASK, SIM_FTMOPT1_FTM1CH0SEL(value)))
#define SIM_BWR_FTMOPT1_FTM1CH0SEL(base, value) (SIM_WR_FTMOPT1_FTM1CH0SEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM2CH0SEL[7:6] (RW)
 *
 * Selects FTM2 CH0 input
 *
 * Values:
 * - 0b00 - FTM2_CH0 input
 * - 0b01 - CMP0 output
 * - 0b10 - CMP1 output
 * - 0b11 - CMP2 output
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM2CH0SEL field. */
#define SIM_RD_FTMOPT1_FTM2CH0SEL(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM2CH0SEL_MASK) >> SIM_FTMOPT1_FTM2CH0SEL_SHIFT)
#define SIM_BRD_FTMOPT1_FTM2CH0SEL(base) (SIM_RD_FTMOPT1_FTM2CH0SEL(base))

/*! @brief Set the FTM2CH0SEL field to a new value. */
#define SIM_WR_FTMOPT1_FTM2CH0SEL(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM2CH0SEL_MASK, SIM_FTMOPT1_FTM2CH0SEL(value)))
#define SIM_BWR_FTMOPT1_FTM2CH0SEL(base, value) (SIM_WR_FTMOPT1_FTM2CH0SEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM2CH1SEL[8] (RW)
 *
 * Selects FTM2 CH1 input
 *
 * Values:
 * - 0b0 - FTM2_CH1 input
 * - 0b1 - exclusive OR of FTM2_CH0,FTM2_CH1, and FTM1_CH1
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM2CH1SEL field. */
#define SIM_RD_FTMOPT1_FTM2CH1SEL(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM2CH1SEL_MASK) >> SIM_FTMOPT1_FTM2CH1SEL_SHIFT)
#define SIM_BRD_FTMOPT1_FTM2CH1SEL(base) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM2CH1SEL_SHIFT))

/*! @brief Set the FTM2CH1SEL field to a new value. */
#define SIM_WR_FTMOPT1_FTM2CH1SEL(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM2CH1SEL_MASK, SIM_FTMOPT1_FTM2CH1SEL(value)))
#define SIM_BWR_FTMOPT1_FTM2CH1SEL(base, value) (BITBAND_ACCESS32(&SIM_FTMOPT1_REG(base), SIM_FTMOPT1_FTM2CH1SEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM0_OUTSEL[23:16] (RW)
 *
 * Bit 7 to 0 are for channel 7 to 0 respectively.
 *
 * Values:
 * - 0b00000000 - No modulation with FTM1_CH1
 * - 0b00000001 - Modulation with FTM1_CH1
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM0_OUTSEL field. */
#define SIM_RD_FTMOPT1_FTM0_OUTSEL(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM0_OUTSEL_MASK) >> SIM_FTMOPT1_FTM0_OUTSEL_SHIFT)
#define SIM_BRD_FTMOPT1_FTM0_OUTSEL(base) (SIM_RD_FTMOPT1_FTM0_OUTSEL(base))

/*! @brief Set the FTM0_OUTSEL field to a new value. */
#define SIM_WR_FTMOPT1_FTM0_OUTSEL(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM0_OUTSEL_MASK, SIM_FTMOPT1_FTM0_OUTSEL(value)))
#define SIM_BWR_FTMOPT1_FTM0_OUTSEL(base, value) (SIM_WR_FTMOPT1_FTM0_OUTSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_FTMOPT1, field FTM3_OUTSEL[31:24] (RW)
 *
 * Bit 7 to 0 are for channel 7 to 0 respectively.
 *
 * Values:
 * - 0b00000000 - No modulation with FTM2_CH1
 * - 0b00000001 - Modulation with FTM2_CH1
 */
/*@{*/
/*! @brief Read current value of the SIM_FTMOPT1_FTM3_OUTSEL field. */
#define SIM_RD_FTMOPT1_FTM3_OUTSEL(base) ((SIM_FTMOPT1_REG(base) & SIM_FTMOPT1_FTM3_OUTSEL_MASK) >> SIM_FTMOPT1_FTM3_OUTSEL_SHIFT)
#define SIM_BRD_FTMOPT1_FTM3_OUTSEL(base) (SIM_RD_FTMOPT1_FTM3_OUTSEL(base))

/*! @brief Set the FTM3_OUTSEL field to a new value. */
#define SIM_WR_FTMOPT1_FTM3_OUTSEL(base, value) (SIM_RMW_FTMOPT1(base, SIM_FTMOPT1_FTM3_OUTSEL_MASK, SIM_FTMOPT1_FTM3_OUTSEL(value)))
#define SIM_BWR_FTMOPT1_FTM3_OUTSEL(base, value) (SIM_WR_FTMOPT1_FTM3_OUTSEL(base, value))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reset value loaded during System Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[6:0] (RO)
 *
 * Specifies the pin count of the device.
 *
 * Values:
 * - 0b0000111 - 64-pin
 * - 0b0001000 - 80-pin
 * - 0b0001010 - 100-pin
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (SIM_RD_SDID_PINID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field PROJECTID[11:7] (RO)
 *
 * Specifies the silicon feature set identication number for the device. 00000
 * by default ?
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PROJECTID field. */
#define SIM_RD_SDID_PROJECTID(base) ((SIM_SDID_REG(base) & SIM_SDID_PROJECTID_MASK) >> SIM_SDID_PROJECTID_SHIFT)
#define SIM_BRD_SDID_PROJECTID(base) (SIM_RD_SDID_PROJECTID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (SIM_RD_SDID_REVID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field RAMSIZE[19:16] (RO)
 *
 * This field specifies the amount of system RAM available on the device.
 *
 * Values:
 * - 0b0101 - 16 KB
 * - 0b0110 - 32 KB
 * - 0b0111 - 64 KB
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_RAMSIZE field. */
#define SIM_RD_SDID_RAMSIZE(base) ((SIM_SDID_REG(base) & SIM_SDID_RAMSIZE_MASK) >> SIM_SDID_RAMSIZE_SHIFT)
#define SIM_BRD_SDID_RAMSIZE(base) (SIM_RD_SDID_RAMSIZE(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Specifies the Kinetis series of the device.
 *
 * Values:
 * - 0b0010 - Kinetis E+ series
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define SIM_RD_SDID_SERIESID(base) ((SIM_SDID_REG(base) & SIM_SDID_SERIESID_MASK) >> SIM_SDID_SERIESID_SHIFT)
#define SIM_BRD_SDID_SERIESID(base) (SIM_RD_SDID_SERIESID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the Kinetis E-series sub-family of the device.
 *
 * Values:
 * - 0b0010 - KEx2 Sub-family (with EEPROM)
 * - 0b0100 - KEx4 Sub-family (Basic)
 * - 0b0101 - KEx5 Sub-family (with TSI)
 * - 0b0110 - KEx6 Sub-family (with CAN)
 * - 0b0111 - KEx7 Sub-family (with CAN and TSI)
 * - 0b1000 - KEx8 Sub-family (with dual CAN)
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define SIM_RD_SDID_SUBFAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_SUBFAMID_MASK) >> SIM_SDID_SUBFAMID_SHIFT)
#define SIM_BRD_SDID_SUBFAMID(base) (SIM_RD_SDID_SUBFAMID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMILYID[31:28] (RO)
 *
 * Specifies the Kinetis E-series family of the device.
 *
 * Values:
 * - 0b0000 - KE0x Family (Entry level)
 * - 0b0001 - KE1x Family (Enhanced features)
 * - 0b0011 - KE3x Family (with SLCD)
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMILYID field. */
#define SIM_RD_SDID_FAMILYID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMILYID_MASK) >> SIM_SDID_FAMILYID_SHIFT)
#define SIM_BRD_SDID_FAMILYID(base) (SIM_RD_SDID_FAMILYID(base))
/*@}*/

/*******************************************************************************
 * SIM_PLATCGC - Platform Clock Gating Control Register
 ******************************************************************************/

/*!
 * @brief SIM_PLATCGC - Platform Clock Gating Control Register (RW)
 *
 * Reset value: 0x00000007U
 */
/*!
 * @name Constants and macros for entire SIM_PLATCGC register
 */
/*@{*/
#define SIM_RD_PLATCGC(base)     (SIM_PLATCGC_REG(base))
#define SIM_WR_PLATCGC(base, value) (SIM_PLATCGC_REG(base) = (value))
#define SIM_RMW_PLATCGC(base, mask, value) (SIM_WR_PLATCGC(base, (SIM_RD_PLATCGC(base) & ~(mask)) | (value)))
#define SIM_SET_PLATCGC(base, value) (SIM_WR_PLATCGC(base, SIM_RD_PLATCGC(base) |  (value)))
#define SIM_CLR_PLATCGC(base, value) (SIM_WR_PLATCGC(base, SIM_RD_PLATCGC(base) & ~(value)))
#define SIM_TOG_PLATCGC(base, value) (SIM_WR_PLATCGC(base, SIM_RD_PLATCGC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_PLATCGC bitfields
 */

/*!
 * @name Register SIM_PLATCGC, field CGCMSCM[0] (RW)
 *
 * Controls the clock gating to the MSCM module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_PLATCGC_CGCMSCM field. */
#define SIM_RD_PLATCGC_CGCMSCM(base) ((SIM_PLATCGC_REG(base) & SIM_PLATCGC_CGCMSCM_MASK) >> SIM_PLATCGC_CGCMSCM_SHIFT)
#define SIM_BRD_PLATCGC_CGCMSCM(base) (BITBAND_ACCESS32(&SIM_PLATCGC_REG(base), SIM_PLATCGC_CGCMSCM_SHIFT))

/*! @brief Set the CGCMSCM field to a new value. */
#define SIM_WR_PLATCGC_CGCMSCM(base, value) (SIM_RMW_PLATCGC(base, SIM_PLATCGC_CGCMSCM_MASK, SIM_PLATCGC_CGCMSCM(value)))
#define SIM_BWR_PLATCGC_CGCMSCM(base, value) (BITBAND_ACCESS32(&SIM_PLATCGC_REG(base), SIM_PLATCGC_CGCMSCM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_PLATCGC, field CGCMPU[1] (RW)
 *
 * Controls the clock gating to the MPU module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_PLATCGC_CGCMPU field. */
#define SIM_RD_PLATCGC_CGCMPU(base) ((SIM_PLATCGC_REG(base) & SIM_PLATCGC_CGCMPU_MASK) >> SIM_PLATCGC_CGCMPU_SHIFT)
#define SIM_BRD_PLATCGC_CGCMPU(base) (BITBAND_ACCESS32(&SIM_PLATCGC_REG(base), SIM_PLATCGC_CGCMPU_SHIFT))

/*! @brief Set the CGCMPU field to a new value. */
#define SIM_WR_PLATCGC_CGCMPU(base, value) (SIM_RMW_PLATCGC(base, SIM_PLATCGC_CGCMPU_MASK, SIM_PLATCGC_CGCMPU(value)))
#define SIM_BWR_PLATCGC_CGCMPU(base, value) (BITBAND_ACCESS32(&SIM_PLATCGC_REG(base), SIM_PLATCGC_CGCMPU_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_PLATCGC, field CGCDMA[2] (RW)
 *
 * Controls the clock gating to the DMA module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_PLATCGC_CGCDMA field. */
#define SIM_RD_PLATCGC_CGCDMA(base) ((SIM_PLATCGC_REG(base) & SIM_PLATCGC_CGCDMA_MASK) >> SIM_PLATCGC_CGCDMA_SHIFT)
#define SIM_BRD_PLATCGC_CGCDMA(base) (BITBAND_ACCESS32(&SIM_PLATCGC_REG(base), SIM_PLATCGC_CGCDMA_SHIFT))

/*! @brief Set the CGCDMA field to a new value. */
#define SIM_WR_PLATCGC_CGCDMA(base, value) (SIM_RMW_PLATCGC(base, SIM_PLATCGC_CGCDMA_MASK, SIM_PLATCGC_CGCDMA(value)))
#define SIM_BWR_PLATCGC_CGCDMA(base, value) (BITBAND_ACCESS32(&SIM_PLATCGC_REG(base), SIM_PLATCGC_CGCDMA_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Reset value of NVMSIZE, PFSIZE, EEERAM_SIZE, DEPART loaded during System
 * Reset from Flash IFR.
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) |  (value)))
#define SIM_CLR_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) & ~(value)))
#define SIM_TOG_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the Flash memory
 * is placed in a low power state. This bit should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0b0 - Flash is enabled
 * - 0b1 - Flash is disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, Flash memory is disabled for the duration of Wait mode. An attempt
 * by the DMA or other bus master to access the Flash when the Flash is disabled
 * will result in a bus error. This bit should be clear during VLP modes. The
 * Flash will be automatically enabled again at the end of Wait mode so interrupt
 * vectors do not need to be relocated out of Flash memory. The wakeup time from
 * Wait mode is extended when this bit is set.
 *
 * Values:
 * - 0b0 - Flash remains enabled during Wait mode
 * - 0b1 - Flash is disabled for the duration of Wait mode
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field DEPART[15:12] (RO)
 *
 * Data flash / EEPROM backup split . See DEPART bit description in FTFE chapter.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_DEPART field. */
#define SIM_RD_FCFG1_DEPART(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_DEPART_MASK) >> SIM_FCFG1_DEPART_SHIFT)
#define SIM_BRD_FCFG1_DEPART(base) (SIM_RD_FCFG1_DEPART(base))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field EEERAMSIZE[19:16] (RO)
 *
 * EEE SRAM data size .
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - Reserved
 * - 0b0010 - 4 KB
 * - 0b0011 - 2 KB
 * - 0b0100 - 1 KB
 * - 0b0101 - 512 Bytes
 * - 0b0110 - 256 Bytes
 * - 0b0111 - 128 Bytes
 * - 0b1000 - 64 Bytes
 * - 0b1001 - 32 Bytes
 * - 0b1111 - 0 Bytes
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_EEERAMSIZE field. */
#define SIM_RD_FCFG1_EEERAMSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_EEERAMSIZE_MASK) >> SIM_FCFG1_EEERAMSIZE_SHIFT)
#define SIM_BRD_FCFG1_EEERAMSIZE(base) (SIM_RD_FCFG1_EEERAMSIZE(base))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * This field specifies the amount of program flash memory available on the
 * device . Undefined values are reserved.
 *
 * Values:
 * - 0b0000 - 8 KB of program flash memory, 0.25 KB protection region
 * - 0b0001 - 16 KB of program flash memory, 0.5 KB protection region
 * - 0b0011 - 32 KB of program flash memory, 1 KB protection region
 * - 0b0101 - 64 KB of program flash memory, 2 KB protection region
 * - 0b0111 - 128 KB of program flash memory, 4 KB protection region
 * - 0b1001 - 256 KB of program flash memory, 8 KB protection region
 * - 0b1111 - 512 KB of program flash memory, 16 KB protection region
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (SIM_RD_FCFG1_PFSIZE(base))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field NVMSIZE[31:28] (RO)
 *
 * This field specifies the amount of FlexNVM memory available on the device.
 * Undefined values are reserved.
 *
 * Values:
 * - 0b0000 - 0 KB of FlexNVM
 * - 0b0011 - 32 KB of FlexNVM
 * - 0b0101 - 64 KB of FlexNVM
 * - 0b0111 - 128 KB of FlexNVM
 * - 0b1001 - 256 KB of FlexNVM
 * - 0b1111 - 512 KB of FlexNVM
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_NVMSIZE field. */
#define SIM_RD_FCFG1_NVMSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_NVMSIZE_MASK) >> SIM_FCFG1_NVMSIZE_SHIFT)
#define SIM_BRD_FCFG1_NVMSIZE(base) (SIM_RD_FCFG1_NVMSIZE(base))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x7F7F0000U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR1[22:16] (RO)
 *
 * This field concatenated with 13 trailing zeros plus the value of the MAXADDR0
 * field indicates the first invalid address of the second program flash block
 * (flash block 1). For example, if MAXADDR0 = MAXADDR1 = 0x10 the first invalid
 * address of flash block 1 is 0x2_0000 + 0x2_0000. This would be the MAXADDR1
 * value for a device with 256 KB program flash memory across two flash blocks.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR1 field. */
#define SIM_RD_FCFG2_MAXADDR1(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR1_MASK) >> SIM_FCFG2_MAXADDR1_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR1(base) (SIM_RD_FCFG2_MAXADDR1(base))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field PFLSHEN[23] (RO)
 *
 * Enables the program flash of device.
 *
 * Values:
 * - 0b0 - Disables the program flash
 * - 0b1 - Enables the program flash.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_PFLSHEN field. */
#define SIM_RD_FCFG2_PFLSHEN(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_PFLSHEN_MASK) >> SIM_FCFG2_PFLSHEN_SHIFT)
#define SIM_BRD_FCFG2_PFLSHEN(base) (BITBAND_ACCESS32(&SIM_FCFG2_REG(base), SIM_FCFG2_PFLSHEN_SHIFT))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with 13 trailing zeros indicates the first invalid
 * address of program flash (block 0). For example, if MAXADDR0 = 0x10, the first
 * invalid address of program flash (block 0) is 0x0002_0000. This would be the
 * MAXADDR0 value for a device with 128 KB program flash in flash block 0.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define SIM_RD_FCFG2_MAXADDR0(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR0_MASK) >> SIM_FCFG2_MAXADDR0_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR0(base) (SIM_RD_FCFG2_MAXADDR0(base))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field PFLASHSWAP[31] (RO)
 *
 * For devices without FlexNVM: Indicates that swap is active .
 *
 * Values:
 * - 0b0 - Swap is not active.
 * - 0b1 - Swap is active.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_PFLASHSWAP field. */
#define SIM_RD_FCFG2_PFLASHSWAP(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_PFLASHSWAP_MASK) >> SIM_FCFG2_PFLASHSWAP_SHIFT)
#define SIM_BRD_FCFG2_PFLASHSWAP(base) (BITBAND_ACCESS32(&SIM_FCFG2_REG(base), SIM_FCFG2_PFLASHSWAP_SHIFT))
/*@}*/

/*******************************************************************************
 * SIM_UIDH - Unique Identification Register High
 ******************************************************************************/

/*!
 * @brief SIM_UIDH - Unique Identification Register High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDH register
 */
/*@{*/
#define SIM_RD_UIDH(base)        (SIM_UIDH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV4 - System Clock Divider Register 4
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV4 - System Clock Divider Register 4 (RW)
 *
 * Reset value: 0x10000000U
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV4 register
 */
/*@{*/
#define SIM_RD_CLKDIV4(base)     (SIM_CLKDIV4_REG(base))
#define SIM_WR_CLKDIV4(base, value) (SIM_CLKDIV4_REG(base) = (value))
#define SIM_RMW_CLKDIV4(base, mask, value) (SIM_WR_CLKDIV4(base, (SIM_RD_CLKDIV4(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV4(base, value) (SIM_WR_CLKDIV4(base, SIM_RD_CLKDIV4(base) |  (value)))
#define SIM_CLR_CLKDIV4(base, value) (SIM_WR_CLKDIV4(base, SIM_RD_CLKDIV4(base) & ~(value)))
#define SIM_TOG_CLKDIV4(base, value) (SIM_WR_CLKDIV4(base, SIM_RD_CLKDIV4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV4 bitfields
 */

/*!
 * @name Register SIM_CLKDIV4, field TRACEFRAC[0] (RW)
 *
 * This field sets the divide value for the fractional clock divider used as a
 * source for trace clock. The source clock for the trace clock is set by the
 * SIM_CHIPCTRL[TRACECLK_SEL]. Divider output clock = Divider input clock *
 * [(TRACEFRAC+1)/(TRACEDIV+1)].
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV4_TRACEFRAC field. */
#define SIM_RD_CLKDIV4_TRACEFRAC(base) ((SIM_CLKDIV4_REG(base) & SIM_CLKDIV4_TRACEFRAC_MASK) >> SIM_CLKDIV4_TRACEFRAC_SHIFT)
#define SIM_BRD_CLKDIV4_TRACEFRAC(base) (BITBAND_ACCESS32(&SIM_CLKDIV4_REG(base), SIM_CLKDIV4_TRACEFRAC_SHIFT))

/*! @brief Set the TRACEFRAC field to a new value. */
#define SIM_WR_CLKDIV4_TRACEFRAC(base, value) (SIM_RMW_CLKDIV4(base, SIM_CLKDIV4_TRACEFRAC_MASK, SIM_CLKDIV4_TRACEFRAC(value)))
#define SIM_BWR_CLKDIV4_TRACEFRAC(base, value) (BITBAND_ACCESS32(&SIM_CLKDIV4_REG(base), SIM_CLKDIV4_TRACEFRAC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV4, field TRACEDIV[3:1] (RW)
 *
 * This field sets the divide value for the fractional clock divider used as a
 * source for trace clock. The source clock for the trace clock is set by the
 * SIM_CHIPCTRL[TRACECLK_SEL]. Divider output clock = Divider input clock *
 * [(TRACEFRAC+1)/(TRACEDIV+1)].
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV4_TRACEDIV field. */
#define SIM_RD_CLKDIV4_TRACEDIV(base) ((SIM_CLKDIV4_REG(base) & SIM_CLKDIV4_TRACEDIV_MASK) >> SIM_CLKDIV4_TRACEDIV_SHIFT)
#define SIM_BRD_CLKDIV4_TRACEDIV(base) (SIM_RD_CLKDIV4_TRACEDIV(base))

/*! @brief Set the TRACEDIV field to a new value. */
#define SIM_WR_CLKDIV4_TRACEDIV(base, value) (SIM_RMW_CLKDIV4(base, SIM_CLKDIV4_TRACEDIV_MASK, SIM_CLKDIV4_TRACEDIV(value)))
#define SIM_BWR_CLKDIV4_TRACEDIV(base, value) (SIM_WR_CLKDIV4_TRACEDIV(base, value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV4, field TRACEDIVEN[28] (RW)
 *
 * This bit controls the Debug Trace Divider.
 *
 * Values:
 * - 0b0 - Debug trace divider disabled
 * - 0b1 - Debug trace divider enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV4_TRACEDIVEN field. */
#define SIM_RD_CLKDIV4_TRACEDIVEN(base) ((SIM_CLKDIV4_REG(base) & SIM_CLKDIV4_TRACEDIVEN_MASK) >> SIM_CLKDIV4_TRACEDIVEN_SHIFT)
#define SIM_BRD_CLKDIV4_TRACEDIVEN(base) (BITBAND_ACCESS32(&SIM_CLKDIV4_REG(base), SIM_CLKDIV4_TRACEDIVEN_SHIFT))

/*! @brief Set the TRACEDIVEN field to a new value. */
#define SIM_WR_CLKDIV4_TRACEDIVEN(base, value) (SIM_RMW_CLKDIV4(base, SIM_CLKDIV4_TRACEDIVEN_MASK, SIM_CLKDIV4_TRACEDIVEN(value)))
#define SIM_BWR_CLKDIV4_TRACEDIVEN(base, value) (BITBAND_ACCESS32(&SIM_CLKDIV4_REG(base), SIM_CLKDIV4_TRACEDIVEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_MISCTRL - Miscellaneous Control register
 ******************************************************************************/

/*!
 * @brief SIM_MISCTRL - Miscellaneous Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_MISCTRL register
 */
/*@{*/
#define SIM_RD_MISCTRL(base)     (SIM_MISCTRL_REG(base))
#define SIM_WR_MISCTRL(base, value) (SIM_MISCTRL_REG(base) = (value))
#define SIM_RMW_MISCTRL(base, mask, value) (SIM_WR_MISCTRL(base, (SIM_RD_MISCTRL(base) & ~(mask)) | (value)))
#define SIM_SET_MISCTRL(base, value) (SIM_WR_MISCTRL(base, SIM_RD_MISCTRL(base) |  (value)))
#define SIM_CLR_MISCTRL(base, value) (SIM_WR_MISCTRL(base, SIM_RD_MISCTRL(base) & ~(value)))
#define SIM_TOG_MISCTRL(base, value) (SIM_WR_MISCTRL(base, SIM_RD_MISCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_MISCTRL bitfields
 */

/*!
 * @name Register SIM_MISCTRL, field SW_TRG[0] (RW)
 *
 * ??TBD??
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL_SW_TRG field. */
#define SIM_RD_MISCTRL_SW_TRG(base) ((SIM_MISCTRL_REG(base) & SIM_MISCTRL_SW_TRG_MASK) >> SIM_MISCTRL_SW_TRG_SHIFT)
#define SIM_BRD_MISCTRL_SW_TRG(base) (BITBAND_ACCESS32(&SIM_MISCTRL_REG(base), SIM_MISCTRL_SW_TRG_SHIFT))

/*! @brief Set the SW_TRG field to a new value. */
#define SIM_WR_MISCTRL_SW_TRG(base, value) (SIM_RMW_MISCTRL(base, SIM_MISCTRL_SW_TRG_MASK, SIM_MISCTRL_SW_TRG(value)))
#define SIM_BWR_MISCTRL_SW_TRG(base, value) (BITBAND_ACCESS32(&SIM_MISCTRL_REG(base), SIM_MISCTRL_SW_TRG_SHIFT) = (value))
/*@}*/

/*
 * S32K144 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_VERID - SMC Version ID Register
 * - SMC_PARAM - SMC Parameter Register
 * - SMC_PMPROT - Power Mode Protection register
 * - SMC_PMCTRL - Power Mode Control register
 * - SMC_STOPCTRL - Stop Control Register
 * - SMC_PMSTAT - Power Mode Status register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_VERID - SMC Version ID Register
 ******************************************************************************/

/*!
 * @brief SMC_VERID - SMC Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire SMC_VERID register
 */
/*@{*/
#define SMC_RD_VERID(base)       (SMC_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SMC_VERID bitfields
 */

/*!
 * @name Register SMC_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000000 - Standard features implemented
 */
/*@{*/
/*! @brief Read current value of the SMC_VERID_FEATURE field. */
#define SMC_RD_VERID_FEATURE(base) ((SMC_VERID_REG(base) & SMC_VERID_FEATURE_MASK) >> SMC_VERID_FEATURE_SHIFT)
#define SMC_BRD_VERID_FEATURE(base) (SMC_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register SMC_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the SMC_VERID_MINOR field. */
#define SMC_RD_VERID_MINOR(base) ((SMC_VERID_REG(base) & SMC_VERID_MINOR_MASK) >> SMC_VERID_MINOR_SHIFT)
#define SMC_BRD_VERID_MINOR(base) (SMC_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register SMC_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the SMC_VERID_MAJOR field. */
#define SMC_RD_VERID_MAJOR(base) ((SMC_VERID_REG(base) & SMC_VERID_MAJOR_MASK) >> SMC_VERID_MAJOR_SHIFT)
#define SMC_BRD_VERID_MAJOR(base) (SMC_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * SMC_PARAM - SMC Parameter Register
 ******************************************************************************/

/*!
 * @brief SMC_PARAM - SMC Parameter Register (RO)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire SMC_PARAM register
 */
/*@{*/
#define SMC_RD_PARAM(base)       (SMC_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual SMC_PARAM bitfields
 */

/*!
 * @name Register SMC_PARAM, field EHSRUN[0] (RO)
 *
 * HSRUN mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_EHSRUN field. */
#define SMC_RD_PARAM_EHSRUN(base) ((SMC_PARAM_REG(base) & SMC_PARAM_EHSRUN_MASK) >> SMC_PARAM_EHSRUN_SHIFT)
#define SMC_BRD_PARAM_EHSRUN(base) (BITBAND_ACCESS32(&SMC_PARAM_REG(base), SMC_PARAM_EHSRUN_SHIFT))
/*@}*/

/*!
 * @name Register SMC_PARAM, field ELLS[3] (RO)
 *
 * LLS mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_ELLS field. */
#define SMC_RD_PARAM_ELLS(base) ((SMC_PARAM_REG(base) & SMC_PARAM_ELLS_MASK) >> SMC_PARAM_ELLS_SHIFT)
#define SMC_BRD_PARAM_ELLS(base) (BITBAND_ACCESS32(&SMC_PARAM_REG(base), SMC_PARAM_ELLS_SHIFT))
/*@}*/

/*!
 * @name Register SMC_PARAM, field ELLS2[5] (RO)
 *
 * LLS2 mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_ELLS2 field. */
#define SMC_RD_PARAM_ELLS2(base) ((SMC_PARAM_REG(base) & SMC_PARAM_ELLS2_MASK) >> SMC_PARAM_ELLS2_SHIFT)
#define SMC_BRD_PARAM_ELLS2(base) (BITBAND_ACCESS32(&SMC_PARAM_REG(base), SMC_PARAM_ELLS2_SHIFT))
/*@}*/

/*!
 * @name Register SMC_PARAM, field EVLLS0[6] (RO)
 *
 * VLLS0 mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_EVLLS0 field. */
#define SMC_RD_PARAM_EVLLS0(base) ((SMC_PARAM_REG(base) & SMC_PARAM_EVLLS0_MASK) >> SMC_PARAM_EVLLS0_SHIFT)
#define SMC_BRD_PARAM_EVLLS0(base) (BITBAND_ACCESS32(&SMC_PARAM_REG(base), SMC_PARAM_EVLLS0_SHIFT))
/*@}*/

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) |  (value)))
#define SMC_CLR_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) & ~(value)))
#define SMC_TOG_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0b0 - VLPR, VLPW, and VLPS are not allowed.
 * - 0b1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BITBAND_ACCESS32(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BITBAND_ACCESS32(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AHSRUN[7] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter High Speed Run mode (HSRUN).
 *
 * Values:
 * - 0b0 - HSRUN is not allowed
 * - 0b1 - HSRUN is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AHSRUN field. */
#define SMC_RD_PMPROT_AHSRUN(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AHSRUN_MASK) >> SMC_PMPROT_AHSRUN_SHIFT)
#define SMC_BRD_PMPROT_AHSRUN(base) (BITBAND_ACCESS32(&SMC_PMPROT_REG(base), SMC_PMPROT_AHSRUN_SHIFT))

/*! @brief Set the AHSRUN field to a new value. */
#define SMC_WR_PMPROT_AHSRUN(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AHSRUN_MASK, SMC_PMPROT_AHSRUN(value)))
#define SMC_BWR_PMPROT_AHSRUN(base, value) (BITBAND_ACCESS32(&SMC_PMPROT_REG(base), SMC_PMPROT_AHSRUN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) |  (value)))
#define SMC_CLR_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) & ~(value)))
#define SMC_TOG_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to STOP, the PSTOPO bits in the STOPCTRL
 * register can be used to select a Partial Stop mode if desired.
 *
 * Values:
 * - 0b000 - Normal Stop (STOP)
 * - 0b001 - Reserved
 * - 0b010 - Very-Low-Power Stop (VLPS)
 * - 0b011 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reseved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (SMC_RD_PMCTRL_STOPM(base))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (SMC_WR_PMCTRL_STOPM(base, value))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt occured during the
 * previous stop mode entry sequence, preventing the system from entering that
 * mode. This field is cleared by reset or by hardware at the beginning of any
 * stop mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0b0 - The previous stop mode entry was successsful.
 * - 0b1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BITBAND_ACCESS32(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR. RUNM may be set to
 * HSRUN only when PMSTAT=RUN. After being programmed to HSRUN, RUNM should not
 * be programmed back to RUN until PMSTAT=HSRUN. Also, stop mode entry should not
 * be attempted while RUNM=HSRUN or PMSTAT=HSRUN.
 *
 * Values:
 * - 0b00 - Normal Run mode (RUN)
 * - 0b01 - Reserved
 * - 0b10 - Very-Low-Power Run mode (VLPR)
 * - 0b11 - High Speed Run mode (HSRUN)
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (SMC_RD_PMCTRL_RUNM(base))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (SMC_WR_PMCTRL_RUNM(base, value))
/*@}*/

/*******************************************************************************
 * SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x00000003U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define SMC_RD_STOPCTRL(base)    (SMC_STOPCTRL_REG(base))
#define SMC_WR_STOPCTRL(base, value) (SMC_STOPCTRL_REG(base) = (value))
#define SMC_RMW_STOPCTRL(base, mask, value) (SMC_WR_STOPCTRL(base, (SMC_RD_STOPCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_STOPCTRL(base, value) (SMC_WR_STOPCTRL(base, SMC_RD_STOPCTRL(base) |  (value)))
#define SMC_CLR_STOPCTRL(base, value) (SMC_WR_STOPCTRL(base, SMC_RD_STOPCTRL(base) & ~(value)))
#define SMC_TOG_STOPCTRL(base, value) (SMC_WR_STOPCTRL(base, SMC_RD_STOPCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN mode, the PMC, SCG and flash remain
 * fully powered, allowing the device to wakeup almost instantaneously at the
 * expense of higher power consumption. In PSTOP2, only system clocks are gated
 * allowing peripherals running on bus clock to remain fully functional. In PSTOP1,
 * both system and bus clocks are gated.
 *
 * Values:
 * - 0b00 - STOP - Normal Stop mode
 * - 0b01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 0b10 - PSTOP2 - Partial Stop with system clock disabled and bus clock
 *     enabled
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define SMC_RD_STOPCTRL_PSTOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PSTOPO_MASK) >> SMC_STOPCTRL_PSTOPO_SHIFT)
#define SMC_BRD_STOPCTRL_PSTOPO(base) (SMC_RD_STOPCTRL_PSTOPO(base))

/*! @brief Set the PSTOPO field to a new value. */
#define SMC_WR_STOPCTRL_PSTOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PSTOPO_MASK, SMC_STOPCTRL_PSTOPO(value)))
#define SMC_BWR_STOPCTRL_PSTOPO(base, value) (SMC_WR_STOPCTRL_PSTOPO(base, value))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x00000001U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual SMC_PMSTAT bitfields
 */

/*!
 * @name Register SMC_PMSTAT, field PMSTAT[7:0] (RO)
 *
 * When debug is enabled, the PMSTAT will not update to STOP or VLPS When a
 * PSTOP mode is enabled, the PMSTAT will not update to STOP or VLPS
 */
/*@{*/
/*! @brief Read current value of the SMC_PMSTAT_PMSTAT field. */
#define SMC_RD_PMSTAT_PMSTAT(base) ((SMC_PMSTAT_REG(base) & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT)
#define SMC_BRD_PMSTAT_PMSTAT(base) (SMC_RD_PMSTAT_PMSTAT(base))
/*@}*/

/*
 * S32K144 TRGMUX
 *
 * TRGMUX
 *
 * Registers defined in this header file:
 * - TRGMUX_DMAMUX_CH0 - TRGMUX DMAMUX_CH0 Register
 * - TRGMUX_XB_OUT0_3 - TRGMUX XB_OUT0_3 Register
 * - TRGMUX_XB_OUT4_7 - TRGMUX XB_OUT4_7 Register
 * - TRGMUX_ADC0 - TRGMUX ADC0 Register
 * - TRGMUX_ADC1 - TRGMUX ADC1 Register
 * - TRGMUX_DUMMY5 - TRGMUX DUMMY5 Register
 * - TRGMUX_DUMMY6 - TRGMUX DUMMY6 Register
 * - TRGMUX_CMP0 - TRGMUX CMP0 Register
 * - TRGMUX_DUMMY8 - TRGMUX DUMMY8 Register
 * - TRGMUX_DUMMY9 - TRGMUX DUMMY9 Register
 * - TRGMUX_FTM0 - TRGMUX FTM0 Register
 * - TRGMUX_FTM1 - TRGMUX FTM1 Register
 * - TRGMUX_FTM2 - TRGMUX FTM2 Register
 * - TRGMUX_FTM3 - TRGMUX FTM3 Register
 * - TRGMUX_PDB0 - TRGMUX PDB0 Register
 * - TRGMUX_PDB1 - TRGMUX PDB1 Register
 * - TRGMUX_DUMMY16 - TRGMUX DUMMY16 Register
 * - TRGMUX_FLEXIO - TRGMUX FLEXIO Register
 * - TRGMUX_LPIT - TRGMUX LPIT Register
 * - TRGMUX_LPUART0 - TRGMUX LPUART0 Register
 * - TRGMUX_LPUART1 - TRGMUX LPUART1 Register
 * - TRGMUX_LPI2C0 - TRGMUX LPI2C0 Register
 * - TRGMUX_LPI2C1 - TRGMUX LPI2C1 Register
 * - TRGMUX_LPSPI0 - TRGMUX LPSPI0 Register
 * - TRGMUX_LPSPI1 - TRGMUX LPSPI1 Register
 * - TRGMUX_LPTMR0 - TRGMUX LPTMR0 Register
 */

#define TRGMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the TRGMUX module. */
#define TRGMUX_IDX (0U) /*!< Instance number for TRGMUX. */

/*******************************************************************************
 * TRGMUX_DMAMUX_CH0 - TRGMUX DMAMUX_CH0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_DMAMUX_CH0 - TRGMUX DMAMUX_CH0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_DMAMUX_CH0 register
 */
/*@{*/
#define TRGMUX_RD_DMAMUX_CH0(base) (TRGMUX_DMAMUX_CH0_REG(base))
#define TRGMUX_WR_DMAMUX_CH0(base, value) (TRGMUX_DMAMUX_CH0_REG(base) = (value))
#define TRGMUX_RMW_DMAMUX_CH0(base, mask, value) (TRGMUX_WR_DMAMUX_CH0(base, (TRGMUX_RD_DMAMUX_CH0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_DMAMUX_CH0(base, value) (TRGMUX_WR_DMAMUX_CH0(base, TRGMUX_RD_DMAMUX_CH0(base) |  (value)))
#define TRGMUX_CLR_DMAMUX_CH0(base, value) (TRGMUX_WR_DMAMUX_CH0(base, TRGMUX_RD_DMAMUX_CH0(base) & ~(value)))
#define TRGMUX_TOG_DMAMUX_CH0(base, value) (TRGMUX_WR_DMAMUX_CH0(base, TRGMUX_RD_DMAMUX_CH0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_DMAMUX_CH0 bitfields
 */

/*!
 * @name Register TRGMUX_DMAMUX_CH0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DMAMUX_CH0_SEL0 field. */
#define TRGMUX_RD_DMAMUX_CH0_SEL0(base) ((TRGMUX_DMAMUX_CH0_REG(base) & TRGMUX_DMAMUX_CH0_SEL0_MASK) >> TRGMUX_DMAMUX_CH0_SEL0_SHIFT)
#define TRGMUX_BRD_DMAMUX_CH0_SEL0(base) (TRGMUX_RD_DMAMUX_CH0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_DMAMUX_CH0_SEL0(base, value) (TRGMUX_RMW_DMAMUX_CH0(base, TRGMUX_DMAMUX_CH0_SEL0_MASK, TRGMUX_DMAMUX_CH0_SEL0(value)))
#define TRGMUX_BWR_DMAMUX_CH0_SEL0(base, value) (TRGMUX_WR_DMAMUX_CH0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DMAMUX_CH0, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DMAMUX_CH0_SEL1 field. */
#define TRGMUX_RD_DMAMUX_CH0_SEL1(base) ((TRGMUX_DMAMUX_CH0_REG(base) & TRGMUX_DMAMUX_CH0_SEL1_MASK) >> TRGMUX_DMAMUX_CH0_SEL1_SHIFT)
#define TRGMUX_BRD_DMAMUX_CH0_SEL1(base) (TRGMUX_RD_DMAMUX_CH0_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_DMAMUX_CH0_SEL1(base, value) (TRGMUX_RMW_DMAMUX_CH0(base, TRGMUX_DMAMUX_CH0_SEL1_MASK, TRGMUX_DMAMUX_CH0_SEL1(value)))
#define TRGMUX_BWR_DMAMUX_CH0_SEL1(base, value) (TRGMUX_WR_DMAMUX_CH0_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DMAMUX_CH0, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DMAMUX_CH0_SEL2 field. */
#define TRGMUX_RD_DMAMUX_CH0_SEL2(base) ((TRGMUX_DMAMUX_CH0_REG(base) & TRGMUX_DMAMUX_CH0_SEL2_MASK) >> TRGMUX_DMAMUX_CH0_SEL2_SHIFT)
#define TRGMUX_BRD_DMAMUX_CH0_SEL2(base) (TRGMUX_RD_DMAMUX_CH0_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_DMAMUX_CH0_SEL2(base, value) (TRGMUX_RMW_DMAMUX_CH0(base, TRGMUX_DMAMUX_CH0_SEL2_MASK, TRGMUX_DMAMUX_CH0_SEL2(value)))
#define TRGMUX_BWR_DMAMUX_CH0_SEL2(base, value) (TRGMUX_WR_DMAMUX_CH0_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DMAMUX_CH0, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DMAMUX_CH0_SEL3 field. */
#define TRGMUX_RD_DMAMUX_CH0_SEL3(base) ((TRGMUX_DMAMUX_CH0_REG(base) & TRGMUX_DMAMUX_CH0_SEL3_MASK) >> TRGMUX_DMAMUX_CH0_SEL3_SHIFT)
#define TRGMUX_BRD_DMAMUX_CH0_SEL3(base) (TRGMUX_RD_DMAMUX_CH0_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_DMAMUX_CH0_SEL3(base, value) (TRGMUX_RMW_DMAMUX_CH0(base, TRGMUX_DMAMUX_CH0_SEL3_MASK, TRGMUX_DMAMUX_CH0_SEL3(value)))
#define TRGMUX_BWR_DMAMUX_CH0_SEL3(base, value) (TRGMUX_WR_DMAMUX_CH0_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DMAMUX_CH0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DMAMUX_CH0_LK field. */
#define TRGMUX_RD_DMAMUX_CH0_LK(base) ((TRGMUX_DMAMUX_CH0_REG(base) & TRGMUX_DMAMUX_CH0_LK_MASK) >> TRGMUX_DMAMUX_CH0_LK_SHIFT)
#define TRGMUX_BRD_DMAMUX_CH0_LK(base) (BITBAND_ACCESS32(&TRGMUX_DMAMUX_CH0_REG(base), TRGMUX_DMAMUX_CH0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_XB_OUT0_3 - TRGMUX XB_OUT0_3 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_XB_OUT0_3 - TRGMUX XB_OUT0_3 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_XB_OUT0_3 register
 */
/*@{*/
#define TRGMUX_RD_XB_OUT0_3(base) (TRGMUX_XB_OUT0_3_REG(base))
#define TRGMUX_WR_XB_OUT0_3(base, value) (TRGMUX_XB_OUT0_3_REG(base) = (value))
#define TRGMUX_RMW_XB_OUT0_3(base, mask, value) (TRGMUX_WR_XB_OUT0_3(base, (TRGMUX_RD_XB_OUT0_3(base) & ~(mask)) | (value)))
#define TRGMUX_SET_XB_OUT0_3(base, value) (TRGMUX_WR_XB_OUT0_3(base, TRGMUX_RD_XB_OUT0_3(base) |  (value)))
#define TRGMUX_CLR_XB_OUT0_3(base, value) (TRGMUX_WR_XB_OUT0_3(base, TRGMUX_RD_XB_OUT0_3(base) & ~(value)))
#define TRGMUX_TOG_XB_OUT0_3(base, value) (TRGMUX_WR_XB_OUT0_3(base, TRGMUX_RD_XB_OUT0_3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_XB_OUT0_3 bitfields
 */

/*!
 * @name Register TRGMUX_XB_OUT0_3, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT0_3_SEL0 field. */
#define TRGMUX_RD_XB_OUT0_3_SEL0(base) ((TRGMUX_XB_OUT0_3_REG(base) & TRGMUX_XB_OUT0_3_SEL0_MASK) >> TRGMUX_XB_OUT0_3_SEL0_SHIFT)
#define TRGMUX_BRD_XB_OUT0_3_SEL0(base) (TRGMUX_RD_XB_OUT0_3_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_XB_OUT0_3_SEL0(base, value) (TRGMUX_RMW_XB_OUT0_3(base, TRGMUX_XB_OUT0_3_SEL0_MASK, TRGMUX_XB_OUT0_3_SEL0(value)))
#define TRGMUX_BWR_XB_OUT0_3_SEL0(base, value) (TRGMUX_WR_XB_OUT0_3_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT0_3, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT0_3_SEL1 field. */
#define TRGMUX_RD_XB_OUT0_3_SEL1(base) ((TRGMUX_XB_OUT0_3_REG(base) & TRGMUX_XB_OUT0_3_SEL1_MASK) >> TRGMUX_XB_OUT0_3_SEL1_SHIFT)
#define TRGMUX_BRD_XB_OUT0_3_SEL1(base) (TRGMUX_RD_XB_OUT0_3_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_XB_OUT0_3_SEL1(base, value) (TRGMUX_RMW_XB_OUT0_3(base, TRGMUX_XB_OUT0_3_SEL1_MASK, TRGMUX_XB_OUT0_3_SEL1(value)))
#define TRGMUX_BWR_XB_OUT0_3_SEL1(base, value) (TRGMUX_WR_XB_OUT0_3_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT0_3, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT0_3_SEL2 field. */
#define TRGMUX_RD_XB_OUT0_3_SEL2(base) ((TRGMUX_XB_OUT0_3_REG(base) & TRGMUX_XB_OUT0_3_SEL2_MASK) >> TRGMUX_XB_OUT0_3_SEL2_SHIFT)
#define TRGMUX_BRD_XB_OUT0_3_SEL2(base) (TRGMUX_RD_XB_OUT0_3_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_XB_OUT0_3_SEL2(base, value) (TRGMUX_RMW_XB_OUT0_3(base, TRGMUX_XB_OUT0_3_SEL2_MASK, TRGMUX_XB_OUT0_3_SEL2(value)))
#define TRGMUX_BWR_XB_OUT0_3_SEL2(base, value) (TRGMUX_WR_XB_OUT0_3_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT0_3, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT0_3_SEL3 field. */
#define TRGMUX_RD_XB_OUT0_3_SEL3(base) ((TRGMUX_XB_OUT0_3_REG(base) & TRGMUX_XB_OUT0_3_SEL3_MASK) >> TRGMUX_XB_OUT0_3_SEL3_SHIFT)
#define TRGMUX_BRD_XB_OUT0_3_SEL3(base) (TRGMUX_RD_XB_OUT0_3_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_XB_OUT0_3_SEL3(base, value) (TRGMUX_RMW_XB_OUT0_3(base, TRGMUX_XB_OUT0_3_SEL3_MASK, TRGMUX_XB_OUT0_3_SEL3(value)))
#define TRGMUX_BWR_XB_OUT0_3_SEL3(base, value) (TRGMUX_WR_XB_OUT0_3_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT0_3, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT0_3_LK field. */
#define TRGMUX_RD_XB_OUT0_3_LK(base) ((TRGMUX_XB_OUT0_3_REG(base) & TRGMUX_XB_OUT0_3_LK_MASK) >> TRGMUX_XB_OUT0_3_LK_SHIFT)
#define TRGMUX_BRD_XB_OUT0_3_LK(base) (BITBAND_ACCESS32(&TRGMUX_XB_OUT0_3_REG(base), TRGMUX_XB_OUT0_3_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_XB_OUT4_7 - TRGMUX XB_OUT4_7 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_XB_OUT4_7 - TRGMUX XB_OUT4_7 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_XB_OUT4_7 register
 */
/*@{*/
#define TRGMUX_RD_XB_OUT4_7(base) (TRGMUX_XB_OUT4_7_REG(base))
#define TRGMUX_WR_XB_OUT4_7(base, value) (TRGMUX_XB_OUT4_7_REG(base) = (value))
#define TRGMUX_RMW_XB_OUT4_7(base, mask, value) (TRGMUX_WR_XB_OUT4_7(base, (TRGMUX_RD_XB_OUT4_7(base) & ~(mask)) | (value)))
#define TRGMUX_SET_XB_OUT4_7(base, value) (TRGMUX_WR_XB_OUT4_7(base, TRGMUX_RD_XB_OUT4_7(base) |  (value)))
#define TRGMUX_CLR_XB_OUT4_7(base, value) (TRGMUX_WR_XB_OUT4_7(base, TRGMUX_RD_XB_OUT4_7(base) & ~(value)))
#define TRGMUX_TOG_XB_OUT4_7(base, value) (TRGMUX_WR_XB_OUT4_7(base, TRGMUX_RD_XB_OUT4_7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_XB_OUT4_7 bitfields
 */

/*!
 * @name Register TRGMUX_XB_OUT4_7, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT4_7_SEL0 field. */
#define TRGMUX_RD_XB_OUT4_7_SEL0(base) ((TRGMUX_XB_OUT4_7_REG(base) & TRGMUX_XB_OUT4_7_SEL0_MASK) >> TRGMUX_XB_OUT4_7_SEL0_SHIFT)
#define TRGMUX_BRD_XB_OUT4_7_SEL0(base) (TRGMUX_RD_XB_OUT4_7_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_XB_OUT4_7_SEL0(base, value) (TRGMUX_RMW_XB_OUT4_7(base, TRGMUX_XB_OUT4_7_SEL0_MASK, TRGMUX_XB_OUT4_7_SEL0(value)))
#define TRGMUX_BWR_XB_OUT4_7_SEL0(base, value) (TRGMUX_WR_XB_OUT4_7_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT4_7, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT4_7_SEL1 field. */
#define TRGMUX_RD_XB_OUT4_7_SEL1(base) ((TRGMUX_XB_OUT4_7_REG(base) & TRGMUX_XB_OUT4_7_SEL1_MASK) >> TRGMUX_XB_OUT4_7_SEL1_SHIFT)
#define TRGMUX_BRD_XB_OUT4_7_SEL1(base) (TRGMUX_RD_XB_OUT4_7_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_XB_OUT4_7_SEL1(base, value) (TRGMUX_RMW_XB_OUT4_7(base, TRGMUX_XB_OUT4_7_SEL1_MASK, TRGMUX_XB_OUT4_7_SEL1(value)))
#define TRGMUX_BWR_XB_OUT4_7_SEL1(base, value) (TRGMUX_WR_XB_OUT4_7_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT4_7, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT4_7_SEL2 field. */
#define TRGMUX_RD_XB_OUT4_7_SEL2(base) ((TRGMUX_XB_OUT4_7_REG(base) & TRGMUX_XB_OUT4_7_SEL2_MASK) >> TRGMUX_XB_OUT4_7_SEL2_SHIFT)
#define TRGMUX_BRD_XB_OUT4_7_SEL2(base) (TRGMUX_RD_XB_OUT4_7_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_XB_OUT4_7_SEL2(base, value) (TRGMUX_RMW_XB_OUT4_7(base, TRGMUX_XB_OUT4_7_SEL2_MASK, TRGMUX_XB_OUT4_7_SEL2(value)))
#define TRGMUX_BWR_XB_OUT4_7_SEL2(base, value) (TRGMUX_WR_XB_OUT4_7_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT4_7, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT4_7_SEL3 field. */
#define TRGMUX_RD_XB_OUT4_7_SEL3(base) ((TRGMUX_XB_OUT4_7_REG(base) & TRGMUX_XB_OUT4_7_SEL3_MASK) >> TRGMUX_XB_OUT4_7_SEL3_SHIFT)
#define TRGMUX_BRD_XB_OUT4_7_SEL3(base) (TRGMUX_RD_XB_OUT4_7_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_XB_OUT4_7_SEL3(base, value) (TRGMUX_RMW_XB_OUT4_7(base, TRGMUX_XB_OUT4_7_SEL3_MASK, TRGMUX_XB_OUT4_7_SEL3(value)))
#define TRGMUX_BWR_XB_OUT4_7_SEL3(base, value) (TRGMUX_WR_XB_OUT4_7_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_XB_OUT4_7, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_XB_OUT4_7_LK field. */
#define TRGMUX_RD_XB_OUT4_7_LK(base) ((TRGMUX_XB_OUT4_7_REG(base) & TRGMUX_XB_OUT4_7_LK_MASK) >> TRGMUX_XB_OUT4_7_LK_SHIFT)
#define TRGMUX_BRD_XB_OUT4_7_LK(base) (BITBAND_ACCESS32(&TRGMUX_XB_OUT4_7_REG(base), TRGMUX_XB_OUT4_7_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_ADC0 - TRGMUX ADC0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_ADC0 - TRGMUX ADC0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_ADC0 register
 */
/*@{*/
#define TRGMUX_RD_ADC0(base)     (TRGMUX_ADC0_REG(base))
#define TRGMUX_WR_ADC0(base, value) (TRGMUX_ADC0_REG(base) = (value))
#define TRGMUX_RMW_ADC0(base, mask, value) (TRGMUX_WR_ADC0(base, (TRGMUX_RD_ADC0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_ADC0(base, value) (TRGMUX_WR_ADC0(base, TRGMUX_RD_ADC0(base) |  (value)))
#define TRGMUX_CLR_ADC0(base, value) (TRGMUX_WR_ADC0(base, TRGMUX_RD_ADC0(base) & ~(value)))
#define TRGMUX_TOG_ADC0(base, value) (TRGMUX_WR_ADC0(base, TRGMUX_RD_ADC0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_ADC0 bitfields
 */

/*!
 * @name Register TRGMUX_ADC0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC0_SEL0 field. */
#define TRGMUX_RD_ADC0_SEL0(base) ((TRGMUX_ADC0_REG(base) & TRGMUX_ADC0_SEL0_MASK) >> TRGMUX_ADC0_SEL0_SHIFT)
#define TRGMUX_BRD_ADC0_SEL0(base) (TRGMUX_RD_ADC0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_ADC0_SEL0(base, value) (TRGMUX_RMW_ADC0(base, TRGMUX_ADC0_SEL0_MASK, TRGMUX_ADC0_SEL0(value)))
#define TRGMUX_BWR_ADC0_SEL0(base, value) (TRGMUX_WR_ADC0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC0, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC0_SEL1 field. */
#define TRGMUX_RD_ADC0_SEL1(base) ((TRGMUX_ADC0_REG(base) & TRGMUX_ADC0_SEL1_MASK) >> TRGMUX_ADC0_SEL1_SHIFT)
#define TRGMUX_BRD_ADC0_SEL1(base) (TRGMUX_RD_ADC0_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_ADC0_SEL1(base, value) (TRGMUX_RMW_ADC0(base, TRGMUX_ADC0_SEL1_MASK, TRGMUX_ADC0_SEL1(value)))
#define TRGMUX_BWR_ADC0_SEL1(base, value) (TRGMUX_WR_ADC0_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC0, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC0_SEL2 field. */
#define TRGMUX_RD_ADC0_SEL2(base) ((TRGMUX_ADC0_REG(base) & TRGMUX_ADC0_SEL2_MASK) >> TRGMUX_ADC0_SEL2_SHIFT)
#define TRGMUX_BRD_ADC0_SEL2(base) (TRGMUX_RD_ADC0_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_ADC0_SEL2(base, value) (TRGMUX_RMW_ADC0(base, TRGMUX_ADC0_SEL2_MASK, TRGMUX_ADC0_SEL2(value)))
#define TRGMUX_BWR_ADC0_SEL2(base, value) (TRGMUX_WR_ADC0_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC0, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC0_SEL3 field. */
#define TRGMUX_RD_ADC0_SEL3(base) ((TRGMUX_ADC0_REG(base) & TRGMUX_ADC0_SEL3_MASK) >> TRGMUX_ADC0_SEL3_SHIFT)
#define TRGMUX_BRD_ADC0_SEL3(base) (TRGMUX_RD_ADC0_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_ADC0_SEL3(base, value) (TRGMUX_RMW_ADC0(base, TRGMUX_ADC0_SEL3_MASK, TRGMUX_ADC0_SEL3(value)))
#define TRGMUX_BWR_ADC0_SEL3(base, value) (TRGMUX_WR_ADC0_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC0_LK field. */
#define TRGMUX_RD_ADC0_LK(base) ((TRGMUX_ADC0_REG(base) & TRGMUX_ADC0_LK_MASK) >> TRGMUX_ADC0_LK_SHIFT)
#define TRGMUX_BRD_ADC0_LK(base) (BITBAND_ACCESS32(&TRGMUX_ADC0_REG(base), TRGMUX_ADC0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_ADC1 - TRGMUX ADC1 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_ADC1 - TRGMUX ADC1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_ADC1 register
 */
/*@{*/
#define TRGMUX_RD_ADC1(base)     (TRGMUX_ADC1_REG(base))
#define TRGMUX_WR_ADC1(base, value) (TRGMUX_ADC1_REG(base) = (value))
#define TRGMUX_RMW_ADC1(base, mask, value) (TRGMUX_WR_ADC1(base, (TRGMUX_RD_ADC1(base) & ~(mask)) | (value)))
#define TRGMUX_SET_ADC1(base, value) (TRGMUX_WR_ADC1(base, TRGMUX_RD_ADC1(base) |  (value)))
#define TRGMUX_CLR_ADC1(base, value) (TRGMUX_WR_ADC1(base, TRGMUX_RD_ADC1(base) & ~(value)))
#define TRGMUX_TOG_ADC1(base, value) (TRGMUX_WR_ADC1(base, TRGMUX_RD_ADC1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_ADC1 bitfields
 */

/*!
 * @name Register TRGMUX_ADC1, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC1_SEL0 field. */
#define TRGMUX_RD_ADC1_SEL0(base) ((TRGMUX_ADC1_REG(base) & TRGMUX_ADC1_SEL0_MASK) >> TRGMUX_ADC1_SEL0_SHIFT)
#define TRGMUX_BRD_ADC1_SEL0(base) (TRGMUX_RD_ADC1_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_ADC1_SEL0(base, value) (TRGMUX_RMW_ADC1(base, TRGMUX_ADC1_SEL0_MASK, TRGMUX_ADC1_SEL0(value)))
#define TRGMUX_BWR_ADC1_SEL0(base, value) (TRGMUX_WR_ADC1_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC1, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC1_SEL1 field. */
#define TRGMUX_RD_ADC1_SEL1(base) ((TRGMUX_ADC1_REG(base) & TRGMUX_ADC1_SEL1_MASK) >> TRGMUX_ADC1_SEL1_SHIFT)
#define TRGMUX_BRD_ADC1_SEL1(base) (TRGMUX_RD_ADC1_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_ADC1_SEL1(base, value) (TRGMUX_RMW_ADC1(base, TRGMUX_ADC1_SEL1_MASK, TRGMUX_ADC1_SEL1(value)))
#define TRGMUX_BWR_ADC1_SEL1(base, value) (TRGMUX_WR_ADC1_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC1, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC1_SEL2 field. */
#define TRGMUX_RD_ADC1_SEL2(base) ((TRGMUX_ADC1_REG(base) & TRGMUX_ADC1_SEL2_MASK) >> TRGMUX_ADC1_SEL2_SHIFT)
#define TRGMUX_BRD_ADC1_SEL2(base) (TRGMUX_RD_ADC1_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_ADC1_SEL2(base, value) (TRGMUX_RMW_ADC1(base, TRGMUX_ADC1_SEL2_MASK, TRGMUX_ADC1_SEL2(value)))
#define TRGMUX_BWR_ADC1_SEL2(base, value) (TRGMUX_WR_ADC1_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC1, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC1_SEL3 field. */
#define TRGMUX_RD_ADC1_SEL3(base) ((TRGMUX_ADC1_REG(base) & TRGMUX_ADC1_SEL3_MASK) >> TRGMUX_ADC1_SEL3_SHIFT)
#define TRGMUX_BRD_ADC1_SEL3(base) (TRGMUX_RD_ADC1_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_ADC1_SEL3(base, value) (TRGMUX_RMW_ADC1(base, TRGMUX_ADC1_SEL3_MASK, TRGMUX_ADC1_SEL3(value)))
#define TRGMUX_BWR_ADC1_SEL3(base, value) (TRGMUX_WR_ADC1_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_ADC1, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_ADC1_LK field. */
#define TRGMUX_RD_ADC1_LK(base) ((TRGMUX_ADC1_REG(base) & TRGMUX_ADC1_LK_MASK) >> TRGMUX_ADC1_LK_SHIFT)
#define TRGMUX_BRD_ADC1_LK(base) (BITBAND_ACCESS32(&TRGMUX_ADC1_REG(base), TRGMUX_ADC1_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_DUMMY5 - TRGMUX DUMMY5 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_DUMMY5 - TRGMUX DUMMY5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_DUMMY5 register
 */
/*@{*/
#define TRGMUX_RD_DUMMY5(base)   (TRGMUX_DUMMY5_REG(base))
#define TRGMUX_WR_DUMMY5(base, value) (TRGMUX_DUMMY5_REG(base) = (value))
#define TRGMUX_RMW_DUMMY5(base, mask, value) (TRGMUX_WR_DUMMY5(base, (TRGMUX_RD_DUMMY5(base) & ~(mask)) | (value)))
#define TRGMUX_SET_DUMMY5(base, value) (TRGMUX_WR_DUMMY5(base, TRGMUX_RD_DUMMY5(base) |  (value)))
#define TRGMUX_CLR_DUMMY5(base, value) (TRGMUX_WR_DUMMY5(base, TRGMUX_RD_DUMMY5(base) & ~(value)))
#define TRGMUX_TOG_DUMMY5(base, value) (TRGMUX_WR_DUMMY5(base, TRGMUX_RD_DUMMY5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_DUMMY5 bitfields
 */

/*!
 * @name Register TRGMUX_DUMMY5, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY5_SEL0 field. */
#define TRGMUX_RD_DUMMY5_SEL0(base) ((TRGMUX_DUMMY5_REG(base) & TRGMUX_DUMMY5_SEL0_MASK) >> TRGMUX_DUMMY5_SEL0_SHIFT)
#define TRGMUX_BRD_DUMMY5_SEL0(base) (TRGMUX_RD_DUMMY5_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_DUMMY5_SEL0(base, value) (TRGMUX_RMW_DUMMY5(base, TRGMUX_DUMMY5_SEL0_MASK, TRGMUX_DUMMY5_SEL0(value)))
#define TRGMUX_BWR_DUMMY5_SEL0(base, value) (TRGMUX_WR_DUMMY5_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY5, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY5_SEL1 field. */
#define TRGMUX_RD_DUMMY5_SEL1(base) ((TRGMUX_DUMMY5_REG(base) & TRGMUX_DUMMY5_SEL1_MASK) >> TRGMUX_DUMMY5_SEL1_SHIFT)
#define TRGMUX_BRD_DUMMY5_SEL1(base) (TRGMUX_RD_DUMMY5_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_DUMMY5_SEL1(base, value) (TRGMUX_RMW_DUMMY5(base, TRGMUX_DUMMY5_SEL1_MASK, TRGMUX_DUMMY5_SEL1(value)))
#define TRGMUX_BWR_DUMMY5_SEL1(base, value) (TRGMUX_WR_DUMMY5_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY5, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY5_SEL2 field. */
#define TRGMUX_RD_DUMMY5_SEL2(base) ((TRGMUX_DUMMY5_REG(base) & TRGMUX_DUMMY5_SEL2_MASK) >> TRGMUX_DUMMY5_SEL2_SHIFT)
#define TRGMUX_BRD_DUMMY5_SEL2(base) (TRGMUX_RD_DUMMY5_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_DUMMY5_SEL2(base, value) (TRGMUX_RMW_DUMMY5(base, TRGMUX_DUMMY5_SEL2_MASK, TRGMUX_DUMMY5_SEL2(value)))
#define TRGMUX_BWR_DUMMY5_SEL2(base, value) (TRGMUX_WR_DUMMY5_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY5, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY5_SEL3 field. */
#define TRGMUX_RD_DUMMY5_SEL3(base) ((TRGMUX_DUMMY5_REG(base) & TRGMUX_DUMMY5_SEL3_MASK) >> TRGMUX_DUMMY5_SEL3_SHIFT)
#define TRGMUX_BRD_DUMMY5_SEL3(base) (TRGMUX_RD_DUMMY5_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_DUMMY5_SEL3(base, value) (TRGMUX_RMW_DUMMY5(base, TRGMUX_DUMMY5_SEL3_MASK, TRGMUX_DUMMY5_SEL3(value)))
#define TRGMUX_BWR_DUMMY5_SEL3(base, value) (TRGMUX_WR_DUMMY5_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY5, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY5_LK field. */
#define TRGMUX_RD_DUMMY5_LK(base) ((TRGMUX_DUMMY5_REG(base) & TRGMUX_DUMMY5_LK_MASK) >> TRGMUX_DUMMY5_LK_SHIFT)
#define TRGMUX_BRD_DUMMY5_LK(base) (BITBAND_ACCESS32(&TRGMUX_DUMMY5_REG(base), TRGMUX_DUMMY5_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_DUMMY6 - TRGMUX DUMMY6 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_DUMMY6 - TRGMUX DUMMY6 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_DUMMY6 register
 */
/*@{*/
#define TRGMUX_RD_DUMMY6(base)   (TRGMUX_DUMMY6_REG(base))
#define TRGMUX_WR_DUMMY6(base, value) (TRGMUX_DUMMY6_REG(base) = (value))
#define TRGMUX_RMW_DUMMY6(base, mask, value) (TRGMUX_WR_DUMMY6(base, (TRGMUX_RD_DUMMY6(base) & ~(mask)) | (value)))
#define TRGMUX_SET_DUMMY6(base, value) (TRGMUX_WR_DUMMY6(base, TRGMUX_RD_DUMMY6(base) |  (value)))
#define TRGMUX_CLR_DUMMY6(base, value) (TRGMUX_WR_DUMMY6(base, TRGMUX_RD_DUMMY6(base) & ~(value)))
#define TRGMUX_TOG_DUMMY6(base, value) (TRGMUX_WR_DUMMY6(base, TRGMUX_RD_DUMMY6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_DUMMY6 bitfields
 */

/*!
 * @name Register TRGMUX_DUMMY6, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY6_SEL0 field. */
#define TRGMUX_RD_DUMMY6_SEL0(base) ((TRGMUX_DUMMY6_REG(base) & TRGMUX_DUMMY6_SEL0_MASK) >> TRGMUX_DUMMY6_SEL0_SHIFT)
#define TRGMUX_BRD_DUMMY6_SEL0(base) (TRGMUX_RD_DUMMY6_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_DUMMY6_SEL0(base, value) (TRGMUX_RMW_DUMMY6(base, TRGMUX_DUMMY6_SEL0_MASK, TRGMUX_DUMMY6_SEL0(value)))
#define TRGMUX_BWR_DUMMY6_SEL0(base, value) (TRGMUX_WR_DUMMY6_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY6, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY6_LK field. */
#define TRGMUX_RD_DUMMY6_LK(base) ((TRGMUX_DUMMY6_REG(base) & TRGMUX_DUMMY6_LK_MASK) >> TRGMUX_DUMMY6_LK_SHIFT)
#define TRGMUX_BRD_DUMMY6_LK(base) (BITBAND_ACCESS32(&TRGMUX_DUMMY6_REG(base), TRGMUX_DUMMY6_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_CMP0 - TRGMUX CMP0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_CMP0 - TRGMUX CMP0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_CMP0 register
 */
/*@{*/
#define TRGMUX_RD_CMP0(base)     (TRGMUX_CMP0_REG(base))
#define TRGMUX_WR_CMP0(base, value) (TRGMUX_CMP0_REG(base) = (value))
#define TRGMUX_RMW_CMP0(base, mask, value) (TRGMUX_WR_CMP0(base, (TRGMUX_RD_CMP0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_CMP0(base, value) (TRGMUX_WR_CMP0(base, TRGMUX_RD_CMP0(base) |  (value)))
#define TRGMUX_CLR_CMP0(base, value) (TRGMUX_WR_CMP0(base, TRGMUX_RD_CMP0(base) & ~(value)))
#define TRGMUX_TOG_CMP0(base, value) (TRGMUX_WR_CMP0(base, TRGMUX_RD_CMP0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_CMP0 bitfields
 */

/*!
 * @name Register TRGMUX_CMP0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_CMP0_SEL0 field. */
#define TRGMUX_RD_CMP0_SEL0(base) ((TRGMUX_CMP0_REG(base) & TRGMUX_CMP0_SEL0_MASK) >> TRGMUX_CMP0_SEL0_SHIFT)
#define TRGMUX_BRD_CMP0_SEL0(base) (TRGMUX_RD_CMP0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_CMP0_SEL0(base, value) (TRGMUX_RMW_CMP0(base, TRGMUX_CMP0_SEL0_MASK, TRGMUX_CMP0_SEL0(value)))
#define TRGMUX_BWR_CMP0_SEL0(base, value) (TRGMUX_WR_CMP0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_CMP0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_CMP0_LK field. */
#define TRGMUX_RD_CMP0_LK(base) ((TRGMUX_CMP0_REG(base) & TRGMUX_CMP0_LK_MASK) >> TRGMUX_CMP0_LK_SHIFT)
#define TRGMUX_BRD_CMP0_LK(base) (BITBAND_ACCESS32(&TRGMUX_CMP0_REG(base), TRGMUX_CMP0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_DUMMY8 - TRGMUX DUMMY8 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_DUMMY8 - TRGMUX DUMMY8 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_DUMMY8 register
 */
/*@{*/
#define TRGMUX_RD_DUMMY8(base)   (TRGMUX_DUMMY8_REG(base))
#define TRGMUX_WR_DUMMY8(base, value) (TRGMUX_DUMMY8_REG(base) = (value))
#define TRGMUX_RMW_DUMMY8(base, mask, value) (TRGMUX_WR_DUMMY8(base, (TRGMUX_RD_DUMMY8(base) & ~(mask)) | (value)))
#define TRGMUX_SET_DUMMY8(base, value) (TRGMUX_WR_DUMMY8(base, TRGMUX_RD_DUMMY8(base) |  (value)))
#define TRGMUX_CLR_DUMMY8(base, value) (TRGMUX_WR_DUMMY8(base, TRGMUX_RD_DUMMY8(base) & ~(value)))
#define TRGMUX_TOG_DUMMY8(base, value) (TRGMUX_WR_DUMMY8(base, TRGMUX_RD_DUMMY8(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_DUMMY8 bitfields
 */

/*!
 * @name Register TRGMUX_DUMMY8, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY8_SEL0 field. */
#define TRGMUX_RD_DUMMY8_SEL0(base) ((TRGMUX_DUMMY8_REG(base) & TRGMUX_DUMMY8_SEL0_MASK) >> TRGMUX_DUMMY8_SEL0_SHIFT)
#define TRGMUX_BRD_DUMMY8_SEL0(base) (TRGMUX_RD_DUMMY8_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_DUMMY8_SEL0(base, value) (TRGMUX_RMW_DUMMY8(base, TRGMUX_DUMMY8_SEL0_MASK, TRGMUX_DUMMY8_SEL0(value)))
#define TRGMUX_BWR_DUMMY8_SEL0(base, value) (TRGMUX_WR_DUMMY8_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY8, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY8_LK field. */
#define TRGMUX_RD_DUMMY8_LK(base) ((TRGMUX_DUMMY8_REG(base) & TRGMUX_DUMMY8_LK_MASK) >> TRGMUX_DUMMY8_LK_SHIFT)
#define TRGMUX_BRD_DUMMY8_LK(base) (BITBAND_ACCESS32(&TRGMUX_DUMMY8_REG(base), TRGMUX_DUMMY8_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_DUMMY9 - TRGMUX DUMMY9 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_DUMMY9 - TRGMUX DUMMY9 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_DUMMY9 register
 */
/*@{*/
#define TRGMUX_RD_DUMMY9(base)   (TRGMUX_DUMMY9_REG(base))
#define TRGMUX_WR_DUMMY9(base, value) (TRGMUX_DUMMY9_REG(base) = (value))
#define TRGMUX_RMW_DUMMY9(base, mask, value) (TRGMUX_WR_DUMMY9(base, (TRGMUX_RD_DUMMY9(base) & ~(mask)) | (value)))
#define TRGMUX_SET_DUMMY9(base, value) (TRGMUX_WR_DUMMY9(base, TRGMUX_RD_DUMMY9(base) |  (value)))
#define TRGMUX_CLR_DUMMY9(base, value) (TRGMUX_WR_DUMMY9(base, TRGMUX_RD_DUMMY9(base) & ~(value)))
#define TRGMUX_TOG_DUMMY9(base, value) (TRGMUX_WR_DUMMY9(base, TRGMUX_RD_DUMMY9(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_DUMMY9 bitfields
 */

/*!
 * @name Register TRGMUX_DUMMY9, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY9_SEL0 field. */
#define TRGMUX_RD_DUMMY9_SEL0(base) ((TRGMUX_DUMMY9_REG(base) & TRGMUX_DUMMY9_SEL0_MASK) >> TRGMUX_DUMMY9_SEL0_SHIFT)
#define TRGMUX_BRD_DUMMY9_SEL0(base) (TRGMUX_RD_DUMMY9_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_DUMMY9_SEL0(base, value) (TRGMUX_RMW_DUMMY9(base, TRGMUX_DUMMY9_SEL0_MASK, TRGMUX_DUMMY9_SEL0(value)))
#define TRGMUX_BWR_DUMMY9_SEL0(base, value) (TRGMUX_WR_DUMMY9_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY9, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY9_LK field. */
#define TRGMUX_RD_DUMMY9_LK(base) ((TRGMUX_DUMMY9_REG(base) & TRGMUX_DUMMY9_LK_MASK) >> TRGMUX_DUMMY9_LK_SHIFT)
#define TRGMUX_BRD_DUMMY9_LK(base) (BITBAND_ACCESS32(&TRGMUX_DUMMY9_REG(base), TRGMUX_DUMMY9_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_FTM0 - TRGMUX FTM0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_FTM0 - TRGMUX FTM0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_FTM0 register
 */
/*@{*/
#define TRGMUX_RD_FTM0(base)     (TRGMUX_FTM0_REG(base))
#define TRGMUX_WR_FTM0(base, value) (TRGMUX_FTM0_REG(base) = (value))
#define TRGMUX_RMW_FTM0(base, mask, value) (TRGMUX_WR_FTM0(base, (TRGMUX_RD_FTM0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_FTM0(base, value) (TRGMUX_WR_FTM0(base, TRGMUX_RD_FTM0(base) |  (value)))
#define TRGMUX_CLR_FTM0(base, value) (TRGMUX_WR_FTM0(base, TRGMUX_RD_FTM0(base) & ~(value)))
#define TRGMUX_TOG_FTM0(base, value) (TRGMUX_WR_FTM0(base, TRGMUX_RD_FTM0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_FTM0 bitfields
 */

/*!
 * @name Register TRGMUX_FTM0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM0_SEL0 field. */
#define TRGMUX_RD_FTM0_SEL0(base) ((TRGMUX_FTM0_REG(base) & TRGMUX_FTM0_SEL0_MASK) >> TRGMUX_FTM0_SEL0_SHIFT)
#define TRGMUX_BRD_FTM0_SEL0(base) (TRGMUX_RD_FTM0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_FTM0_SEL0(base, value) (TRGMUX_RMW_FTM0(base, TRGMUX_FTM0_SEL0_MASK, TRGMUX_FTM0_SEL0(value)))
#define TRGMUX_BWR_FTM0_SEL0(base, value) (TRGMUX_WR_FTM0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM0, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM0_SEL1 field. */
#define TRGMUX_RD_FTM0_SEL1(base) ((TRGMUX_FTM0_REG(base) & TRGMUX_FTM0_SEL1_MASK) >> TRGMUX_FTM0_SEL1_SHIFT)
#define TRGMUX_BRD_FTM0_SEL1(base) (TRGMUX_RD_FTM0_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_FTM0_SEL1(base, value) (TRGMUX_RMW_FTM0(base, TRGMUX_FTM0_SEL1_MASK, TRGMUX_FTM0_SEL1(value)))
#define TRGMUX_BWR_FTM0_SEL1(base, value) (TRGMUX_WR_FTM0_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM0, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM0_SEL2 field. */
#define TRGMUX_RD_FTM0_SEL2(base) ((TRGMUX_FTM0_REG(base) & TRGMUX_FTM0_SEL2_MASK) >> TRGMUX_FTM0_SEL2_SHIFT)
#define TRGMUX_BRD_FTM0_SEL2(base) (TRGMUX_RD_FTM0_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_FTM0_SEL2(base, value) (TRGMUX_RMW_FTM0(base, TRGMUX_FTM0_SEL2_MASK, TRGMUX_FTM0_SEL2(value)))
#define TRGMUX_BWR_FTM0_SEL2(base, value) (TRGMUX_WR_FTM0_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM0, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM0_SEL3 field. */
#define TRGMUX_RD_FTM0_SEL3(base) ((TRGMUX_FTM0_REG(base) & TRGMUX_FTM0_SEL3_MASK) >> TRGMUX_FTM0_SEL3_SHIFT)
#define TRGMUX_BRD_FTM0_SEL3(base) (TRGMUX_RD_FTM0_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_FTM0_SEL3(base, value) (TRGMUX_RMW_FTM0(base, TRGMUX_FTM0_SEL3_MASK, TRGMUX_FTM0_SEL3(value)))
#define TRGMUX_BWR_FTM0_SEL3(base, value) (TRGMUX_WR_FTM0_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM0_LK field. */
#define TRGMUX_RD_FTM0_LK(base) ((TRGMUX_FTM0_REG(base) & TRGMUX_FTM0_LK_MASK) >> TRGMUX_FTM0_LK_SHIFT)
#define TRGMUX_BRD_FTM0_LK(base) (BITBAND_ACCESS32(&TRGMUX_FTM0_REG(base), TRGMUX_FTM0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_FTM1 - TRGMUX FTM1 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_FTM1 - TRGMUX FTM1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_FTM1 register
 */
/*@{*/
#define TRGMUX_RD_FTM1(base)     (TRGMUX_FTM1_REG(base))
#define TRGMUX_WR_FTM1(base, value) (TRGMUX_FTM1_REG(base) = (value))
#define TRGMUX_RMW_FTM1(base, mask, value) (TRGMUX_WR_FTM1(base, (TRGMUX_RD_FTM1(base) & ~(mask)) | (value)))
#define TRGMUX_SET_FTM1(base, value) (TRGMUX_WR_FTM1(base, TRGMUX_RD_FTM1(base) |  (value)))
#define TRGMUX_CLR_FTM1(base, value) (TRGMUX_WR_FTM1(base, TRGMUX_RD_FTM1(base) & ~(value)))
#define TRGMUX_TOG_FTM1(base, value) (TRGMUX_WR_FTM1(base, TRGMUX_RD_FTM1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_FTM1 bitfields
 */

/*!
 * @name Register TRGMUX_FTM1, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM1_SEL0 field. */
#define TRGMUX_RD_FTM1_SEL0(base) ((TRGMUX_FTM1_REG(base) & TRGMUX_FTM1_SEL0_MASK) >> TRGMUX_FTM1_SEL0_SHIFT)
#define TRGMUX_BRD_FTM1_SEL0(base) (TRGMUX_RD_FTM1_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_FTM1_SEL0(base, value) (TRGMUX_RMW_FTM1(base, TRGMUX_FTM1_SEL0_MASK, TRGMUX_FTM1_SEL0(value)))
#define TRGMUX_BWR_FTM1_SEL0(base, value) (TRGMUX_WR_FTM1_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM1, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM1_SEL1 field. */
#define TRGMUX_RD_FTM1_SEL1(base) ((TRGMUX_FTM1_REG(base) & TRGMUX_FTM1_SEL1_MASK) >> TRGMUX_FTM1_SEL1_SHIFT)
#define TRGMUX_BRD_FTM1_SEL1(base) (TRGMUX_RD_FTM1_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_FTM1_SEL1(base, value) (TRGMUX_RMW_FTM1(base, TRGMUX_FTM1_SEL1_MASK, TRGMUX_FTM1_SEL1(value)))
#define TRGMUX_BWR_FTM1_SEL1(base, value) (TRGMUX_WR_FTM1_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM1, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM1_SEL2 field. */
#define TRGMUX_RD_FTM1_SEL2(base) ((TRGMUX_FTM1_REG(base) & TRGMUX_FTM1_SEL2_MASK) >> TRGMUX_FTM1_SEL2_SHIFT)
#define TRGMUX_BRD_FTM1_SEL2(base) (TRGMUX_RD_FTM1_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_FTM1_SEL2(base, value) (TRGMUX_RMW_FTM1(base, TRGMUX_FTM1_SEL2_MASK, TRGMUX_FTM1_SEL2(value)))
#define TRGMUX_BWR_FTM1_SEL2(base, value) (TRGMUX_WR_FTM1_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM1, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM1_SEL3 field. */
#define TRGMUX_RD_FTM1_SEL3(base) ((TRGMUX_FTM1_REG(base) & TRGMUX_FTM1_SEL3_MASK) >> TRGMUX_FTM1_SEL3_SHIFT)
#define TRGMUX_BRD_FTM1_SEL3(base) (TRGMUX_RD_FTM1_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_FTM1_SEL3(base, value) (TRGMUX_RMW_FTM1(base, TRGMUX_FTM1_SEL3_MASK, TRGMUX_FTM1_SEL3(value)))
#define TRGMUX_BWR_FTM1_SEL3(base, value) (TRGMUX_WR_FTM1_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM1, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM1_LK field. */
#define TRGMUX_RD_FTM1_LK(base) ((TRGMUX_FTM1_REG(base) & TRGMUX_FTM1_LK_MASK) >> TRGMUX_FTM1_LK_SHIFT)
#define TRGMUX_BRD_FTM1_LK(base) (BITBAND_ACCESS32(&TRGMUX_FTM1_REG(base), TRGMUX_FTM1_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_FTM2 - TRGMUX FTM2 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_FTM2 - TRGMUX FTM2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_FTM2 register
 */
/*@{*/
#define TRGMUX_RD_FTM2(base)     (TRGMUX_FTM2_REG(base))
#define TRGMUX_WR_FTM2(base, value) (TRGMUX_FTM2_REG(base) = (value))
#define TRGMUX_RMW_FTM2(base, mask, value) (TRGMUX_WR_FTM2(base, (TRGMUX_RD_FTM2(base) & ~(mask)) | (value)))
#define TRGMUX_SET_FTM2(base, value) (TRGMUX_WR_FTM2(base, TRGMUX_RD_FTM2(base) |  (value)))
#define TRGMUX_CLR_FTM2(base, value) (TRGMUX_WR_FTM2(base, TRGMUX_RD_FTM2(base) & ~(value)))
#define TRGMUX_TOG_FTM2(base, value) (TRGMUX_WR_FTM2(base, TRGMUX_RD_FTM2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_FTM2 bitfields
 */

/*!
 * @name Register TRGMUX_FTM2, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM2_SEL0 field. */
#define TRGMUX_RD_FTM2_SEL0(base) ((TRGMUX_FTM2_REG(base) & TRGMUX_FTM2_SEL0_MASK) >> TRGMUX_FTM2_SEL0_SHIFT)
#define TRGMUX_BRD_FTM2_SEL0(base) (TRGMUX_RD_FTM2_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_FTM2_SEL0(base, value) (TRGMUX_RMW_FTM2(base, TRGMUX_FTM2_SEL0_MASK, TRGMUX_FTM2_SEL0(value)))
#define TRGMUX_BWR_FTM2_SEL0(base, value) (TRGMUX_WR_FTM2_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM2, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM2_SEL1 field. */
#define TRGMUX_RD_FTM2_SEL1(base) ((TRGMUX_FTM2_REG(base) & TRGMUX_FTM2_SEL1_MASK) >> TRGMUX_FTM2_SEL1_SHIFT)
#define TRGMUX_BRD_FTM2_SEL1(base) (TRGMUX_RD_FTM2_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_FTM2_SEL1(base, value) (TRGMUX_RMW_FTM2(base, TRGMUX_FTM2_SEL1_MASK, TRGMUX_FTM2_SEL1(value)))
#define TRGMUX_BWR_FTM2_SEL1(base, value) (TRGMUX_WR_FTM2_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM2, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM2_SEL2 field. */
#define TRGMUX_RD_FTM2_SEL2(base) ((TRGMUX_FTM2_REG(base) & TRGMUX_FTM2_SEL2_MASK) >> TRGMUX_FTM2_SEL2_SHIFT)
#define TRGMUX_BRD_FTM2_SEL2(base) (TRGMUX_RD_FTM2_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_FTM2_SEL2(base, value) (TRGMUX_RMW_FTM2(base, TRGMUX_FTM2_SEL2_MASK, TRGMUX_FTM2_SEL2(value)))
#define TRGMUX_BWR_FTM2_SEL2(base, value) (TRGMUX_WR_FTM2_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM2, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM2_SEL3 field. */
#define TRGMUX_RD_FTM2_SEL3(base) ((TRGMUX_FTM2_REG(base) & TRGMUX_FTM2_SEL3_MASK) >> TRGMUX_FTM2_SEL3_SHIFT)
#define TRGMUX_BRD_FTM2_SEL3(base) (TRGMUX_RD_FTM2_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_FTM2_SEL3(base, value) (TRGMUX_RMW_FTM2(base, TRGMUX_FTM2_SEL3_MASK, TRGMUX_FTM2_SEL3(value)))
#define TRGMUX_BWR_FTM2_SEL3(base, value) (TRGMUX_WR_FTM2_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM2, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM2_LK field. */
#define TRGMUX_RD_FTM2_LK(base) ((TRGMUX_FTM2_REG(base) & TRGMUX_FTM2_LK_MASK) >> TRGMUX_FTM2_LK_SHIFT)
#define TRGMUX_BRD_FTM2_LK(base) (BITBAND_ACCESS32(&TRGMUX_FTM2_REG(base), TRGMUX_FTM2_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_FTM3 - TRGMUX FTM3 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_FTM3 - TRGMUX FTM3 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_FTM3 register
 */
/*@{*/
#define TRGMUX_RD_FTM3(base)     (TRGMUX_FTM3_REG(base))
#define TRGMUX_WR_FTM3(base, value) (TRGMUX_FTM3_REG(base) = (value))
#define TRGMUX_RMW_FTM3(base, mask, value) (TRGMUX_WR_FTM3(base, (TRGMUX_RD_FTM3(base) & ~(mask)) | (value)))
#define TRGMUX_SET_FTM3(base, value) (TRGMUX_WR_FTM3(base, TRGMUX_RD_FTM3(base) |  (value)))
#define TRGMUX_CLR_FTM3(base, value) (TRGMUX_WR_FTM3(base, TRGMUX_RD_FTM3(base) & ~(value)))
#define TRGMUX_TOG_FTM3(base, value) (TRGMUX_WR_FTM3(base, TRGMUX_RD_FTM3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_FTM3 bitfields
 */

/*!
 * @name Register TRGMUX_FTM3, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM3_SEL0 field. */
#define TRGMUX_RD_FTM3_SEL0(base) ((TRGMUX_FTM3_REG(base) & TRGMUX_FTM3_SEL0_MASK) >> TRGMUX_FTM3_SEL0_SHIFT)
#define TRGMUX_BRD_FTM3_SEL0(base) (TRGMUX_RD_FTM3_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_FTM3_SEL0(base, value) (TRGMUX_RMW_FTM3(base, TRGMUX_FTM3_SEL0_MASK, TRGMUX_FTM3_SEL0(value)))
#define TRGMUX_BWR_FTM3_SEL0(base, value) (TRGMUX_WR_FTM3_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM3, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM3_SEL1 field. */
#define TRGMUX_RD_FTM3_SEL1(base) ((TRGMUX_FTM3_REG(base) & TRGMUX_FTM3_SEL1_MASK) >> TRGMUX_FTM3_SEL1_SHIFT)
#define TRGMUX_BRD_FTM3_SEL1(base) (TRGMUX_RD_FTM3_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_FTM3_SEL1(base, value) (TRGMUX_RMW_FTM3(base, TRGMUX_FTM3_SEL1_MASK, TRGMUX_FTM3_SEL1(value)))
#define TRGMUX_BWR_FTM3_SEL1(base, value) (TRGMUX_WR_FTM3_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM3, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM3_SEL2 field. */
#define TRGMUX_RD_FTM3_SEL2(base) ((TRGMUX_FTM3_REG(base) & TRGMUX_FTM3_SEL2_MASK) >> TRGMUX_FTM3_SEL2_SHIFT)
#define TRGMUX_BRD_FTM3_SEL2(base) (TRGMUX_RD_FTM3_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_FTM3_SEL2(base, value) (TRGMUX_RMW_FTM3(base, TRGMUX_FTM3_SEL2_MASK, TRGMUX_FTM3_SEL2(value)))
#define TRGMUX_BWR_FTM3_SEL2(base, value) (TRGMUX_WR_FTM3_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM3, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM3_SEL3 field. */
#define TRGMUX_RD_FTM3_SEL3(base) ((TRGMUX_FTM3_REG(base) & TRGMUX_FTM3_SEL3_MASK) >> TRGMUX_FTM3_SEL3_SHIFT)
#define TRGMUX_BRD_FTM3_SEL3(base) (TRGMUX_RD_FTM3_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_FTM3_SEL3(base, value) (TRGMUX_RMW_FTM3(base, TRGMUX_FTM3_SEL3_MASK, TRGMUX_FTM3_SEL3(value)))
#define TRGMUX_BWR_FTM3_SEL3(base, value) (TRGMUX_WR_FTM3_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FTM3, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FTM3_LK field. */
#define TRGMUX_RD_FTM3_LK(base) ((TRGMUX_FTM3_REG(base) & TRGMUX_FTM3_LK_MASK) >> TRGMUX_FTM3_LK_SHIFT)
#define TRGMUX_BRD_FTM3_LK(base) (BITBAND_ACCESS32(&TRGMUX_FTM3_REG(base), TRGMUX_FTM3_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_PDB0 - TRGMUX PDB0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_PDB0 - TRGMUX PDB0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_PDB0 register
 */
/*@{*/
#define TRGMUX_RD_PDB0(base)     (TRGMUX_PDB0_REG(base))
#define TRGMUX_WR_PDB0(base, value) (TRGMUX_PDB0_REG(base) = (value))
#define TRGMUX_RMW_PDB0(base, mask, value) (TRGMUX_WR_PDB0(base, (TRGMUX_RD_PDB0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_PDB0(base, value) (TRGMUX_WR_PDB0(base, TRGMUX_RD_PDB0(base) |  (value)))
#define TRGMUX_CLR_PDB0(base, value) (TRGMUX_WR_PDB0(base, TRGMUX_RD_PDB0(base) & ~(value)))
#define TRGMUX_TOG_PDB0(base, value) (TRGMUX_WR_PDB0(base, TRGMUX_RD_PDB0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_PDB0 bitfields
 */

/*!
 * @name Register TRGMUX_PDB0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_PDB0_SEL0 field. */
#define TRGMUX_RD_PDB0_SEL0(base) ((TRGMUX_PDB0_REG(base) & TRGMUX_PDB0_SEL0_MASK) >> TRGMUX_PDB0_SEL0_SHIFT)
#define TRGMUX_BRD_PDB0_SEL0(base) (TRGMUX_RD_PDB0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_PDB0_SEL0(base, value) (TRGMUX_RMW_PDB0(base, TRGMUX_PDB0_SEL0_MASK, TRGMUX_PDB0_SEL0(value)))
#define TRGMUX_BWR_PDB0_SEL0(base, value) (TRGMUX_WR_PDB0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_PDB0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_PDB0_LK field. */
#define TRGMUX_RD_PDB0_LK(base) ((TRGMUX_PDB0_REG(base) & TRGMUX_PDB0_LK_MASK) >> TRGMUX_PDB0_LK_SHIFT)
#define TRGMUX_BRD_PDB0_LK(base) (BITBAND_ACCESS32(&TRGMUX_PDB0_REG(base), TRGMUX_PDB0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_PDB1 - TRGMUX PDB1 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_PDB1 - TRGMUX PDB1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_PDB1 register
 */
/*@{*/
#define TRGMUX_RD_PDB1(base)     (TRGMUX_PDB1_REG(base))
#define TRGMUX_WR_PDB1(base, value) (TRGMUX_PDB1_REG(base) = (value))
#define TRGMUX_RMW_PDB1(base, mask, value) (TRGMUX_WR_PDB1(base, (TRGMUX_RD_PDB1(base) & ~(mask)) | (value)))
#define TRGMUX_SET_PDB1(base, value) (TRGMUX_WR_PDB1(base, TRGMUX_RD_PDB1(base) |  (value)))
#define TRGMUX_CLR_PDB1(base, value) (TRGMUX_WR_PDB1(base, TRGMUX_RD_PDB1(base) & ~(value)))
#define TRGMUX_TOG_PDB1(base, value) (TRGMUX_WR_PDB1(base, TRGMUX_RD_PDB1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_PDB1 bitfields
 */

/*!
 * @name Register TRGMUX_PDB1, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_PDB1_SEL0 field. */
#define TRGMUX_RD_PDB1_SEL0(base) ((TRGMUX_PDB1_REG(base) & TRGMUX_PDB1_SEL0_MASK) >> TRGMUX_PDB1_SEL0_SHIFT)
#define TRGMUX_BRD_PDB1_SEL0(base) (TRGMUX_RD_PDB1_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_PDB1_SEL0(base, value) (TRGMUX_RMW_PDB1(base, TRGMUX_PDB1_SEL0_MASK, TRGMUX_PDB1_SEL0(value)))
#define TRGMUX_BWR_PDB1_SEL0(base, value) (TRGMUX_WR_PDB1_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_PDB1, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_PDB1_LK field. */
#define TRGMUX_RD_PDB1_LK(base) ((TRGMUX_PDB1_REG(base) & TRGMUX_PDB1_LK_MASK) >> TRGMUX_PDB1_LK_SHIFT)
#define TRGMUX_BRD_PDB1_LK(base) (BITBAND_ACCESS32(&TRGMUX_PDB1_REG(base), TRGMUX_PDB1_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_DUMMY16 - TRGMUX DUMMY16 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_DUMMY16 - TRGMUX DUMMY16 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_DUMMY16 register
 */
/*@{*/
#define TRGMUX_RD_DUMMY16(base)  (TRGMUX_DUMMY16_REG(base))
#define TRGMUX_WR_DUMMY16(base, value) (TRGMUX_DUMMY16_REG(base) = (value))
#define TRGMUX_RMW_DUMMY16(base, mask, value) (TRGMUX_WR_DUMMY16(base, (TRGMUX_RD_DUMMY16(base) & ~(mask)) | (value)))
#define TRGMUX_SET_DUMMY16(base, value) (TRGMUX_WR_DUMMY16(base, TRGMUX_RD_DUMMY16(base) |  (value)))
#define TRGMUX_CLR_DUMMY16(base, value) (TRGMUX_WR_DUMMY16(base, TRGMUX_RD_DUMMY16(base) & ~(value)))
#define TRGMUX_TOG_DUMMY16(base, value) (TRGMUX_WR_DUMMY16(base, TRGMUX_RD_DUMMY16(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_DUMMY16 bitfields
 */

/*!
 * @name Register TRGMUX_DUMMY16, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY16_SEL0 field. */
#define TRGMUX_RD_DUMMY16_SEL0(base) ((TRGMUX_DUMMY16_REG(base) & TRGMUX_DUMMY16_SEL0_MASK) >> TRGMUX_DUMMY16_SEL0_SHIFT)
#define TRGMUX_BRD_DUMMY16_SEL0(base) (TRGMUX_RD_DUMMY16_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_DUMMY16_SEL0(base, value) (TRGMUX_RMW_DUMMY16(base, TRGMUX_DUMMY16_SEL0_MASK, TRGMUX_DUMMY16_SEL0(value)))
#define TRGMUX_BWR_DUMMY16_SEL0(base, value) (TRGMUX_WR_DUMMY16_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_DUMMY16, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_DUMMY16_LK field. */
#define TRGMUX_RD_DUMMY16_LK(base) ((TRGMUX_DUMMY16_REG(base) & TRGMUX_DUMMY16_LK_MASK) >> TRGMUX_DUMMY16_LK_SHIFT)
#define TRGMUX_BRD_DUMMY16_LK(base) (BITBAND_ACCESS32(&TRGMUX_DUMMY16_REG(base), TRGMUX_DUMMY16_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_FLEXIO - TRGMUX FLEXIO Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_FLEXIO - TRGMUX FLEXIO Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_FLEXIO register
 */
/*@{*/
#define TRGMUX_RD_FLEXIO(base)   (TRGMUX_FLEXIO_REG(base))
#define TRGMUX_WR_FLEXIO(base, value) (TRGMUX_FLEXIO_REG(base) = (value))
#define TRGMUX_RMW_FLEXIO(base, mask, value) (TRGMUX_WR_FLEXIO(base, (TRGMUX_RD_FLEXIO(base) & ~(mask)) | (value)))
#define TRGMUX_SET_FLEXIO(base, value) (TRGMUX_WR_FLEXIO(base, TRGMUX_RD_FLEXIO(base) |  (value)))
#define TRGMUX_CLR_FLEXIO(base, value) (TRGMUX_WR_FLEXIO(base, TRGMUX_RD_FLEXIO(base) & ~(value)))
#define TRGMUX_TOG_FLEXIO(base, value) (TRGMUX_WR_FLEXIO(base, TRGMUX_RD_FLEXIO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_FLEXIO bitfields
 */

/*!
 * @name Register TRGMUX_FLEXIO, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FLEXIO_SEL0 field. */
#define TRGMUX_RD_FLEXIO_SEL0(base) ((TRGMUX_FLEXIO_REG(base) & TRGMUX_FLEXIO_SEL0_MASK) >> TRGMUX_FLEXIO_SEL0_SHIFT)
#define TRGMUX_BRD_FLEXIO_SEL0(base) (TRGMUX_RD_FLEXIO_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_FLEXIO_SEL0(base, value) (TRGMUX_RMW_FLEXIO(base, TRGMUX_FLEXIO_SEL0_MASK, TRGMUX_FLEXIO_SEL0(value)))
#define TRGMUX_BWR_FLEXIO_SEL0(base, value) (TRGMUX_WR_FLEXIO_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FLEXIO, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FLEXIO_SEL1 field. */
#define TRGMUX_RD_FLEXIO_SEL1(base) ((TRGMUX_FLEXIO_REG(base) & TRGMUX_FLEXIO_SEL1_MASK) >> TRGMUX_FLEXIO_SEL1_SHIFT)
#define TRGMUX_BRD_FLEXIO_SEL1(base) (TRGMUX_RD_FLEXIO_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_FLEXIO_SEL1(base, value) (TRGMUX_RMW_FLEXIO(base, TRGMUX_FLEXIO_SEL1_MASK, TRGMUX_FLEXIO_SEL1(value)))
#define TRGMUX_BWR_FLEXIO_SEL1(base, value) (TRGMUX_WR_FLEXIO_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FLEXIO, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FLEXIO_SEL2 field. */
#define TRGMUX_RD_FLEXIO_SEL2(base) ((TRGMUX_FLEXIO_REG(base) & TRGMUX_FLEXIO_SEL2_MASK) >> TRGMUX_FLEXIO_SEL2_SHIFT)
#define TRGMUX_BRD_FLEXIO_SEL2(base) (TRGMUX_RD_FLEXIO_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_FLEXIO_SEL2(base, value) (TRGMUX_RMW_FLEXIO(base, TRGMUX_FLEXIO_SEL2_MASK, TRGMUX_FLEXIO_SEL2(value)))
#define TRGMUX_BWR_FLEXIO_SEL2(base, value) (TRGMUX_WR_FLEXIO_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FLEXIO, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FLEXIO_SEL3 field. */
#define TRGMUX_RD_FLEXIO_SEL3(base) ((TRGMUX_FLEXIO_REG(base) & TRGMUX_FLEXIO_SEL3_MASK) >> TRGMUX_FLEXIO_SEL3_SHIFT)
#define TRGMUX_BRD_FLEXIO_SEL3(base) (TRGMUX_RD_FLEXIO_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_FLEXIO_SEL3(base, value) (TRGMUX_RMW_FLEXIO(base, TRGMUX_FLEXIO_SEL3_MASK, TRGMUX_FLEXIO_SEL3(value)))
#define TRGMUX_BWR_FLEXIO_SEL3(base, value) (TRGMUX_WR_FLEXIO_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_FLEXIO, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_FLEXIO_LK field. */
#define TRGMUX_RD_FLEXIO_LK(base) ((TRGMUX_FLEXIO_REG(base) & TRGMUX_FLEXIO_LK_MASK) >> TRGMUX_FLEXIO_LK_SHIFT)
#define TRGMUX_BRD_FLEXIO_LK(base) (BITBAND_ACCESS32(&TRGMUX_FLEXIO_REG(base), TRGMUX_FLEXIO_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPIT - TRGMUX LPIT Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPIT - TRGMUX LPIT Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPIT register
 */
/*@{*/
#define TRGMUX_RD_LPIT(base)     (TRGMUX_LPIT_REG(base))
#define TRGMUX_WR_LPIT(base, value) (TRGMUX_LPIT_REG(base) = (value))
#define TRGMUX_RMW_LPIT(base, mask, value) (TRGMUX_WR_LPIT(base, (TRGMUX_RD_LPIT(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPIT(base, value) (TRGMUX_WR_LPIT(base, TRGMUX_RD_LPIT(base) |  (value)))
#define TRGMUX_CLR_LPIT(base, value) (TRGMUX_WR_LPIT(base, TRGMUX_RD_LPIT(base) & ~(value)))
#define TRGMUX_TOG_LPIT(base, value) (TRGMUX_WR_LPIT(base, TRGMUX_RD_LPIT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPIT bitfields
 */

/*!
 * @name Register TRGMUX_LPIT, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPIT_SEL0 field. */
#define TRGMUX_RD_LPIT_SEL0(base) ((TRGMUX_LPIT_REG(base) & TRGMUX_LPIT_SEL0_MASK) >> TRGMUX_LPIT_SEL0_SHIFT)
#define TRGMUX_BRD_LPIT_SEL0(base) (TRGMUX_RD_LPIT_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPIT_SEL0(base, value) (TRGMUX_RMW_LPIT(base, TRGMUX_LPIT_SEL0_MASK, TRGMUX_LPIT_SEL0(value)))
#define TRGMUX_BWR_LPIT_SEL0(base, value) (TRGMUX_WR_LPIT_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPIT, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPIT_SEL1 field. */
#define TRGMUX_RD_LPIT_SEL1(base) ((TRGMUX_LPIT_REG(base) & TRGMUX_LPIT_SEL1_MASK) >> TRGMUX_LPIT_SEL1_SHIFT)
#define TRGMUX_BRD_LPIT_SEL1(base) (TRGMUX_RD_LPIT_SEL1(base))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_LPIT_SEL1(base, value) (TRGMUX_RMW_LPIT(base, TRGMUX_LPIT_SEL1_MASK, TRGMUX_LPIT_SEL1(value)))
#define TRGMUX_BWR_LPIT_SEL1(base, value) (TRGMUX_WR_LPIT_SEL1(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPIT, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPIT_SEL2 field. */
#define TRGMUX_RD_LPIT_SEL2(base) ((TRGMUX_LPIT_REG(base) & TRGMUX_LPIT_SEL2_MASK) >> TRGMUX_LPIT_SEL2_SHIFT)
#define TRGMUX_BRD_LPIT_SEL2(base) (TRGMUX_RD_LPIT_SEL2(base))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_LPIT_SEL2(base, value) (TRGMUX_RMW_LPIT(base, TRGMUX_LPIT_SEL2_MASK, TRGMUX_LPIT_SEL2(value)))
#define TRGMUX_BWR_LPIT_SEL2(base, value) (TRGMUX_WR_LPIT_SEL2(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPIT, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPIT_SEL3 field. */
#define TRGMUX_RD_LPIT_SEL3(base) ((TRGMUX_LPIT_REG(base) & TRGMUX_LPIT_SEL3_MASK) >> TRGMUX_LPIT_SEL3_SHIFT)
#define TRGMUX_BRD_LPIT_SEL3(base) (TRGMUX_RD_LPIT_SEL3(base))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_LPIT_SEL3(base, value) (TRGMUX_RMW_LPIT(base, TRGMUX_LPIT_SEL3_MASK, TRGMUX_LPIT_SEL3(value)))
#define TRGMUX_BWR_LPIT_SEL3(base, value) (TRGMUX_WR_LPIT_SEL3(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPIT, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPIT_LK field. */
#define TRGMUX_RD_LPIT_LK(base) ((TRGMUX_LPIT_REG(base) & TRGMUX_LPIT_LK_MASK) >> TRGMUX_LPIT_LK_SHIFT)
#define TRGMUX_BRD_LPIT_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPIT_REG(base), TRGMUX_LPIT_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPUART0 - TRGMUX LPUART0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPUART0 - TRGMUX LPUART0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPUART0 register
 */
/*@{*/
#define TRGMUX_RD_LPUART0(base)  (TRGMUX_LPUART0_REG(base))
#define TRGMUX_WR_LPUART0(base, value) (TRGMUX_LPUART0_REG(base) = (value))
#define TRGMUX_RMW_LPUART0(base, mask, value) (TRGMUX_WR_LPUART0(base, (TRGMUX_RD_LPUART0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPUART0(base, value) (TRGMUX_WR_LPUART0(base, TRGMUX_RD_LPUART0(base) |  (value)))
#define TRGMUX_CLR_LPUART0(base, value) (TRGMUX_WR_LPUART0(base, TRGMUX_RD_LPUART0(base) & ~(value)))
#define TRGMUX_TOG_LPUART0(base, value) (TRGMUX_WR_LPUART0(base, TRGMUX_RD_LPUART0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPUART0 bitfields
 */

/*!
 * @name Register TRGMUX_LPUART0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPUART0_SEL0 field. */
#define TRGMUX_RD_LPUART0_SEL0(base) ((TRGMUX_LPUART0_REG(base) & TRGMUX_LPUART0_SEL0_MASK) >> TRGMUX_LPUART0_SEL0_SHIFT)
#define TRGMUX_BRD_LPUART0_SEL0(base) (TRGMUX_RD_LPUART0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPUART0_SEL0(base, value) (TRGMUX_RMW_LPUART0(base, TRGMUX_LPUART0_SEL0_MASK, TRGMUX_LPUART0_SEL0(value)))
#define TRGMUX_BWR_LPUART0_SEL0(base, value) (TRGMUX_WR_LPUART0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPUART0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPUART0_LK field. */
#define TRGMUX_RD_LPUART0_LK(base) ((TRGMUX_LPUART0_REG(base) & TRGMUX_LPUART0_LK_MASK) >> TRGMUX_LPUART0_LK_SHIFT)
#define TRGMUX_BRD_LPUART0_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPUART0_REG(base), TRGMUX_LPUART0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPUART1 - TRGMUX LPUART1 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPUART1 - TRGMUX LPUART1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPUART1 register
 */
/*@{*/
#define TRGMUX_RD_LPUART1(base)  (TRGMUX_LPUART1_REG(base))
#define TRGMUX_WR_LPUART1(base, value) (TRGMUX_LPUART1_REG(base) = (value))
#define TRGMUX_RMW_LPUART1(base, mask, value) (TRGMUX_WR_LPUART1(base, (TRGMUX_RD_LPUART1(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPUART1(base, value) (TRGMUX_WR_LPUART1(base, TRGMUX_RD_LPUART1(base) |  (value)))
#define TRGMUX_CLR_LPUART1(base, value) (TRGMUX_WR_LPUART1(base, TRGMUX_RD_LPUART1(base) & ~(value)))
#define TRGMUX_TOG_LPUART1(base, value) (TRGMUX_WR_LPUART1(base, TRGMUX_RD_LPUART1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPUART1 bitfields
 */

/*!
 * @name Register TRGMUX_LPUART1, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPUART1_SEL0 field. */
#define TRGMUX_RD_LPUART1_SEL0(base) ((TRGMUX_LPUART1_REG(base) & TRGMUX_LPUART1_SEL0_MASK) >> TRGMUX_LPUART1_SEL0_SHIFT)
#define TRGMUX_BRD_LPUART1_SEL0(base) (TRGMUX_RD_LPUART1_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPUART1_SEL0(base, value) (TRGMUX_RMW_LPUART1(base, TRGMUX_LPUART1_SEL0_MASK, TRGMUX_LPUART1_SEL0(value)))
#define TRGMUX_BWR_LPUART1_SEL0(base, value) (TRGMUX_WR_LPUART1_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPUART1, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPUART1_LK field. */
#define TRGMUX_RD_LPUART1_LK(base) ((TRGMUX_LPUART1_REG(base) & TRGMUX_LPUART1_LK_MASK) >> TRGMUX_LPUART1_LK_SHIFT)
#define TRGMUX_BRD_LPUART1_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPUART1_REG(base), TRGMUX_LPUART1_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPI2C0 - TRGMUX LPI2C0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPI2C0 - TRGMUX LPI2C0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPI2C0 register
 */
/*@{*/
#define TRGMUX_RD_LPI2C0(base)   (TRGMUX_LPI2C0_REG(base))
#define TRGMUX_WR_LPI2C0(base, value) (TRGMUX_LPI2C0_REG(base) = (value))
#define TRGMUX_RMW_LPI2C0(base, mask, value) (TRGMUX_WR_LPI2C0(base, (TRGMUX_RD_LPI2C0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPI2C0(base, value) (TRGMUX_WR_LPI2C0(base, TRGMUX_RD_LPI2C0(base) |  (value)))
#define TRGMUX_CLR_LPI2C0(base, value) (TRGMUX_WR_LPI2C0(base, TRGMUX_RD_LPI2C0(base) & ~(value)))
#define TRGMUX_TOG_LPI2C0(base, value) (TRGMUX_WR_LPI2C0(base, TRGMUX_RD_LPI2C0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPI2C0 bitfields
 */

/*!
 * @name Register TRGMUX_LPI2C0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPI2C0_SEL0 field. */
#define TRGMUX_RD_LPI2C0_SEL0(base) ((TRGMUX_LPI2C0_REG(base) & TRGMUX_LPI2C0_SEL0_MASK) >> TRGMUX_LPI2C0_SEL0_SHIFT)
#define TRGMUX_BRD_LPI2C0_SEL0(base) (TRGMUX_RD_LPI2C0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPI2C0_SEL0(base, value) (TRGMUX_RMW_LPI2C0(base, TRGMUX_LPI2C0_SEL0_MASK, TRGMUX_LPI2C0_SEL0(value)))
#define TRGMUX_BWR_LPI2C0_SEL0(base, value) (TRGMUX_WR_LPI2C0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPI2C0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPI2C0_LK field. */
#define TRGMUX_RD_LPI2C0_LK(base) ((TRGMUX_LPI2C0_REG(base) & TRGMUX_LPI2C0_LK_MASK) >> TRGMUX_LPI2C0_LK_SHIFT)
#define TRGMUX_BRD_LPI2C0_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPI2C0_REG(base), TRGMUX_LPI2C0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPI2C1 - TRGMUX LPI2C1 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPI2C1 - TRGMUX LPI2C1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPI2C1 register
 */
/*@{*/
#define TRGMUX_RD_LPI2C1(base)   (TRGMUX_LPI2C1_REG(base))
#define TRGMUX_WR_LPI2C1(base, value) (TRGMUX_LPI2C1_REG(base) = (value))
#define TRGMUX_RMW_LPI2C1(base, mask, value) (TRGMUX_WR_LPI2C1(base, (TRGMUX_RD_LPI2C1(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPI2C1(base, value) (TRGMUX_WR_LPI2C1(base, TRGMUX_RD_LPI2C1(base) |  (value)))
#define TRGMUX_CLR_LPI2C1(base, value) (TRGMUX_WR_LPI2C1(base, TRGMUX_RD_LPI2C1(base) & ~(value)))
#define TRGMUX_TOG_LPI2C1(base, value) (TRGMUX_WR_LPI2C1(base, TRGMUX_RD_LPI2C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPI2C1 bitfields
 */

/*!
 * @name Register TRGMUX_LPI2C1, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPI2C1_SEL0 field. */
#define TRGMUX_RD_LPI2C1_SEL0(base) ((TRGMUX_LPI2C1_REG(base) & TRGMUX_LPI2C1_SEL0_MASK) >> TRGMUX_LPI2C1_SEL0_SHIFT)
#define TRGMUX_BRD_LPI2C1_SEL0(base) (TRGMUX_RD_LPI2C1_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPI2C1_SEL0(base, value) (TRGMUX_RMW_LPI2C1(base, TRGMUX_LPI2C1_SEL0_MASK, TRGMUX_LPI2C1_SEL0(value)))
#define TRGMUX_BWR_LPI2C1_SEL0(base, value) (TRGMUX_WR_LPI2C1_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPI2C1, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPI2C1_LK field. */
#define TRGMUX_RD_LPI2C1_LK(base) ((TRGMUX_LPI2C1_REG(base) & TRGMUX_LPI2C1_LK_MASK) >> TRGMUX_LPI2C1_LK_SHIFT)
#define TRGMUX_BRD_LPI2C1_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPI2C1_REG(base), TRGMUX_LPI2C1_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPSPI0 - TRGMUX LPSPI0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPSPI0 - TRGMUX LPSPI0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPSPI0 register
 */
/*@{*/
#define TRGMUX_RD_LPSPI0(base)   (TRGMUX_LPSPI0_REG(base))
#define TRGMUX_WR_LPSPI0(base, value) (TRGMUX_LPSPI0_REG(base) = (value))
#define TRGMUX_RMW_LPSPI0(base, mask, value) (TRGMUX_WR_LPSPI0(base, (TRGMUX_RD_LPSPI0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPSPI0(base, value) (TRGMUX_WR_LPSPI0(base, TRGMUX_RD_LPSPI0(base) |  (value)))
#define TRGMUX_CLR_LPSPI0(base, value) (TRGMUX_WR_LPSPI0(base, TRGMUX_RD_LPSPI0(base) & ~(value)))
#define TRGMUX_TOG_LPSPI0(base, value) (TRGMUX_WR_LPSPI0(base, TRGMUX_RD_LPSPI0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPSPI0 bitfields
 */

/*!
 * @name Register TRGMUX_LPSPI0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPSPI0_SEL0 field. */
#define TRGMUX_RD_LPSPI0_SEL0(base) ((TRGMUX_LPSPI0_REG(base) & TRGMUX_LPSPI0_SEL0_MASK) >> TRGMUX_LPSPI0_SEL0_SHIFT)
#define TRGMUX_BRD_LPSPI0_SEL0(base) (TRGMUX_RD_LPSPI0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPSPI0_SEL0(base, value) (TRGMUX_RMW_LPSPI0(base, TRGMUX_LPSPI0_SEL0_MASK, TRGMUX_LPSPI0_SEL0(value)))
#define TRGMUX_BWR_LPSPI0_SEL0(base, value) (TRGMUX_WR_LPSPI0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPSPI0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPSPI0_LK field. */
#define TRGMUX_RD_LPSPI0_LK(base) ((TRGMUX_LPSPI0_REG(base) & TRGMUX_LPSPI0_LK_MASK) >> TRGMUX_LPSPI0_LK_SHIFT)
#define TRGMUX_BRD_LPSPI0_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPSPI0_REG(base), TRGMUX_LPSPI0_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPSPI1 - TRGMUX LPSPI1 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPSPI1 - TRGMUX LPSPI1 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPSPI1 register
 */
/*@{*/
#define TRGMUX_RD_LPSPI1(base)   (TRGMUX_LPSPI1_REG(base))
#define TRGMUX_WR_LPSPI1(base, value) (TRGMUX_LPSPI1_REG(base) = (value))
#define TRGMUX_RMW_LPSPI1(base, mask, value) (TRGMUX_WR_LPSPI1(base, (TRGMUX_RD_LPSPI1(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPSPI1(base, value) (TRGMUX_WR_LPSPI1(base, TRGMUX_RD_LPSPI1(base) |  (value)))
#define TRGMUX_CLR_LPSPI1(base, value) (TRGMUX_WR_LPSPI1(base, TRGMUX_RD_LPSPI1(base) & ~(value)))
#define TRGMUX_TOG_LPSPI1(base, value) (TRGMUX_WR_LPSPI1(base, TRGMUX_RD_LPSPI1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPSPI1 bitfields
 */

/*!
 * @name Register TRGMUX_LPSPI1, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPSPI1_SEL0 field. */
#define TRGMUX_RD_LPSPI1_SEL0(base) ((TRGMUX_LPSPI1_REG(base) & TRGMUX_LPSPI1_SEL0_MASK) >> TRGMUX_LPSPI1_SEL0_SHIFT)
#define TRGMUX_BRD_LPSPI1_SEL0(base) (TRGMUX_RD_LPSPI1_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPSPI1_SEL0(base, value) (TRGMUX_RMW_LPSPI1(base, TRGMUX_LPSPI1_SEL0_MASK, TRGMUX_LPSPI1_SEL0(value)))
#define TRGMUX_BWR_LPSPI1_SEL0(base, value) (TRGMUX_WR_LPSPI1_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPSPI1, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPSPI1_LK field. */
#define TRGMUX_RD_LPSPI1_LK(base) ((TRGMUX_LPSPI1_REG(base) & TRGMUX_LPSPI1_LK_MASK) >> TRGMUX_LPSPI1_LK_SHIFT)
#define TRGMUX_BRD_LPSPI1_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPSPI1_REG(base), TRGMUX_LPSPI1_LK_SHIFT))
/*@}*/

/*******************************************************************************
 * TRGMUX_LPTMR0 - TRGMUX LPTMR0 Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_LPTMR0 - TRGMUX LPTMR0 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TRGMUX Register
 */
/*!
 * @name Constants and macros for entire TRGMUX_LPTMR0 register
 */
/*@{*/
#define TRGMUX_RD_LPTMR0(base)   (TRGMUX_LPTMR0_REG(base))
#define TRGMUX_WR_LPTMR0(base, value) (TRGMUX_LPTMR0_REG(base) = (value))
#define TRGMUX_RMW_LPTMR0(base, mask, value) (TRGMUX_WR_LPTMR0(base, (TRGMUX_RD_LPTMR0(base) & ~(mask)) | (value)))
#define TRGMUX_SET_LPTMR0(base, value) (TRGMUX_WR_LPTMR0(base, TRGMUX_RD_LPTMR0(base) |  (value)))
#define TRGMUX_CLR_LPTMR0(base, value) (TRGMUX_WR_LPTMR0(base, TRGMUX_RD_LPTMR0(base) & ~(value)))
#define TRGMUX_TOG_LPTMR0(base, value) (TRGMUX_WR_LPTMR0(base, TRGMUX_RD_LPTMR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_LPTMR0 bitfields
 */

/*!
 * @name Register TRGMUX_LPTMR0, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPTMR0_SEL0 field. */
#define TRGMUX_RD_LPTMR0_SEL0(base) ((TRGMUX_LPTMR0_REG(base) & TRGMUX_LPTMR0_SEL0_MASK) >> TRGMUX_LPTMR0_SEL0_SHIFT)
#define TRGMUX_BRD_LPTMR0_SEL0(base) (TRGMUX_RD_LPTMR0_SEL0(base))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_LPTMR0_SEL0(base, value) (TRGMUX_RMW_LPTMR0(base, TRGMUX_LPTMR0_SEL0_MASK, TRGMUX_LPTMR0_SEL0(value)))
#define TRGMUX_BWR_LPTMR0_SEL0(base, value) (TRGMUX_WR_LPTMR0_SEL0(base, value))
/*@}*/

/*!
 * @name Register TRGMUX_LPTMR0, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_LPTMR0_LK field. */
#define TRGMUX_RD_LPTMR0_LK(base) ((TRGMUX_LPTMR0_REG(base) & TRGMUX_LPTMR0_LK_MASK) >> TRGMUX_LPTMR0_LK_SHIFT)
#define TRGMUX_BRD_LPTMR0_LK(base) (BITBAND_ACCESS32(&TRGMUX_LPTMR0_REG(base), TRGMUX_LPTMR0_LK_SHIFT))
/*@}*/

/*
 * S32K144 WDOG
 *
 * Watchdog timer
 *
 * Registers defined in this header file:
 * - WDOG_CS - Watchdog Control and Status Register
 * - WDOG_CNT - Watchdog Counter Register
 * - WDOG_TOVAL - Watchdog Timeout Value Register
 * - WDOG_WIN - Watchdog Window Register
 */

#define WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define WDOG_IDX (0U) /*!< Instance number for WDOG. */

/*******************************************************************************
 * WDOG_CS - Watchdog Control and Status Register
 ******************************************************************************/

/*!
 * @brief WDOG_CS - Watchdog Control and Status Register (RW)
 *
 * Reset value: 0x00002180U
 *
 * This section describes the function of Watchdog Control and Status Register.
 * TST is cleared (0:0) on POR only. Any other reset does not affect the value of
 * this field.
 */
/*!
 * @name Constants and macros for entire WDOG_CS register
 */
/*@{*/
#define WDOG_RD_CS(base)         (WDOG_CS_REG(base))
#define WDOG_WR_CS(base, value)  (WDOG_CS_REG(base) = (value))
#define WDOG_RMW_CS(base, mask, value) (WDOG_WR_CS(base, (WDOG_RD_CS(base) & ~(mask)) | (value)))
#define WDOG_SET_CS(base, value) (WDOG_WR_CS(base, WDOG_RD_CS(base) |  (value)))
#define WDOG_CLR_CS(base, value) (WDOG_WR_CS(base, WDOG_RD_CS(base) & ~(value)))
#define WDOG_TOG_CS(base, value) (WDOG_WR_CS(base, WDOG_RD_CS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_CS bitfields
 */

/*!
 * @name Register WDOG_CS, field STOP[0] (RW)
 *
 * This write-once bit enables the watchdog to operate when the chip is in stop
 * mode.
 *
 * Values:
 * - 0b0 - Watchdog disabled in chip stop mode.
 * - 0b1 - Watchdog enabled in chip stop mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_STOP field. */
#define WDOG_RD_CS_STOP(base) ((WDOG_CS_REG(base) & WDOG_CS_STOP_MASK) >> WDOG_CS_STOP_SHIFT)
#define WDOG_BRD_CS_STOP(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_STOP_SHIFT))

/*! @brief Set the STOP field to a new value. */
#define WDOG_WR_CS_STOP(base, value) (WDOG_RMW_CS(base, (WDOG_CS_STOP_MASK | WDOG_CS_FLG_MASK), WDOG_CS_STOP(value)))
#define WDOG_BWR_CS_STOP(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_STOP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field WAIT[1] (RW)
 *
 * This write-once bit enables the watchdog to operate when the chip is in wait
 * mode.
 *
 * Values:
 * - 0b0 - Watchdog disabled in chip wait mode.
 * - 0b1 - Watchdog enabled in chip wait mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_WAIT field. */
#define WDOG_RD_CS_WAIT(base) ((WDOG_CS_REG(base) & WDOG_CS_WAIT_MASK) >> WDOG_CS_WAIT_SHIFT)
#define WDOG_BRD_CS_WAIT(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_WAIT_SHIFT))

/*! @brief Set the WAIT field to a new value. */
#define WDOG_WR_CS_WAIT(base, value) (WDOG_RMW_CS(base, (WDOG_CS_WAIT_MASK | WDOG_CS_FLG_MASK), WDOG_CS_WAIT(value)))
#define WDOG_BWR_CS_WAIT(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_WAIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field DBG[2] (RW)
 *
 * This write-once bit enables the watchdog to operate when the chip is in debug
 * mode.
 *
 * Values:
 * - 0b0 - Watchdog disabled in chip debug mode.
 * - 0b1 - Watchdog enabled in chip debug mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_DBG field. */
#define WDOG_RD_CS_DBG(base) ((WDOG_CS_REG(base) & WDOG_CS_DBG_MASK) >> WDOG_CS_DBG_SHIFT)
#define WDOG_BRD_CS_DBG(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_DBG_SHIFT))

/*! @brief Set the DBG field to a new value. */
#define WDOG_WR_CS_DBG(base, value) (WDOG_RMW_CS(base, (WDOG_CS_DBG_MASK | WDOG_CS_FLG_MASK), WDOG_CS_DBG(value)))
#define WDOG_BWR_CS_DBG(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_DBG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field TST[4:3] (RW)
 *
 * Enables the fast test mode. The test mode allows software to exercise all
 * bits of the counter to demonstrate that the watchdog is functioning properly. See
 * the Fast testing of the watchdog section. This write-once field is cleared
 * (0:0) on POR only. Any other reset does not affect the value of this field.
 *
 * Values:
 * - 0b00 - Watchdog test mode disabled.
 * - 0b01 - Watchdog user mode enabled. (Watchdog test mode disabled.) After
 *     testing the watchdog, software should use this setting to indicate that the
 *     watchdog is functioning normally in user mode.
 * - 0b10 - Watchdog test mode enabled, only the low byte is used. CNT[CNTLOW]
 *     is compared with TOVAL[TOVALLOW].
 * - 0b11 - Watchdog test mode enabled, only the high byte is used. CNT[CNTHIGH]
 *     is compared with TOVAL[TOVALHIGH].
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_TST field. */
#define WDOG_RD_CS_TST(base) ((WDOG_CS_REG(base) & WDOG_CS_TST_MASK) >> WDOG_CS_TST_SHIFT)
#define WDOG_BRD_CS_TST(base) (WDOG_RD_CS_TST(base))

/*! @brief Set the TST field to a new value. */
#define WDOG_WR_CS_TST(base, value) (WDOG_RMW_CS(base, (WDOG_CS_TST_MASK | WDOG_CS_FLG_MASK), WDOG_CS_TST(value)))
#define WDOG_BWR_CS_TST(base, value) (WDOG_WR_CS_TST(base, value))
/*@}*/

/*!
 * @name Register WDOG_CS, field UPDATE[5] (RW)
 *
 * This write-once bit allows software to reconfigure the watchdog without a
 * reset.
 *
 * Values:
 * - 0b0 - Updates not allowed. After the initial configuration, the watchdog
 *     cannot be later modified without forcing a reset.
 * - 0b1 - Updates allowed. Software can modify the watchdog configuration
 *     registers within 128 bus clocks after performing the unlock write sequence.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_UPDATE field. */
#define WDOG_RD_CS_UPDATE(base) ((WDOG_CS_REG(base) & WDOG_CS_UPDATE_MASK) >> WDOG_CS_UPDATE_SHIFT)
#define WDOG_BRD_CS_UPDATE(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_UPDATE_SHIFT))

/*! @brief Set the UPDATE field to a new value. */
#define WDOG_WR_CS_UPDATE(base, value) (WDOG_RMW_CS(base, (WDOG_CS_UPDATE_MASK | WDOG_CS_FLG_MASK), WDOG_CS_UPDATE(value)))
#define WDOG_BWR_CS_UPDATE(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_UPDATE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field INT[6] (RW)
 *
 * This write-once bit configures the watchdog to immediately generate an
 * interrupt request upon a reset-triggering event (timeout or illegal write to the
 * watchdog), before forcing a reset. After the interrupt vector fetch (which comes
 * after the reset-triggering event), the reset occurs after a delay of 128 bus
 * clocks.
 *
 * Values:
 * - 0b0 - Watchdog interrupts are disabled. Watchdog resets are not delayed.
 * - 0b1 - Watchdog interrupts are enabled. Watchdog resets are delayed by 128
 *     bus clocks from the interrupt vector fetch.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_INT field. */
#define WDOG_RD_CS_INT(base) ((WDOG_CS_REG(base) & WDOG_CS_INT_MASK) >> WDOG_CS_INT_SHIFT)
#define WDOG_BRD_CS_INT(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_INT_SHIFT))

/*! @brief Set the INT field to a new value. */
#define WDOG_WR_CS_INT(base, value) (WDOG_RMW_CS(base, (WDOG_CS_INT_MASK | WDOG_CS_FLG_MASK), WDOG_CS_INT(value)))
#define WDOG_BWR_CS_INT(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_INT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field EN[7] (RW)
 *
 * This write-once bit enables the watchdog counter to start counting.
 *
 * Values:
 * - 0b0 - Watchdog disabled.
 * - 0b1 - Watchdog enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_EN field. */
#define WDOG_RD_CS_EN(base)  ((WDOG_CS_REG(base) & WDOG_CS_EN_MASK) >> WDOG_CS_EN_SHIFT)
#define WDOG_BRD_CS_EN(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_EN_SHIFT))

/*! @brief Set the EN field to a new value. */
#define WDOG_WR_CS_EN(base, value) (WDOG_RMW_CS(base, (WDOG_CS_EN_MASK | WDOG_CS_FLG_MASK), WDOG_CS_EN(value)))
#define WDOG_BWR_CS_EN(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field CLK[9:8] (RW)
 *
 * This write-once field indicates the clock source that feeds the watchdog
 * counter. See the Clock source section.
 *
 * Values:
 * - 0b00 - Bus clock
 * - 0b01 - LPO (128 kHz clock from PMC)
 * - 0b10 - SIRC (8 MHz IRC from SCG)
 * - 0b11 - ERCLK (external reference clock from SCG)
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_CLK field. */
#define WDOG_RD_CS_CLK(base) ((WDOG_CS_REG(base) & WDOG_CS_CLK_MASK) >> WDOG_CS_CLK_SHIFT)
#define WDOG_BRD_CS_CLK(base) (WDOG_RD_CS_CLK(base))

/*! @brief Set the CLK field to a new value. */
#define WDOG_WR_CS_CLK(base, value) (WDOG_RMW_CS(base, (WDOG_CS_CLK_MASK | WDOG_CS_FLG_MASK), WDOG_CS_CLK(value)))
#define WDOG_BWR_CS_CLK(base, value) (WDOG_WR_CS_CLK(base, value))
/*@}*/

/*!
 * @name Register WDOG_CS, field PRES[12] (RW)
 *
 * This write-once bit enables a fixed 256 pre-scaling of watchdog counter
 * reference clock. (The block diagram shows this clock divider option.)
 *
 * Values:
 * - 0b0 - 256 prescalar disabled.
 * - 0b1 - 256 prescalar enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_PRES field. */
#define WDOG_RD_CS_PRES(base) ((WDOG_CS_REG(base) & WDOG_CS_PRES_MASK) >> WDOG_CS_PRES_SHIFT)
#define WDOG_BRD_CS_PRES(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_PRES_SHIFT))

/*! @brief Set the PRES field to a new value. */
#define WDOG_WR_CS_PRES(base, value) (WDOG_RMW_CS(base, (WDOG_CS_PRES_MASK | WDOG_CS_FLG_MASK), WDOG_CS_PRES(value)))
#define WDOG_BWR_CS_PRES(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_PRES_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field FLG[14] (W1C)
 *
 * This bit is an interrupt indicator when INT is set in control and status
 * register 1. Write 1 to clear it.
 *
 * Values:
 * - 0b0 - No interrupt occurred.
 * - 0b1 - An interrupt occurred.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_FLG field. */
#define WDOG_RD_CS_FLG(base) ((WDOG_CS_REG(base) & WDOG_CS_FLG_MASK) >> WDOG_CS_FLG_SHIFT)
#define WDOG_BRD_CS_FLG(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_FLG_SHIFT))

/*! @brief Set the FLG field to a new value. */
#define WDOG_WR_CS_FLG(base, value) (WDOG_RMW_CS(base, WDOG_CS_FLG_MASK, WDOG_CS_FLG(value)))
#define WDOG_BWR_CS_FLG(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_FLG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_CS, field WIN[15] (RW)
 *
 * This write-once bit enables window mode. See the Window mode section.
 *
 * Values:
 * - 0b0 - Window mode disabled.
 * - 0b1 - Window mode enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_WIN field. */
#define WDOG_RD_CS_WIN(base) ((WDOG_CS_REG(base) & WDOG_CS_WIN_MASK) >> WDOG_CS_WIN_SHIFT)
#define WDOG_BRD_CS_WIN(base) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_WIN_SHIFT))

/*! @brief Set the WIN field to a new value. */
#define WDOG_WR_CS_WIN(base, value) (WDOG_RMW_CS(base, (WDOG_CS_WIN_MASK | WDOG_CS_FLG_MASK), WDOG_CS_WIN(value)))
#define WDOG_BWR_CS_WIN(base, value) (BITBAND_ACCESS32(&WDOG_CS_REG(base), WDOG_CS_WIN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * WDOG_CNT - Watchdog Counter Register
 ******************************************************************************/

/*!
 * @brief WDOG_CNT - Watchdog Counter Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes the watchdog counter register. The watchdog counter
 * register provides access to the value of the free-running watchdog counter.
 * Software can read the counter register at any time. Software cannot write directly
 * to the watchdog counter; however, two write sequences to these registers have
 * special functions: The refresh sequence resets the watchdog counter to
 * 0x0000. See the Refreshing the Watchdog section. The unlock sequence allows the
 * watchdog to be reconfigured without forcing a reset (when CS[UPDATE] = 1). See the
 * Example code: Reconfiguring the Watchdog section. All other writes to this
 * register are illegal and force a reset.
 */
/*!
 * @name Constants and macros for entire WDOG_CNT register
 */
/*@{*/
#define WDOG_RD_CNT(base)        (WDOG_CNT_REG(base))
#define WDOG_WR_CNT(base, value) (WDOG_CNT_REG(base) = (value))
#define WDOG_RMW_CNT(base, mask, value) (WDOG_WR_CNT(base, (WDOG_RD_CNT(base) & ~(mask)) | (value)))
#define WDOG_SET_CNT(base, value) (WDOG_WR_CNT(base, WDOG_RD_CNT(base) |  (value)))
#define WDOG_CLR_CNT(base, value) (WDOG_WR_CNT(base, WDOG_RD_CNT(base) & ~(value)))
#define WDOG_TOG_CNT(base, value) (WDOG_WR_CNT(base, WDOG_RD_CNT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_CNT bitfields
 */

/*!
 * @name Register WDOG_CNT, field CNTLOW[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_CNT_CNTLOW field. */
#define WDOG_RD_CNT_CNTLOW(base) ((WDOG_CNT_REG(base) & WDOG_CNT_CNTLOW_MASK) >> WDOG_CNT_CNTLOW_SHIFT)
#define WDOG_BRD_CNT_CNTLOW(base) (WDOG_RD_CNT_CNTLOW(base))

/*! @brief Set the CNTLOW field to a new value. */
#define WDOG_WR_CNT_CNTLOW(base, value) (WDOG_RMW_CNT(base, WDOG_CNT_CNTLOW_MASK, WDOG_CNT_CNTLOW(value)))
#define WDOG_BWR_CNT_CNTLOW(base, value) (WDOG_WR_CNT_CNTLOW(base, value))
/*@}*/

/*!
 * @name Register WDOG_CNT, field CNTHIGH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_CNT_CNTHIGH field. */
#define WDOG_RD_CNT_CNTHIGH(base) ((WDOG_CNT_REG(base) & WDOG_CNT_CNTHIGH_MASK) >> WDOG_CNT_CNTHIGH_SHIFT)
#define WDOG_BRD_CNT_CNTHIGH(base) (WDOG_RD_CNT_CNTHIGH(base))

/*! @brief Set the CNTHIGH field to a new value. */
#define WDOG_WR_CNT_CNTHIGH(base, value) (WDOG_RMW_CNT(base, WDOG_CNT_CNTHIGH_MASK, WDOG_CNT_CNTHIGH(value)))
#define WDOG_BWR_CNT_CNTHIGH(base, value) (WDOG_WR_CNT_CNTHIGH(base, value))
/*@}*/

/*******************************************************************************
 * WDOG_TOVAL - Watchdog Timeout Value Register
 ******************************************************************************/

/*!
 * @brief WDOG_TOVAL - Watchdog Timeout Value Register (RW)
 *
 * Reset value: 0x00000400U
 *
 * This section describes the watchdog timeout value register. TOVAL contains
 * the 16-bit value used to set the timeout period of the watchdog. The watchdog
 * counter (CNT) is continuously compared with the timeout value (TOVAL). If the
 * counter reaches the timeout value, the watchdog forces a reset. Do not write 0
 * to the Watchdog Timeout Value Register; otherwise, the watchdog always
 * generates a reset.
 */
/*!
 * @name Constants and macros for entire WDOG_TOVAL register
 */
/*@{*/
#define WDOG_RD_TOVAL(base)      (WDOG_TOVAL_REG(base))
#define WDOG_WR_TOVAL(base, value) (WDOG_TOVAL_REG(base) = (value))
#define WDOG_RMW_TOVAL(base, mask, value) (WDOG_WR_TOVAL(base, (WDOG_RD_TOVAL(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVAL(base, value) (WDOG_WR_TOVAL(base, WDOG_RD_TOVAL(base) |  (value)))
#define WDOG_CLR_TOVAL(base, value) (WDOG_WR_TOVAL(base, WDOG_RD_TOVAL(base) & ~(value)))
#define WDOG_TOG_TOVAL(base, value) (WDOG_WR_TOVAL(base, WDOG_RD_TOVAL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_TOVAL bitfields
 */

/*!
 * @name Register WDOG_TOVAL, field TOVALLOW[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_TOVAL_TOVALLOW field. */
#define WDOG_RD_TOVAL_TOVALLOW(base) ((WDOG_TOVAL_REG(base) & WDOG_TOVAL_TOVALLOW_MASK) >> WDOG_TOVAL_TOVALLOW_SHIFT)
#define WDOG_BRD_TOVAL_TOVALLOW(base) (WDOG_RD_TOVAL_TOVALLOW(base))

/*! @brief Set the TOVALLOW field to a new value. */
#define WDOG_WR_TOVAL_TOVALLOW(base, value) (WDOG_RMW_TOVAL(base, WDOG_TOVAL_TOVALLOW_MASK, WDOG_TOVAL_TOVALLOW(value)))
#define WDOG_BWR_TOVAL_TOVALLOW(base, value) (WDOG_WR_TOVAL_TOVALLOW(base, value))
/*@}*/

/*!
 * @name Register WDOG_TOVAL, field TOVALHIGH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_TOVAL_TOVALHIGH field. */
#define WDOG_RD_TOVAL_TOVALHIGH(base) ((WDOG_TOVAL_REG(base) & WDOG_TOVAL_TOVALHIGH_MASK) >> WDOG_TOVAL_TOVALHIGH_SHIFT)
#define WDOG_BRD_TOVAL_TOVALHIGH(base) (WDOG_RD_TOVAL_TOVALHIGH(base))

/*! @brief Set the TOVALHIGH field to a new value. */
#define WDOG_WR_TOVAL_TOVALHIGH(base, value) (WDOG_RMW_TOVAL(base, WDOG_TOVAL_TOVALHIGH_MASK, WDOG_TOVAL_TOVALHIGH(value)))
#define WDOG_BWR_TOVAL_TOVALHIGH(base, value) (WDOG_WR_TOVAL_TOVALHIGH(base, value))
/*@}*/

/*******************************************************************************
 * WDOG_WIN - Watchdog Window Register
 ******************************************************************************/

/*!
 * @brief WDOG_WIN - Watchdog Window Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes the watchdog window register. When window mode is
 * enabled (CS[WIN] is set), The WIN register determines the earliest time that a
 * refresh sequence is considered valid. See the Watchdog refresh mechanism section.
 * The WIN register value must be less than the TOVAL register value.
 */
/*!
 * @name Constants and macros for entire WDOG_WIN register
 */
/*@{*/
#define WDOG_RD_WIN(base)        (WDOG_WIN_REG(base))
#define WDOG_WR_WIN(base, value) (WDOG_WIN_REG(base) = (value))
#define WDOG_RMW_WIN(base, mask, value) (WDOG_WR_WIN(base, (WDOG_RD_WIN(base) & ~(mask)) | (value)))
#define WDOG_SET_WIN(base, value) (WDOG_WR_WIN(base, WDOG_RD_WIN(base) |  (value)))
#define WDOG_CLR_WIN(base, value) (WDOG_WR_WIN(base, WDOG_RD_WIN(base) & ~(value)))
#define WDOG_TOG_WIN(base, value) (WDOG_WR_WIN(base, WDOG_RD_WIN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_WIN bitfields
 */

/*!
 * @name Register WDOG_WIN, field WINLOW[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_WIN_WINLOW field. */
#define WDOG_RD_WIN_WINLOW(base) ((WDOG_WIN_REG(base) & WDOG_WIN_WINLOW_MASK) >> WDOG_WIN_WINLOW_SHIFT)
#define WDOG_BRD_WIN_WINLOW(base) (WDOG_RD_WIN_WINLOW(base))

/*! @brief Set the WINLOW field to a new value. */
#define WDOG_WR_WIN_WINLOW(base, value) (WDOG_RMW_WIN(base, WDOG_WIN_WINLOW_MASK, WDOG_WIN_WINLOW(value)))
#define WDOG_BWR_WIN_WINLOW(base, value) (WDOG_WR_WIN_WINLOW(base, value))
/*@}*/

/*!
 * @name Register WDOG_WIN, field WINHIGH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_WIN_WINHIGH field. */
#define WDOG_RD_WIN_WINHIGH(base) ((WDOG_WIN_REG(base) & WDOG_WIN_WINHIGH_MASK) >> WDOG_WIN_WINHIGH_SHIFT)
#define WDOG_BRD_WIN_WINHIGH(base) (WDOG_RD_WIN_WINHIGH(base))

/*! @brief Set the WINHIGH field to a new value. */
#define WDOG_WR_WIN_WINHIGH(base, value) (WDOG_RMW_WIN(base, WDOG_WIN_WINHIGH_MASK, WDOG_WIN_WINHIGH(value)))
#define WDOG_BWR_WIN_WINHIGH(base, value) (WDOG_WR_WIN_WINHIGH(base, value))
/*@}*/

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define SWD_IDX (0) /*!< Instance number for SWD. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#endif /* __S32K144_EXTENSION_H__ */
/* EOF */
